<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/tool/npm/"/>
      <url>/2019/tool/npm/</url>
      
        <content type="html"><![CDATA[<h2 id="npm-使用"><a href="#npm-使用" class="headerlink" title="npm 使用"></a>npm 使用</h2><h3 id="解决-npm-包无法下载"><a href="#解决-npm-包无法下载" class="headerlink" title="解决 npm 包无法下载"></a>解决 npm 包无法下载</h3><p> electron sass </p><p>进入 <code>~/.npmrc</code>，增加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org</span><br><span class="line">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjs</span><br><span class="line">electron_mirror=http://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure><p>淘宝 npm 镜像 <a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a></p><h3 id="npm-基本命令"><a href="#npm-基本命令" class="headerlink" title="npm 基本命令"></a>npm 基本命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新 npm</span></span><br><span class="line">npm -v|--version</span><br><span class="line">npm install npm@latest -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># nvm : npm Version Manager </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索包</span></span><br><span class="line">npm search &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt; <span class="comment"># [&lt;@scope&gt;/] 安装限定范围的包</span></span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt;</span><br><span class="line">npm install &lt;folder&gt;</span><br><span class="line">npm install &lt;tarball file&gt;  <span class="comment"># .tar, .tar.gz, or .tgz</span></span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install &lt;github usename&gt;/&lt;guthub project&gt;</span><br><span class="line">npm install &lt;git:// url&gt;</span><br><span class="line"></span><br><span class="line">npm install &lt;pkg&gt; -S|--save <span class="comment"># 安装到 dependencies</span></span><br><span class="line">npm install &lt;pkg&gt; -D|--save-dev <span class="comment"># 安装到 devDependencies</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装全局包</span></span><br><span class="line">npm install -g &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包</span></span><br><span class="line">npm update</span><br><span class="line"><span class="comment"># 更新全局安装的包</span></span><br><span class="line">npm update -g <span class="comment"># 更新全部</span></span><br><span class="line">npm update -g| --global &lt;pkg&gt; <span class="comment"># 更新指定包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地包</span></span><br><span class="line">npm uninstall &lt;pkg&gt;</span><br><span class="line">npm uninstall --save &lt;pkg&gt; <span class="comment"># 从 `package.json` 文件中删除依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载全局安装的包</span></span><br><span class="line">npm uninstall -g &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开官网</span></span><br><span class="line">npm docs|home [&lt;pkg&gt;]</span><br><span class="line"><span class="comment"># 打开源码仓库页面</span></span><br><span class="line">npm repo [&lt;pkg&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 package.json 文件</span></span><br><span class="line">npm init</span><br><span class="line"><span class="comment"># 创建默认 package.json 文件</span></span><br><span class="line">npm init --yes or -y</span><br></pre></td></tr></table></figure><h3 id="npm-修改源"><a href="#npm-修改源" class="headerlink" title="npm 修改源"></a>npm 修改源</h3><ul><li><p>进入~/.npmrc 增加 <code>registry=https://registry.npm.taobao.org</code></p></li><li><p>通过命令 <code>npm config set registry http://registry.cnpmjs.org</code></p></li><li><p>临时使用指定源下载 <code>npm install jquery --registry=https://registry.npm.taobao.org</code></p></li><li><p>使用 nrm 管理源</p></li></ul><h3 id="npm-配置文件"><a href="#npm-配置文件" class="headerlink" title="npm 配置文件"></a>npm 配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .npmrc 配置文件位置（~/.npmrc）</span></span><br><span class="line">npm config list</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 缓存目录，默认 C:\Users\&lt;username&gt;\AppData\Roaming\npm-cache</span></span><br><span class="line">npm config get cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 npm 缓存</span></span><br><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 全局 node 包位置</span></span><br><span class="line">npm config get prefix</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm root -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 npm 全局文件位置及缓存文件位置</span></span><br><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"&lt;new_path&gt;"</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"&lt;new_path&gt;"</span></span><br></pre></td></tr></table></figure><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码</p><p>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p><ul><li>如果只是修复bug，需要更新Z位</li><li>如果是新增了功能，但是向下兼容，需要更新Y位</li><li>如果有大变动，向下不兼容，需要更新X位</li></ul><h3 id="nrm-使用"><a href="#nrm-使用" class="headerlink" title="nrm 使用"></a>nrm 使用</h3><p>nrm ls 查看配置列表，带*号即为当前使用的配置</p><p>nrm use 源的别名：切换源</p><p>nrm add 别名 地址 ： 添加源</p><p>nrm test 别名 ： 测速</p><p>nrm del 别名 ：删除源</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端调试</title>
      <link href="/2019/tool/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
      <url>/2019/tool/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一些调试工具"><a href="#一些调试工具" class="headerlink" title="一些调试工具"></a>一些调试工具</h2><ol><li><p>直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法 100% 还原手机的真实情况</p></li><li><p>chrome <a href="https://developer.chrome.com/devtools/docs/remote-debugging" target="_blank" rel="noopener">远程调试功能</a></p><p>需要连接数据线，其次是设置比较繁琐，而且还限制了 android 手机。对于 IOS 的调试则可能要使用 Safari 的另一套工具</p></li><li><p><a href="https://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener">weinre</a>：远程调试，在 PC 上生成一个像 chrome 开发工具一样的调试器，需要手动引入 js</p></li><li><p>Eruda、vConsole：在移动端页面上生成一个调试器，调试信息会挡住操作元素，查看复杂数据结构的 log 不方便，需要手动引入 js</p></li><li><p>安装各种虚拟机sdk，在电脑上进行手机调试。能比较真实模拟手机，但是安装繁琐，操作不方便，无法模拟真实的手势操作</p></li></ol><h2 id="Eruda"><a href="#Eruda" class="headerlink" title="Eruda"></a>Eruda</h2><p><a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">https://github.com/liriliri/eruda</a></p><p>Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。</p><ol><li>按钮拖拽，面板透明度大小设置。</li><li>Console面板：捕获Console日志，支持log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括%c自定义样式输出；支持按日志类型及正则表达式过滤；支持快捷命令加载underscore、jQuery库；支持JavaScript脚本执行。</li><li>Elements面板：查看标签内容及属性；查看应用在Dom上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看Dom上绑定的各类事件。</li><li>Network面板：捕获请求，查看发送数据、返回头、返回内容等信息。</li><li>Resources面板：查看并清除localStorage、sessionStorage及cookie；查看页面加载脚本及样式文件；查看页面加载图片。</li><li>Sources面板：查看页面源码；格式化html，css，js代码及json数据。</li><li>Info面板：输出URL及User Agent；支持自定义输出内容。</li><li>Snippets面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。</li></ol><p>使用</p><p>通过 CDN 使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/eruda/1.5.2/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 npm 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eruda --save</span><br></pre></td></tr></table></figure><p>在页面中加载脚本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/eruda/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Js文件对于移动端来说略重（gzip后大概100kb）。建议通过url参数来控制是否加载调试器，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> src = <span class="string">'node_modules/eruda/eruda.min.js'</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/eruda=true/</span>.test(<span class="built_in">window</span>.location) &amp;&amp; localStorage.getItem(<span class="string">'active-eruda'</span>) != <span class="string">'true'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt src="'</span> + src + <span class="string">'"&gt;&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt&gt;eruda.init();&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>初始化时可以传入配置：</p><ul><li>container：用于插件初始化的 Dom 元素，如果不设置，默认创建 div 作为容器直接置于 html 根结点下面</li><li>tool：指定要初始化哪些面板，默认加载所有</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el)</span><br><span class="line"></span><br><span class="line">eruda.init(&#123;</span><br><span class="line">  container: el,</span><br><span class="line">  tool: [<span class="string">'console'</span>, <span class="string">'elements'</span>],</span><br><span class="line">  useShadowDom: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vConsole"><a href="#vConsole" class="headerlink" title="vConsole"></a>vConsole</h2><p><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">https://github.com/Tencent/vConsole</a></p><p>一个轻量、可拓展、针对手机网页的前端开发者调试面板。</p><p>特性</p><ul><li>查看 console 日志</li><li>查看网络请求</li><li>查看页面 element 结构</li><li>查看 Cookies、localStorage 和 SessionStorage</li><li>手动执行 JS 命令行</li><li>自定义插件</li></ul><p><a href="https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md" target="_blank" rel="noopener">使用说明</a></p><p>下载 vConsole 的<a href="https://github.com/Tencent/vConsole/releases/latest" target="_blank" rel="noopener">最新版本</a>。（不要直接下载 dev 分支下的 <code>dist/vconsole.min.js</code>）</p><p>或者使用 npm 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure><p>引入 <code>dist/vconsole.min.js</code> 到项目中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/vconsole.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vConsole = <span class="keyword">new</span> VConsole()</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'Hello world'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="weinre"><a href="#weinre" class="headerlink" title="weinre"></a>weinre</h2><p><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html" target="_blank" rel="noopener">http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html</a></p><ol><li>Element： 查看/修改dom，查看/修改 dom CSS</li><li>Resources：查看/修改 localStorage, sessionStorage</li><li>Network：查看网络请求</li><li>Timeline：</li><li>Console：查看控制台输出</li></ol><p>不能做 JS 调试</p><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install -g weinre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 weinre 服务</span></span><br><span class="line">weinre --boundHost 192.168.3.44 --httpPort 8888</span><br><span class="line"></span><br><span class="line">启动调试客户端</span><br><span class="line">在浏览器中打开 <span class="string">'http://192.168.3.44:8888'</span> 即可启动调试客户端</span><br><span class="line"></span><br><span class="line">在需要调试的页面中添加如下</span><br><span class="line">&lt;script src=<span class="string">"http://192.168.3.44:8888/target/target-script-min.js#anonymous"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="spy-debugger"><a href="#spy-debugger" class="headerlink" title="spy-debugger"></a>spy-debugger</h2><p><a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="noopener">https://github.com/wuchangming/spy-debugger</a></p><p>微信调试，各种 WebView 样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP/HTTPS，无需USB连接设备</p><p>spy-debugger 集成了<code>weinre</code>，简化了<code>weinre</code>需要给每个调试的页面添加 js 代码。原理是拦截所有 html 页面请求注入<code>weinre</code>所需要的 js 代码。让页面调试更加方便</p><p>1、页面调试＋抓包<br>2、操作简单，无需USB连接设备<br>3、<strong>支持HTTPS</strong><br>4、<code>spy-debugger</code>内部集成了<a href="http://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener"><code>weinre</code></a>、<a href="https://github.com/wuchangming/node-mitmproxy" target="_blank" rel="noopener"><code>node-mitmproxy</code></a>、<a href="https://github.com/alibaba/anyproxy" target="_blank" rel="noopener"><code>AnyProxy</code></a>。5、自动忽略原生 App 发起的 https 请求，只拦截 webview 发起的 https 请求。对使用了 SSL pinning 技术的原生App 不造成任何影响。<br>6、可以配合其它代理工具一起使用(默认使用AnyProxy) <a href="https://github.com/wuchangming/spy-debugger#%E8%AE%BE%E7%BD%AE%E5%A4%96%E9%83%A8%E4%BB%A3%E7%90%86%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8anyproxy" target="_blank" rel="noopener">(设置外部代理)</a></p><p>基本使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install spy-debugger -g</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">spy-debugger</span><br><span class="line"><span class="comment">#设置手机的HTTP代理</span></span><br><span class="line">代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)</span><br><span class="line"><span class="comment"># 手机安装证书</span></span><br><span class="line">手机浏览器访问 http://s.xxx</span><br><span class="line">设置-&gt;通用-&gt;描述文件与设备管理-&gt;找到node-mitmproxy CA（安装）</span><br><span class="line">设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到node-mitmproxy CA（打开）</span><br></pre></td></tr></table></figure><p>自定义选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义端口</span></span><br><span class="line">spy-debugger -p 8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置页面内容为可编辑模式</span></span><br><span class="line">spy-debugger -w <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否只拦截浏览器发起的https请求(默认： true)</span></span><br><span class="line">spy-debugger -b <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许weinre监控iframe加载的页面(默认： false)</span></span><br><span class="line">spy-debugger -i <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 HTTP 缓存(默认： false)</span></span><br><span class="line">spy-debugger -c <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="m-console"><a href="#m-console" class="headerlink" title="m-console"></a>m-console</h2><p><a href="https://github.com/fwon/m-console" target="_blank" rel="noopener">https://github.com/fwon/m-console</a></p><p>手机远程调试工具，手机通过代理连接上PC后，可以在PC版浏览器打印log和错误日志</p><p>需要手动给每个调试的页面添加 js 代码</p><h2 id="DebugGap-VIDE"><a href="#DebugGap-VIDE" class="headerlink" title="DebugGap-VIDE"></a>DebugGap-VIDE</h2><p><a href="https://www.debuggap.com/debug_webview.html" target="_blank" rel="noopener">https://www.debuggap.com/debug_webview.html</a></p><h2 id="Mobile-Debug"><a href="#Mobile-Debug" class="headerlink" title="Mobile Debug"></a>Mobile Debug</h2><p><a href="https://www.mobiledebug.com/" target="_blank" rel="noopener">https://www.mobiledebug.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2019/tool/docker/"/>
      <url>/2019/tool/docker/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-dcoker"><a href="#安装-dcoker" class="headerlink" title="安装 dcoker"></a>安装 dcoker</h2><p>安装</p><p>ubuntu 16.04 (LTS)安装docker</p><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p>镜像仓库方式安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置镜像仓库</span></span><br><span class="line"><span class="comment"># 更新 apt 软件包索引：</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># 安装软件包，以允许 apt 通过 HTTPS 使用镜像仓库：</span></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">     apt-transport-https \</span><br><span class="line">     ca-certificates \</span><br><span class="line">     curl \</span><br><span class="line">     software-properties-common</span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥：</span></span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 验证密钥指纹是否为 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。</span></span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p>设置 stable 镜像仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ amd64：</span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure><p>安装 DOCKER CE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><p>验证是否正确安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令将下载一个测试镜像并在容器中运行它。容器运行时，它将输出一条参考消息并退出。</p><p>升级 DOCKER CE</p><p>如需升级 Docker CE，首先运行 <code>sudo apt-get update</code>，然后按照顺序执行操作，并选择您要安装的新版本</p><p>卸载 Docker CE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure><p>主机上的镜像、容器、存储卷、或定制配置文件不会自动删除。如需删除所有镜像、容器和存储卷，请运行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><p>将 Docker 配置为在启动时启动</p><h2 id="使用-docker-安装-ubuntu-镜像"><a href="#使用-docker-安装-ubuntu-镜像" class="headerlink" title="使用 docker 安装 ubuntu 镜像"></a>使用 docker 安装 ubuntu 镜像</h2><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">docker search ubuntu <span class="comment"># 查找 Ubuntu 镜像</span></span><br><span class="line">docker pull ubuntu <span class="comment"># 安装 Ubuntu 镜像</span></span><br><span class="line">docker images <span class="comment">#查看 docker 镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并运行 docker 容器</span></span><br><span class="line">docker run -it -d --name ubuntu_test -p 8088:80 ubuntu</span><br><span class="line"><span class="comment"># --name 自定义容器名，-p 指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回 id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 docker 容器  启动一个bash交互终端</span></span><br><span class="line">docker run -it 容器名:容器tag /bin/bash</span><br><span class="line"></span><br><span class="line">docker start container_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有启动的容器(查看所有容器加 -a)</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 id 查看容器信息</span></span><br><span class="line">docker inspect id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker(或者把容器id改为容器名，也可以进入)</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id或容器名 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi 删除镜像</span><br></pre></td></tr></table></figure><p>备份镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 制作 docker 镜像  1.0 为版本号</span></span><br><span class="line">docker commit 98 ubuntu_test:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像是否创建</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存镜像到docker账号中</span></span><br><span class="line"><span class="comment"># 登录进Docker注册中心</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送镜像</span></span><br><span class="line">docker tag a25ddfec4d2a arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line">docker push arunpyasi/container-backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包镜像并查看</span></span><br><span class="line">docker save -o ubuntu_test.tar ubuntu_test:1.0</span><br></pre></td></tr></table></figure><p>恢复容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从docker账号中拉取</span></span><br><span class="line">docker pull arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地</span></span><br><span class="line">docker load -i ~/container-backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用加载的镜像去运行Docker容器</span></span><br><span class="line">docker run -d -p 80:80 container-backup</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/2019/other/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/other/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><h3 id="http-相关"><a href="#http-相关" class="headerlink" title="http 相关"></a>http 相关</h3><h3 id="HTML-css-相关"><a href="#HTML-css-相关" class="headerlink" title="HTML css 相关"></a>HTML css 相关</h3><h3 id="js-相关"><a href="#js-相关" class="headerlink" title="js 相关"></a>js 相关</h3><h3 id="jquery-相关"><a href="#jquery-相关" class="headerlink" title="jquery 相关"></a>jquery 相关</h3><h3 id="工具类相关"><a href="#工具类相关" class="headerlink" title="工具类相关"></a>工具类相关</h3><p><a href="zh-cn/_Tool/webpack配置?id=webpack-和-gulp-区别">webpack 和 gulp 区别</a><br><a href></a><br><a href></a><br><a href></a><br><a href></a></p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack</title>
      <link href="/2019/tool/webpack%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/tool/webpack%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><ul><li><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack 官网</a></li><li><a href="https://webpack.docschina.org/" target="_blank" rel="noopener">webpack 中文网</a></li><li><a href="https://github.com/cuilongjin/webpack-config/" target="_blank" rel="noopener">webpack 配置文件</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webpack 是一个现代 JavaScript 应用程序的模块打包器（module bundler）</p><p>webpack 是一个模块化方案（预编译）</p><p>webpack 获取具有依赖关系的模块，并生成表示这些模块的静态资源</p><p>webpack 的两个特点：模块化、打包</p><p>四个核心概念：<strong>入口(entry)</strong>、<strong>输出(output)</strong>、<strong>加载器(loader)</strong>、<strong>插件(plugins)</strong></p><p>模块化方案：webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）<br>browserify 是与 webpack 相似的模块化打包工具</p><h3 id="webpack-起源"><a href="#webpack-起源" class="headerlink" title="webpack 起源"></a>webpack 起源</h3><ul><li>webpack 解决了现存模块打包器的两个痛点：<ul><li>Code Spliting - 代码分离</li><li>静态资源的模块化处理方案</li></ul></li></ul><h3 id="webpack-与模块"><a href="#webpack-与模块" class="headerlink" title="webpack 与模块"></a>webpack 与模块</h3><ul><li><p><a href="http://zhaoda.net/webpack-handbook/module-system.html" target="_blank" rel="noopener">前端模块系统的演进</a></p></li><li><p>在 webpack 看来：所有的<strong>静态资源都是模块</strong></p></li><li><p>webpack 模块能够识别以下等形式的模块之间的依赖：</p><ul><li><p>ES2015 <code>import</code> <code>export</code></p></li><li><p>CommonJS <code>require()</code> <code>module.exports</code></p></li><li><p>AMD <code>define</code> 和 <code>require</code></p></li><li><p>css/sass/less 文件中的 <code>@import</code></p></li><li><p>图片连接，比如：样式 <code>url(...)</code> 或 HTML <code>&lt;img src=...&gt;</code></p></li><li><p>字体等</p></li></ul></li></ul><ul><li>在webpack提供的模块化环境中<ul><li>想要加载一个JS文件，只需要 require(‘a.js’)</li><li>想要加载一个CSS文件，只需要 require(‘css/index.css’)</li><li>想要加载一个图片文件，只需要 require(‘images/a.png’)</li></ul></li></ul><ul><li><a href="http://www.jianshu.com/p/42e11515c10f#" target="_blank" rel="noopener">入门 Webpack，看这篇就够了</a></li></ul><h3 id="webpack-打包原理："><a href="#webpack-打包原理：" class="headerlink" title="webpack 打包原理："></a>webpack 打包原理：</h3><p>​        入口文件： main.js</p><p>​        webpack 从入口出发，递归分析项目中所有的依赖项（模块），使用loader来处理对应的模块最终，打包生成一个 bundle.js 文件。</p><p>​        如果配置了 webpack 中的 代码分离（Code Spliting），webpack 会根据 分离点 将这个模块生成一个独立的JS文件</p><p>​        还可以通过配置，将 CSS 、 图片、 字体 等文件，从 bundle.js 中抽离为独立的文件</p><h2 id="webpack-的基本使用"><a href="#webpack-的基本使用" class="headerlink" title="webpack 的基本使用"></a>webpack 的基本使用</h2><p>安装：<code>npm i -D webpack webpack-cli</code></p><p>webpack：是 webpack 工具的核心包</p><p>webpack-cli：提供了一些在终端中使用的命令</p><p>-D(–save-dev)：表示项目开发期间的依赖</p><p>webpack 的两种使用方式：命令行、配置文件（<code>webpack.config.js</code>）</p><h3 id="命令行使用说明"><a href="#命令行使用说明" class="headerlink" title="命令行使用说明"></a>命令行使用说明</h3><ul><li><code>package.json</code>中的<code>scripts</code>中可以存放一些 bash 命令，这些 bash 命令可以通过 <code>npm run 命令名称</code> 来执行</li><li>注意：npm 在执行 scripts 中的命令的时候，是在电脑系统后台默认开启一个 bash，将当前目录下的<code>./node_modules/.bin</code>这个文件夹临时加入了系统环境变量</li><li>使用方式：<code>npm run build</code></li><li>设置开发状态： <code>mode</code>  如果没有设置 mode 配置项，webpack 会默认提供开发环境(production)</li><li>在入口文件中可以使用 <code>import</code> 引入 js css less 等文件</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // webpack 是 webpack-cli 提供的命令</span><br><span class="line">  // src/js/main.js 为入口文件</span><br><span class="line">  // --output dist/bundle.js 为出口文件</span><br><span class="line">  // --mode development 生产环境</span><br><span class="line">  "build": "webpack"</span><br><span class="line">  "build1": "webpack src/js/main.js --output dist/bundle.js --mode development"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件方式（推荐）"><a href="#配置文件方式（推荐）" class="headerlink" title="配置文件方式（推荐）"></a>配置文件方式（推荐）</h3><p>项目<code>根目录</code>下创建一个 <code>webpack.config.js</code>文件，运行 <code>webpack</code> 命令时的默认配置文件</p><p>指定其他文件：<code>--config  webpack.XX.js</code></p><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;build&quot;: &quot;webpack&quot;</code></p><p>执行命令 : <code>npm run build</code></p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置</span></span><br><span class="line"><span class="comment">// 注意 : 不要再这个文件中使用ES6的的模块化 import语法</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  entry: path.join(__dirname, <span class="string">'./src/js/main.js'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出口</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 出口目录</span></span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发模式</span></span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>安装：<code>npm i -D webpack-dev-server</code></p><p>作用：配合 webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率</p><p>注意：无法直接在终端中执行 <code>webpack-dev-server</code>，需要在 <code>package.json</code> 配置 <code>scripts</code> 后使用</p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>webpack-dev-server</code>将打包好的文件存储在内存中，提高编译和加载速度，效率更高（不会生成dist目录）</li><li>在内存中出口目录为项目根目录（命令行中的提示：<code>webpack output is served from /</code>）<ul><li>在<code>index.html</code>页面中引入文件不需要加<code>dist</code></li></ul></li></ul><h3 id="CLI-配置"><a href="#CLI-配置" class="headerlink" title="CLI 配置"></a>CLI 配置</h3><ul><li><code>--contentBase</code> ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的 index.html）<ul><li><code>--contentBase ./src</code>：当前目录下的 src 文件夹</li></ul></li><li><code>--open true</code> ：自动打开浏览器</li><li><code>--port 3000</code> ：指定端口号</li><li><code>--hot</code> ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载</li><li><code>--progress</code>：显示进度条</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --contentBase src --open --port 8888 --hot"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;dev&quot;: &quot;webpack-dev-server --hot&quot;</code></p><p>执行命令 : <code>npm run dev</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --hot 热更新写在命令行里，不然的话还要配其他插件麻烦</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'src'</span>),</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    port: <span class="number">3000</span></span><br><span class="line">    <span class="comment">// hot: true</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// plugins: [</span></span><br><span class="line">  <span class="comment">//   new webpack.HotModuleReplacementPlugin()</span></span><br><span class="line">  <span class="comment">// ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="html-webpack-plugin-插件"><a href="#html-webpack-plugin-插件" class="headerlink" title="html-webpack-plugin 插件"></a>html-webpack-plugin 插件</h2><ul><li>安装：<code>npm i -D html-webpack-plugin</code></li><li>作用：根据模板，在内存中自动生成 html 页面，并自动引入<code>bundle.js</code>、<code>css</code>等文件</li></ul><p>配置文件配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 html-webpack-plugin 插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 配置插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin 配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 模板页面路径</span></span><br><span class="line">      template: path.join(__dirname, <span class="string">'src/index.html'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包非js文件"><a href="#打包非js文件" class="headerlink" title="打包非js文件"></a>打包非js文件</h2><p>webpack 默认只能处理 js 文件，非 js(css、less、图片、字体等)处理不了，借助 loader 加载器</p><h3 id="处理-css-文件"><a href="#处理-css-文件" class="headerlink" title="处理 css 文件"></a>处理 css 文件</h3><p>在 <code>main.js</code>中引入css文件 <code>import &#39;../css/main.css&#39;</code></p><p>安装 : <code>npm i -D style-loader css-loader</code></p><p>在 <code>webpack.config.js</code> 中，添加个新的配置项 <code>module</code></p><p>在 <code>module</code> 中添加 <code>loader</code> 来处理 <code>css</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理 css</span></span><br><span class="line">      <span class="comment">// 注意点 use 执行loader 顺序 从右往左</span></span><br><span class="line">      <span class="comment">// css-loader: 读取css文件内容，将其转化为一个模块</span></span><br><span class="line">      <span class="comment">// style-loader: 拿到模块, 创建一个style标签，插入页面中</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-less-文件"><a href="#处理-less-文件" class="headerlink" title="处理 less 文件"></a>处理 less 文件</h3><p>在 <code>main.js</code>中引入 less 文件 <code>import &#39;../css/main.less&#39;</code></p><p>安装 : <code>npm i -D less-loader less style-loader css-loader</code></p><p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理 <code>less</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">//处理 css</span></span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h3><p>安装 : <code>npm i -D url-loader file-loader</code></p><p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">//  图片大小 &lt;= 10000 =&gt; 转化为base64</span></span><br><span class="line">              <span class="comment">//  图片大小 &gt;= 10000 =&gt; 不会转base64 内部调用 file-loader 加载图片</span></span><br><span class="line">              limit: <span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url-loader</strong> 默认会将图片转化为 base64 编码格式，目的：提高性能</p><p><strong>file-loader</strong> 在处理图片时，会对文件进行重命名</p><p>base64 编码格式的图片说明：</p><ul><li>精灵图：将一些小图片合并为一张图片，减少请求次数，提高性能</li><li>字体图标：直接将一些小的图片,合并到字体文件中，并且不会失真</li><li>base64：是一种编码格式,能够将图片、文字等常见的文件，转化为 base64 格式，这种字符串格式浏览器能够识别并且读取显示到页面中</li><li>base64 是一个字符串，也可以直接被内嵌到页面中，或者 css 中</li><li>注意：大图片不适合用 base64 处理，只有小的图标才适合 base64 处理</li></ul><h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><p>在 <strong>main.js</strong> 中引入 css 文件 <code>import &#39;../css/iconfont/iconfont.css&#39;</code></p><p>在 webpack.config.js 中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理字体图标</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(svg|woff|woff2|ttf|eot)$/</span>,</span><br><span class="line">        use: <span class="string">'url-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-ES6-语法"><a href="#处理-ES6-语法" class="headerlink" title="处理 ES6 语法"></a>处理 ES6 语法</h3><ol><li>现在的项目都是使用 ES6 开发的，但是这些新的 ES6 语法，并不是所有的浏览器都支持，所以就需要有一个工具，帮我们转成 es5 语法，这个就是：babel</li><li><a href="https://babeljs.io/" target="_blank" rel="noopener">babel</a></li><li>Babel is a JavaScript compiler. ==&gt; babel 是一个 JavaScript 编译器</li><li>webpack 只能处理 import / export 这个 es6 模块化语法，而其他的 js 新语法，应该使用 babel 来处理</li></ol><p>babel 的使用 :</p><ul><li>安装： <code>npm i -D babel-core babel-loader@7</code><ul><li>babel-core 是 babel 的核心包</li><li>babel-loader 加载 js 文件，并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js</li></ul></li></ul><ul><li>安装：<code>npm i -D babel-preset-env babel-preset-stage-2</code><ul><li>babel-preset-env：表示能够解析 es2015、es2016、es2017、es2018 这些标准的语法</li><li>babel-preset-stage-2：用来解析还没有被采纳为标准的语法</li><li><code>babel-polyfill与babel-plugin-transform-runtime</code> 也是做兼容处理的,以前都是用这个，兼容更早的</li></ul></li></ul><ul><li>配置 : 在 webpack.config.js 中添加一个 loader</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理 ES6 语法</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">        <span class="comment">// 设置忽略 node-modules 文件夹</span></span><br><span class="line">        exclude: <span class="regexp">/node-modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在项目根目录中创建 babel 的配置文件，叫：<code>.babelrc</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;,</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  -----------</span><br><span class="line">  // 暂时不用</span><br><span class="line">  // 如果未来某一天真的用到了polify</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;, &#123;</span><br><span class="line">      &quot;helpers&quot;: false,</span><br><span class="line">      &quot;polyfill&quot;: true,</span><br><span class="line">      &quot;regenerator&quot;: true,</span><br><span class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目打包上线"><a href="#项目打包上线" class="headerlink" title="项目打包上线"></a>项目打包上线</h2><p>执行 : <code>npm run build</code> 对项目进行打包，生成dist文件</p><p>模拟本地服务器 : 安装 : <code>npm i -g http-server</code></p><p>把dist文件里的内容放到服务器里即可，直接运行<code>http-server</code></p><h2 id="webpack-和-gulp-区别"><a href="#webpack-和-gulp-区别" class="headerlink" title="webpack 和 gulp 区别"></a>webpack 和 gulp 区别</h2><ol><li>Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给 gulp 配置不通的 task（通过Gulp 中的 gulp.task() 方法配置，比如启动 server、sass/less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程</li><li>Webpack 也称之为模块打包机 ，由此也可以看出 Webpack 更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块，最初 Webpack 本身就是为前端 JS 代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack 是通过 loader（加载器）和 plugins（插件）对资源进行处理的</li><li>gulp是构建工具，Webpack是 js 模块化的解决方案</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2019/vue/vuex/"/>
      <url>/2019/vue/vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="vuex-是什么"><a href="#vuex-是什么" class="headerlink" title="vuex 是什么?"></a>vuex 是什么?</h2><ul><li>状态管理工具</li><li>状态即数据，状态管理就是管理组件中的 data(数据)</li><li>Vuex 中的状态管理工具采用 <code>集中式</code> 统一管理项目中组件之间需要通讯的数据</li><li>最佳实践：只将组件之间共享的数据放在 vuex 中，而不是将所有的数据都放在 vuex 中，也就是如果数据只是在组件内部使用的，这个数据应该放在组件中，而不要放在 vuex</li><li>vuex 中的数据也是响应式的，如果一个组件中修改了 vuex 中的数据，另外一个使用的 vuex 数据的组件，就会自动更新</li><li>任何组件中都可以直接获取 vuex</li><li>前端状态该管理的思想最早是由 react 团队提出来的，就是 Flux(思想以及具体的实现)</li><li>前端状态管理工具 : Flux / Redux / Mobx / vuex 等等</li></ul><h2 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用?"></a>什么时候用?</h2><ul><li>项目体量很小，不需要使用 vuex，如果项目中组件通讯不复杂，也不需要使用 vuex</li><li>写项目的时候，发现组件通讯多，组件之间的关系复杂，项目已经无法继续开发了，此时就应该使用 vuex</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>安装 : <code>npm i vuex</code></li><li>导入 vuex</li><li>创建 vuex 示例</li></ul><h2 id="vuex-中的概念"><a href="#vuex-中的概念" class="headerlink" title="vuex 中的概念"></a>vuex 中的概念</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li><p>状态 , 状态即数据</p></li><li><p>状态是由 store 提供的</p></li><li><p>状态也是响应的</p></li><li><p>推荐通过 mutations 中提供的方法去修改数据，因为在严格模式下不允许在 mutation 外部修改 state下的数据，否则会报错</p><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3></li><li><p>作用：提供修改 state 的状态数据的方法</p></li><li><p>只要想改变 state 中的状态数据，就应该在 mutations 中提供一个方法来修改，接受 <code>state</code> 作为第一个参数（如果定义在模块中，则为模块的局部状态），<code>payload</code> 作为第二个参数（可选）</p></li><li><p>通过 <code>$store.commit(&#39;方法名&#39;)</code> 调用 mutations 中的方法</p></li><li><p>传参数的话，紧挨着方法名后面继续传就可以了，推荐传入一个对象（payload 即可）</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addTodo () &#123;</span><br><span class="line">    <span class="comment">// commit =&gt; 找 mutations</span></span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'addTodo'</span>, &#123;</span><br><span class="line">      todoName: <span class="keyword">this</span>.todoName</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  addTodo (state, playload) &#123;</span><br><span class="line">    state.list.push(playload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>提供异步修改 state 的状态数据的方法</p><p>处理函数总是接受 <code>context</code> 作为第一个参数，<code>payload</code>作为第二个参数（可选）</p><p>通过 <code>$store.dispatch(&#39;方法名&#39;)</code> 调用 actions 中的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addTodo () &#123;</span><br><span class="line">    <span class="comment">// 异步: 分发 dispatch  =&gt; actions</span></span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'addTodoAsync'</span>, &#123;</span><br><span class="line">      todoName: <span class="keyword">this</span>.todoName</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  addTodoAsync (context, playload) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">'addTodo'</span>, playload)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>可以认为是 store 的计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</p><p>getter 接受 state 作为其第一个参数，Getter 也可以接受其他 getter 作为第二个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：<code>store.getters.doneTodos</code></p><h2 id="vue-和-vuex-的配合使用"><a href="#vue-和-vuex-的配合使用" class="headerlink" title="vue 和 vuex 的配合使用"></a>vue 和 vuex 的配合使用</h2><ol><li>实例 vue 和实例 store</li><li>一定要把 store 挂在到 vue上</li><li>读取<ul><li>组件读取:<code></code></li><li>js读取: <code>this.$store.state.count</code></li><li>js操作: 在 mutations 里放一个方法，在方法里修改</li><li>js中触发这个方法 <code>this.​$store.commit(&#39;addCount&#39;, { num : 8})</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 生命周期</title>
      <link href="/2019/vue/vue-lifecycle/"/>
      <url>/2019/vue/vue-lifecycle/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">生命周期</a></p><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p><p><img src="lifecycle.png" alt title=":no-zoom"></p><p><img src="Vue%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE.png" alt title=":no-zoom"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2019/javascript/promise/"/>
      <url>/2019/javascript/promise/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul><li>Promise 是<code>异步编程</code>的一种解决方案，它允许你以一种同步的方式编写异步代码</li><li><code>promise</code>：承诺、保证</li><li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES6 - Promise</a></li><li>JS 是通过回调函数来实现异步编程的，当异步操作多了以后，就会产生回调嵌套回调的问题，这就是<code>回调地狱</code></li><li>Promise 方式：将异步操作以同步操作的方式表达出来，避免了层层嵌套的回调函数</li></ul><h2 id="封装一个-Promise"><a href="#封装一个-Promise" class="headerlink" title="封装一个 Promise"></a>封装一个 Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按序读取文件：a -&gt; b -&gt; c</span></span><br><span class="line"><span class="comment">// 按顺序读取 a b c 文件</span></span><br><span class="line"><span class="comment">// 以前</span></span><br><span class="line"><span class="comment">// 读取 a 文件</span></span><br><span class="line">fs.readFile(<span class="string">'./a'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 b 文件</span></span><br><span class="line">  fs.readFile(<span class="string">'./b'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 c 文件</span></span><br><span class="line">    fs.readFile(<span class="string">'./a'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise</span></span><br><span class="line"><span class="comment">// 封装</span></span><br><span class="line"><span class="comment">// Promise 是一个构造函数</span></span><br><span class="line"><span class="comment">// 通过 new 创建 Promise 的实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化 Promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve 表示成功，异步操作成功调用</span></span><br><span class="line">    <span class="comment">// reject  表示失败，异步操作失败调用</span></span><br><span class="line">    fs.readFile(path, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 读取错误，调用 reject()</span></span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取成功 调用 resolve</span></span><br><span class="line">      resolve(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 Promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">readFile(<span class="string">'a'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'a'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="promise-的三个状态"><a href="#promise-的三个状态" class="headerlink" title="promise 的三个状态"></a>promise 的三个状态</h2><ul><li><p>pending : 等待  (等待成功或者失败去调用)</p></li><li><p>resolved : 成功调用</p></li><li><p>rejected : 失败调用</p></li></ul><h2 id="then-和-catch"><a href="#then-和-catch" class="headerlink" title="then 和 catch"></a>then 和 catch</h2><ul><li>说明：获取异步操作的结果</li><li><code>then()</code> ：用于获取异步操作成功时的结果 -&gt; <em>resolve</em></li><li><code>catch()</code>：用于获取异步操作失败时的结果 -&gt; <em>reject</em></li><li>说明：<code>then()</code>方法可以有多个，按照先后顺序执行，通过回调函数返回值传递数据给下一个 then</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件a的内容为：'</span>, value)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 失败（比如：文件路径错误）</span></span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件读取失败：'</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------- 或者 -----------</span></span><br><span class="line">p.then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="all-和-race"><a href="#all-和-race" class="headerlink" title="all 和 race"></a>all 和 race</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有请求完成，才会执行后续代码</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  axios(<span class="string">'/a'</span>),</span><br><span class="line">  axios(<span class="string">'/b'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// res 是 all() 方法中所有异步操作的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有一个请求完成，就会继续执行后续代码</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  axios(<span class="string">'/a'</span>),</span><br><span class="line">  axios(<span class="string">'/b'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// res 是 race() 方法中先完成的异步操作的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><ul><li>异步编程终极方案</li></ul><ul><li>async / await 用同步编写代码的方式 处理异步操作的一个方案</li><li>async：修饰 (修饰一个内部有异步操作的函数)    格式 :  async + 函数 (里面有异步操作的函数)</li><li>await : 等待 (等上一个异步操作完成啊 , 修饰 一个结果是promise的)异步操作    格式 : await + 异步操作(结果promise对象)</li><li>async 和 await 是成对出现的，await 只能在 async 函数中使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 实例化 promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 操作错误 调用 =&gt;  reject  =&gt; catch</span></span><br><span class="line">        <span class="keyword">return</span> reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 操作成功  调用 =&gt; resolve =&gt; then</span></span><br><span class="line">      resolve(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 2. 返回 promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：使用 (async/await)</span></span><br><span class="line"><span class="comment">// async + 函数 (里面有异步操作的函数)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await + 异步操作(结果promise对象)</span></span><br><span class="line">  <span class="comment">// 读取a文件</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFile(<span class="string">'./data/a1.txt'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 b 文件</span></span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFile(<span class="string">'./data/b.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 c 文件</span></span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> readFile(<span class="string">'./data/c.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(b)</span><br><span class="line">    &#125;, a)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> sleep(<span class="number">1000</span>, <span class="string">'a'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res1)</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> sleep(<span class="number">5000</span>, <span class="string">'b'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> sleep(<span class="number">3000</span>, <span class="string">'c'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn()</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>, <span class="string">'a'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> sleep(<span class="number">5000</span>, <span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> sleep(<span class="number">3000</span>, <span class="string">'c'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.all([sleep(<span class="number">1000</span>, <span class="string">'a'</span>), sleep(<span class="number">5000</span>, <span class="string">'b'</span>)])</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.race([sleep(<span class="number">1000</span>, <span class="string">'a'</span>), sleep(<span class="number">5000</span>, <span class="string">'b'</span>)])</span><br><span class="line">p2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2019/vue/vue+elementui/"/>
      <url>/2019/vue/vue+elementui/</url>
      
        <content type="html"><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p>组件抽离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 标签不要动，只需要把内容题出去后，添加 src 引入即可</span><br><span class="line">&lt;template src=&quot;./Roles.html&quot;&gt;&lt;/template&gt;</span><br><span class="line">&lt;script src=&quot;./Roles.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style src=&quot;./Roles.less&quot; lang=&quot;less&quot; scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>scoped</p><p>vue 组件之间的样式有自动复用的问题，给一个类设置样式，其他组件中相同类的元素也会被设置样式</p><p>解决：在 <code>style</code> 标签上添加 <code>scoped</code> 字段，设置样式只作用于当前组件</p><p> <code>&lt;style scoped&gt;&lt;/style&gt;</code></p><p>作用 1：让当前组件内的样式，只能在当前组件上起效果<br>作用 2：如果添加了 scoped，样式只会对本来就存在的标签/组件起效果，如果是动态添加的组件/标签，是无效的</p><p>动态添加的组件/标签，在 <code>.vue</code>文件里添加一个 style 标签，在标签里设置该样式属性，或者在选择器前添加<code>/deep/</code></p><p>vm.$nextTick( [callback] )：将回调延迟到下次 DOM 更新循环之后执行</p><p>如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise：<code>await this.$nextTick()</code></p><p>插槽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">通过 scope.row 获取当前行的数据</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面跳转</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'login'</span> &#125;)</span><br><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="element"><a href="#element" class="headerlink" title="element"></a>element</h2><p><code>span=&#39;1&#39;</code>：赋值 span 的是一个字符串 ‘1’</p><p><code>:span=&#39;1&#39;</code>：前面加一个<code>:</code> 意思是动态数据绑定，赋值 span 的是具体数据类型的数据，即数字  1</p><h3 id="时间日期选择器"><a href="#时间日期选择器" class="headerlink" title="时间日期选择器"></a>时间日期选择器</h3><p>日期选择器限制选择范围</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-date-picker</span> <span class="attr">v-model</span>=<span class="string">"options.endDate"</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">:picker-options</span>=<span class="string">"endDateOptions"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-date-picker</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">endDateOptions: &#123;</span><br><span class="line">  disabledDate: <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 限制结束时间范围为大于开始时间，并在一周内</span></span><br><span class="line">  <span class="keyword">return</span> time.getTime() &lt; <span class="keyword">this</span>.options.startDate || time.getTime() &gt; <span class="keyword">this</span>.options.startDate + <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tree-树形控件"><a href="#Tree-树形控件" class="headerlink" title="Tree 树形控件"></a>Tree 树形控件</h3><ul><li>Attributes</li></ul><p>show-checkbox：节点是否可被选择</p><p>default-expand-all：是否默认展开所有节点</p><p>node-key： 每个树节点用来作为唯一标识的属性，整棵树应该是唯一的</p><ul><li>方法</li></ul><p>this.$refs.tree.setCheckedKeys：通过 keys 设置目前勾选的节点，使用此方法必须设置 node-key 属性</p><p>this.$refs.tree.getCheckedKeys：若节点可被选择（即 show-checkbox 为 true），则返回目前被选中的节点的 key 所组成的数组</p><h3 id="NavMenu-导航菜单"><a href="#NavMenu-导航菜单" class="headerlink" title="NavMenu 导航菜单"></a>NavMenu 导航菜单</h3><h4 id="Menu-Attribute"><a href="#Menu-Attribute" class="headerlink" title="Menu Attribute"></a>Menu Attribute</h4><p>router：是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转</p><p>background-color：菜单的背景色（仅支持 hex 格式）#ffffff</p><p>text-color：菜单的文字颜色（仅支持 hex 格式）</p><p>active-text-color：当前激活菜单的文字颜色（仅支持 hex 格式）</p><p>default-active：当前激活菜单的 index</p><p>unique-opened：是否只保持一个子菜单的展开</p><h3 id="Table-表格"><a href="#Table-表格" class="headerlink" title="Table 表格"></a>Table 表格</h3><h4 id="Table-column-Attributes"><a href="#Table-column-Attributes" class="headerlink" title="Table-column Attributes"></a>Table-column Attributes</h4><ul><li>type：设置 <code>index</code> 则显示该行的索引（从 1 开始计算）；设置 <code>expand</code> 则显示为一个可展开的按钮；</li></ul><p>设置了 <code>selection</code> 则显示多选框</p><ul><li>自定义索引 <code>index</code>：如果设置了 <code>type=index</code>，可以通过传递 <code>index</code> 属性来自定义索引，属性传入数字时，将作为索引的起始值。传入方法是，它提供当前行的行号（从 <code>0</code> 开始）作为参数，返回值将作为索引展示。</li></ul><p><code>type=&quot;index&quot; :index=&quot;indexMethod&quot;</code>  <code>indexMethod(index) {return index}</code></p><h3 id="Radio-单选框"><a href="#Radio-单选框" class="headerlink" title="Radio 单选框"></a>Radio 单选框</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-radio v-model=&quot;radio&quot; label=&quot;1&quot;&gt;备选项&lt;/el-radio&gt;</span><br><span class="line">&lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;备选项&lt;/el-radio&gt;</span><br></pre></td></tr></table></figure><p>选中意味着变量的值为相应 <code>label</code> 属性的值，<code>label</code>可以是<code>String</code>、<code>Number</code>或<code>Boolean</code>。</p><h4 id="禁用状态"><a href="#禁用状态" class="headerlink" title="禁用状态"></a>禁用状态</h4><p>设置<code>disabled</code>属性<code>true</code>为禁用</p><h4 id="单选框组"><a href="#单选框组" class="headerlink" title="单选框组"></a>单选框组</h4><p>结合 el-radio-group 元素和子元素 el-radio 可以实现单选组，在 el-radio-group 中绑定 v-model，在 el-radio 中设置好 label 即可，无需再给每一个 el-radio 绑定变量，另外，还提供了 change 事件来响应变化，它会传入一个参数value</p><h4 id="Radio-Events"><a href="#Radio-Events" class="headerlink" title="Radio Events"></a>Radio Events</h4><p>change：绑定值变化时触发的事件  选中的 Radio label 值</p><h3 id="Cascader-级联选择器"><a href="#Cascader-级联选择器" class="headerlink" title="Cascader 级联选择器"></a>Cascader 级联选择器</h3><h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>options：可选项数据源，键名可通过 <code>props</code> 属性配置</p><p>props：配置选项，对象</p><p>​    value：指定选项的值为选项对象的某个属性值</p><p>​    label：指定选项标签为选项对象的某个属性值</p><p>​    children：指定选项的子选项为选项对象的某个属性值</p><h3 id="Upload-上传"><a href="#Upload-上传" class="headerlink" title="Upload 上传"></a>Upload 上传</h3><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><ul><li><p>action: 必选参数，上传的完整地址</p></li><li><p>multiple: 是否支持多选文件</p></li><li><p>:on-preview: 点击文件列表中已上传的文件时的钩子  function(file)</p></li><li><p>:on-remove: 文件列表移除文件时的钩子 function(file, fileList)</p></li><li><p>list-type: 文件列表的类型</p></li><li><p>:before-upload: 对文件校验 function(file)，若返回 false 或者返回 Promise 且被 reject，则停止上传</p></li><li><p>:on-success: 文件上传成功时的钩子  function(response, file, fileList)</p></li></ul><p>​    response：参数一， 接口的响应结；file：参数二， 文件对象；fileLIst：参数三，文件对象列表</p><p>​    自定义参数 <code>:on-success=&quot;(res, file, fileList) =&gt; UploadImg(1, res, file, fileList)&quot;</code></p><ul><li><p>headers: 设置上传的请求头部 object</p></li><li><p>:auto-upload=”false”：手动调用<code>this.$refs.upload.submit()</code>上传</p></li><li><p>on-progress: 文件上传时的钩子    function(event, file, fileList)</p></li></ul><h3 id="Steps-步骤条"><a href="#Steps-步骤条" class="headerlink" title="Steps 步骤条"></a>Steps 步骤条</h3><p>active    设置当前激活步骤    number</p><p>设置<code>active</code>属性，接受一个<code>Number</code>，表明步骤的 index，从 0 开始</p><h3 id="Tabs-标签页"><a href="#Tabs-标签页" class="headerlink" title="Tabs 标签页"></a>Tabs 标签页</h3><h4 id="Tabs-Attributes"><a href="#Tabs-Attributes" class="headerlink" title="Tabs Attributes"></a>Tabs Attributes</h4><p>value / v-model    绑定值，选中选项卡的 name       string    —    第一个选项卡的 name</p><p>tab-position    选项卡所在位置    string    top/right/bottom/left    top</p><h4 id="Tabs-Events"><a href="#Tabs-Events" class="headerlink" title="Tabs Events"></a>Tabs Events</h4><p>tab-click    tab 被选中时触发    被选中的标签 tab 实例</p><h3 id="element-中的-Events-和-Methods"><a href="#element-中的-Events-和-Methods" class="headerlink" title="element 中的 Events 和 Methods"></a>element 中的 Events 和 Methods</h3><p>// 假设有个el-box ,如果看文档,有个 Events 和 Methods<br><el-box></el-box></p><p>// Events<br>close</p><p>// Methdos<br>getData</p><p>// 使用<br>&lt;el-box ref=’box’ @close=’函数名自己写’&gt;</p><p>this.$refs.box.getData()</p><h3 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h3><p>打包 :  npm run build<br>把打好的包放到 http-server 里面</p><p>介绍 vendor : 里面放一些第三方包 vue/vue-router/element-ui 包等</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化 :"></a>优化 :</h4><ul><li><p>按需加载</p></li><li><p>首屏加载时间，是衡量一个网站性能快慢的很重要的一个指标</p></li><li><p>如何提高加载速度呢?</p></li></ul><p>只加载首屏中看到的内容，没有看到的内容都不加载，需要用到的时候，再去加载<br>进来减少首屏的请求次数</p><ul><li>vue 项目打包的时候，如何实现按需加载功能 ?</li></ul><p>vue 的异步组件(路由) 配合 webpack 代码分割的功能实现按需加载功能</p><p>路由懒加载：<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'Home.vue'</span></span><br><span class="line">==&gt;</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'Home.vue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个组件打包在一起</span></span><br><span class="line"><span class="keyword">const</span> Goods = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'goods' */</span> <span class="string">'Goods.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> GoodsAdd = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'goods' */</span> <span class="string">'GoodsAdd.vue'</span>)</span><br></pre></td></tr></table></figure><ul><li>CDN</li></ul><p>在 index.html 引入 CDN 提供的文件</p><p>在 webpack.base.conf.js中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  <span class="comment">// 键：表示 导入包语法 from 后面跟着的名称</span></span><br><span class="line">  <span class="comment">// 值：表示 script 引入JS文件时，在全局环境中的变量名称</span></span><br><span class="line">  vue: <span class="string">'Vue'</span>,</span><br><span class="line">  <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">  axios: <span class="string">'axios'</span>,</span><br><span class="line">  <span class="string">'element-ui'</span>: <span class="string">'ELEMENT'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 index.html 引入 css 文件就不需要在 main.js 中引入了</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> vue </category>
          
          <category> element </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> element </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2019/vue/vue/"/>
      <url>/2019/vue/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><ul><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue 中文网</a></p></li><li><p><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">github 下载地址</a></p></li><li><p>Vue.js (读音 /vju:/ view)</p></li><li><p>渐进式 JavaScript 框架</p><ul><li><p>渐进式：小型项目使用 vue 就够了，随着页面的复杂程度提高，就要学习 vue-rouer 来管理更多的页面，再随着项目的数据越来越多，管理数据也变得麻烦起来了，就开始使用 vuex 来管理数据</p></li><li><p>框架 : 一整套的解决方案</p></li></ul></li></ul><h2 id="框架和库的区别-面试"><a href="#框架和库的区别-面试" class="headerlink" title="框架和库的区别 (面试)"></a>框架和库的区别 (面试)</h2><h3 id="库-Library-，代表-jquery"><a href="#库-Library-，代表-jquery" class="headerlink" title="库(Library) ，代表 : jquery"></a>库(Library) ，代表 : jquery</h3><ul><li>库就是一系列函数的集合，我们开发人员在使用库的时候，想要完成什么样的功能，就调用库中提供的某个方法</li></ul><p>比如：想要添加样式，就调用 jquery 中的 .css() / .addClass()</p><ul><li>库起到了一个辅助的作用，在使用库的是时候，是由开发人员说了算，也是由开发人员起主导作用</li></ul><h3 id="框架-Framework-，代表-vue"><a href="#框架-Framework-，代表-vue" class="headerlink" title="框架 (Framework)，代表 : vue"></a>框架 (Framework)，代表 : vue</h3><ul><li><p>在使用框架的时候，是由框架说了算，由框架起到了主导作用</p></li><li><p>框架是一套完整的解决方案，框架中制定了一套规则，使用框架的时候，只需要按照规则把代码放到合适的地方，然后框架会在合适的时机，主动调用开发人员的代码</p></li></ul><p>比如 : 想用vue组件里遍历就得使用 v-for，使用 for 不行</p><h3 id="主要区别：控制反转"><a href="#主要区别：控制反转" class="headerlink" title="主要区别：控制反转"></a>主要区别：控制反转</h3><blockquote><p>也就是 : 谁起到了主导作用</p></blockquote><ul><li><p>使用库的时候：开发人员起主导作用</p></li><li><p>使用框架的时候：框架起到了主导作用</p></li><li><p>从体量上看，框架一般比库大</p></li><li><p>会发现使用框架的时候，会受到很多限制</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/26078359?group_id=830801800406917120" target="_blank" rel="noopener">我们所说的前端框架与库的区别？</a></p></li></ul><h2 id="MVC-MVVM-面试"><a href="#MVC-MVVM-面试" class="headerlink" title="MVC + MVVM (面试)"></a>MVC + MVVM (面试)</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ol><li><p>MVC 是一种软件架构模式，也有人叫做设计模式</p></li><li><p>M : Model 数据模型 (专门用来操作数据，数据的 CRUD)</p></li><li><p>V : View 视图 (对于前端来说就是页面)</p></li><li><p>C : Controller 控制器 (是视图和数据模型沟通的桥梁，用于处理业务逻辑)</p></li></ol><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><blockquote><p>Vue 使用的是 MVVM 模式</p></blockquote><ul><li><p>MVVM ===&gt; M / V / VM</p></li><li><p>M : model 数据层</p></li><li><p>V : view 视图层</p></li><li><p>VM : ViewModel 视图模型</p></li><li><p>核心 : M &lt;===&gt; VM &lt;===&gt; V</p></li></ul><h3 id="MVVM-优势"><a href="#MVVM-优势" class="headerlink" title="MVVM 优势"></a>MVVM 优势</h3><ul><li><p>MVC 模式将应用程序划为三个部分，实现职责分离</p><ul><li><p>但是，在前端中，经常要通过 js 代码来进行一些逻辑操作，最终还要把这些逻辑操作展示页面中，也需要<code>频繁的操作DOM</code></p></li><li><p>比如 : ajax 请求、添加、修改、设置样式、动画</p></li></ul></li><li><p>MVVM 的思想通过 <code>数据双向绑定</code> 让数据自动的双向同步</p><ul><li><p>V (修改视图) –&gt; M</p></li><li><p>M (修改数据) –&gt; V</p></li></ul></li><li><p>采用的是 : <strong>数据驱动视图</strong>的思想，<strong>数据是核心</strong>。不要再想着怎么操作 DOM，而是想着如何操作数据</p></li></ul><h3 id="Vue-中的-MVVM"><a href="#Vue-中的-MVVM" class="headerlink" title="Vue 中的 MVVM"></a>Vue 中的 MVVM</h3><ul><li>注意 : 不推荐直接手动操作 DOM<blockquote><p>每个人操作 DOM 的方法不一样，会造成性能不一样<br>官网 : 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例</p></blockquote></li></ul><h2 id="Vue-基本使用"><a href="#Vue-基本使用" class="headerlink" title="Vue 基本使用"></a>Vue 基本使用</h2><ol><li><p>安装 : <code>npm i vue</code></p></li><li><p>导入 : <code>&lt;script src=&#39;./vue.js&#39;&gt;&lt;/script&gt;</code></p></li><li><p>实例化 vue</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 指定 vue 管理的边界，不能是 body 或 html 节点</span></span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 提供视图中 需要的数据</span></span><br><span class="line">  <span class="comment">// 视图可以直接使用 data 中的数据</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">'xxx'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul><li><p>vm 官网建议</p></li><li><p>Vue 构造函数首字母大写</p></li><li><p>参数是一个对象</p></li><li><p>id=’#app’, 其他也可以</p></li><li><p>边界外的无法使用 msg</p></li></ul><h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. &#123;&#123;&#125;&#125; : mustache 语法，小胡子语法，插值表达式</span><br><span class="line">2. 作用 : 使用`&#123;&#123;&#125;&#125;` 从`data`中获取数据，并展示在模板中</span><br><span class="line">3. 说明 : `&#123;&#123;&#125;&#125;` 中只能出现 js 表达式</span><br><span class="line">4. `&#123;&#123;&#125;&#125;` 语法不能作用在 HTML 元素的属性上</span><br></pre></td></tr></table></figure><ul><li>表达式 (有返回值的)<ul><li>基本的数据类型 <code>1 &#39;abc&#39; false [] {}</code></li><li>数据类型 和 运算符结合在一起<code>1+2 arr.join(&#39;-&#39;) true ? 123 : 321</code></li></ul></li><li>语句 <code>if语句 for语句</code></li></ul><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><h3 id="input-v-model"><a href="#input-v-model" class="headerlink" title="input + v-model"></a>input + v-model</h3><p> v-model 指令：数据双向绑定的指令</p><ul><li>作用：把 data 中的 num 值 和 input 上的值绑定到一起，一方的值发生了改变，另 一方也会跟着改变</li><li>注意：v-model 只能用在表单控件上（input checkbox 等）</li></ul><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"><span class="comment">// 参数1：要给哪个对象设置属性</span></span><br><span class="line"><span class="comment">// 参数2：给对象设置什么属性</span></span><br><span class="line"><span class="comment">// 参数3：属性的修饰符</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'赋值了'</span>, newVal)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'取值了'</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据双向绑定的原理"><a href="#数据双向绑定的原理" class="headerlink" title="数据双向绑定的原理"></a>数据双向绑定的原理</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">    <span class="comment">// 设置属性时会触发该函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'设置'</span>, newVal)</span><br><span class="line">    temp = newVal</span><br><span class="line">    input.value = newVal</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="comment">// 获取属性时会触发该函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'获取'</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">input.oninput = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this.value)</span></span><br><span class="line">  obj.name = <span class="keyword">this</span>.value</span><br><span class="line">  <span class="built_in">console</span>.log(obj.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><p>检测变化注意：受现代 JavaScript 的限制 (而且 <code>Object.observe</code> 也已经被废弃)，Vue <strong>不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 转换它，这样才能让它是响应的</p><p><strong>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性</strong>，可以使用 <code>Vue.set(object, key, value)</code> 方法将响应属性添加到嵌套的对象上，或者创建一个包含原对象属性和新属性的对象替换掉原对象</p><h3 id="列表渲染数组更新检测"><a href="#列表渲染数组更新检测" class="headerlink" title="列表渲染数组更新检测"></a>列表渲染数组更新检测</h3><p>数组的方法可以触发视图更新：方法如下：</p><p><code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code></p><p>替换数组</p><p>用一个含有相同元素的数组去替换原来的数组并不会导致 Vue 丢弃现有 DOM 并重新渲染整个列表</p><p>注意：由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p><ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>解决第一类问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure><p>解决第二类问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><h2 id="指令学习"><a href="#指令学习" class="headerlink" title="指令学习"></a>指令学习</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>指令：就是一个特殊的标记，起一个辅助作用，使 html 具备原来没有的功能</li><li>vue 中所有的指令都是以 <code>v-</code> 开头的，比如 : v-model v-bind v-if v-for 等等</li></ul><h3 id="v-model-常用"><a href="#v-model-常用" class="headerlink" title="v-model (常用)"></a>v-model (常用)</h3><blockquote><p>说明：用在<code>表单</code>元素中，用来实现<code>数据双向绑定</code> (input checkbox 等等)<br>作用：将 <code>数据</code> 和 <code>文本框的值</code> 绑定到一起，任何一方发生改变，都会引起对方的改变<br>注意：v-model 在不同类型的表单元素中作用不同<br><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 的初始值而总是将 Vue 实例的数据作为数据来源</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 文本输入框 绑定的是值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"num"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 多选框  绑定的选中状态 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"isChecked"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    num: <span class="number">0</span>,</span><br><span class="line">    isChecked: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-text-和-v-html"><a href="#v-text-和-v-html" class="headerlink" title="v-text 和 v-html"></a>v-text 和 v-html</h3><blockquote><p>说明 : 设置文本内容</p></blockquote><p>v-text :  相当于之前的 innerText</p><p>v-html :  相当于之前的 innerHTML，会解析 html 标签，（已经废弃三大括号的插值）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">"msg1"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-html</span>=<span class="string">"msg2"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg1: <span class="string">'&lt;a href="#"&gt;haha&lt;/a&gt;'</span>,</span><br><span class="line">    msg2: <span class="string">'&lt;a href="#"&gt;haha&lt;/a&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-bind-常用"><a href="#v-bind-常用" class="headerlink" title="v-bind (常用)"></a>v-bind (常用)</h3><blockquote><p>说明：动态绑定数据 (单向)<br>出现原因：在 HTML 属性中，无法使用插值表达式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"href"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-bind 可以直接省略 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"href"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v-bind：</span></span><br><span class="line"><span class="comment">// 说明：动态数据绑定 (单向)，因为html的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据, 需要使用 v-bind</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    href: <span class="string">'https://www.baidu.com'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="v-bind-和-v-model-的区别"><a href="#v-bind-和-v-model-的区别" class="headerlink" title="v-bind 和 v-model 的区别"></a>v-bind 和 v-model 的区别</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-model 数据双向绑定 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--场景：表单元素中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"isChecked1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  v-bind 数据动态绑定 (单向) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--场景：主要用在属性中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">:checked</span>=<span class="string">"isChecked2"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 操作样式 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1. 动态添加类，但不符合vue数据是核心的思想 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">"cls"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 2. class值是一个对象 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性名为类名 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性值为布尔值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">"&#123;red: isRed, fz: isFz&#125;"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 3. style --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">"&#123;backgroundColor: 'red', fontSize: fz + 'px'&#125;"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v-bind :</span></span><br><span class="line"><span class="comment">// 说明 : 动态数据绑定 (单向)，因为html的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据 , 需要使用 v-bind</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    href: <span class="string">'https://www.baidu.com'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其他操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"['red', 'fz']"</span>&gt;</span>heheheh<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ===&gt; &lt;div class="red fz"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 多个样式对象写成数组的形式，如果有相同样式后面会覆盖前面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[&#123;red: true&#125;, 'fz']"</span>&gt;</span>hehehe<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ===&gt; &lt;div class="red fz"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><blockquote><p>注册事件/绑定事件</p></blockquote><ol><li><p>v-on:click 绑定了一个 click 事件</p></li><li><p>缩写 : @click=’fn’</p></li><li><p>函数写在 <code>methods</code> 里面</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"fn"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 简写 @ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn1"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传参 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn2(123)"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v-on 注册事件</span></span><br><span class="line"><span class="comment">// v-on:click =&gt; 绑定点击事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 事件函数写在 methods 中</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'haha'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn1 () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'haha'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2 (ref) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(ref)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>函数里面的 this 指的就是 vm 实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> === vm <span class="comment">// true</span></span><br><span class="line"><span class="keyword">this</span>.msg <span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">this</span>.msg = <span class="string">'XXX'</span> <span class="comment">// 修改数据</span></span><br></pre></td></tr></table></figure><ol start="5"><li>事件对象 $event</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定事件对象的时候, 没有添加小括号，此时，直接在方法中，通过参数 e 就可以获取到事件对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果绑定事件的地方,事件函数有()  @click='fn()' 则需要通过 $event 获取 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn1($event, 123)"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn1 (e, ref) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">      <span class="built_in">console</span>.log(ref)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>遍历数据，为数据中的每一项生成一个指令所在的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1: 最常用 遍历数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in list1"</span>&gt;</span>&#123;&#123; item &#125;&#125; - &#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2: 遍历元素是对象的数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in list2"</span>&gt;</span>&#123;&#123; item.name &#125;&#125; - id:&#123;&#123; item.id &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3: 遍历对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- item 是 属性值，key 是属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, key) in obj"</span>&gt;</span>&#123;&#123; item &#125;&#125;-&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4: 生成10个h1 （item是1-10）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">"item in 10"</span>&gt;</span>我是h1 &#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="headerlink" title="v-if 和 v-show"></a>v-if 和 v-show</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">'isShow'</span>&gt;</span>我是h1 v-if<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">'isShow'</span>&gt;</span>我是h1 v-show<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-if 和 v-show 的异同点：</p><ul><li><p>相同点: 可以切换元素的显示与隐藏</p></li><li><p>不同点: 切换显示和隐藏的实现不同</p><ul><li>v-if：显示：创建节点；隐藏：删除节点</li><li>v-show：显示：display:block；隐藏： display:none</li></ul></li><li><p>使用场景 :</p><ul><li>v-if 因为要不断的创建和删除来切换显示与隐藏，所以性能不高</li><li>v-if：切换次数不频繁的时候</li><li>v-show：切换次数频繁的时候</li></ul></li></ul><h3 id="v-else-if-和-v-else"><a href="#v-else-if-和-v-else" class="headerlink" title="v-else-if 和 v-else"></a>v-else-if 和 v-else</h3><ul><li>v-else：两种情况的</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"num &gt; 40"</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>v-else-if：三种以上情况</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"num &gt;= 40"</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">"num &gt;= 30 &amp;&amp; num &lt; 40"</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>作用：告诉 vue 这个标签中的内容只需要解析一次，即便是数据再发送改变，这个标签中的内容也不会被更新</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>带 onece 的 &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>作用：告诉 vue 这段节点中没有指令或表达式，不需要解析，从而，提升性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span>带 v-pre &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><p>使用遮盖</p><ul><li><p>给要遮盖的元素添加一个 v-cloak 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用属性选择器，添加样式：<code>[v-cloak] { display: none }</code></p></li><li><p>vue 会在解析模板后将 v-cloak 指令从页面中移除，移除指令的时候，差值表达式已经变为对应的数据</p></li></ul><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符</p><p> Vue 为最常用的按键提供了别名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>全部的按键别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>写起来像一个方法，用起来像一个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fn () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：只有跟计算属性相关的数据发生了改变，计算属性才会重新计算<br>注意点:</p><ul><li><p>计算属性必须返回一个值</p></li><li><p>计算属性只能当属性用，不能当方法用</p></li><li><p>不能和 data 中的属性名重名</p></li></ul><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。它的工作方式类似于一个属性，所以你需要用 <code>v-bind</code> 来绑定动态值</p><p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升</p><ul><li><code>就地复用</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">  &#123;&#123;item.name&#125;&#125; <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据 --&gt;</span></span><br><span class="line">data: &#123;list: [&#123;id: 1, name: 'zs'&#125;, &#123;id: 2, name: 'ls'&#125;, &#123;id: 3, name: 'ww'&#125;]</span><br><span class="line"><span class="comment">&lt;!-- 演示  --&gt;</span></span><br><span class="line">vm.list.unshift(&#123;id:4, name:'zl'&#125;)</span><br></pre></td></tr></table></figure><ul><li>使用 key<ul><li>如果数组的元素是一个对象，使用对象里固定属性，一般情况下，对象里都有 id</li><li>如果数组的元素是一个简单类型，不是一个对象，就可以取索引作为 key</li></ul></li></ul><h2 id="异步-DOM-更新"><a href="#异步-DOM-更新" class="headerlink" title="异步 DOM 更新"></a>异步 DOM 更新</h2><ol><li>Vue 中采用了 <code>异步DOM更新</code> 的机制</li><li>数据发生改变后，vue 没有立即将数据的改变更新到视图中，而是等到数据不再变化的时候 一次性的将数据的改变更新到视图中</li></ol><p>为什么是异步 DOM 更新?</p><ul><li>性能的考虑</li><li>因为对于前端来说，修改数据进行 DOM 操作是常有的事情，如果频繁操作 DOM，会严重影响页面的加载性能</li><li>DOM 操作这是前端的性能的瓶颈</li><li>比如 : for (let i = 1; i &lt; 10000; i++&gt;) 如果同步 就要重新渲染 1000 次</li></ul><p>验证异步 DOM 更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过dom来获取count的值</span></span><br><span class="line"><span class="comment">// this.$el ==&gt; vue 边界元素</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.count = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>需求：在数据更新后，立即获取到更新后的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 更新后，会执行 this.$nextTick() 的回调函数，所以能拿到值</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="监听-watch"><a href="#监听-watch" class="headerlink" title="监听 watch"></a>监听 watch</h2><p>vue 中可以通过 watch 配置项来监听 vue 实例中数据的变化</p><ul><li>基本使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  num: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//  监听</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 监听 num 属性的数据变化</span></span><br><span class="line">  <span class="comment">// 作用: 只要 num 的值发生变化，这个方法就会被调用</span></span><br><span class="line">  <span class="comment">// 第一个参数: 新值</span></span><br><span class="line">  <span class="comment">// 第二个参数: 旧值</span></span><br><span class="line">  num (newVal, oldVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'新:'</span>, newVal)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'旧:'</span>, oldVal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>监听对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  msg: <span class="string">''</span>,</span><br><span class="line">  obj: &#123;</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 监听对象</span></span><br><span class="line">  obj (newVal) &#123;</span><br><span class="line">    <span class="comment">// 虽然 obj 中的属性值发生改变了，但 obj 引用的地址没有发生改变，所以不会触发事件</span></span><br><span class="line">    <span class="built_in">console</span>.log(newVal)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 监听对象的属性</span></span><br><span class="line">  <span class="comment">// 从对象的角度来监听的</span></span><br><span class="line">  obj: &#123;</span><br><span class="line">    <span class="comment">// 深度监听 监听对象里面的属性</span></span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面刚进入立即触发监听，以表达式的当前值触发回调</span></span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象里的属性值发生变化，调用 handler 方法</span></span><br><span class="line">    handler (newVal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.msg = <span class="string">`obj.age 值变化了，新值：<span class="subst">$&#123;newVal.age&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 从属性的角度来监听</span></span><br><span class="line">  <span class="string">'obj.age'</span> (newVal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.msg = <span class="string">`obj.age 值变化了，新值：<span class="subst">$&#123;newVal&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用案例：需求 : 监听文本框字符个数，并显示格式验证码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"val"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">'isTrue'</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  val: <span class="string">''</span>,</span><br><span class="line">  msg: <span class="string">'请输入 6-12 位'</span>,</span><br><span class="line">  isTrue: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  val (newVal) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^[0-9a-zA-z]&#123;6,12&#125;$/</span>.test(newVal)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.isTrue = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.isTrue = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><ul><li>所有的 vue 组件，都是 vue 实例，一个组件对应一个实例，并且接收相同的选项对象（一些根实例特有的选项除外）</li><li>实例生命周期也叫做：组件生命周期</li><li>声明周期图：<a href="/zh-cn/_vue/Vue实例生命周期图">01</a></li></ul><h3 id="生命周期介绍"><a href="#生命周期介绍" class="headerlink" title="生命周期介绍"></a>生命周期介绍</h3><p><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">vue 生命周期钩子函数</a></p><ul><li>简单说：一个组件（实例）从开始到最后消化所经历的各种状态，就是一个组件的生命周期</li><li>生命周期钩子函数的定义：从组件被创建，到组件挂在到页面上运行，再到页面关闭组件被销毁，这三个阶段总是伴随着组件的各种事件，这些事件，统称为组件的生命周期函数（简称 : 钩子函数）</li><li>开发人员可以通过 vue 提供的钩子函数，让我们写的代码参与到 vue 的生命周期里面来，让我们的代码在合适的阶段起到相应的作用</li></ul><p>注意：</p><ul><li>vue 在执行过程中会 <strong>自动调用</strong> <code>生命周期钩子函数</code>，我们只需要提供这些钩子函数即可</li><li>钩子函数的名称都是  vue 中规定好的</li></ul><p><a href="https://segmentfault.com/a/1190000008879966" target="_blank" rel="noopener">vue 实例生命周期 参考 1</a></p><p><a href="https://segmentfault.com/a/1190000008010666" target="_blank" rel="noopener">vue 实例生命周期 参考 2</a></p><h3 id="钩子函数-beforeCreate"><a href="#钩子函数-beforeCreate" class="headerlink" title="钩子函数 - beforeCreate"></a>钩子函数 - beforeCreate</h3><ul><li>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li><li>此时组件的选项还未挂载，因此无法访问 methods，data，computed 上的方法或数据</li><li>使用场景 : 几乎不用</li></ul><h3 id="钩子函数-created-掌握"><a href="#钩子函数-created-掌握" class="headerlink" title="钩子函数 - created (掌握)"></a>钩子函数 - created (掌握)</h3><ul><li>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见</li><li>可以调用 methods 中的方法、改变 data 中的数据，并且修改可以通过 vue 的响应式绑定体现在页面上、获取computed 中的计算属性等</li><li>使用场景：发送 ajax、本地存储获取数据</li></ul><h3 id="钩子函数-beforeMounted"><a href="#钩子函数-beforeMounted" class="headerlink" title="钩子函数 - beforeMounted()"></a>钩子函数 - beforeMounted()</h3><ul><li>在挂载开始之前被调用（挂载：DOM 渲染）</li></ul><h3 id="钩子函数-mounted-掌握"><a href="#钩子函数-mounted-掌握" class="headerlink" title="钩子函数 - mounted() (掌握)"></a>钩子函数 - mounted() (掌握)</h3><ul><li><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</li><li>这个周期可以获取 DOM</li><li>指令的生效在 mounted 周期之前</li><li>在这个周期内，对 data 的改变可以生效。但是要进下一轮的 DOM 更新，DOM 上的数据才会更新</li><li>使用场景：发送 ajax、操作 DOM</li></ul><h3 id="钩子函数-beforeUpdate"><a href="#钩子函数-beforeUpdate" class="headerlink" title="钩子函数 - beforeUpdate()"></a>钩子函数 - beforeUpdate()</h3><ul><li><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p></li><li><p>此处获取的数据是更新后的数据，但是获取页面中的 DOM 元素是更新之前的</p><blockquote><p>小提示 : 打印 this.$el ，打开小三角是之后的，是因为打印是有监听的功能，展示的是后面更改之后的</p></blockquote></li></ul><h3 id="钩子函数-updated"><a href="#钩子函数-updated" class="headerlink" title="钩子函数 - updated()"></a>钩子函数 - updated()</h3><ul><li>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</li><li>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作</li><li>应该避免在此期间更改状态。如果要相应状态改变，通常最好使用 <strong>计算属性</strong> 或 <strong>watcher</strong> 取而代之</li></ul><h3 id="钩子函数-beforeDestroy"><a href="#钩子函数-beforeDestroy" class="headerlink" title="钩子函数 - beforeDestroy()"></a>钩子函数 - beforeDestroy()</h3><ul><li>实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">this</span>.timerId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1111</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果当组件销毁了,还不清除定时器会出现性能问题</span></span><br><span class="line"> <span class="comment">// 在浏览器中可以尝试销毁 vm.$destroy()</span></span><br><span class="line"> <span class="comment">// 最后销毁</span></span><br><span class="line">beforeDestroy () &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="钩子函数-destroyed"><a href="#钩子函数-destroyed" class="headerlink" title="钩子函数 - destroyed()"></a>钩子函数 - destroyed()</h3><ul><li>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul><h2 id="使用接口的形式发送数据"><a href="#使用接口的形式发送数据" class="headerlink" title="使用接口的形式发送数据"></a>使用接口的形式发送数据</h2><h3 id="json-server-提供假数据接口"><a href="#json-server-提供假数据接口" class="headerlink" title="json-server 提供假数据接口"></a>json-server 提供假数据接口</h3><ul><li>作用：根据指定的 JSON 文件，提供假数据接口</li><li>地址：<a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">json-server</a></li><li>使用步骤</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 全局安装 json-server: <span class="string">`npm i -g json-server`</span></span><br><span class="line"><span class="number">2.</span> 准备一个json数据</span><br><span class="line"><span class="number">3.</span> 执行：<span class="string">`json-server data.json`</span></span><br><span class="line"></span><br><span class="line">data.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"todos"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">      <span class="string">"age"</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>REST API格式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 查询：GET</span><br><span class="line"><span class="number">2.</span> 添加：POST</span><br><span class="line"><span class="number">3.</span> 删除：DELETE</span><br><span class="line"><span class="number">4.</span> 更新：</span><br><span class="line">PUT：需要将对象里的所有属性提交</span><br><span class="line">  PATCH(打补丁)：只需要提交需要修改的属性</span><br></pre></td></tr></table></figure><ul><li>具体接口<ul><li>查询全部数据 <a href="http://localhost:3000/todos" target="_blank" rel="noopener">http://localhost:3000/todos</a><br>查询指定数据 <a href="http://localhost:3000/todos/2" target="_blank" rel="noopener">http://localhost:3000/todos/2</a></li><li>添加一个对象 <a href="http://localhost:3000/todos" target="_blank" rel="noopener">http://localhost:3000/todos</a><br>POST<br>id 会自动帮我们添加</li><li>更新数据 <a href="http://localhost:3000/todos/3" target="_blank" rel="noopener">http://localhost:3000/todos/3</a><br>PUT 或者 PATCH<br>PUT 需要提供该对象的所有数据<br>PATCH 只需要提供要修改的数据即可</li><li>删除数据<a href="http://localhost:3000/todos/3" target="_blank" rel="noopener">http://localhost:3000/todos/3</a><br>DELETE</li></ul></li><li>可以借助 <code>postman</code> 测试接口</li></ul><h3 id="axios-发送请求"><a href="#axios-发送请求" class="headerlink" title="axios 发送请求"></a>axios 发送请求</h3><ul><li><strong>作用</strong> : 一个专门用来发送 ajax 请求的库,  可以在浏览器或者node.js 中使用</li><li><strong>使用步骤</strong><ul><li>本地安装 axios : <code>npm i -g axios</code></li><li>导入 axios</li></ul></li><li><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios 使用说明</a></li><li><strong>GTE 方式发送请求</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">axios.get(<span class="string">'http://localhost:3000/todoList/1'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'获取到数据了：'</span>, res.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">axios.get(<span class="string">'http://localhost:3000/todoList'</span>,&#123;</span><br><span class="line">  params : &#123;</span><br><span class="line">    id : <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'获取到数据了：'</span>, res.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>POST 方式发送请求</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// post 请求</span></span><br><span class="line">axios</span><br><span class="line"><span class="comment">// 第一个参数：表示接口地址</span></span><br><span class="line"><span class="comment">// 第二个参数：表示接口需要的参数</span></span><br><span class="line">  .post(<span class="string">'http://localhost:3000/todoList'</span>, &#123;</span><br><span class="line">  name: <span class="string">'haha'</span>,</span><br><span class="line">  done: <span class="literal">true</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><strong>概念 :</strong></p><ul><li>vue 中的过滤器(filter)：<strong>数据格式化</strong>，让数据按照我们规定的格式输出</li><li>比如 : 对于日期来说，将日期格式化转化为 <code>年-月-日 小时:分:秒</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">显示：2019-01-11T10:11:19.566Z</span><br><span class="line">不是我们想要的</span><br><span class="line">我们想要的：2019-01-11 18-11-53</span><br></pre></td></tr></table></figure><p><strong>全局过滤器 和 局部过滤器</strong></p><ul><li>全局方式创建的过滤器，在任何一个 Vue 实例中都可以使用 (一般情况下，为了项目方便管理，都是一个 vue 实例)</li><li>局部创建的过滤器只能在当前 vue 实例中使用</li><li>全局过滤器应在 Vue 实例创建之前创建</li></ul><p><strong>注册全局过滤器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：过滤器的名字</span></span><br><span class="line"><span class="comment">// 第二个参数：是一个回调函数，只要使用过滤器的时候，这个回调函数就会执行，res =&gt; 原始数据</span></span><br><span class="line"><span class="comment">// 必须要有返回值：通过回调函数的返回值得到格式化后的数据</span></span><br><span class="line">Vue.filter(<span class="string">'date'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注册局部过滤器</strong></p><p>在 vm 的配置项里写一个 <code>filters</code>，对应的是一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  date (res) &#123;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>moment 插件</strong></p><ul><li><p><a href="http://momentjs.cn/" target="_blank" rel="noopener">moment</a></p></li><li><p>使用：<code>npm i moment</code></p></li><li><p>日期 =&gt; 指定格式<code>moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;)</code></p></li><li><p>时间戳 =&gt; 指定格式<code>moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;)</code></p></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'dataFilter'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> moment(res).format(<span class="string">'YYYY-MM-DD HH-mm-ss'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>使用过滤器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- data: 原始数据  dataFilter: 过滤器名称  |：管道--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date | dataFilter &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局</span></span><br><span class="line">Vue.filter(<span class="string">'dataFilter'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> moment(res).format(<span class="string">'YYYY-MM-DD HH-mm-ss'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部</span></span><br><span class="line">filters: &#123;</span><br><span class="line">  date (res, format = <span class="string">'YYYY-MM-DD'</span>, arg) &#123;</span><br><span class="line">    <span class="keyword">return</span> moment(res).format(format)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数问题</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date | dateFilter('YYYY-MM-DD HH-mm-ss', 888) &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'dateFilter'</span>, (res, format = <span class="string">'YYYY-MM-DD'</span>, arg) =&gt; &#123;</span><br><span class="line">  <span class="comment">// res: 原始数据</span></span><br><span class="line">  <span class="comment">// format：dateFilter 中的第一个参数，等号后面为默认值</span></span><br><span class="line">  <span class="comment">// arg: dateFilter 中的第二个参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg) <span class="comment">// 888</span></span><br><span class="line">  <span class="keyword">return</span> moment(res).format(format)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote><p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常 <strong>可复用</strong> 的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p></blockquote><p><img src="components.png" alt="组件化图释"></p><ul><li>注册组件的两种方式：全局组件、局部组件</li><li>Vue实例中的配置项（如：methods、filters、watch、computed、directives、生命周期钩子函数）都可以在组件中使用</li></ul><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><ul><li>说明：全局组件在所有的 vue 实例中都可以使用</li><li>注意：<ul><li>注册全局组件应放在 vm 实例之前</li><li>模板只允许有一个根节点</li><li>组件中的 <code>data</code> 必须是函数，并且要返回一个对象</li><li>组件复用时如果 data 为对象，所有复用的组件的 data 指向同一片内存空间，一个组件被修改了会影响其他组件，这不是我们想要的</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册全局组件</span></span><br><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;A custom component!&lt;/p&gt;'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'注意：组件的data必须是一个函数！！！'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给组件指定返回值</span></span><br><span class="line"><span class="comment">// 组件名称为 One</span></span><br><span class="line"><span class="keyword">const</span> One = Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;A custom component!&lt;/p&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 可以简写为 ==&gt;</span></span><br><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;A custom component!&lt;/p&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用：以自定义元素的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><ul><li>局部组件是在某一个具体的vue实例（组件）中定义的，只能在当前 vue 实例（组件）中使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 局部组件</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// 子组件 com-a</span></span><br><span class="line">    <span class="string">'com-a'</span>: &#123;</span><br><span class="line">      template: <span class="string">`&lt;h1&gt;局部组件：&#123;&#123; num &#125;&#125;&lt;/h1&gt;`</span>,</span><br><span class="line">      data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          num: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><ul><li>组件是一个独立、封闭的个体</li><li>也就是说：组件中的数据默认情况下，只能在组件内部使用，无法直接在组件外部使用</li><li>可以将 vue 实例看做一个组件</li><li>对于组件之间需要相互使用彼此的情况，应该使用 <strong>组件通讯机制</strong> 来解决</li><li>组件通讯的三种情况 :<ul><li>父组件将数据传递给子组件(父 -&gt; 子)</li><li>子组件将数据传递给父组件 (子 =&gt; 父)</li><li>非父子组件(兄弟组件)</li></ul></li></ul><h4 id="父组件到子组件"><a href="#父组件到子组件" class="headerlink" title="父组件到子组件"></a>父组件到子组件</h4><ul><li>将要传递的数据，通过属性传递给子组件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">"pmsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子组件通过 <code>props</code> 配置项来指定要接收的数据，props 是一个数组<ul><li>在使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名代替</li><li>如果使用字符串模板，那么这个限制就不存在了</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'msg'</span>]</span><br></pre></td></tr></table></figure><ul><li>传递过来的 <code>props</code> 属性的用法与 <code>data</code> 属性的用法相同</li><li>子组件不能直接修改父组件传过来的数据，可以将父组件传过来的值保存在一个临时变量中<ul><li>如果 props 传过来的数据为引用类型，只要不是重新赋值，修改数据不会报错，但不推荐这样做</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一步：将你要传递的数据,作为属性传递给子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hello</span> <span class="attr">:num</span>=<span class="string">"pnum"</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二部：子组件通过 props 配置项来指定要接收的数据</span></span><br><span class="line">  props: [<span class="string">'num'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="子组件到父组件"><a href="#子组件到父组件" class="headerlink" title="子组件到父组件"></a>子组件到父组件</h4><ul><li>方式：父组件给子组件传递一个函数，由子组件调用这个函数</li><li>说明：借助 vue 中的自定义事件(v-on:cunstomFn=”fn”)</li><li><code>$emit()</code>：触发事件</li><li>第一步：父组件了里准备一个方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    pfn (num) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>第二步：把这个方法作为事件传递给子组件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello</span> @<span class="attr">fn</span>=<span class="string">"pfn"</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>第三步：子组件调用父组件传过来的方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;button @click='click'&gt;按钮&lt;/button&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">num</span>: <span class="number">5</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    click () &#123;</span><br><span class="line">      <span class="comment">// 第一个参数：表示要触发的自定义事件名称，也就是 @fn</span></span><br><span class="line">    <span class="comment">// 第二个参数：表示要传递给父组件的数据</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'fn'</span>, <span class="keyword">this</span>.num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="非父子组件通讯"><a href="#非父子组件通讯" class="headerlink" title="非父子组件通讯"></a>非父子组件通讯</h4><ul><li><p>是通过 <code>事件总线 (event bus 公交车) 机制</code> 来实现的</p></li><li><p>事件总线：实际上就是一个 <code>空 Vue 实例</code></p></li><li><p>可以实现任意两个组件之间的通讯而不管两个组件到底有什么样的层级关系</p></li><li><p><code>$emit()</code>：发送数据</p></li><li><p><code>$on()</code>：接收数据</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：实例化事件总线 bus</span></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发组件 A 中的事件</span></span><br><span class="line">bus.$emit(<span class="string">'id'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件 B 创建的钩子中监听事件</span></span><br><span class="line">bus.$on(<span class="string">'id'</span>, id =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例：组件A —&gt; 组件B</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com-a</span>&gt;</span><span class="tag">&lt;/<span class="name">com-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com-b</span>&gt;</span><span class="tag">&lt;/<span class="name">com-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：实例化事件总线 bus</span></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 A</span></span><br><span class="line">Vue.component(<span class="string">'com-a'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;h1 @click="click"&gt;组件A&lt;/h1&gt;`</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    click () &#123;</span><br><span class="line">      <span class="comment">// 第二部：发送数据</span></span><br><span class="line">      bus.$emit(<span class="string">'hello'</span>, <span class="string">'你好'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 B</span></span><br><span class="line">Vue.component(<span class="string">'com-b'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;h1&gt;组件B&lt;/h1&gt;`</span>,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">// 第三步：接收数据</span></span><br><span class="line">    bus.$on(<span class="string">'hello'</span>, res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'接收到数据'</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>[开关灯案例]</p><h3 id="单向数据流-组件与组件之间"><a href="#单向数据流-组件与组件之间" class="headerlink" title="单向数据流(组件与组件之间)"></a>单向数据流(组件与组件之间)</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<code>单向下行绑定</code>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>当 todo-head 中的 todoName 设置数据后回车添加到 todoList，todoList 的长度就会发生变化，然后就会根据(组件与组件之间的)单向数据流，把数据单向下流到子组件中<br>而且必须是通过 props 往下传递的才可以</p><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p> <code>vm.$refs</code> 一个对象，持有已注册过 ref 的所有子组件 ( HTML 元素)</p><ul><li>使用 :</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML元素 中，添加ref属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"div"</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JS中通过 $refs.属性 来获取</span></span><br><span class="line"><span class="comment">// 在 mounted 函数中使用</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;h1&gt;组件A&lt;/h1&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">num</span>: <span class="number">100</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn () &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.div) <span class="comment">// div 标签</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child) <span class="comment">// child 组件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果获取的是一个子组件，那么通过 ref 就能获取到子组件中的 <code>data</code> 和 <code>methods</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child.num) <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child.fn) <span class="comment">// fn</span></span><br></pre></td></tr></table></figure><ul><li>一般在第三方的组件中， 可能会用到这个功能</li></ul><h2 id="单页面应用程序"><a href="#单页面应用程序" class="headerlink" title="单页面应用程序"></a>单页面应用程序</h2><p>SPA : <strong>Single Page Application</strong> 单页面应用程序</p><p>MPA : <strong>Multiple Page Application</strong> 多页面应用程序</p><ul><li>单页 web 应用，就是只有一个 web 页面的应用，是加载单个 HTML 页面，并在用户与应用程序交互时动态更新该页面的 web 应用程序</li></ul><ul><li>区别<ul><li>对于传统的多页面应用程序来说，每次请求服务器返回的都是一个完整的页面</li><li>对于单页应用程序来说，只有第一次会加载页面，以后的每次请求，仅仅是获取必要的数据，然后由页面中js解析获取的数据展示在页面中</li></ul></li></ul><ul><li>优势 :<ul><li>减少了请求体积，加快页面响应速度，降低了对服务器的压力</li><li>更好的用户体验，让用户在 web app 感受 native app 的流畅</li></ul></li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul><li><strong>路由</strong> : 是浏览器 URL 中的<code>哈希值</code>( # hash) 与 <code>展示视图内容</code> 之间的<code>对应规则</code><ul><li>在 web App 中，通过一个页面来展示和管理整个应用的功能。SPA 往往是功能复杂的应用，为了有效管理所有视图内容，前端路由应运而生。简单来说，路由就是一套映射规则(一对一的对应规则)，由开发人员制定规则。当 URL 中的哈希值( <code>#</code> hash) 发生改变后，路由会根据制定好的规则，展示对应的视图内容。</li></ul></li><li><strong>vue 中的路由</strong>；是 <strong>hash</strong> 和 <strong>component</strong> 的对应关系，一个哈希值对应一个组件</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装路由 : <code>npm i vue-router</code></p><p>引入路由</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue-router/dist/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>详细使用步骤</p><ul><li>实例路由对象并挂载到 vue 实例 上</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由实例 与 Vue 实例 关联到一起</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter()</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>入口 (#哈希值)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">方式1 : url地址为入口 输入url地址改变哈希值</span></span><br><span class="line"><span class="comment">router.html#/one</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方式2 : router-link+to</span></span><br><span class="line"><span class="comment">to 属性：实际上就是哈希值，将来要参与路由规则中进行与组件匹配</span></span><br><span class="line"><span class="comment">router-link 标签最终会转化为 a 标签，to 属性转化为 a 标签的 href 属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/two"</span>&gt;</span>Tow<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注册组件并设置返回值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置规则</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path : 路由路径</span></span><br><span class="line"><span class="comment">// component : 将来要展示的路由组件</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/one'</span>, <span class="attr">component</span>: One&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/two'</span>, <span class="attr">component</span>: Two&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>出口</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  出口：组件要展示的地方--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>示例 ：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 入口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可以直接通过url地址访问路由 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- to 属性：路由匹配路径</span></span><br><span class="line"><span class="comment">router-link 最终会转化为 a 标签</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/two"</span>&gt;</span>Tow<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 5. 出口 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 注册组件并设置返回值</span></span><br><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实例化路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 4. 配置路由规则，路由和实例一一对应</span></span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/one'</span>, <span class="attr">component</span>: One&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/two'</span>, <span class="attr">component</span>: Two&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 2. 将路由挂载到 vue 实例上，让 vue 和路由关联在一起</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>多出口情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 多个出口的形式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"two"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 配置路由规则，一个路由对应多个实例</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      <span class="comment">// conponents 为一个对象</span></span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="comment">// key 为出口的 name 属性值</span></span><br><span class="line">        <span class="comment">// value 为组件实例</span></span><br><span class="line">        one: One,</span><br><span class="line">        two: Two</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="入口菜单高亮处理"><a href="#入口菜单高亮处理" class="headerlink" title="入口菜单高亮处理"></a>入口菜单高亮处理</h3><p>点击导航会给链接添加两个类名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/one"</span> <span class="attr">class</span>=<span class="string">"router-link-exact-active router-link-active"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/two"</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改方式 1：直接修改类的内容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.router-link-exact-active</span>,</span><br><span class="line"><span class="selector-class">.router-link-active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰方式 2：给默认高亮类名设置别名，别名为已经定义好样式的类名 (推荐)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改默认高亮的a标签的类名</span></span><br><span class="line">  linkActiveClass: <span class="string">'red'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="精确匹配和模糊匹配"><a href="#精确匹配和模糊匹配" class="headerlink" title="精确匹配和模糊匹配"></a>精确匹配和模糊匹配</h3><ul><li>精确匹配：router-link-exact-active 类名 : 只有当浏览器地址栏中的哈希值 与 router-link 的 to 属性值完全匹配才会添加该类</li><li>模糊匹配：router-link-active 类名 : 只要浏览器地址栏中的哈希值包含 router-link 的 to 属性值就会添加该类名</li><li>解决办法：加个 exact</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span> <span class="attr">exact</span>&gt;</span></span><br><span class="line">  One</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：精确匹配和模糊匹配，只对添加类名这个机制有效，与路由的匹配规则无关</li></ul><h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>入口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 入口  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/detail/1"</span>&gt;</span>手机1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/detail/2"</span>&gt;</span>手机2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/detail/3"</span>&gt;</span>手机3<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>传参</p><p><a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D" target="_blank" rel="noopener">动态路由匹配</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Detail = Vue.component(<span class="string">'detail'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">routes: [</span><br><span class="line">  <span class="comment">// 方式1：手动一个一个配置</span></span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/1'</span>, <span class="attr">component</span>: Detail&#125;,</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/2'</span>, <span class="attr">component</span>: Detail&#125;,</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/3'</span>, <span class="attr">component</span>: Detail&#125;，</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确的方式：把传过去的 1/2/3 当成参数</span></span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/:id?'</span>, <span class="attr">component</span>: Detail&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>?</code> 代表参数可传可不传，即可识别的路径包括：<code>detail</code>、<code>detail/1</code>、<code>detail2</code>、<code>detail3</code></p><p>获取参数的三种正确方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $route =&gt; 路由配置对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Detail = Vue.component(<span class="string">'detail'</span>, &#123;</span><br><span class="line">  <span class="comment">// 方式1：组件中直接读取</span></span><br><span class="line">  <span class="comment">// $route.path 为路由路径</span></span><br><span class="line">  <span class="comment">// $route.params.id 为路由参数</span></span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// 方式2：js直接读取</span></span><br><span class="line">    <span class="comment">// 打印只会打印一次，因为组件是复用的，每次进来钩子函数只会执行一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #/detail/2?name=zs</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route) <span class="comment">// 路由配置对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.path) <span class="comment">// #/detail/2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.params) <span class="comment">// &#123;id: "2"&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.query) <span class="comment">// &#123;name: 'zs'&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.params.id) <span class="comment">// 2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 方式3：监听路由的参数变化(因为不是 data 中的数据，不需要深度监听)</span></span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// to：新值</span></span><br><span class="line">    <span class="comment">// from：旧值</span></span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(to.params.id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://router.vuejs.org/zh/guide/essentials/navigation.html#%E7%BC%96%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%AF%BC%E8%88%AA" target="_blank" rel="noopener">编程式导航</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">'123'</span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">'/user'</span>) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象, path为路由的path属性值</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span> &#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由，name 为路由的 name 属性值</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 如果提供了 path，params 会被忽略</span></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'register'</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">'private'</span> &#125;&#125;) <span class="comment">// -&gt; /register?plan=private</span></span><br><span class="line"></span><br><span class="line">routes: [&#123; <span class="attr">path</span>: <span class="string">'/user/:id?'</span>, name=<span class="string">'user'</span>, <span class="attr">component</span>: User &#125;]</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><code>redirect</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 / 重定向到 /home</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/home'</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><h3 id="vue-是单文件组件"><a href="#vue-是单文件组件" class="headerlink" title="vue 是单文件组件"></a>vue 是单文件组件</h3><p>后缀为 .vue 的文件</p><p>单文件组件，无法直接在浏览器中使用，必须经过 webpack 这种打包工具处理后，才能在浏览器中使用</p><p>单文件组件的三个组成部分</p><ul><li>template (模板结构)</li><li>script 组件的代码逻辑</li><li>style 样式</li></ul><h3 id="脚手架介绍"><a href="#脚手架介绍" class="headerlink" title="脚手架介绍"></a>脚手架介绍</h3><p><strong>vue-cli</strong> 是 vue 的脚手架工具</p><p>因为 webpack 配置繁琐，阻止一批想用 vue 但是不会 webpack 的开发人员</p><p>vue-cli 提供了一条命令，我们直接通过这条命令就可以快速的生成一个 vue 项目 (<code>vue init XX</code>)，项目的基本结构、以及 webpack 配置项  <strong>全部配置</strong>  好了</p><p><a href="https://vue-loader.vuejs.org/zh/" target="_blank" rel="noopener">Vue Loader</a> 手动配置置 <code>webpack</code></p><p><a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">Vue CLI3</a></p><p><a href="https://vuejs-templates.github.io/webpack/" target="_blank" rel="noopener">Vue webpack 配置</a></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>安装：<code>npm i -g vue-cli</code></p><p>初始化 vue 项目：<code>vue init webpack 项目名称</code></p><p>进入到项目根目录运行项目：<code>npm run dev</code></p><p>项目安装过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">? Project name demo</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author</span><br><span class="line">? Vue build standalone  =&gt; 运行时+编译</span><br><span class="line">? Install vue-router? Yes</span><br><span class="line">? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard</span><br><span class="line">? <span class="built_in">Set</span> up unit tests No</span><br><span class="line">? Setup e2e tests <span class="keyword">with</span> Nightwatch? No</span><br></pre></td></tr></table></figure><h4 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a>项目目录介绍</h4><p><a href="https://vuejs-templates.github.io/webpack/structure.html" target="_blank" rel="noopener">https://vuejs-templates.github.io/webpack/structure.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build/                      # webpack config files</span><br><span class="line">├── config/index.js             # main project config</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.js                 # app entry file</span><br><span class="line">│   ├── App.vue                 # main app component</span><br><span class="line">│   ├── components/             # ui components</span><br><span class="line">│   └── assets/                 # module assets (processed by webpack)</span><br><span class="line">├── static/                     # pure static assets (directly copied)</span><br><span class="line">├── test/</span><br><span class="line">│   └── unit/                   # unit tests</span><br><span class="line">│   └── e2e/                    # e2e tests</span><br><span class="line">├── .babelrc                    # babel config</span><br><span class="line">├── .editorconfig               # settings for your editor</span><br><span class="line">├── .eslintrc.js                # eslint config</span><br><span class="line">├── .eslintignore               # eslint ignore rules</span><br><span class="line">├── .gitignore                  # sensible defaults for gitignore</span><br><span class="line">├── .postcssrc.js               # postcss config</span><br><span class="line">├── index.html                  # index.html template</span><br><span class="line">├── package.json                # build scripts and dependencies</span><br><span class="line">└── README.md                   # Default README file</span><br></pre></td></tr></table></figure><ul><li>build 和 config 不要动，都是一些配置好的，还有一些他们之间的约定</li><li>.gitkeep：static 为预留的文件夹，空文件夹默认不会上传到 github，添加这个文件让static文件夹被 git 上传</li><li><code>.editorconfig</code> 编译器配置，需要安装 vscode 插件：Editorconfig</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">charset = utf-8   utf-8 格式编码</span><br><span class="line">indent_style = space   空格和tab都可以缩进</span><br><span class="line">indent_size = 2    缩进为2个</span><br><span class="line">end_of_line = lf  回车换行</span><br><span class="line">insert_final_newline = true   结束最后一行+一个空白</span><br><span class="line">trim_trailing_whitespace = true   开头去除空白</span><br></pre></td></tr></table></figure><ul><li><code>eslint</code> 校验<ul><li>忽略文件中有这个 =&gt; /*.js =&gt; 意思是根目录下的.js 文件不校验,,但是发现根目录就没有.js 文件</li><li>/*  eslint-disable no-new */ eslint 忽略 no-new规则</li><li>/_ eslint-disable_/ 也可以</li><li>如果去掉,就会提示你 不要以 new 开头</li><li>可以前面给个变量 var vm = new Vue()</li><li>但是又提示没有用,还要打印一下,其实这个赋值是没有意义的</li><li>不要去掉.这是 eslint 的<code>不校验下一行代码</code></li><li><a href="https://standardjs.com/readme-zhcn.html" target="_blank" rel="noopener">standard 代码规范</a></li></ul></li><li>postcssrc 处理 less css 等</li><li>src<ul><li>assets 静态资源</li><li>components 组件</li><li>router 路由</li><li>App.vue 根组件 =&gt; 指定路由出口</li><li>脚手架之后，所有的组件都将渲染到 app.vue 中</li><li>vm 中的 #app 还是 index.html 中的 #app， app.vue 中的会覆盖前者<br>可以通过分别添加 title 属性验证一下</li><li><code>&lt;router-view/&gt;</code> 路由出口要写在 app.vue 组件模板中</li><li>main.js<ul><li>入口 js 文件</li><li>作用：创建 vue 实例，导入其他组件并挂在到 vue 实例上</li><li><code>Vue.config.productionTip = false</code> 不要打印提示</li></ul></li><li>route/index.js：路由<ul><li><code>@</code>：build/ webpack.base.config.js =&gt;  <code>&#39;@&#39;: resolve(&#39;src&#39;)</code></li><li>如果在一个模块化工程中使用它，必须要通过 <code>Vue.use()</code> 明确地安装路由功能</li><li><code>https://router.vuejs.org/zh/installation.html</code></li></ul></li></ul></li></ul><h3 id="两种编译模式"><a href="#两种编译模式" class="headerlink" title="两种编译模式"></a>两种编译模式</h3><p>完整版和运行时版</p><p><a href="https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A" target="_blank" rel="noopener">参考官网</a></p><p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码</p><p>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切</p><ul><li>使用 完整版 (包含编译器)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>只使用运行时</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查看编译模式：build =&gt; webpack.base.config.js =&gt;  <code>&#39;vue\$&#39;: &#39;vue/dist/vue.esm.js&#39;,</code></p><h3 id="手动配置路由"><a href="#手动配置路由" class="headerlink" title="手动配置路由"></a>手动配置路由</h3><p>安装路由 <code>npm i vue-router</code></p><p>准备工作：创建一个文件夹 router/router.js</p><p>具体配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* router.js */</span></span><br><span class="line"><span class="comment">// 引入路由</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'@/components/home/Home'</span>   (template + script + style)</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'@/components/login/Login'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把路由当成插件安装</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由，配置路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 路由规则</span></span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path : <span class="string">'/home'</span>,</span><br><span class="line">    component : Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path : <span class="string">'/login'</span>,</span><br><span class="line">    component : Login</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main.js 中绑定路由</span></span><br><span class="line">router</span><br><span class="line"></span><br><span class="line">在跟组件 App.vue 下配置出口</span><br><span class="line">&lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.js */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 绑定路由</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置出口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编辑器配置插件"><a href="#编辑器配置插件" class="headerlink" title="编辑器配置插件"></a>编辑器配置插件</h3><ul><li><p><code>vetur</code>：vue 单文件组件的高亮</p></li><li><p>eslint</p><ul><li>关闭 <strong>eslint</strong>：打开 config/index.js，将26行 :  <code>dev.useEslint</code>设置为false，重启项目 ( npm run dev)</li></ul></li><li><p><code>Prettier</code>：格式化插件</p></li></ul><h2 id="TODOMVC-案例"><a href="#TODOMVC-案例" class="headerlink" title="TODOMVC 案例"></a>TODOMVC 案例</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><a href="http://todomvc.com/examples/vue/" target="_blank" rel="noopener">Vue-TodoMVC</a></li><li><a href="https://github.com/tastejs/todomvc-app-template" target="_blank" rel="noopener">下载模板地址</a> <code>git clone https://github.com/tastejs/todomvc-app-template.git</code></li><li>安装依赖包 : <code>npm i</code></li><li>安装 vue : <code>npm i vue</code></li><li>开始 <a href="https://github.com/cuilongjin/todomvc-app-template/tree/master" target="_blank" rel="noopener">https://github.com/cuilongjin/todomvc-app-template/tree/master</a></li></ol><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><ul><li>渲染任务列表：<code>&lt;label&gt;&lt;/label&gt;</code></li><li>任务完成 : <code>:class=&quot;{ completed : item.done }&quot;</code></li><li>多选框选中状态 : <code>v-model=&#39;item.done&#39;</code></li></ul><h3 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h3><ul><li>获取文本输入框的内容 (关键点)<ul><li>把 input 通过 v-model 双向数据绑定 == todoName</li><li>@keyup.enter 触发事件 addTodo =&gt; 拿到 todoName 的值</li><li>判断文本框不能为空</li><li>按回车添加任务</li></ul></li><li>对象{done: false, id: , name : todoName}<ul><li>获取数组里最后一个元素的 id+1</li><li>如果数组之前一个元素都没有 , id = 1</li></ul></li><li>将对象添加进数组</li><li>添加完，清除文本框内容</li></ul><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><ul><li>传索引<br><code>this.todoList.splice(index, 1)</code></li><li>传 id</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id  找到对应的元素索引</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="keyword">this</span>.todoList.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id)</span><br><span class="line"><span class="comment">// 根据索引删除</span></span><br><span class="line"><span class="keyword">this</span>.todoList.splice(index, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>传 id 过滤</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传过来一个 id, 过滤出来不等于这个 id 的元素，重新赋值给 todoList</span></span><br><span class="line"><span class="keyword">this</span>.todoList = <span class="keyword">this</span>.todoList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id !== id)</span><br></pre></td></tr></table></figure><h3 id="编辑任务"><a href="#编辑任务" class="headerlink" title="编辑任务"></a>编辑任务</h3><ul><li><p>显示<code>编辑框</code> ( editing : true) (难点)</p><ul><li>在 data 中添加一个 editId : -1</li><li>在 :class<br>editing: item.id === editId</li><li>双击 : 接收过来双击元素的id<br>this.editId = id</li><li>关键点 :<br>vue 中 data 中的数据一旦发生改变，当前页面的指令和表达式都会重新计算</li></ul></li><li><p>读取内容<br><code>&lt;input class=&quot;edit&quot; v-model=&quot;item.name&quot;&gt;</code></p></li><li><p>回车隐藏编辑框</p></li></ul><h3 id="底部的显示与隐藏"><a href="#底部的显示与隐藏" class="headerlink" title="底部的显示与隐藏"></a>底部的显示与隐藏</h3><ul><li>v-if/v-show</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件部分</span></span><br><span class="line">&lt;footer <span class="class"><span class="keyword">class</span></span>=<span class="string">"footer"</span> v-show=<span class="string">"isFooter()"</span>&gt;</span><br><span class="line"><span class="comment">// js</span></span><br><span class="line">  isFooter() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.todoList.length &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>因为 vue 中 data 的数据发送了改变，当前页面中的指令和表达式都会重新计算，所以只要文本框里的内容发生改变，todoName 也会发送改变，isFooter 会一直被调用，性能不好。我们需要的是数组列表的个数改变才会影响底部的变化，所以需要用到计算属性</p></li><li><p>计算属性</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span> <span class="attr">v-show</span>=<span class="string">"isFooter"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 计算属性 判断底部是否显示</span></span><br><span class="line">  <span class="comment">// 1. 计算属性只会跟着相关属性的值发生变化而变化</span></span><br><span class="line">  <span class="comment">// 2. 一定要有返回值</span></span><br><span class="line">  <span class="comment">// 3. 一定要写在 computed 里面</span></span><br><span class="line">  <span class="comment">// 4. 写起来像一个方法，用起来像一个属性</span></span><br><span class="line">  isFooter () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.todoList.length &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><ul><li>存储数据<ul><li>监听 list 数据的改变，只要 list 数据变了，就调用保存数据的方法</li><li>使用 vue 的 watch 监听 list 的数据改变</li><li>保存值，记得把对象转化为字符串(存的快省空间)</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 监听 todoList</span></span><br><span class="line">  todoList: &#123;</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    handler (newVal) &#123;</span><br><span class="line">   localStorage.setItem(<span class="string">'todoList'</span>, <span class="built_in">JSON</span>.stringify(newVal))</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 data 中可以初始值</span></span><br><span class="line"><span class="comment">// 设置一个默认值 空数组 []</span></span><br><span class="line">todoList: <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'todoList'</span>)) || []</span><br></pre></td></tr></table></figure><h3 id="使用钩子函数来完善数据存储"><a href="#使用钩子函数来完善数据存储" class="headerlink" title="使用钩子函数来完善数据存储"></a>使用钩子函数来完善数据存储</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">this</span>.todoList = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'todoList'</span>)) || []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取接口数据"><a href="#获取接口数据" class="headerlink" title="获取接口数据"></a>获取接口数据</h3><p><a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">json-server</a> 提供假数据接口</p><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a> 发送请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -g json-server</span><br><span class="line">npm i axios</span><br><span class="line">json-server data.json</span><br></pre></td></tr></table></figure><h3 id="组件化TODOMVC"><a href="#组件化TODOMVC" class="headerlink" title="组件化TODOMVC"></a>组件化TODOMVC</h3><p><a href="https://github.com/cuilongjin/todomvc-app-template/tree/zujianhua" target="_blank" rel="noopener">https://github.com/cuilongjin/todomvc-app-template/tree/zujianhua</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs</title>
      <link href="/2018/javascript/nodejs/"/>
      <url>/2018/javascript/nodejs/</url>
      
        <content type="html"><![CDATA[<h1 id="nodejs基本介绍"><a href="#nodejs基本介绍" class="headerlink" title="nodejs基本介绍"></a>nodejs基本介绍</h1><h2 id="为什么要学习nodejs"><a href="#为什么要学习nodejs" class="headerlink" title="为什么要学习nodejs"></a>为什么要学习nodejs</h2><ol><li>降低编程语言切换的成本(nodejs实质上用的还是javascript)</li><li>NodeJS是前端项目的基础设施，前端项目中用到的大量工具 (大前端)</li><li>nodejs在处理高并发上有得天独厚的优势(利用nodejs做中间层)</li><li>对于前端工程师，面试时对于nodejs有一定的要求</li></ol><h2 id="node-js-是什么？"><a href="#node-js-是什么？" class="headerlink" title="node.js 是什么？"></a>node.js 是什么？</h2><p>node.js，也叫作node，或者nodejs，指的都是一个平台</p><ol><li><a href="https://nodejs.org/" target="_blank" rel="noopener">node.js官方网站</a></li><li><a href="http://nodejs.cn/" target="_blank" rel="noopener">node.js中文网</a></li><li><a href="https://cnodejs.org/" target="_blank" rel="noopener">node.js 中文社区</a></li></ol><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，nodejs 允许 javascript 代码运行在服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. nodejs不是一门新的编程语言，nodejs是在服务端运行javascript的运行环境</span><br><span class="line">2. 运行环境：写得程序想要运行必须要有对应的运行环境</span><br><span class="line">php代码必须要有apache服务器</span><br><span class="line">在web端，浏览器就是javascript的运行环境</span><br><span class="line">在node端，nodejs就是javascript的运行环境</span><br><span class="line">2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。</span><br><span class="line">3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎</span><br></pre></td></tr></table></figure><p><strong>nodejs的本质：不是一门新的编程语言，nodejs是javascript运行在服务端的运行环境，编程语言还是javascript</strong></p><h2 id="nodejs与浏览器的区别"><a href="#nodejs与浏览器的区别" class="headerlink" title="nodejs与浏览器的区别"></a>nodejs与浏览器的区别</h2><p>相同点：nodejs与浏览器都是js的运行环境，都能够解析js程序。对于ECMAScript语法来说，在nodejs和浏览器中都能运行</p><p>不同点：nodejs无法使用DOM和BOM的操作，浏览器无法执行nodejs中的文件操作等功能</p><p><img src="nodejs.png" alt></p><h2 id="nodejs可以干什么？"><a href="#nodejs可以干什么？" class="headerlink" title="nodejs可以干什么？"></a>nodejs可以干什么？</h2><ol><li>开发服务端程序</li><li>开发命令行工具（CLI），比如npm，webpack，gulp，less，sass等</li><li>开发桌面应用程序（借助 node-webkit、electron 等框架实现）</li></ol><h1 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h1><h2 id="nodejs版本"><a href="#nodejs版本" class="headerlink" title="nodejs版本"></a>nodejs版本</h2><p>下载地址</p><ul><li><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">当前版本</a></li><li><a href="https://nodejs.org/en/download/releases/" target="_blank" rel="noopener">历史版本</a></li></ul><p>官网术语解释</p><ul><li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li><li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入</li></ul><p>查看node版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h1 id="运行nodejs程序"><a href="#运行nodejs程序" class="headerlink" title="运行nodejs程序"></a>运行nodejs程序</h1><h2 id="方式一：使用node执行js文件"><a href="#方式一：使用node执行js文件" class="headerlink" title="方式一：使用node执行js文件"></a>方式一：使用node执行js文件</h2><ul><li>创建js文件 <code>helloworld.js</code></li></ul><ul><li>写nodejs的内容：<code>console.log(&#39;hello nodejs&#39;)</code></li><li>打开命令窗口 <code>cmd</code><ul><li>shift加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li></ul></li><li>执行命令：<code>node helloworld.js</code></li></ul><p>注意：在nodejs中是无法使用DOM和BOM的内容的，因此<code>document</code>， <code>window</code>等内容是无法使用的</p><h2 id="方式二：REPL介绍"><a href="#方式二：REPL介绍" class="headerlink" title="方式二：REPL介绍"></a>方式二：REPL介绍</h2><ol><li>REPL 全称: Read-Eval-Print-Loop（交互式解释器）<ul><li>R 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中</li><li>E 执行 - 执行输入的数据结构</li><li>P 打印 - 输出结果</li><li>L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出</li></ul></li><li>在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能）<ul><li>直接在控制台输入 <code>node</code> 命令进入 REPL 环境</li></ul></li><li>按两次 Control + C 退出REPL界面 或者 输入 <code>.exit</code> 退出 REPL 界面<ul><li>按住 control 键不要放开, 然后按两下 c 键</li></ul></li></ol><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>当要求系统运行一个<strong>程序</strong> 而没有告诉它程序所在的完整路径时</p><ol><li>首先在<strong>当前目录</strong>中查找和该字符串匹配的可执行文件</li><li>进入用户 path 环境变量查找</li><li>进入系统 path 环境变量查找</li></ol><p>配置环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到环境变量：计算机 --右键--&gt; 属性 --&gt; 高级系统设置 --&gt; 高级 --&gt; 环境变量</span><br></pre></td></tr></table></figure><h1 id="global模块-全局变量"><a href="#global模块-全局变量" class="headerlink" title="global模块-全局变量"></a>global模块-全局变量</h1><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p><p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 <code>global</code>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p><p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p><p><strong>常用的 global 属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>: 用于打印日志</span><br><span class="line">setTimeout/clearTimeout: 设置清除延时器</span><br><span class="line">setInterval/clearInterval: 设置清除定时器</span><br><span class="line"></span><br><span class="line">__dirname: 当前文件的路径，不包括文件名</span><br><span class="line">__filename：当前文件的路径，包括文件名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与模块化相关的，模块化的时候会用到</span></span><br><span class="line"><span class="built_in">require</span></span><br><span class="line">exports</span><br><span class="line"><span class="built_in">module</span></span><br></pre></td></tr></table></figure><h1 id="fs-模块"><a href="#fs-模块" class="headerlink" title="fs 模块"></a>fs 模块</h1><blockquote><p>fs 模块是 nodejs 中最常用的一个模块，因此掌握fs模块非常的有必要，fs模块的方法非常多，用到了哪个查哪个即可。</p><p>文档地址：<a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html</a></p></blockquote><p>  在 nodejs 中，提供了 fs 模块，这是 node 的核心模块</p><p>  注意：</p><ol><li>除了 global 模块中的内容可以直接使用，其他模块都是需要加载的。</li><li>fs 模块不是全局的，不能直接使用。因此需要导入才能使用。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br></pre></td></tr></table></figure><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><blockquote><p>语法：fs.readFile(file[, options], callback)</p></blockquote><p>方式一：不传编码参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件路径</span></span><br><span class="line"><span class="comment">// 参数2：读取文件的回调函数</span></span><br><span class="line">  <span class="comment">// 参数1：错误对象，如果读取失败，err 会包含错误信息，如果读取成功，err 是 null</span></span><br><span class="line">  <span class="comment">// 参数2：读取成功后的数据（是一个Buffer对象）</span></span><br><span class="line">fs.readFile(<span class="string">'data.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString()) <span class="comment">// 将Buffer对象转换成字符串</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方式二：传编码参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件的路径</span></span><br><span class="line"><span class="comment">// 参数2：编码，如果设置了，返回一个字符串，如果没有设置，会返回一个buffer对象</span></span><br><span class="line"><span class="comment">// 参数3：回调函数</span></span><br><span class="line">fs.readFile(<span class="string">'data.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关于Buffer对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Buffer对象是Nodejs用于处理二进制数据的</span><br><span class="line">2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制</span><br><span class="line">3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象</span><br><span class="line">4. Buffer对象可以调用toString()方法转换成字符串</span><br></pre></td></tr></table></figure><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><blockquote><p>语法：fs.writeFile(file, data[, options], callback)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件路径(如果文件不存在，会自动创建)</span></span><br><span class="line"><span class="comment">// 参数2：写入的文件内容（注意：写入的内容会覆盖以前的内容）</span></span><br><span class="line"><span class="comment">// 参数3：写文件后的回调函数</span></span><br><span class="line">fs.writeFile(<span class="string">'2.txt'</span>, <span class="string">'hello world'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'写入文件失败'</span>, err)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'写入文件成功'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>写文件的时候，会把原来的内容给覆盖掉</li></ol><blockquote><p>语法：fs.appendFile(path, data[, options], callback)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：追加的文件名(如果文件不存在，会自动创建)</span></span><br><span class="line"><span class="comment">// 参数2：追加的文件内容</span></span><br><span class="line"><span class="comment">// 参数3：追加文件后的回调函数</span></span><br><span class="line">fs.appendFile(<span class="string">'2.txt'</span>, <span class="string">'我是追加的内容'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'追加文件内容失败'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'追加文件内容成功'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>思考：如果没有appendFile，通过readFile与writeFile应该怎么实现？</p><h2 id="文件同步与异步的说明"><a href="#文件同步与异步的说明" class="headerlink" title="文件同步与异步的说明"></a>文件同步与异步的说明</h2><blockquote><p>fs中所有的文件操作，都提供了异步和同步两种方式</p></blockquote><p>异步方式：不会阻塞代码的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">fs.readFile(<span class="string">'2.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取文件失败'</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'222'</span>)</span><br></pre></td></tr></table></figure><p>同步方式：会阻塞代码的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line"><span class="keyword">const</span> result = fs.readFileSync(<span class="string">"2.txt"</span>, <span class="string">"utf-8"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">222</span>);</span><br></pre></td></tr></table></figure><p>总结：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p><h2 id="其他api（了解）"><a href="#其他api（了解）" class="headerlink" title="其他api（了解）"></a>其他api（了解）</h2><p>方法有很多，但是用起来都非常的简单，学会查文档</p><p>文档：<a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html</a></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>fs.readFile(path,  callback)</code></td><td>读取文件内容（异步）</td></tr><tr><td><code>fs.readFileSync(path)</code></td><td>读取文件内容（同步）</td></tr><tr><td><code>fs.writeFile(path,  data,  callback)</code></td><td>写入文件内容（异步）</td></tr><tr><td><code>fs.writeFileSync(path,  data)</code></td><td>写入文件内容（同步）</td></tr><tr><td><code>fs.appendFile(path,  data,  callback)</code></td><td>追加文件内容（异步）</td></tr><tr><td><code>fs.appendFileSync(path,  data)</code></td><td>追加文件内容（同步）</td></tr><tr><td><code>fs.rename(oldPath,  newPath,  callback)</code></td><td>重命名文件（异步）</td></tr><tr><td><code>fs.renameSync(oldPath,  newPath)</code></td><td>重命名文件（同步）</td></tr><tr><td><code>fs.unlink(path,  callback)</code></td><td>删除文件（异步）</td></tr><tr><td><code>fs.unlinkSync(path)</code></td><td>删除文件（同步）</td></tr><tr><td><code>fs.mkdir(path,  mode,  callback)</code></td><td>创建文件夹（异步）</td></tr><tr><td><code>fs.mkdirSync(path,  mode)</code></td><td>创建文件夹（同步）</td></tr><tr><td><code>fs.rmdir(path,  callback)</code></td><td>删除文件夹（异步）</td></tr><tr><td><code>fs.rmdirSync(path)</code></td><td>删除文件夹（同步）</td></tr><tr><td><code>fs.readdir(path,  option,  callback)</code></td><td>读取文件夹内容（异步）</td></tr><tr><td><code>fs.readdirSync(path,  option)</code></td><td>读取文件夹内容（同步）</td></tr><tr><td><code>fs.stat(path,  callback)</code></td><td>查看文件状态（异步）</td></tr><tr><td><code>fs.statSync(path)</code></td><td>查看文件状态（同步）</td></tr></tbody></table><h1 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h1><h2 id="路径操作的问题"><a href="#路径操作的问题" class="headerlink" title="路径操作的问题"></a>路径操作的问题</h2><p>在读写文件的时候，文件路径可以写相对路径或者绝对路径</p><p>data.txt 是相对路径，读取当前目录下的 data.txt，相对路径相对的是指向node命令的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果node命令不是在当前目录下执行就会报错，在当前执行node命令的目录下查找data.txt，找不到</span></span><br><span class="line">fs.readFile(<span class="string">'data.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取文件失败'</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相对路径：相对于执行node命令的路径</p><p>推荐使用绝对路径：<code>__dirname</code>: 当前文件的目录，<code>__filename</code>: 当前文件的目录，包含文件名</p><h2 id="path模块的常用方法"><a href="#path模块的常用方法" class="headerlink" title="path模块的常用方法"></a>path模块的常用方法</h2><blockquote><p>关于路径，在linux系统中，路径分隔符使用的是<code>/</code>，但是在windows系统中，路径使用的<code>\</code></p></blockquote><p>在我们拼写路径的时候会带来很多的麻烦，经常会出现windows下写的代码，在linux操作系统下执行不了，path模块就是为了解决这个问题而存在的。</p><p>常用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">path.join() <span class="comment">// 拼接路径，返回拼接后的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// windows系统下</span></span><br><span class="line">path.join(<span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'gg'</span>, <span class="string">'index.html'</span>)</span><br><span class="line"><span class="string">'abc\def\gg\a.html'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// linux系统下</span></span><br><span class="line">path.join(<span class="string">'abc'</span>,<span class="string">'def'</span>,<span class="string">'gg'</span>, <span class="string">'index.html'</span>)</span><br><span class="line"><span class="string">'abc/def/gg/index.html'</span></span><br><span class="line"></span><br><span class="line">【优化读写文件的代码】</span><br><span class="line"></span><br><span class="line">其他方法:</span><br><span class="line">path.basename(path[, ext])返回文件的最后一部分</span><br><span class="line">path.dirname(path)返回路径的目录名</span><br><span class="line">path.extname(path)获取路径的扩展名(后缀名)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> temp = <span class="string">'abc\\def\\gg\\a.html'</span></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(temp)) <span class="comment">//a.html</span></span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(temp)) <span class="comment">//abc\def\gg</span></span><br><span class="line"><span class="built_in">console</span>.log(path.extname(temp)) <span class="comment">//.html</span></span><br></pre></td></tr></table></figure><h2 id="path模块其他api（了解）"><a href="#path模块其他api（了解）" class="headerlink" title="path模块其他api（了解）"></a>path模块其他api（了解）</h2><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>path.basename(path[, ext])</code></td><td>返回文件的最后一部分</td></tr><tr><td><code>path.dirname(path)</code></td><td>返回路径的目录名</td></tr><tr><td><code>path.extname(path)</code></td><td>获取路径的扩展名</td></tr><tr><td><code>path.isAbsolute(path)</code></td><td>判断目录是否是绝对路径</td></tr><tr><td><code>path.join([...paths])</code></td><td>将所有的path片段拼接成一个规范的路径</td></tr><tr><td><code>path.normalize(path)</code></td><td>规范化路径</td></tr><tr><td><code>path.parse(path)</code></td><td>将一个路径解析成一个path对象</td></tr><tr><td><code>path.format(pathObj)</code></td><td>讲一个path对象解析成一个规范的路径</td></tr></tbody></table><h1 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h1><h2 id="创建服务器基本步骤"><a href="#创建服务器基本步骤" class="headerlink" title="创建服务器基本步骤"></a>创建服务器基本步骤</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入http模块，http模块是node的核心模块，作用是用来创建 http 服务器的</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 服务器处理请求</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我接收到请求了'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 启动服务器，监听某个端口</span></span><br><span class="line">server.listen(<span class="number">9999</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'服务器启动成功了, 请访问： http://localhost:9999'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>详细说明</p><ol><li>给服务器注册 request 事件，只要服务器接收到了客户端的请求，就会触发 request 事件</li><li>request事件有两个参数，req表示请求对象，可以获取所有与请求相关的信息，res是响应对象，可以获取所有与响应相关的信息</li><li>服务器监听的端口范围为：1-65535之间，推荐使用3000以上的端口，因为3000以下的端口一般留给系统使用</li></ol><h2 id="request-对象详解"><a href="#request-对象详解" class="headerlink" title="request 对象详解"></a>request 对象详解</h2><p>文档地址：<a href="http://nodejs.cn/api/http.html#http_message_headers" target="_blank" rel="noopener">http://nodejs.cn/api/http.html#http_message_headers</a></p><p>常见属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">headers: 所有的请求头信息</span><br><span class="line">method：请求的方式</span><br><span class="line">rawHeaders：所有的请求头信息（数组的方式）</span><br><span class="line">url：请求的地址（url地址的路径部分）</span><br><span class="line">请求 http:<span class="comment">//127.0.0.1:3000/index 获取到的是：/index</span></span><br><span class="line">请求 http:<span class="comment">//127.0.0.1:3000 获取到的是：/</span></span><br></pre></td></tr></table></figure><p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求</p><p>小结：request对象中，常用的就是 method 和 url 两个参数</p><h2 id="response-对象详解"><a href="#response-对象详解" class="headerlink" title="response 对象详解"></a>response 对象详解</h2><p>文档地址：<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse" target="_blank" rel="noopener">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p><p>常见的属性和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">res.write(data): 给浏览器发送响应体，可以调用多次，从而提供连续的响应体</span><br><span class="line">res.end()：通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成</span><br><span class="line">res.end(data)：结束请求，并且响应一段内容，相当于res.write(data) + res.end()</span><br><span class="line">res.statusCode: 响应的的状态码 <span class="number">200</span> <span class="number">404</span> <span class="number">500</span></span><br><span class="line">res.statusMessage: 响应的状态信息（不能有中文）， 如果不设置会根据statusCode自动设置</span><br><span class="line">res.setHeader(name, value)：设置响应头信息，比如<span class="string">'content-type'</span>，<span class="string">'text/html;charset=utf-8'</span></span><br><span class="line">res.writeHead(statusCode, statusMessage, options)：设置响应头，同时可以设置状态码和状态信息</span><br><span class="line">options 是对象，写响应头的键值对</span><br></pre></td></tr></table></figure><p><strong>注意：必须先设置响应头，才能设置响应主体。</strong></p><ul><li><p>注意：浏览器中输入的URL地址，仅仅是一个标识，可以不与服务器中的文件路径一致。也就是说：返回什么内容是由服务端的逻辑决定</p></li><li><p>路由 : url标示和对应文件/数据的一一对应关系</p></li></ul><h2 id="模拟Apache服务器"><a href="#模拟Apache服务器" class="headerlink" title="模拟Apache服务器"></a>模拟Apache服务器</h2><ul><li>根据 <code>req.url</code> 读取不同的页面内容，返回给浏览器</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求: 简单模仿apache服务器，浏览器发送127.0.0.1:8888/index.html</span></span><br><span class="line"><span class="comment">// 对应的返回www文件夹下面的index.html的内容</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer()</span><br><span class="line"><span class="comment">// 监听请求</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 根据不同请求输出不同响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/'</span> || req.url === <span class="string">'/i'</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取www下面的index.html</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(__dirname, <span class="string">'www'</span>, <span class="string">'index.html'</span>)</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'文件读取失败'</span>)</span><br><span class="line">      <span class="comment">// 服务器响应文件</span></span><br><span class="line">      res.statusCode = <span class="number">200</span></span><br><span class="line">      res.statusMessage = <span class="string">'ok'</span></span><br><span class="line">      res.setHeader(<span class="string">'content-type'</span>, <span class="string">'text/html;charset=utf-8'</span>)</span><br><span class="line">      res.end(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url === <span class="string">'/l'</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取list.html</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(__dirname, <span class="string">'www'</span>, <span class="string">'list.html'</span>)</span><br><span class="line">    fs.readFile( filename, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'文件读取失败'</span>)</span><br><span class="line">      <span class="comment">// 服务器响应文件</span></span><br><span class="line">      res.writeHead(<span class="number">200</span>, <span class="string">'OOOOOOK'</span>, &#123;</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">'text/html;charset=utf-8'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      res.end(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回浏览器, 未找到资源</span></span><br><span class="line">    res.writeHead(<span class="number">404</span>, <span class="string">'NOT FOUND'</span>, &#123;</span><br><span class="line">      <span class="string">'content-type'</span>: <span class="string">'text/html;charset=utf-8'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.end(<span class="string">'404 ,资源未找到'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 开启服务器</span></span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>, ()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'服务器开启了'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><ul><li>MIME(Multipurpose Internet Mail Extensions)多用途Internet邮件扩展类型 是一种表示文档性质和格式的标准化方式</li><li>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的MIME类型附加到响应对象的头部是非常重要的</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types" target="_blank" rel="noopener">MIME 类型</a></li></ul><h2 id="mime模块"><a href="#mime模块" class="headerlink" title="mime模块"></a>mime模块</h2><ul><li>作用：获取文件的MIME类型</li><li>安装：<code>npm i mime</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径对应的 MIME 类型</span></span><br><span class="line">mime.getType(<span class="string">'txt'</span>) <span class="comment">// 'text/plain'</span></span><br><span class="line"><span class="comment">// 根据 MIME 获取到文件后缀名</span></span><br><span class="line">mime.getExtension(<span class="string">'text/plain'</span>)  <span class="comment">// 'txt'</span></span><br></pre></td></tr></table></figure><h1 id="npm-Node-包管理工具"><a href="#npm-Node-包管理工具" class="headerlink" title="npm - Node 包管理工具"></a>npm - Node 包管理工具</h1><h2 id="npm-的基本概念"><a href="#npm-的基本概念" class="headerlink" title="npm 的基本概念"></a>npm 的基本概念</h2><ul><li>node package manager</li><li><a href="https://npmjs.com" target="_blank" rel="noopener">npm官网</a></li><li><a href="https://www.npmjs.com.cn/" target="_blank" rel="noopener">npm中文文档</a></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. npm 是node的包管理工具，</span><br><span class="line">2. 它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。</span><br><span class="line">3. 来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。</span><br><span class="line"></span><br><span class="line">npm 由三个独立的部分组成：</span><br><span class="line">    网站</span><br><span class="line">    注册表（registry）</span><br><span class="line">    命令行工具 (CLI)</span><br></pre></td></tr></table></figure><ul><li>作用：通过<code>npm</code>来快速安装开发中使用的包</li><li>npm不需要安装，只要安装了node，就自带了<code>npm</code></li></ul><h2 id="npm-基本使用"><a href="#npm-基本使用" class="headerlink" title="npm 基本使用"></a>npm 基本使用</h2><h3 id="初始化包"><a href="#初始化包" class="headerlink" title="初始化包"></a>初始化包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个命令用于初始化一个包，创建一个package.json文件，我们的项目都应该先执行npm init</span></span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速的初始化一个包， 不能是一个中文名</span></span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装指定的包名的最新版本到项目中</span></span><br><span class="line">npm install 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定包的指定版本</span></span><br><span class="line">npm install 包名@版本号</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简写</span></span><br><span class="line">npm i 包名</span><br></pre></td></tr></table></figure><h3 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载已经安装的包</span></span><br><span class="line">npm uninstall 包名</span><br></pre></td></tr></table></figure><h2 id="package-json-文件"><a href="#package-json-文件" class="headerlink" title="package.json 文件"></a>package.json 文件</h2><p>package.json文件，包（项目）描述文件，用来管理组织一个包（项目），它是一个纯JSON格式的</p><ul><li>作用：描述当前项目（包）的信息，描述当前包（项目）的依赖项</li><li>如何生成：<code>npm init</code>或者<code>npm init -y</code></li><li>作用<ul><li>作为一个标准的包，必须要有<code>package.json</code>文件进行描述</li><li>一个项目的node_modules目录通常都会很大，不用拷贝node_modules目录，可以通过package.json文件配合<code>npm install</code>直接安装项目所有的依赖项</li></ul></li><li>描述内容</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "name": "03-npm",  // 描述了包的名字，不能有中文</span><br><span class="line">  "version": "1.0.0",  // 描述了包的的版本信息， x.y.z  如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。</span><br><span class="line">  "description": "", // 包的描述信息</span><br><span class="line">  "main": "index.js", // 入口文件（模块化）</span><br><span class="line">  "scripts": &#123;  // 配置一些脚本，在vue的时候会用到，现在体会不到</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "keywords": [],  // 关键字（方便搜索）</span><br><span class="line">  "author": "",  // 作者的信息</span><br><span class="line">  "license": "ISC",  // 许可证，开源协议</span><br><span class="line">  "dependencies": &#123;   // 重要，项目的依赖， 方便代码的共享  通过 npm install</span><br><span class="line">    "bootstrap": "^3.3.7",</span><br><span class="line">    "jquery": "^3.3.1"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：一个合法的package.json，必须要有 name 和 version 两个属性</strong></p><h2 id="本地安装和全局安装"><a href="#本地安装和全局安装" class="headerlink" title="本地安装和全局安装"></a>本地安装和全局安装</h2><p>有两种方式用来安装 npm 包：本地安装和全局安装。选用哪种方式来安装，取决于你如何使用这个包。</p><ul><li>全局安装：如果你想将其作为一个命令行工具，那么你应该将其安装到全局。这种安装方式后可以让你在任何目录下使用这个命令。比如nrm, nodemon等命令</li><li>本地安装：如果你自己的模块依赖于某个包，并通过 Node.js 的 <code>require</code> 加载，那么你应该选择本地安装，这种方式也是 <code>npm install</code> 命令的默认行为</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装，会把 npm 包安装到C:\Users\用户名\AppData\Roaming\npm目录下，作为命令行工具使用</span></span><br><span class="line">npm install -g 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地安装，会把 npm 包安装到当前项目的node_modules文件中，作为项目的依赖</span></span><br><span class="line">npm install 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意： 如果网速慢的话，会导致下载失败。 再重新下载之前,建议使用以下命令,清除刚才下载的缓存.否则有可能一直无法下载成功</span></span><br><span class="line">npm cache clean -f</span><br></pre></td></tr></table></figure><h2 id="npm下载加速"><a href="#npm下载加速" class="headerlink" title="npm下载加速"></a>npm下载加速</h2><h3 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h3><ul><li>nrm：npm registry manager（npm仓库地址管理工具）</li><li>安装：<code>npm i -g nrm</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 带*表示当前正在使用的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看仓库地址列表</span></span><br><span class="line">nrm ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换仓库地址</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure><h2 id="nodemon-自动重启"><a href="#nodemon-自动重启" class="headerlink" title="nodemon 自动重启"></a>nodemon 自动重启</h2><ul><li>作用：监听到 js 文件修改后，自动重启node程序</li><li>安装：<code>npm i -g nodemon</code></li><li>使用：<code>nodemon app.js</code> 运行node程序</li></ul><h1 id="hacknews案例"><a href="#hacknews案例" class="headerlink" title="hacknews案例"></a>hacknews案例</h1><ul><li><a href="https://news.ycombinator.com/" target="_blank" rel="noopener">Hacker News 示例</a></li><li>路由（route）：就是一套映射规则，根据url地址分配到对应的处理程序</li></ul><h2 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h2><ul><li>1 新闻列表页 - /index    get</li><li>2 新闻详情页 - /details  get</li><li>3 新闻添加页 - /submit   get</li><li>4 新闻添加请求 - /add    post</li></ul><h2 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art-template 模板引擎"></a>art-template 模板引擎</h2><ul><li><a href="https://aui.github.io/art-template/zh-cn/docs/" target="_blank" rel="noopener">文档</a></li><li>安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install art-template</span><br></pre></td></tr></table></figure><ul><li>核心方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于模板路径渲染模板</span></span><br><span class="line"><span class="comment">// 参数1：文件的路径</span></span><br><span class="line"><span class="comment">// 参数2：数据</span></span><br><span class="line"><span class="comment">// 返回值：返回渲染后的内容</span></span><br><span class="line"><span class="comment">// template(filename, data)</span></span><br><span class="line"><span class="keyword">let</span> html = template(path.join(__dirname, <span class="string">'pages'</span>, <span class="string">'index.html'</span>), &#123;<span class="attr">name</span>: <span class="string">'大吉大利，今晚吃鸡'</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意点：文件的路径必须是绝对路径</strong>；会将整个html当做模板返回</p><h2 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a>url 模块</h2><ul><li>说明：用于 URL 处理与解析</li><li>注意：通过 url 拿到的查询参数都是字符串格式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入url模块</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 URL 字符串并返回一个 URL 对象</span></span><br><span class="line"><span class="comment">// 第一个参数：表示要解析的URL字符串</span></span><br><span class="line"><span class="comment">// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象</span></span><br><span class="line"><span class="keyword">var</span> ret = url.parse(<span class="string">'http://localhost:3000/details?id=1&amp;name=jack'</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ret.query) <span class="comment">// &#123;id: '1', name: 'jack'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="querystring-模块"><a href="#querystring-模块" class="headerlink" title="querystring 模块"></a>querystring 模块</h2><ul><li>用于解析与格式化 URL 查询字符串</li><li>注意：只在专门处理查询字符串时使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo=bar&amp;abc=xyz&amp;abc=123</span></span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将查询参数转化为对象</span></span><br><span class="line"><span class="comment">// 第一个参数: 要解析的 URL 查询字符串</span></span><br><span class="line">querystring.parse(<span class="string">'foo=bar&amp;abc=xyz'</span>) <span class="comment">// &#123;foo: 'bar', abc: 'xyz'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="服务端重定向"><a href="#服务端重定向" class="headerlink" title="服务端重定向"></a>服务端重定向</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP 状态码说明</a></li><li><a href="http://shuai.be/archives/301-302-redirection/" target="_blank" rel="noopener">301 和 302</a></li><li>说明：服务端可以通过HTTP状态码让浏览器中的页面重定向</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.writeHead(<span class="number">302</span>, &#123;</span><br><span class="line">  <span class="string">'Location'</span>: <span class="string">'/'</span></span><br><span class="line">&#125;)</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure><h2 id="POST-请求参数的处理"><a href="#POST-请求参数的处理" class="headerlink" title="POST 请求参数的处理"></a>POST 请求参数的处理</h2><ul><li>说明：POST请求可以发送大量数据，没有大小限制</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受POST参数</span></span><br><span class="line"><span class="keyword">var</span> postData = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// data事件：用来接受客户端发送过来的POST请求数据</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">''</span></span><br><span class="line">req.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">  result += chunk</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// end事件：当POST数据接收完毕时，触发</span></span><br><span class="line">req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">  cosnole.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="模块化改造hackerNews"><a href="#模块化改造hackerNews" class="headerlink" title="模块化改造hackerNews"></a>模块化改造hackerNews</h2>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6（ECMAScript）</title>
      <link href="/2018/javascript/ES6/"/>
      <url>/2018/javascript/ES6/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6（ECMAScript）"><a href="#ES6（ECMAScript）" class="headerlink" title="ES6（ECMAScript）"></a>ES6（ECMAScript）</h1><p>ECMAScript 6.0（以下简称 ES6）是在 2015 年 6 月正式发布的标准。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言</p><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门 阮一峰</a></p><h2 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h2><blockquote><p>ES6 中提供了两个声明变量的关键字：const 和 let</p></blockquote><h3 id="let-的使用"><a href="#let-的使用" class="headerlink" title="let 的使用"></a>let 的使用</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code></p><ul><li>let声明的变量只有在当前作用域(块作用域)有效</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><ul><li>不存在变量提升</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>不允许重复声明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> <span class="comment">// SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><ul><li>不绑定全局作用域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>-</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 报错</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const-的使用"><a href="#const-的使用" class="headerlink" title="const 的使用"></a>const 的使用</h3><p><code>const</code>声明一个常量。常量：代码执行的过程中，不可以修改常量里面的值</p><ul><li>const 声明的量不可以改变</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span></span><br><span class="line">PI = <span class="number">3</span> <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><ul><li>const 声明的变量必须赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><ul><li>如果 const 声明了一个对象，仅仅保证地址不变，可以修改对象的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">'zs'</span>&#125;</span><br><span class="line">obj.age = <span class="number">18</span> <span class="comment">// 正确</span></span><br><span class="line">obj = &#123;&#125; <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><ul><li>其他用法和 let 一样</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只能在当前代码块中使用</span><br><span class="line">不会提升</span><br><span class="line">不能重复声明</span><br><span class="line">不绑定全局作用域</span><br></pre></td></tr></table></figure><h2 id="模板字符串-模板字面量"><a href="#模板字符串-模板字面量" class="headerlink" title="模板字符串(模板字面量)"></a>模板字符串(模板字面量)</h2><p>模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通过``可以定义一个字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`hello world`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 模板字符串内部允许换行</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">  hello</span></span><br><span class="line"><span class="string">  world</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 模板字符串内部可以使用表达式</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">你好，我是<span class="subst">$&#123;name&#125;</span></span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 标准新增了一种新的函数：Arrow Function（箭头函数）</p><p>为什么叫 Arrow Function？因为它的定义用的就是一个箭头</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line"><span class="comment">// 语法： (参数列表) =&gt; &#123;函数体&#125;</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><ul><li>如果没有参数列表，使用()表示参数列表</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果只有一个参数，可以省略()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">n1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果有多个参数，需要使用 () 把参数列表括起来</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给参数指定默认值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">n = <span class="number">1</span></span>) =&gt;</span> <span class="built_in">console</span>.log(n)</span><br><span class="line">a() <span class="comment">// 1</span></span><br><span class="line">a(<span class="number">3</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>不存在 prototype 这个属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li><p>没有 arguments</p><p>箭头函数没有自己的 arguments 对象，箭头函数可以访问外围函数的 arguments 对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">1</span>, <span class="number">2</span>)()) <span class="comment">// [Arguments] &#123; '0': 1, '1': 2 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问箭头函数的参数</span></span><br><span class="line"><span class="comment">// Rest 参数接受函数的多余参数组成一个数组</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">a, b, ...Args</span>) =&gt;</span> <span class="built_in">console</span>.log(Args)</span><br><span class="line">a(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// [3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.length) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>Rest 参数和 arguments 对象的区别：</li></ul><p>rest 参数只包括那些没有给出名称的参数，arguments 包含所有参数</p><p>rest 参数之后不能再有其他参数，否则会报错</p><p>函数的 length 属性，不包括 rest 参数</p><p>arguments 对象不是真正的数组，而 rest 参数是数组实例，可以直接使用数组的方法</p><p>arguments 对象拥有一些自己额外的功能</p><h3 id="返回值详解"><a href="#返回值详解" class="headerlink" title="返回值详解"></a>返回值详解</h3><ul><li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">  <span class="keyword">return</span> n1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">n1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">  <span class="keyword">return</span> n1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果函数体只有一行一句，并且需要返回这个值，那么可以省略 {} 和 return</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2</span><br></pre></td></tr></table></figure><h3 id="箭头函数的注意点"><a href="#箭头函数的注意点" class="headerlink" title="箭头函数的注意点"></a>箭头函数的注意点</h3><ol><li>箭头函数内部没有 this，因此箭头函数内部的 this 指向了外部的 this</li><li>因为箭头函数没有 this，因此箭头函数不能作为构造函数</li><li>不能用 call()、apply()、bind() 这些方法改变 this 的指向</li></ol><p>【定义一个对象，定时器打招呼】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'大家好，我是'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.sayHi()</span><br></pre></td></tr></table></figure><h2 id="对象简化语法"><a href="#对象简化语法" class="headerlink" title="对象简化语法"></a>对象简化语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当属性的 key 和变量的名相同时可以简写</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: name&#125; ==&gt; <span class="keyword">let</span> person = &#123;name&#125;</span><br><span class="line"></span><br><span class="line">声明函数</span><br><span class="line"><span class="keyword">let</span> cal = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 可以省略 `:function`</span></span><br><span class="line">  add()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><ul><li>ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">let</span> methodKey = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// foo: true</span></span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span>,</span><br><span class="line">  <span class="comment">// abc: 123</span></span><br><span class="line">  [methodKey]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="class-关键字"><a href="#class-关键字" class="headerlink" title="class 关键字"></a>class 关键字</h2><p>ES5 中通过 构造函数 + 原型 的方式来实现面向对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'jack'</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在原型中添加实例方法</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure><p>ES6 中出现了 class 关键字，用来实现面向对象。</p><p>class 仅仅是一个语法结构（语法糖），本质上还是通过构造函数+原型的方式来实现继承的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="comment">// 创建 Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类的构造函数</span></span><br><span class="line">  <span class="comment">// constructor 固定名称</span></span><br><span class="line">  <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加实例方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'tom'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure><p>继承：要实现至少需要两个class（子类 和 父类），子类继承自父类，继承后，子类就可以使用父类中的属性或方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类中的 say 方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// 子类中使用 constructor 必须手动调用 super</span></span><br><span class="line">    <span class="comment">// super 表示父类的构造函数</span></span><br><span class="line">    <span class="comment">// 先调用 super() 在使用 this</span></span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'ls'</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Chinese()</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line">c.say() <span class="comment">// 父类中的方法</span></span><br></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 对象解构</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b&#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取变量并赋值</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: p, <span class="attr">b</span>: q&#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(p, q) <span class="comment">// 10 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余数组赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b, ...rest &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;</span><br><span class="line"><span class="comment">// ;(&#123; a, b, ...rest &#125; = &#123; a: 10, b: 20, c: 30, d: 40 &#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest) <span class="comment">// 10 20 &#123;c: 30, d: 40&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123; a = <span class="number">1</span>, b = <span class="number">1</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值并提供默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">a</span>:aa = <span class="number">10</span>, <span class="attr">b</span>:bb = <span class="number">1</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa, bb) <span class="comment">// 10 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 数组解构</span></span><br><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余数组赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> [a, b, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest) <span class="comment">// 1 2 [3, 4]</span></span><br><span class="line"><span class="comment">// ==&gt; var a = arr[0]; var b = arr[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供默认值</span></span><br><span class="line"><span class="keyword">var</span> [c = <span class="number">2</span>, d = <span class="number">2</span>] = [<span class="number">10</span>]</span><br><span class="line"><span class="built_in">console</span>.log(c, d) <span class="comment">// 10 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略某些值</span></span><br><span class="line"><span class="keyword">var</span> [a = <span class="number">2</span>, , b = <span class="number">2</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 函数参数的解构赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">foo(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x = <span class="number">10</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 解构的特殊应用</span></span><br><span class="line"><span class="comment">// 交换变量</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">[a, b] = [b, a]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串解构</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'love'</span></span><br><span class="line"><span class="keyword">var</span> [a, b, c, d] = str</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// l o v e</span></span><br></pre></td></tr></table></figure><h2 id="数组扩展运算符"><a href="#数组扩展运算符" class="headerlink" title="数组扩展运算符"></a>数组扩展运算符</h2><p>扩展运算符（spread）是三个点（…）。作用：将一个数组转为用逗号分隔的参数序列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr)</span><br><span class="line"><span class="comment">// 上面这句代码相当于：</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组深拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = [...arr]</span><br><span class="line"><span class="built_in">console</span>.log(arr === arr1) <span class="comment">// false, 说明arr1和arr指向不同数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个数组插入另一个数组字面量</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转数组</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'love'</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [...str]</span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [ 'l', 'o', 'v', 'e' ]</span></span><br></pre></td></tr></table></figure><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="/2018/other/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>/2018/other/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>防抖和节流都是为了解决<strong>短时间内大量触发某函数</strong>而导致的<strong>性能问题，</strong>比如触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象</p></blockquote><h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>在事件被触发n秒后再执行回调函数，如果在这n秒内又被触发，则重新计时</p><p>应用场景</p><ul><li><p>用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源</p></li><li><p>window 的 resize、scroll 事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次</p></li></ul><h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p>规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内事件被触发多次，只有一次能生效</p><p>应用场景</p><ul><li><p>鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次</p></li><li><p>在页面的无限加载场景下，需要用户在滚动页面时，每隔一段时间发一次 ajax 请求，而不是在用户停下滚动页面操作时才去请求数据</p></li><li><p>监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断</p></li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>防抖的作用是将多个连续的<code>debounced</code>调用合并为一次<code>func</code>调用。防抖是基于最近次 <code>debounced</code> 调用来重置 <code>waitTime</code>，如果<code>debounced</code>事件触发间隔小于 <code>waitTime</code>，<code>func</code>就不会执行；</p><p>节流的作用是限制<code>func</code>调用的频率（每<code>waitTime</code>调用一次）。是基于上次 <code>func</code> 调用来计算 <code>waitTime</code> 的，不管<code>func</code> 事件触发有多频繁，只要距离上次 <code>func</code> 调用超过了 <code>waitTime</code>，就一定会进行下次 <code>func</code> 调用。</p><p>– 原理：</p><p>防抖是 <code>debounced</code> 维护了一个计时器，规定在 <code>waitTime</code> 时间后触发 <code>func</code>，但是在 <code>waitTime</code> 时间内再次触发 <code>debounced</code> 的话，会清除当前的 timer 然后重新计时，这样一来，只有最后一次<code>debounced</code> 操作才能触发 <code>func</code>；</p><p>节流是通过判断是否到达一定时间 (<code>waitTime</code>) 来再次触发 <code>func</code> ， <code>func</code> 在 <code>waitTime</code> 时间内不能被再次触发。</p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gulp 前端自动化环境</title>
      <link href="/2018/tool/gulp%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
      <url>/2018/tool/gulp%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前端自动化环境"><a href="#前端自动化环境" class="headerlink" title="前端自动化环境"></a>前端自动化环境</h1><p>实现一些简单的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 版本控制</span><br><span class="line">2. 编译SASS</span><br><span class="line">3. 检查JS</span><br><span class="line">4. 图片合并</span><br><span class="line">5. 压缩CSS</span><br><span class="line">6. 压缩JS</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这些都是每个Web项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。</p><p>构建工具： Gulp、Grunt、Webpack、…</p><h2 id="gulp-环境"><a href="#gulp-环境" class="headerlink" title="gulp 环境"></a>gulp 环境</h2><p>Gulp 是基于 Node.js 的，需要要安装 Node.js</p><h3 id="安装-4-0版本"><a href="#安装-4-0版本" class="headerlink" title="安装 # 4.0版本"></a>安装 # 4.0版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 node 环境</span></span><br><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装 gulp</span></span><br><span class="line">$ npm install -g gulp</span><br><span class="line">$ gulp -v  <span class="comment">#4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到你的在项目根文件夹下，运行</span></span><br><span class="line">$ npm install gulp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 gulp 功能插件依赖包</span></span><br><span class="line">$ npm install gulp-less gulp-sass gulp-concat gulp-connect gulp-rename</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>新建 <code>gulpfile.js</code> 配置文件放在项目根目录下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gulp3.x 配置不能直接在 4.0 上使用</span></span><br><span class="line"><span class="comment">// gulp4.0 配置内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"><span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>)</span><br><span class="line"><span class="keyword">const</span> fileinclude = <span class="built_in">require</span>(<span class="string">'gulp-file-include'</span>)</span><br><span class="line"><span class="keyword">const</span> connect = <span class="built_in">require</span>(<span class="string">'gulp-connect'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 serve</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  connect.server(&#123;</span><br><span class="line">    root: <span class="string">'./'</span>,</span><br><span class="line">    port: <span class="string">'8888'</span>,</span><br><span class="line">    <span class="comment">// 启用https</span></span><br><span class="line">    <span class="comment">// https: true,</span></span><br><span class="line">    livereload: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译 less</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileLess</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">  <span class="comment">// '!./**' 忽略文件</span></span><br><span class="line">    .src([<span class="string">'./less/*.less'</span>, <span class="string">'!./less/_*.less'</span>])</span><br><span class="line">    .pipe(less())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html 刷新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshHtml</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./*.html'</span>)</span><br><span class="line">    .pipe(connect.reload())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入外部 html 文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileHtml</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src([<span class="string">'./*.html'</span>, <span class="string">'!./_*.html'</span>])</span><br><span class="line">    .pipe(</span><br><span class="line">      fileinclude(&#123;</span><br><span class="line">        prefix: <span class="string">'@@'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 html 中使用 `@@include('_header-aside.html')` 引入公共 html 结构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听文件变化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.watch([<span class="string">'./less'</span>], compileLess)</span><br><span class="line">  gulp.watch([<span class="string">'./image'</span>], compileImg)</span><br><span class="line">  gulp.watch([<span class="string">'./js'</span>], compileJs)</span><br><span class="line">  gulp.watch([<span class="string">'./*.html'</span>], compileHtml)</span><br><span class="line">  gulp.watch([<span class="string">'./public'</span>], refreshHtml)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认任务，执行 gulp 会自动执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(serve, watch))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制 lib 文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyLib</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./lib/**/*'</span>).pipe(gulp.dest(<span class="string">'./dest/lib'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 dest 文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> del([<span class="string">'./dest'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行-gulp-任务"><a href="#运行-gulp-任务" class="headerlink" title="运行 gulp 任务"></a>运行 gulp 任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行定义的 default 任务</span></span><br><span class="line"><span class="comment"># $ gulp default</span></span><br><span class="line">$ gulp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独运行 sass 任务</span></span><br><span class="line">$ gulp less</span><br></pre></td></tr></table></figure><p><code>!./**</code> 忽略文件</p><p><code>gulp.parallel()</code> –并行运行任务</p><p><code>gulp.series()</code> –运行任务序列</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">其他 gulp 插件参考</span><br><span class="line">gulp-imagemin: 压缩图片</span><br><span class="line">gulp-minify-css: 压缩css</span><br><span class="line">gulp-uglify:      压缩js</span><br><span class="line">gulp-concat:    合并文件</span><br><span class="line">gulp-rename:  重命名文件</span><br><span class="line">gulp-htmlmin: 压缩html</span><br><span class="line">gulp-clean:      清空文件夹</span><br><span class="line">del:              删除文件</span><br></pre></td></tr></table></figure><p>gulp-connect 启动服务本机可以打开，局域网下手机打不开解决办法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connect.server(&#123;</span><br><span class="line">  host: <span class="string">'0.0.0.0'</span></span><br><span class="line">  或</span><br><span class="line">  host: <span class="string">'::'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在gulp 3.x 版本中报错会暂停监听需重新开启任务，4.0 修复了此问题</p><p><a href="https://www.tuicool.com/articles/nAzqiaN" target="_blank" rel="noopener">https://www.tuicool.com/articles/nAzqiaN</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gulp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LESS</title>
      <link href="/2018/tool/less/"/>
      <url>/2018/tool/less/</url>
      
        <content type="html"><![CDATA[<h1 id="LESS"><a href="#LESS" class="headerlink" title="LESS"></a>LESS</h1><h2 id="Less-简介"><a href="#Less-简介" class="headerlink" title="Less 简介"></a>Less 简介</h2><blockquote><p> <strong><em>Less</em> 是一门 CSS 预处理语言（预先处理）,它扩展了 CSS 语言，增加了变量、Mixin、函数等特性</strong></p><p> 浏览器不直接识别 less 文件，浏览器只识别 css 文件，所以我们写了 less 文件之后，我们需要预先把 less 文件转换成css文件。</p></blockquote><p>本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。</p><p><strong>less仅仅是写css的另一种方式，写出来的less文件浏览器也不识别，所以啊，我们写完了less文件，还需要通过less解析器解析成css，最终浏览器引入的还是css文件。</strong></p><p>学习网站：</p><p><a href="http://lesscss.org/" target="_blank" rel="noopener">官网http://lesscss.org/</a><br><a href="http://lesscss.cn/" target="_blank" rel="noopener">中文网http://lesscss.cn/</a></p><h2 id="less-的编译"><a href="#less-的编译" class="headerlink" title="less 的编译"></a>less 的编译</h2><blockquote><p>如何把 less 文件变成 css 文件</p></blockquote><h3 id="使用打包工具"><a href="#使用打包工具" class="headerlink" title="使用打包工具"></a>使用打包工具</h3><p><code>gulp</code></p><p><code>webpack</code></p><h3 id="使用考拉"><a href="#使用考拉" class="headerlink" title="使用考拉"></a>使用考拉</h3><blockquote><p>koala 是一个前端预处理器语言（less/sass）图形编译工具，支持 Less、Sass、Compass、CoffeeScript，帮助web开发者更高效地使用它们进行开发。跨平台运行，完美兼容windows、linux、mac。</p></blockquote><p><a href="http://koala-app.com/index-zh.html" target="_blank" rel="noopener">考拉官网</a></p><p>使用步骤：</p><ol><li>把<code>less</code>文件夹拖进去</li><li>会在当前目录生成一个<code>css</code>目录</li></ol><p>优点：不用node环境，不用less环境，koala内置了</p><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>easy less</p><h2 id="Less-语法"><a href="#Less-语法" class="headerlink" title="Less 语法"></a>Less 语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>注释</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是CSS中的注释，因此会编译到css中 */</span></span><br><span class="line"><span class="comment">// 这是less的注释，css不能识别这个注释， 最后不会编译到css文件</span></span><br></pre></td></tr></table></figure><p><strong>变量</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @变量名: 变量值;</span></span><br><span class="line"><span class="variable">@color:</span> <span class="number">#ccc</span>;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mixin-函数"><a href="#mixin-函数" class="headerlink" title="mixin 函数"></a>mixin 函数</h3><p><strong>混入函数</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数：不带参数</span></span><br><span class="line"><span class="selector-class">.btn</span>() &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="selector-class">.btn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数：带参数</span></span><br><span class="line"><span class="selector-class">.btn_border</span>(<span class="variable">@width</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@width</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="comment">// 如果函数定义了参数，调用的时候必须传入参数，否则会报错</span></span><br><span class="line">  <span class="selector-class">.btn_border</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数：带参数默认值</span></span><br><span class="line"><span class="selector-class">.btn_border</span>(<span class="variable">@width</span>: <span class="number">1px</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@width</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="comment">// 因为有默认值，所以不会报错</span></span><br><span class="line">  <span class="selector-class">.btn_border</span>();</span><br><span class="line">  <span class="selector-class">.btn_border</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：定义兼容多浏览器的圆角</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_radius</span>(<span class="variable">@value</span>: <span class="number">5px</span>) &#123;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>:<span class="variable">@value</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>:<span class="variable">@value</span>;</span><br><span class="line">  <span class="attribute">-ms-border-radius</span>:<span class="variable">@value</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>:<span class="variable">@value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.border_radius</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><blockquote><p>我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。</p></blockquote><ul><li>使用伪类的时候 可以使用<code>&amp;</code> 表示自己</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="comment">// 子代</span></span><br><span class="line">  <span class="selector-class">.son1</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后代</span></span><br><span class="line">  &gt; <span class="selector-class">.son2</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交集： &amp; 表示本身</span></span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-class">.now</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以省略后缀名</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"variable"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"maxin"</span>;</span><br></pre></td></tr></table></figure><p>模块化的思想，分模块进行管理这些less文件，最终只需要使用import将less引入到一起即可。</p><h3 id="函数（运算）"><a href="#函数（运算）" class="headerlink" title="函数（运算）"></a>函数（运算）</h3><blockquote><p>在我们的 CSS 中充斥着大量的数值型的 value，less可以直接支持运算，也提供了一系列的函数提供给我们使用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: round(100%/6, 2);</span><br><span class="line">  height: 100px + 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.1024i.com/demo/less/reference.html" target="_blank" rel="noopener">http://www.1024i.com/demo/less/reference.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> less </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap 框架</title>
      <link href="/2018/bootstrap/bootstrap/"/>
      <url>/2018/bootstrap/bootstrap/</url>
      
        <content type="html"><![CDATA[<h1 id="bootstrap-框架"><a href="#bootstrap-框架" class="headerlink" title="bootstrap 框架"></a>bootstrap 框架</h1><p>Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷</p><p><a href="http://www.bootcss.com/" target="_blank" rel="noopener">bootstrap 中文网</a></p><p>特点：</p><ul><li>组件简洁大方、代码规范精简、界面自定义性强</li><li>Bootstrap 是基于 HTML5 和 CSS3 开发的，它在 jQuery 的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分 jQuery 插件</li><li>Bootstrap 中包含了丰富的 Web 组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站</li></ul><p>优点：</p><ul><li>有自己的生态圈，不断的更新迭代</li><li>提供了一套简洁、直观、强悍的组件</li><li>标准化的 HTML+CSS 编码规范</li><li>让开发更简单，提高了开发效率</li><li>扩展性强，虽然界面组件样式已经定义好了，我们还可以自定义，修改默认样式</li></ul><p>版本：</p><ul><li>2.x.x 停止维护<ul><li>优点：兼容性好 IE678</li><li>缺点：代码不够简洁、功能不够完善</li></ul></li><li>3.x.x <strong>目前使用最多（H5C3 很多东西）</strong><ul><li>优点：稳定，偏向于开发响应式布局，移动设备优先的 WEB 项目</li><li>缺点：放弃了 IE67，对 IE8 支持但是界面效果不友好</li></ul></li><li>4.x.x 测试阶段</li></ul><h2 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h2><p>!&gt; 但凡看到 <code>role属性</code> <code>aria-*的属性</code> <code>class=&#39;sr-only&#39;的标签</code> 都可以直接删除，因为是给屏幕阅读器用的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>bootstrap基本模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 bootstrap 的核心样式文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"lib/bootstrap/css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- html5shiv 是用来解决 IE8 以下浏览器不支持 HTML5 语义化标签的问题 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- respond 是用来解决 IE8 以下浏览器不支持媒体查询的问题，注意：respond 不支持 file 协议打开 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 条件注释：IE浏览器专属 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src="html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src="respond.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">  &lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- bootstrap 依赖于 jquery，因此需要在 bootstrap 之前引入jquery文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/jquery/jquery-1.12.4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 bootstrap 的核心js文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/bootstrap/js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h2><h3 id="normalize-css"><a href="#normalize-css" class="headerlink" title="normalize.css"></a>normalize.css</h3><p>Normalize.css 是一种 CSS reset 的替代方案。经过@necolas 和@jon_neal 花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样</p><p><a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">官网</a> <a href="https://github.com/necolas/normalize.css" target="_blank" rel="noopener">github 网址</a></p><p>normalize 的特点：</p><ul><li><strong>保护有用的浏览器默认样式</strong>而不是完全去掉它们</li><li><strong>一般化的样式</strong>：为大部分 HTML 元素提供</li><li><strong>修复浏览器自身的 bug</strong>并保证各浏览器的一致性</li><li><strong>优化 CSS 可用性</strong>：用一些小技巧</li></ul><p><code>Normalize.css</code> 支持包括手机浏览器在内的超多浏览器，同时对 HTML5 元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。</p><p><a href="http://www.cnblogs.com/webpush/p/4974063.html" target="_blank" rel="noopener">Normalize.css 与 CSS reset 区别</a></p><h3 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h3><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。默认带了 15px 的 padding 值</p><p><code>.container</code> 类用于固定宽度并支持响应式布局的容器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>.container-fluid</code> 类用于 100% 宽度，占据全部视口（viewport）的容器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container-fluid"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两种容器类不能互相嵌套</p><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>栅格系统，也叫网格系统，bootstrap 栅格系统把一个盒子分成 12 格</p><ul><li><p>栅格参数：<code>col-xx-yy</code></p><p>xx：<code>lg</code> 大屏(≥1200px)、<code>md</code> 中屏(≥992px)、<code>sm</code> 小屏(≥768px)、<code>xs</code> 超小屏(&lt;768px)</p><p>yy：取值范围为 1 - 12 表示占几格</p><p><code>col-xx-12</code>：可以省略不写</p></li><li><p>列偏移：<code>col-xx-offset-yy</code></p><p>xx ：lg、md、sm、xs</p><p>yy：取值范围为 1 - 12 表示往右偏移几格</p><p>列偏移：实际上是给当前元素增加了左侧的边距（margin）</p></li><li><p>多余列（column）的元素将作为一个整体单元被另起一行排列</p></li><li><p><code>.row</code>用于抵消 <code>.container</code>容器的 15px 的 padding 值，实际上是给元素添加了 margin: -15px</p></li><li><p>可以在<code>.row</code>中嵌套<code>column</code></p></li><li><p>列排序：<code>.col-md-push-*</code> 和 <code>.col-md-pull-*</code></p></li></ul><p>栅格系统常用类（总共 12 列）</p><table><thead><tr><th>类名</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>.col-xs-xx</td><td>.col-xs-6</td><td>在超小屏幕（及以上）生效</td></tr><tr><td>.col-sm-xx</td><td>.col-sm-6</td><td>在小屏幕（及以上）生效</td></tr><tr><td>.col-md-xx</td><td>.col-md-6</td><td>在中屏幕（及以上）生效</td></tr><tr><td>.col-lg-xx</td><td>.col-lg-3</td><td>在大屏幕及生效，占 1/4</td></tr><tr><td>.col-lg-xx</td><td>.col-lg-4</td><td>在大屏幕及生效，占 1/3</td></tr><tr><td>.col-lg-xx</td><td>.col-lg-5</td><td>在大屏幕及生效，占 1/2</td></tr></tbody></table><p>【案例：列嵌套.html】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-4"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 栅格系统无处不在，只要父盒子有宽度，就可以使用栅格系统 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-6"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-6"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【案例：列偏移.html】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 .col-md-offset-* 类可以将列向右侧偏移--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- col-lg-offset-3:在大屏下，这个div将向右侧偏移3个单位 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-6 col-lg-offset-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><p>标题：h1 到 h6 标签、<code>.h1</code> 到 <code>.h6</code> 类、 <code>&lt;small&gt;</code> 标签或 <code>.small</code> 类用来标记副标题</p><p>文本：<code>&lt;mark&gt;</code>标记、<code>&lt;del&gt;</code>删除、<code>&lt;s&gt;</code>无用文本、<code>&lt;ins&gt;</code>插入文本、<code>&lt;u&gt;</code>下划线文本、 <code>.small</code> 类或<code>&lt;small&gt;</code> 小号文本、<code>&lt;strong&gt;</code>着重</p><p>对齐：<code>text-left</code>、<code>text-center</code>、<code>text-right</code>、<code>text-justify</code>、<code>text-nowrap</code></p><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p><code>&lt;a&gt;</code>、<code>&lt;button&gt;</code> 或 <code>&lt;input&gt;</code></p><p>预定义样式：btn、btn-default、btn-primary(蓝)、btn-success(绿)、btn-info(浅蓝)、btn-warning(橙)、btn-danger(红)、btn-link(链接)</p><p>尺寸：btn-lg(大)、(默认)、btn-sm(小)、btn-xs(超小)<br>btn-block (块元素 100%宽度)</p><p>激活状态：active</p><p>禁用状态：button 元素 添加 <code>disabled</code> 属性、链接<code>&lt;a&gt;</code>元素添加 <code>.disabled</code> 类（建议通过 JavaScript 代码来禁止链接的原始功能）</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>响应式图片：<code>img-responsive</code></p><p>实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性</p><p>图片形状：<code>img-rounded</code>、<code>img-circle</code>、<code>img-thumbnail</code></p><h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><p>文本颜色：<code>text-muted</code>、<code>text-muted</code>、<code>text-primary</code>、<code>text-success</code>、<code>text-info</code>、<code>text-warning</code>、<code>text-danger</code></p><p>背景颜色：<code>bg-primary</code>、<code>bg-success</code>、<code>bg-info</code>、<code>bg-warning</code>、<code>bg-danger</code></p><p>关闭按钮：<code>&lt;button type=&quot;button&quot; class=&quot;close&quot;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;</code></p><p>三角符号：<code>&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</code></p><p>快速浮动：<code>pull-left</code>、<code>pull-right</code></p><p>让内容块居中：<code>&lt;div class=&quot;center-block&quot;&gt;...&lt;/div&gt;</code></p><p>清除浮动：<code>clearfix</code></p><p>显示隐藏内容：<code>show</code>、<code>hidden</code>、<code>invisible</code></p><h3 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">            超小屏 小屏幕 中等屏幕 大屏幕桌面</span><br><span class="line">.visible-xs-*可见   隐藏   隐藏  隐藏</span><br><span class="line">.visible-sm-*隐藏   可见   隐藏  隐藏</span><br><span class="line">.visible-md-*隐藏   隐藏   可见  隐藏</span><br><span class="line">.visible-lg-*隐藏   隐藏   隐藏  可见</span><br><span class="line"></span><br><span class="line">.hidden-xs  隐藏 可见  可见  可见</span><br><span class="line">.hidden-sm  可见 隐藏  可见  可见</span><br><span class="line">.hidden-md  可见 可见  隐藏  可见</span><br><span class="line">.hidden-lg    可见 可见  可见  隐藏</span><br></pre></td></tr></table></figure><p><code>*</code> -&gt; block inline inline-block</p><p>推荐使用 hidden 相关的属性</p><h2 id="bootstrap-validator-插件"><a href="#bootstrap-validator-插件" class="headerlink" title="bootstrap-validator 插件"></a>bootstrap-validator 插件</h2><p>基于 bootstrap 的前端校验插件</p><p><a href="http://bootstrapvalidator.votintsev.ru/api" target="_blank" rel="noopener">http://bootstrapvalidator.votintsev.ru/api</a></p><h3 id="引包"><a href="#引包" class="headerlink" title="引包"></a>引包</h3><p>引入 css 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"lib/bootstrap/css/bootstrap.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"lib/bootstrap-validator/css/bootstrapValidator.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>引入 js 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/jquery/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/bootstrap/js/bootstrap.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/bootstrap-validator/js/bootstrapValidator.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="初始化表单校验插件"><a href="#初始化表单校验插件" class="headerlink" title="初始化表单校验插件"></a>初始化表单校验插件</h3><p>bootstrap-validator 插件会在表单提交的时候进行校验，如果校验成功了，表单会继续提交，但是如果校验失败了，就会阻止表单的提交</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用表单校验插件</span></span><br><span class="line">$(formSelector).bootstrapValidator(&#123;</span><br><span class="line">  <span class="comment">// 1. 指定不校验的类型，默认为[':disabled', ':hidden', ':not(:visible)'],可以不设置</span></span><br><span class="line">  excluded: [], <span class="comment">// 全部校验</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 指定校验时的图标显示，默认是bootstrap风格</span></span><br><span class="line">  feedbackIcons: &#123;</span><br><span class="line">    valid: <span class="string">'glyphicon glyphicon-ok'</span>,</span><br><span class="line">    invalid: <span class="string">'glyphicon glyphicon-remove'</span>,</span><br><span class="line">    validating: <span class="string">'glyphicon glyphicon-refresh'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 指定校验字段</span></span><br><span class="line">  fields: &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      <span class="comment">// 设置校验规则</span></span><br><span class="line">      validators: &#123;</span><br><span class="line">        <span class="comment">// 不能为空</span></span><br><span class="line">        notEmpty: &#123;</span><br><span class="line">          message: <span class="string">''</span></span><br><span class="line">        &#125;,</span><br><span class="line">        stringLength: &#123;</span><br><span class="line">          min: <span class="number">6</span>,</span><br><span class="line">          max: <span class="number">12</span>,</span><br><span class="line">          message: <span class="string">''</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 正则校验</span></span><br><span class="line">        regexp: &#123;</span><br><span class="line">          regexp: <span class="regexp">/^[a-zA-Z0-9_\.]+$/</span>,</span><br><span class="line">          message: <span class="string">'用户名由数字字母下划线和.组成'</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        callback: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    password: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="注册表单校验成功的事件"><a href="#注册表单校验成功的事件" class="headerlink" title="注册表单校验成功的事件"></a>注册表单校验成功的事件</h3><p>当表单校验成功时，会触发<code>success.form.bv</code>事件，此时会提交表单，通常我们需要禁止表单的自动提交，使用 ajax 进行表单的提交</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#form'</span>).on(<span class="string">'success.form.bv'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="comment">// 使用ajax提交逻辑</span></span><br><span class="line">  $.ajax(&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="获取-validator-实例-对象"><a href="#获取-validator-实例-对象" class="headerlink" title="获取 validator 实例(对象)"></a>获取 validator 实例(对象)</h3><p>当我们初始化好表单校验插件时，我们可以通过以下方法来获取表单校验的 validator 实例，通过 validator 实例调用一些方法来完成某些功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取表单校验实例</span></span><br><span class="line"><span class="keyword">var</span> validator = $(<span class="string">'#form'</span>).data(<span class="string">'bootstrapValidator'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用表单校验实例可以调用一些常用的方法</span></span><br><span class="line">validator.methodName(params)</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h4><p>重置表单中设置过校验的内容，将隐藏所有错误提示和图标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置表单，隐藏所有的错误提示和图标 传入参数 true 会将内容也清空</span></span><br><span class="line">validator.resetForm()</span><br></pre></td></tr></table></figure><h4 id="更新字段的状态"><a href="#更新字段的状态" class="headerlink" title="更新字段的状态"></a>更新字段的状态</h4><p>BootstrapValidator 在用户输入内容的时候，会做校验，当调用 bootstrap 的插件的方法可以手动会改变字段值的状态</p><p><code>validator.updateStatus(field*, status*, validator)</code></p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>field</code></td><td>String|jQuery</td><td>The field name or field element</td></tr><tr><td><code>status</code></td><td>String</td><td>Can be <code>NOT_VALIDATED</code>, <code>VALIDATING</code>, <code>INVALID</code> or <code>VALID</code></td></tr><tr><td><code>validator</code></td><td>String</td><td>The validator name. If <code>null</code>, the method updates validity result for all validators</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> bootstrap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动 web</title>
      <link href="/2018/%E7%A7%BB%E5%8A%A8web/%E7%A7%BB%E5%8A%A8web/"/>
      <url>/2018/%E7%A7%BB%E5%8A%A8web/%E7%A7%BB%E5%8A%A8web/</url>
      
        <content type="html"><![CDATA[<h1 id="移动web基础"><a href="#移动web基础" class="headerlink" title="移动web基础"></a>移动web基础</h1><h2 id="移动端开发现状"><a href="#移动端开发现状" class="headerlink" title="移动端开发现状"></a>移动端开发现状</h2><ul><li>移动web开发指的是需要适配移动设备的网页开发</li><li>移动web开发与pc端web开发没有本质的区别，使用的还是HTML/CSS/JavaScript的技术</li><li>移动web开发与pc端web开发的区别是什么？</li></ul><p>移动端的浏览器与pc端不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">谷歌浏览器 苹果浏览器、 UC浏览器 QQ浏览器 欧朋浏览器 百度手机浏览器  <span class="number">360</span>安全浏览器  搜狗浏览器  猎豹浏览器等</span><br><span class="line">国内的手机浏览器都是根据webkit内核修改过来的，国内没有自主研发的内核，国内的操作系统也是基于Android系统修改的。</span><br><span class="line"></span><br><span class="line">因此在移动端，css3属性只需要加webkit前缀即可。</span><br></pre></td></tr></table></figure><p>移动端设备尺寸不一样(尺寸非常多，碎片化很严重)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android： <span class="number">320</span>*<span class="number">480</span> <span class="number">480</span>*<span class="number">800</span>  <span class="number">540</span>*<span class="number">960</span> <span class="number">720</span>*<span class="number">1280</span> <span class="number">1080</span>*<span class="number">1920</span> <span class="number">2</span>k屏 <span class="number">4</span>k屏</span><br><span class="line">iphpne：  <span class="number">640</span>*<span class="number">960</span> <span class="number">640</span>*<span class="number">1136</span> <span class="number">750</span>*<span class="number">1334</span> <span class="number">1242</span>*<span class="number">2208</span></span><br></pre></td></tr></table></figure><h2 id="移动端开发分类"><a href="#移动端开发分类" class="headerlink" title="移动端开发分类"></a>移动端开发分类</h2><ul><li>原生app（native app）</li><li>混合app（Hybrid app）</li><li>web应用（webApp）</li></ul><p><strong>原生app（native app）</strong></p><blockquote><p> 原生app是基于操作系统的开发，比如安卓，ios，windows phone,他们只能在各自的操作系统上运行。</p></blockquote><p>优点：</p><ol><li>可以访问操作系统，获取更多的资源（gps，摄像头，传感器，麦克风等）</li><li>速度快，性能高，用户体验好</li><li>可以离线使用</li></ol><p>缺点：</p><ol><li>开发成本高</li><li>需要安装和更新，更新与发布需要审核。</li></ol><p><strong>Web App</strong></p><blockquote><p> Web应用使用H5C3开发页面，为浏览器设计的基于web的应用，可以在各种智能设备的手机浏览器上运行。不需要安装即可运行。</p></blockquote><p>优点：</p><ol><li>支持设备广泛</li><li>开发成本低（使用）</li><li>可以随时上线与更新，无需审核</li></ol><p>缺点：</p><ol><li>用户体验极度依赖网速</li><li>要求联网</li><li>无法获取手机的资源（gps，摄像头）</li></ol><p><strong>混合app（Hybrid App）</strong></p><blockquote><p>Hybrid App是指介于web-app、native-app这两者之间的app,它虽然看上去是一个Native App，但只有一个UI WebView，里面访问的是一个Web App。（淘宝、京东、手机百度）</p></blockquote><p>Hybird App说白了就是使用了Native app的壳，里面其实还是HTML5页面。</p><p>优点：</p><ol><li>开发成本和难度更低，兼容多个平台</li><li>也可以访问手机的操作系统资源。</li><li>更新维护更方便</li></ol><p>缺点：</p><ol><li>用户体验相比原生app稍差。</li><li>性能依赖于网速</li></ol><p>总结：</p><p>三种开发各有优缺点，具体用什么需要根据实际情况而定，比如预算，app注重功能还是内容等。</p><p><img src="%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%88%86%E7%B1%BB.png" alt></p><h2 id="屏幕与分辨率"><a href="#屏幕与分辨率" class="headerlink" title="屏幕与分辨率"></a>屏幕与分辨率</h2><blockquote><p>移动设备与PC设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面。</p></blockquote><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>通常我们所指的屏幕<code>尺寸</code>，实际上指的是屏幕对角线的长度（一般用英寸来度量）</p><p><code>1英寸 = 2.54厘米</code></p><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>分辨率则一般用像素来度量，表示屏幕水平和垂直方向的像素数，例如1920*1080指的是屏幕垂直方向和水平方向分别有1920和1080个像素点而构成。</p><p><code>像素</code>：指计算机显示设备中的最小单位，即一个像素点的大小。每一个像素点可以理解为就是屏幕上的一个发光点。</p><h3 id="像素密度ppi-了解"><a href="#像素密度ppi-了解" class="headerlink" title="像素密度ppi(了解)"></a>像素密度ppi(了解)</h3><p><code>PPI（Pixels Per Inch）</code>表示屏幕每英寸的像素数</p><p>PPI值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙。</p><p><strong>结论：当PPI 越大，展示的画质越精细。</strong></p><h2 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h2><blockquote><p>随着技术发展，设备不断更新，出现了不同PPI的屏幕共存的状态，给我们开发带来的问题</p></blockquote><p>做为用户是不会关心这些细节的，他们只是希望在不同PPI的设备上看到的图像内容差不多大小，所以这时我们需要一个新的单位，<code>这个新的单位能够保证图像内容在不同的PPI设备看上去大小应该差不多</code>，这就是独立像素，也叫（设备无关像素），在IOS设备上叫<code>PT</code>，Android设备上叫<code>DP</code>，在css中，叫<code>PX</code>。</p><p>获取设备的像素比</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.devicePixelRatio  <span class="comment">// 物理像素与独立像素的比值 DPR</span></span><br></pre></td></tr></table></figure><h2 id="2倍图与3倍图（重要）"><a href="#2倍图与3倍图（重要）" class="headerlink" title="2倍图与3倍图（重要）"></a>2倍图与3倍图（重要）</h2><blockquote><p>以后同学在工作的过程中，从UI那拿到的设计图通常都是640的设计图或者是750的设计图.</p></blockquote><p>把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。</p><p><img src="2x.png" alt></p><p>设备像素比devicePixelRatio：即像素的压缩比例</p><p><strong>结论 ：在移动端为了在高清屏手机上显示得更加细腻，通常会使用更大的图片，比如2倍图或者3倍图。</strong></p><h2 id="视口viewport（重要）"><a href="#视口viewport（重要）" class="headerlink" title="视口viewport（重要）"></a>视口viewport（重要）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">问题：一个电脑上的网站，在手机端访问，效果是什么样的？</span><br><span class="line"></span><br><span class="line">iPhone5的设备宽度只有<span class="number">320</span>px，一张宽度为<span class="number">640</span>px的图片在手机端访问，显示的效果是什么？</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 在手机端，html的大小都是<span class="number">980</span>px，为什么？</span><br><span class="line">这主要是历史原因导致的，因为在移动设备刚流行的时候，网站大多都是pc端的，pc端的页面宽度一般都比较大，移动设备的宽度比较小，如果pc端页面直接在移动端显示的话，页面就会错乱。为了解决这个问题，移动端html的大小直接就定死成了<span class="number">980</span>px（因为早起的pc端网站版心就是<span class="number">980</span>px居多）。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 视口</span><br><span class="line">在pc端，html的大小默认是继承了浏览器的宽度，即浏览器多宽，html的大小就是多宽，但是在移动端，多出来了一个视口的概念（乔布斯）,视口说白了就是介于浏览器与html之间的一个东西，视口的宽度默认定死了<span class="number">980</span>px，因此html的宽度默认就是<span class="number">980</span>px，视口的特点是能够根据设备的宽度进行缩放。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 视口设置。</span><br><span class="line">对于现在的移动端页面来说，视口默认为<span class="number">980</span>px肯定不合适，因为设备宽度不够的话，视口会进行缩放，导致页面展示效果不好看。</span><br></pre></td></tr></table></figure><p><strong>视口参数设置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// width 设置视口的宽度</span></span><br><span class="line"><span class="comment">// width=device-width   设置视口宽度为设备的宽度（常用）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initial-scale 设置初始缩放比例</span></span><br><span class="line"><span class="comment">// initial-scale=1.0  表示不缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user-scalable 设置是否允许用户缩放</span></span><br><span class="line"><span class="comment">// user-scalable=no  不允许用户缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum-scale  设置允许的最大缩放比例</span></span><br><span class="line"><span class="comment">// maximum-scale=1.0  可以不设置，因为都禁止用户缩放了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// minimum-scale 设置允许最小缩放比</span></span><br><span class="line"><span class="comment">// minimum-scale=1.0  不设置，因为都禁用用户缩放了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准写法：</span></span><br><span class="line"><span class="comment">// 快捷键：  meta:vp + tab键</span></span><br><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0"</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="移动端调试问题"><a href="#移动端调试问题" class="headerlink" title="移动端调试问题"></a>移动端调试问题</h2><ol><li>模拟器调试</li><li>真机调试：使用手机进行访问。</li></ol><p>手机设备五花八门，屏幕尺寸都大不一样，尤其是安卓端，给我们的页面预览带来了一些麻烦。在实际工作中，作为开发者不可能有足够的设备让我们去测试（<strong>除了测试部门</strong> ），即便有，效率也特别的低，因此开发者一般都是通过浏览器的手机模拟器来模拟不同的设备。</p><h1 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h1><p><strong>移动端的特点</strong></p><ul><li>手机端的兼容性问题比PC端小很多，因为手机端的浏览器版本比较新</li><li>手机端屏幕比较小，能够放的内容比较少。</li></ul><p>问题：布局的时候怎么解决屏幕大小不一致的问题？</p><ul><li>PC端，固定版心，让所有分辨率的电脑的版心都是一样的，比如京东</li><li>移动端：移动端无法设置版心，因为移动端的设备屏幕本身就小，设置版心不合适。因此移动端大多会采用流式布局（百分比布局）</li></ul><p><strong>流式布局</strong>，也叫百分比布局，是移动端开发中经常使用的布局方式之一。</p><p>流式布局的特征：</p><ul><li>宽度自适应，高度写死，并不是百分百还原设计图</li><li>图标都是固定死大小的，包括字体等也是固定死的。并不是所有的东西都是自适应的。</li><li>一些大的图片，设置宽度为百分比自适应即可，随着屏幕大小进行变化</li></ul><p><strong>流式布局无法做到所有设备都非常逼真的还原设计图，有些设备显示效果不是特别的好看。但是流式布局是移动端非常常用的一种布局方式，比较简单，需要掌握（携程、京东)</strong></p><p><strong>最后一天会学习rem布局，配合less非常的方便，并且能够实现完全的自适应，包括字体以及图标等</strong></p><p>经典的流式布局</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 左侧固定，右侧自适应</span><br><span class="line"><span class="number">2.</span> 右侧固定，左侧自适应</span><br><span class="line"><span class="number">3.</span> 两侧固定，中间自适应（圣杯布局，双飞翼布局）</span><br><span class="line"><span class="number">4.</span> 等分布局</span><br></pre></td></tr></table></figure><h1 id="touch-事件"><a href="#touch-事件" class="headerlink" title="touch 事件"></a>touch 事件</h1><p>移动端新增了4个与手指触摸相关的事件</p><ul><li><code>touchstart</code>: 手指放到屏幕上时触发</li><li><code>touchmove</code>: 手指在屏幕上滑动式触发（会触发多次）</li><li><code>touchend</code>: 手指离开屏幕时触发</li><li><code>touchcancel</code>: 系统取消touch事件的时候触发，比如电话</li></ul><p>每个触摸事件被触发后，会生成一个event对象，event对象中<code>changedTouches</code>会记录手指滑动的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.touches <span class="comment">// 当前屏幕上的手指</span></span><br><span class="line">e.targetTouches <span class="comment">// 当前dom元素上的手指。</span></span><br><span class="line">e.changedTouches <span class="comment">// 触摸时发生改变的手指(重点)(如手指离开屏幕)</span></span><br></pre></td></tr></table></figure><p>这些列表里的每次触摸由touch对象组成，touch对象里包含着触摸信息，主要属性如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e.changedTouches[0].clientX</span></span><br><span class="line">clientX / clientY <span class="comment">// 触摸点相对浏览器窗口的位置</span></span><br><span class="line">pageX / pageY     <span class="comment">// 触摸点相对于页面的位置</span></span><br></pre></td></tr></table></figure><p>!&gt; 使用 jquery 注册 touch 类事件时，获取手指使用 <code>e.originalEvent.touchs[0]</code> ，因为 jq 对事件对象进行了封装</p><p>【案例：jdm-滑动轮播图】</p><p>【案例：jdm-区域滚动】</p><h2 id="iscroll-插件使用"><a href="#iscroll-插件使用" class="headerlink" title="iscroll 插件使用"></a>iscroll 插件使用</h2><p><a href="https://github.com/cubiq/iscroll" target="_blank" rel="noopener">https://github.com/cubiq/iscroll</a></p><p><a href="http://www.mamicode.com/info-detail-331827.html" target="_blank" rel="noopener">iscroll参考文档</a></p><p><strong>注意</strong>：使用 iscroll 需要满足的条件</p><ol><li>父盒子嵌套了子盒子（一个）<ol><li>如果有多个子盒子，所以我们需要使用一个盒子把所有的子盒子包裹起来</li><li>如果有图片，我们需要保证图片加载完成，如果有浮动，需要清除浮动，为了保证子盒子的高度获取的是正确的</li></ol></li><li>子盒子大小一定要超过父盒子的大小</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用：box为父盒子</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>)</span><br><span class="line"><span class="keyword">new</span> IScroll(box, &#123;</span><br><span class="line">    scrollX:<span class="literal">false</span>, <span class="comment">// 横向滚动</span></span><br><span class="line">    scrollY:<span class="literal">true</span> <span class="comment">// 纵向滚动</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h1 id="zepto-框架"><a href="#zepto-框架" class="headerlink" title="zepto 框架"></a>zepto 框架</h1><blockquote><p><strong>Zepto</strong>是一个轻量级的<strong>针对现代高级浏览器的JavaScript库， **它与jquery</strong>有着类似的api**。 如果你会用jquery，那么你也会用zepto。</p></blockquote><p><a href="https://github.com/madrobby/zepto" target="_blank" rel="noopener">github地址</a></p><p><a href="http://www.css88.com/doc/zeptojs_api/" target="_blank" rel="noopener">中文文档</a></p><h2 id="zepto-与-jquery-的区别"><a href="#zepto-与-jquery-的区别" class="headerlink" title="zepto 与 jquery 的区别"></a>zepto 与 jquery 的区别</h2><ul><li>jquery 针对 pc 端，主要用于解决浏览器兼容性问题，zepto 主要针对移动端</li><li>zepto 比 jquery 轻量，文件体积更小</li><li>zepto 封装了一些移动端的手势事件</li></ul><h2 id="zepto-的基本使用"><a href="#zepto-的基本使用" class="headerlink" title="zepto 的基本使用"></a>zepto 的基本使用</h2><p>zepto的使用与jquery基本一致，zepto是分模块的，需要某个功能，就需要引入某个zepto的文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"zepto/zepto.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"zepto/event.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"zepto/fx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">".box"</span>).addClass(<span class="string">"demo"</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="string">"button"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="string">".box"</span>).animate(&#123;<span class="attr">width</span>:<span class="number">500</span>&#125;, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="zepto-的定制"><a href="#zepto-的定制" class="headerlink" title="zepto 的定制"></a>zepto 的定制</h2><p>安装Nodejs环境</p><p>1、下载zepto.js</p><p>2、解压缩</p><p>3、cmd命令行进入解压缩后的目录</p><p>4、执行<code>npm install</code>命令</p><p>5、编辑make文件的<code>41行</code>，添加自定义模块并保存</p><p>7、然后执行命令 <code>npm run-script dist</code></p><p>8、查看目录dist即构建好的zepto.js</p><h2 id="zepto-手势事件"><a href="#zepto-手势事件" class="headerlink" title="zepto 手势事件"></a>zepto 手势事件</h2><p>zepto中根据<code>touchstart touchmove touchend</code>封装了一些常用的手势事件，这些事件都是基于touchstart touchmove touchend封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tap   <span class="comment">// 轻触事件,用于替代移动端的click事件，因为click事件在老版本中会有300ms的延迟</span></span><br><span class="line">swipe <span class="comment">//手指滑动时触发</span></span><br><span class="line">swipeLeft  <span class="comment">//左滑</span></span><br><span class="line">swipeRight  <span class="comment">//右滑</span></span><br><span class="line">swipeUp    <span class="comment">//上滑</span></span><br><span class="line">swipeDown   <span class="comment">//下滑</span></span><br></pre></td></tr></table></figure><h1 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h1><h2 id="什么是响应式布局"><a href="#什么是响应式布局" class="headerlink" title="什么是响应式布局"></a>什么是响应式布局</h2><blockquote><p>响应式布局（respond layout）是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是<strong>一个网站能够兼容多个终端（手机、平板、pc电脑、手表）</strong> ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的</p></blockquote><p><strong>为什么要有响应式布局？</strong></p><ul><li>在移动互联日益成熟的时候，在PC端开发的网页已经无法满足移动设备的要求</li><li>通常的做法是针对移动端单独做一套特定的版本</li><li>如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及）</li><li><strong>响应式布局</strong> ：一个网站能够兼容多个终端（节约开发成本）</li></ul><p><strong>优点：</strong></p><p>面对不同分辨率设备灵活性强</p><p>能够快捷解决多设备显示适应问题</p><p>*<em>缺点： *</em></p><p>兼容各种设备工作量大，效率低下</p><p>代码累赘，会出现隐藏无用的元素，加载时间加长</p><p>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</p><p>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p><p>响应式开发现状：</p><ul><li>如果已经存在PC的网站了，那么一般不会使用响应式开发，而是针对移动端再开发一套系统（比如京东、淘宝）</li><li>在<strong>新建站点</strong> 上采用响应式开发的越来越多</li><li>在国内，响应式开发还不是特别的流行。但响应式开发是大势所趋，会越来越流行</li></ul><h2 id="响应式开发与移动web开发的比较"><a href="#响应式开发与移动web开发的比较" class="headerlink" title="响应式开发与移动web开发的比较"></a>响应式开发与移动web开发的比较</h2><table><thead><tr><th>开发方式</th><th>移动web开发+pc开发</th><th>响应式开发</th></tr></thead><tbody><tr><td>引用场景</td><td>一般已经有了PC端网站，只需要端独开发移动端网站即可</td><td>针对一些新建网站，并且要求适配移动端</td></tr><tr><td>开发</td><td>针对性强，开发效率高</td><td>兼容各种终端，效率低</td></tr><tr><td>适配</td><td>只能适配移动端或者PC端，pad上体验比较差</td><td>可以适配各种终端</td></tr><tr><td>效率</td><td>代码简介，加载快</td><td>代码相对复杂，加载慢</td></tr></tbody></table><h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><blockquote><p>媒体查询（Media Query）是 CSS3 提出来的一个新的属性，通过媒体查询可以查询到 screen 的宽度，从而指定某个宽度区间的网页布局</p></blockquote><h2 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h2><table><thead><tr><th>分类</th><th>宽度范围</th></tr></thead><tbody><tr><td>大屏设备</td><td>&gt;1200px</td></tr><tr><td>中屏设备</td><td>992px~1200px</td></tr><tr><td>小屏设备</td><td>768px~992px</td></tr><tr><td>超小屏设备</td><td>&lt; 768px</td></tr></tbody></table><h2 id="媒体查询的使用"><a href="#媒体查询的使用" class="headerlink" title="媒体查询的使用"></a>媒体查询的使用</h2><p>需求：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    大屏设备(&gt;1200px)   版心：1170px   背景色：红色</span></span><br><span class="line"><span class="comment">    中屏设备(992-1200)  版心：970px    背景色：蓝色</span></span><br><span class="line"><span class="comment">    小屏设备(768-992)   版心：750px    背景色：黄色</span></span><br><span class="line"><span class="comment">    超小屏设备(&lt;768px)  版心：100%     背景色：绿色</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>响应式开发的原理：使用媒体查询实现不同终端的布局和样式的切换</p><p>媒体查询语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查询屏幕 */</span></span><br><span class="line"><span class="comment">/* screen 和第一个 and 可以省略 */</span></span><br><span class="line">@<span class="keyword">media</span> screen and 条件 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 条件的写法 */</span></span><br><span class="line"><span class="comment">/* min-width: 只要屏幕宽度超过这个值的设备样式就能生效 */</span></span><br><span class="line"><span class="comment">/* max-width: 只要屏幕宽度小于这个值的设备样式就能生效 */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1170px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">992px</span>) and (max-width: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) and (max-width: <span class="number">992px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bootstrap-框架"><a href="#bootstrap-框架" class="headerlink" title="bootstrap 框架"></a>bootstrap 框架</h1><p><strong>【项目：微金所】</strong></p><h1 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h1><h2 id="rem-是什么？"><a href="#rem-是什么？" class="headerlink" title="rem 是什么？"></a>rem 是什么？</h2><p><code>rem</code>（font size of the root element）是指相对于<code>根元素</code>的字体大小的单位。它就是一个相对单位。</p><p><code>em</code>（font size of the element）是指相对于当前元素的字体大小的单位。它也是一个相对单位。</p><p>它们之间其实很相似，只不过计算的规则一个是依赖根元素，一个是当前元素计算。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.em</span> &#123;</span><br><span class="line">  <span class="comment">/* em 的计算方式参照的当前元素的 font-size，如果不设置，默认继承自父盒子 */</span></span><br><span class="line">  <span class="attribute">width</span>:<span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* rem 的计算方式参照的是 html 的 font-size */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.rem</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要用-rem？"><a href="#为什么要用-rem？" class="headerlink" title="为什么要用 rem？"></a>为什么要用 rem？</h2><blockquote><p>rem 的主要目的就是解决用于不同屏幕的适配问题。rem 能够等比例的适配所有的屏幕。</p></blockquote><p>由于市面上手机种类繁多，导致移动端的屏幕种类非常的混乱，比如有常见的<code>320px  360px  375px  384px  480px  640px</code>等。在开发中，美工一般只会提供750px或者是640px的设计稿，这就要求我们通过一张设计稿能够适配所有的屏幕。通常解决方案如下：</p><ul><li>流式布局：虽然可以让各种屏幕都适配，但是显示效果不是非常的友好，因为只有几个尺寸的手机能够完美的显示出来视觉设计师和交互最想要的效果。但是目前使用流式布局的公司非常多，比如 <a href="https://www.amazon.cn/" target="_blank" rel="noopener">亚马逊</a> 、<a href="https://m.jd.com/" target="_blank" rel="noopener">京东</a> 、<a href="https://m.ctrip.com/" target="_blank" rel="noopener">携程</a></li><li>响应式布局：响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是<strong>工作大，维护性难</strong> 。所以一般都是中小型的门户或者博客类站点会采用响应式的方法从PC端页面到移动端页面以及web app直接一步到位，因为这样反而可以节约成本。</li><li>rem布局：rem能够适配所有的屏幕，与less配合使用效果会更好。目前使用rem布局的有：<a href="https://m.taobao.com" target="_blank" rel="noopener">淘宝</a> 、 <a href="https://m.suning.com/" target="_blank" rel="noopener">苏宁</a></li></ul><h2 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h2><p>因为 rem 的基准点是根元素html的字体大小，因此我们只需要设置不同屏幕的 html 的 font-size 大小不一样就可以达到不同屏幕的适配了。</p><h3 id="rem-配合媒体查询"><a href="#rem-配合媒体查询" class="headerlink" title="rem 配合媒体查询"></a>rem 配合媒体查询</h3><p>使用 rem 配合媒体查询可以适配多个终端</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@media(min-width: 320px) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="comment">/* 基准值 / 设计图的大小  = 某个屏幕的font-size / 屏幕的宽度 */</span></span><br><span class="line">        <span class="comment">/* 100/750 = x/370 */</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>优点：使用媒体查询适配，速度快。</p><p>缺点：适配多个终端时，需要添加响应的代码。</p><h3 id="rem-配合-javascript"><a href="#rem-配合-javascript" class="headerlink" title="rem 配合 javascript"></a>rem 配合 javascript</h3><p>通过 javascript 获取可视区的宽度，计算 font-size 的值，也可以适配多个终端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据屏幕的大小动态设置 html的 font-size</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">responsive</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> uiWidth = <span class="number">750</span> <span class="comment">// 设计图宽度</span></span><br><span class="line">  <span class="keyword">var</span> base = <span class="number">100</span> <span class="comment">// 设计图中1rem的大小</span></span><br><span class="line">  <span class="comment">// 当前屏幕的大小</span></span><br><span class="line">  <span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth</span><br><span class="line">  <span class="keyword">if</span>(pageWidth &gt;= <span class="number">750</span>) &#123;</span><br><span class="line">    pageWidth = <span class="number">750</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pageWidth &lt;= <span class="number">320</span>) &#123;</span><br><span class="line">    pageWidth = <span class="number">320</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 说白了就是把一个屏幕分成了 7.5 rem</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.fontSize = (base / uiWidth * pageWidth).toFixed(<span class="number">2</span>) + ’px‘</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：直接适配所有的终端</p><p>缺点：必须在页面加载之前设置html的font-size值，不然会出现文字大小调动的情况。</p><h3 id="rem-配合-flexible-插件"><a href="#rem-配合-flexible-插件" class="headerlink" title="rem 配合 flexible 插件"></a>rem 配合 flexible 插件</h3><ul><li><p>flexible 插件基准值（base）是设计图的 1/10</p></li><li><p>使用 flexible</p></li></ul><ol><li><p>在 header 中引入 flexible.js 这个文件</p></li><li><p>根据设计图能够确定基准值， 配合 px2rem 插件 ，需要设置一个 rootFontSize</p></li></ol><p>【案例：苏宁易购】</p><h1 id="swiper-插件"><a href="#swiper-插件" class="headerlink" title="swiper 插件"></a>swiper 插件</h1><blockquote><p>Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端</p></blockquote><p><a href="http://www.swiper.com.cn/" target="_blank" rel="noopener">swiper中文网</a></p><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="comment">/* 取消链接高亮, 移动端特有的样式  */</span></span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 移动web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术栈</title>
      <link href="/2018/other/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
      <url>/2018/other/%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="技术栈："><a href="#技术栈：" class="headerlink" title="技术栈："></a>技术栈：</h3><p>ajax + jquery + art-template：较原始的开发方式</p><p>vue + vuex + vue-router + webpack + less + weex + nuxt(ssr)</p><p>react + react-router + redux + webpack + less + react-native</p><p>angular + webpack + typescript + less + ionic</p><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的工作原理</title>
      <link href="/2018/other/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2018/other/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h1><h2 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h2><p><img src="How-browsers-work1.png" alt="浏览器的组成"></p><ul><li>用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</li><li>浏览器引擎－ 用来查询及操作渲染引擎的接口</li><li>渲染引擎（浏览器内核）－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</li><li>网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</li><li>UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li><li>JS解释器－ 用来解释执行JS代码</li><li>数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了Storage技术，这是一种轻量级完整的客户端存储技术</li></ul><h2 id="主流的渲染引擎"><a href="#主流的渲染引擎" class="headerlink" title="主流的渲染引擎"></a>主流的渲染引擎</h2><blockquote><p>浏览器的渲染引擎也叫排版引擎，或者是<strong>浏览器内核</strong></p></blockquote><p>主流的 渲染引擎 有</p><ul><li><strong>Chrome浏览器</strong>: Blink引擎（WebKit的一个分支）。</li><li><strong>Safari浏览器</strong>: WebKit引擎，windows版本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发Windows版的Safari。</li><li><strong>FireFox浏览器</strong>: Gecko引擎。</li><li><strong>Opera浏览器</strong>: Blink引擎(早期版使用Presto引擎）。</li><li><strong>Internet Explorer浏览器</strong>: Trident引擎。</li><li><strong>Microsoft Edge浏览器</strong>: EdgeHTML引擎（Trident的一个分支）。</li></ul><h2 id="渲染引擎工作原理"><a href="#渲染引擎工作原理" class="headerlink" title="渲染引擎工作原理"></a>渲染引擎工作原理</h2><p>渲染引擎解析的基本流程：</p><ol><li><p>解析 HTML 构建 <code>Dom树</code>，同时解析所有的 css 样式，构建 css 规则。DOM 是 W3C 组织推荐的处理可扩展置标语言的标准编程接口。</p></li><li><p>根据 DOM 树和 css 规则合并构建 <code>渲染树</code></p><ul><li>DOM树上的节点没有样式的，渲染树的节点有样式的</li><li>渲染树上的节点都是需要渲染的，所以渲染树上没有像<code>head</code>标签 或 <code>display: none</code>这样的元素，但是它们在Dom树中</li></ul></li><li><p>对渲染树进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫<code>layout</code> 或 <code>reflow</code>。</p></li><li><p>绘制渲染树，调用操作系统底层API(UI Backend)进行绘图操作。</p></li></ol><p><img src="flow.png" alt></p><p><strong>webkit内核工作流程</strong></p><p><img src="webkitflow.png" alt></p><p><strong>gecko内核工作流程</strong></p><p><img src="gecko.jpg" alt></p><p>结论：浏览器能够解析HTML文件，并且显示到页面中。所以我们写的文件能够使用浏览器打开并且能够看到效果。</p><h1 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h1><h2 id="重绘与回流-1"><a href="#重绘与回流-1" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p><code>回流(reflow)</code>: 又叫重排，当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。</p><p><code>重绘(repaint)</code>：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。</p><ol><li>每个页面至少需要一次回流+重绘。</li><li>回流必将引起重绘</li></ol><p>回流什么时候发生？</p><p>1、添加或者删除可见的DOM元素</p><p>2、元素位置改变</p><p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p><p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变</p><p>5、页面渲染初始化</p><p>6、浏览器窗口尺寸改变——resize事件发生时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style</span><br><span class="line">s.padding = <span class="string">"2px"</span> <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">"1px solid red"</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">"blue"</span> <span class="comment">// 再一次重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">"#ccc"</span> <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">"14px"</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="comment">// 添加node，再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'abc!'</span>))</span><br></pre></td></tr></table></figure><h2 id="聪明的浏览器"><a href="#聪明的浏览器" class="headerlink" title="聪明的浏览器"></a>聪明的浏览器</h2><blockquote><p>从上个实例代码中可以看到几行简单的JS代码就引起了6次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句JS操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p></blockquote><p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：</p><ol><li><p>offsetTop, offsetLeft, offsetWidth, offsetHeight</p></li><li><p>scrollTop/Left/Width/Height</p></li><li><p>clientTop/Left/Width/Height</p></li><li><p>width,height</p></li><li><p>请求了getComputedStyle(), 或者 IE的 currentStyle</p></li></ol><h2 id="如何性能优化"><a href="#如何性能优化" class="headerlink" title="如何性能优化"></a>如何性能优化</h2><blockquote><p>减少回流与重绘的次数，就需要简单对渲染树的操作</p></blockquote><ol><li>直接使用 <code>className</code> 修改样式，少用 style 设置样式</li><li>让要操作的元素进行”离线处理”，处理完后一起更新<ul><li>使用 <code>DocumentFragment</code> 进行缓存操作，引发一次回流和重绘</li><li>使用 <code>display:none</code> 技术，只引发两次回流和重绘</li></ul></li><li>将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow</li><li><strong>完成功能是前提，在完成功能的情况下想着优化代码</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fullpage 全屏网站插件</title>
      <link href="/2018/jquery/fullpage/"/>
      <url>/2018/jquery/fullpage/</url>
      
        <content type="html"><![CDATA[<h2 id="fullpage"><a href="#fullpage" class="headerlink" title="fullpage"></a>fullpage</h2><p>fullPage.js 是一个基于 jQuery 的插件，它能够很方便、很轻松的制作出全屏网站</p><p>参考文档 <a href="http://www.dowebok.com/77.html" target="_blank" rel="noopener">http://www.dowebok.com/77.html</a></p><p>下载地址 <a href="http://www.dowebok.com/77.html" target="_blank" rel="noopener">https://github.com/alvarotrigo/fullPage.js</a></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li>引入jQuery文件，因为fullpage是jquery插件</li><li>引入fullpage的js文件</li><li>页面结构</li><li>编写js代码</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 每一个class为section的div都是一屏,section这个类是固定的 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>我是内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>我是内容2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>我是内容3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>我是内容4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写js代码</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#box'</span>).fullpage()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="鼠标滚轮滚动事件"><a href="#鼠标滚轮滚动事件" class="headerlink" title="鼠标滚轮滚动事件"></a>鼠标滚轮滚动事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'mousewheel'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.wheelDelta)</span><br><span class="line">  <span class="keyword">if</span> (e.wheelDelta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'往上滚了'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'往下滚了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'鼠标滚轮事件触发了'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>sectionsColor</strong></td><td>设置每一个section的背景颜色（为一个数组）</td></tr><tr><td>controlArrows</td><td>定义是否使用箭头来控制幻灯片，默认true</td></tr><tr><td><strong>verticalCentered</strong></td><td>设定每一个section的内容是否垂直居中，默认true，</td></tr><tr><td>resize</td><td>设定字体是否随着窗口缩放而缩放，默认false，一般不修改</td></tr><tr><td><strong>scrollingSpeed</strong></td><td>设置滚动的速度，默认700毫秒</td></tr><tr><td>easing</td><td>设置动画的方式，默认是easeInOutCubic,如果想要修改此页，需要引入jquery.easing.js</td></tr><tr><td>css3</td><td>是否使用css3 transform来实现滚动效果，默认true，不用修改，CSS3的动画效率比较js高。</td></tr><tr><td>loopTop</td><td>滚动到顶部后是否连续滚动到底部，默认false</td></tr><tr><td>loopBottom</td><td>滚动到底部后是否连续滚动到顶部，默认false</td></tr><tr><td>loopHorizontal</td><td>设置幻灯片是否循环滚动，默认true</td></tr><tr><td><strong>continuousVertical</strong></td><td>是否循环滚动，默认为false，如果设置为true，则页面会循环滚动，不会出现loopTop与loopBottom那样的跳动。</td></tr><tr><td>autoScrolling</td><td>是否使用插件的滚动方式，默认true，如果选择false，会出现浏览器子代的滚动条，将不会按页滚动，按照滚动进行滚动。</td></tr><tr><td>scrollBar</td><td>是否包含滚动条，默认false，如果设置为true，那么浏览器自定的滚动条会出现，这个时候，页面滚动还是按页滚动，但是浏览器也能滚动。不建议开启，不然会不同步。</td></tr><tr><td>paddingTop/paddingBottom</td><td>给每一个section设置一个paddingTop或者paddingBottom,默认值为0，如果需要给页面设置一个固定定位的头部菜单或者底部菜单的时候，可以使用这两个选项。</td></tr><tr><td>keyboardScrolling</td><td>是否可以使用键盘方向键导航，默认true</td></tr><tr><td><strong>navigation</strong></td><td>是否显示导航，默认为false，设置为true，会显示小圆点，作为导航</td></tr><tr><td>navigationPositon</td><td>导航小圆点的位置，设置left或者right，默认是right</td></tr><tr><td>navigationTooltips</td><td>小圆点的提示信息，鼠标一上去能看到提示信息</td></tr><tr><td>showActiveTooltip</td><td>是否显示当前页面的导航的tooltip信息，默认是false</td></tr><tr><td>slidesNavigation</td><td>是否显示横向幻灯片的导航，默认为false</td></tr><tr><td>slidesNavPosition</td><td>设置横向幻灯片的位置，top或者bottom，默认bottom</td></tr><tr><td>sectionSelector</td><td>section的选择器，默认是.section</td></tr><tr><td>slideSelector</td><td>slide的选择器，默认是.slide</td></tr></tbody></table><h3 id="常用回调函数"><a href="#常用回调函数" class="headerlink" title="常用回调函数"></a>常用回调函数</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>afterLoad(anchorLink, index)</td><td>滚动到某一个section,当滚动结束后，会触发一次这个回调函数，anchorLink是锚链接的名称，index从1开始计算</td></tr><tr><td>onLeave(index,nextIndex,diretion)</td><td>当我们离开一个section时，会触发这个函数，index是离开的页面的序号，从1开始计算。  nextIndex是滚动到的页面的序号，direction是往上还是往下滚动，值是up或者down.  return false可以取消滚动</td></tr><tr><td>afterResize()</td><td>窗口大小发生改变后会触发的回调函数</td></tr><tr><td>afterSlideLoad(anchor,index,  slideAnchor,slideIndex)</td><td>页面滚动到某一个幻灯片的时候会触发这个回调函数</td></tr><tr><td>afterSlideLeave(anchor,index,slideIndex,  diretion,nextSlideIndex)</td><td>当离开某一个幻灯片的时候会触发一次这个回调函数。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> jquery </category>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件 </tag>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3 基础</title>
      <link href="/2018/html&amp;css/css3/"/>
      <url>/2018/html&amp;css/css3/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><p>如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，<strong>增强</strong> 或 <strong>新增</strong> 了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><ul><li>PC 端浏览器支持程度差，需要添加私有前缀</li><li>移动端支持优于 PC 端</li><li>不断改进中</li><li>应用相对广泛</li></ul><p>关于私有前缀：</p><blockquote><p>在标准还未确定时，部分浏览器已经根据最初草案实现了部分功能，为了与之后确定下来的标准进行兼容，所以每种浏览器使用了自己的私有前缀与标准进行区分，当标准确立后，各大浏览器将逐步支持不带前缀的 css3 新属性</p><p>目前已有很多私有前缀可以不写了，但为了兼容老版本的浏览器，可以仍沿用私有前缀和标准方法，逐渐过渡</p><p>一般来说，CSS3主要是为移动端而生的，因此我们在移动端没必要写太多的前缀，因为移动端的 ios 和 Android 的浏览器都是 webkit 内核</p><p>谷歌、苹果浏览器：<code>-webkit-</code><br>火狐浏览器：<code>-moz-</code><br>IE浏览器：<code>-ms-</code><br>欧朋浏览器：<code>-o-</code></p><p>一般工作中不用去加，会通过打包工具 webpack 自动添加</p></blockquote><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><ul><li>text-shadow: 文字阴影</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：text-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]*</span><br><span class="line">  &lt;shadow&gt; =&gt; &lt;length&gt;&#123;2,3&#125; &amp;&amp; &lt;color&gt;?</span><br><span class="line">text-shadow：水平偏移 垂直偏移 羽化大小 颜色</span><br><span class="line">水平偏移 垂直偏移 可以为负值，羽化大小可选且不可为负</span><br><span class="line">可以设置多组阴影值，用逗号隔开</span><br></pre></td></tr></table></figure><ul><li>box-shadow: 边框阴影</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：box-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]*</span><br><span class="line">  &lt;shadow&gt; =&gt; inset? &amp;&amp; &lt;length&gt;&#123;2,4&#125; &amp;&amp; &lt;color&gt;?</span><br><span class="line"></span><br><span class="line">box-shadow：水平偏移 垂直偏移 羽化大小 阴影外延 颜色</span><br><span class="line">水平偏移、垂直偏移、阴影外延可以为负值，羽化大小、阴影外延可选，羽化大小不允许负值</span><br><span class="line">可以设置多组阴影值，用逗号隔开</span><br><span class="line">inset：设置对象的阴影类型为内阴影。该值为空时，则对象的阴影类型为外阴影</span><br></pre></td></tr></table></figure><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>background-size</p><p>bakground-clip</p><p>background-origin</p><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><blockquote><p>linear-gradient() 指沿着某条直线朝一个方向产生的渐变效果</p><p>渐变实际上相当与一张图片，因为需要加给 background-image 才会生效</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最简单的渐变 颜色至少两个 方向默认从上到下 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定渐变的方向 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 也可以设定渐变的角度 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(45<span class="selector-tag">deg</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定渐变的范围 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span> 20%, <span class="selector-tag">green</span> 80%)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每一个区间表示渐变颜色的范围 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span> 20%, <span class="selector-tag">green</span> 20%)</span><br></pre></td></tr></table></figure><h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><blockquote><p>radial-gradient 指从一个中心点开始沿着四周产生渐变效果</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最简单的渐变 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定圆的半径和圆心 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(200<span class="selector-tag">px</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定椭圆 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(200<span class="selector-tag">px</span> 80<span class="selector-tag">px</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定范围 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(200<span class="selector-tag">px</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>, <span class="selector-tag">green</span> 50%, <span class="selector-tag">red</span> 50%);</span><br></pre></td></tr></table></figure><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><blockquote><p>CSS3 中可以通过 box-sizing 来指定盒模型，即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变</p></blockquote><p>可以分成两种情况：</p><ul><li>box-sizing: border-box 计算方式为 content = width – border - padding</li><li>box-sizing: content-box 计算方式为 content = width</li></ul><h2 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc() 函数"></a>calc() 函数</h2><p>用于动态计算长度值</p><ul><li>注意：运算符前后都需要保留一个空格，例如：<code>width: calc(100% - 10px)</code></li><li>任何长度值都可以使用 calc() 函数进行计算</li><li>calc() 函数支持 <code>+</code> 、<code>-</code>、 <code>*</code> 、<code>/</code> 运算</li><li>calc() 函数使用标准的数学运算优先级规则</li></ul><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><ul><li>过渡的属性</li></ul><p>如果两个状态发生改变，没有过渡，效果是瞬间变化的，如果加上了过渡，那么这个过程就会有动画的效果，整个状态变化的过程是由浏览器来完成的，我们只需要关注开始状态与结束状态即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* transition-property：设置过渡属性 默认值为 all 表示全部*/</span></span><br><span class="line"><span class="comment">/* 多个用逗号分隔 */</span></span><br><span class="line"><span class="selector-tag">transition-property</span>: <span class="selector-tag">all</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-duration:设置过渡时间 */</span></span><br><span class="line"><span class="selector-tag">transition-duration</span>: 1<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-delay：设置过渡延时 */</span></span><br><span class="line"><span class="selector-tag">transition-delay</span>: 2<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-timing-function:设置过渡的速度 */</span></span><br><span class="line"><span class="comment">/* linear(匀速)，ease(平滑)，ease-in，ease-out，ease-in-out， steps(10)(分步动画) */</span></span><br><span class="line"><span class="selector-tag">transition-timing-function</span>: <span class="selector-tag">linear</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>过渡必须要有两个状态的变化</li><li>过渡除了可以加到初始的状态，可以加到 hover 状态，但效果不一样，如果加到 hover 状态，回来就没有过渡了</li></ol></blockquote><ul><li>属性合写</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 属性 时间 延时 速度 */</span></span><br><span class="line"><span class="comment">/* 多个过渡用逗号隔开 */</span></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">width</span> 1<span class="selector-tag">s</span> 3<span class="selector-tag">s</span> <span class="selector-tag">linear</span>, <span class="selector-tag">border-radius</span> 3<span class="selector-tag">s</span>;</span><br></pre></td></tr></table></figure><h2 id="2D-转换"><a href="#2D-转换" class="headerlink" title="2D 转换"></a>2D 转换</h2><blockquote><p>transform: 转换，是 CSS3 最具颠覆性的几个特性之一，既可以用于 2D 转换，也可以用于 3D 转换</p><p>transform: 2D 转换，元素在平面上实现移动、旋转、缩放、斜切等操作</p></blockquote><h3 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale 缩放"></a>scale 缩放</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleX</span>(0<span class="selector-class">.5</span>); <span class="comment">/* 让宽度变化 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleY</span>(0<span class="selector-class">.5</span>); <span class="comment">/* 让高度变化，注意不能写多个transform，不然会覆盖 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>); <span class="comment">/* 让宽度和高度同时变化 */</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>scale 接收的值是倍数，因此没有单位</p></li><li><p>scale 是一个值时，宽度高度会等比例同事缩放</p></li><li><p>scale 缩放时内部内容也会缩放</p></li><li><blockquote><p>可以通过 transition-origin 设定缩放原点 （可以是数值或方位词top、left…)</p></blockquote></li></ul><h3 id="translate-平移"><a href="#translate-平移" class="headerlink" title="translate 平移"></a>translate 平移</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(100<span class="selector-tag">px</span>, 100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(50%, 50%);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>translate 的值可以是 px，也可以是百分比，如果是百分比，那么参照的是<strong>自身的宽高</strong></li><li>translate 移动的元素并不会影响其他盒子，类似于相对定位</li></ul><h3 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(360<span class="selector-tag">deg</span>); <span class="comment">/* 旋转360度 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-360deg</span>); <span class="comment">/* 逆时针旋转360度 */</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>单位是 deg，角度，不是 px</li><li>正值顺时针转，负值逆时针转</li><li>可以通过 transition-origin 设定旋转原点</li></ul><blockquote><p>rotate 旋转会让坐标轴也跟着旋转</p></blockquote><h3 id="skew-斜切-变形"><a href="#skew-斜切-变形" class="headerlink" title="skew 斜切(变形)"></a>skew 斜切(变形)</h3><p>skew 在实际开发中，是用的最少的一个属性。一般来说，x 和 y 只会倾斜其中的一个</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在水平方向倾斜30deg */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewX</span>(30<span class="selector-tag">deg</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在垂直方向倾斜30deg */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewY</span>(30<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure><p>【案例：扫光效果.html】</p><h3 id="transform-origin-转换原点"><a href="#transform-origin-转换原点" class="headerlink" title="transform-origin 转换原点"></a>transform-origin 转换原点</h3><blockquote><p>通过 transform-origin 可以设置转换的中心原点</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform-origin</span>: <span class="selector-tag">center</span> <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">transform-origin</span>: 40<span class="selector-tag">px</span> 40<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><h3 id="转换合写问题"><a href="#转换合写问题" class="headerlink" title="转换合写问题"></a>转换合写问题</h3><blockquote><p>transform 属性只能写一个，如果写了多个会覆盖，属性的值可以写多个， 用空格隔开即可</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(800<span class="selector-tag">px</span>) <span class="selector-tag">scale</span>(1<span class="selector-class">.5</span>) <span class="selector-tag">rotate</span>(360<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure><ul><li>transform 属性可以连写，但是顺序对效果影响的，因为它会在第一个效果的基础上执行第二个效果，然后执行第三个效果（通常会把 rotate 放后面）</li><li>如果对 transform 进行过度效果的时候，初始状态和结束状态要一一对应</li></ul><p>【案例：盾牌打散与合并效果.html】</p><h2 id="3D-转换"><a href="#3D-转换" class="headerlink" title="3D 转换"></a>3D 转换</h2><p>思考：2D与3D的区别？</p><h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><blockquote><p>用 X、Y、Z 分别表示空间的3个维度，三条轴互相垂直。<strong>注意+Y是向下的</strong></p></blockquote><p><img src="zbz.png" alt="img"></p><h3 id="perspective-透视"><a href="#perspective-透视" class="headerlink" title="perspective 透视"></a>perspective 透视</h3><blockquote><p>电脑显示屏是一个 2D 的平面，因为我们看不出来旋转的方向，通过 perspective 属性，可以定义 3D 元素距视图的距离，单位是 px。</p><p>说白了，设置了perspective属性后，就有了进大远小的效果了，在视觉上，让我们能看出来 3d 的效果。</p><p>注意：当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">perspective</span>：500<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>对于我们眼睛来说，离我们越近的房子，我们会感觉到这个房子越大，离我们越远的房子，就会感觉越小，其实房子的大小都是一样的，只是在视觉上的一种不同。</p><p><img src="per3.png" alt="img"></p><h3 id="rotate-旋转-1"><a href="#rotate-旋转-1" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素在平面2D中旋转，相当于沿着Z轴旋转 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateX</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素沿着X轴转45度 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateY</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素沿着Y轴转45度 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateZ</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素沿着Z轴转45度 */</span></span><br></pre></td></tr></table></figure><p>【3D旋转.html】</p><h3 id="translate-平移-1"><a href="#translate-平移-1" class="headerlink" title="translate 平移"></a>translate 平移</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 沿着X轴的正方向移动45px */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(45<span class="selector-tag">px</span>);</span><br><span class="line"><span class="comment">/* 沿着Y轴的正方向移动45px */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(45<span class="selector-tag">px</span>);</span><br><span class="line"><span class="comment">/* 沿着Z轴的正方向移动45px */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateZ</span>(45<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure><p>【3D平移.html】</p><p>【立方体.html】</p><h3 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h3><p>transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注意这个属性只能给父元素添加</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flat</span>: 默认值，2<span class="selector-tag">d</span>显示</span><br><span class="line"><span class="selector-tag">preserve-3d</span>: 3<span class="selector-tag">d</span>显示</span><br></pre></td></tr></table></figure><p>transform-style 与 perspective 区别</p><ul><li>透视：透视只是相当于设置了一个距离，辅助我们查看 3D 效果的工具</li><li>preserve-3d：给父盒子添加，让子元素保留 3D 的位置，说白了，只有设置了 preserve-3d，这个元素才能被称之为 3d 元素</li><li>一个 3d 元素可以没有perspective，但是不能没有 transform-style</li></ul><p>【3D导航案例.html】</p><p>【切割轮播图案例】</p><p>【3D相册案例】</p><h3 id="过渡结束事件"><a href="#过渡结束事件" class="headerlink" title="过渡结束事件"></a>过渡结束事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给最后一个ul添加过渡结束事件（节流阀）</span></span><br><span class="line">uls[uls.length - <span class="number">1</span>].addEventListener(<span class="string">'transitionend'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">isCanAnimate = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><blockquote><p>动画可以通过设置多个节点来精确控制一个或者一组动画，常用来实现复杂的动画效果</p></blockquote><p>动画与过渡的区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过渡必须触发，需要两个状态的改变。</span><br><span class="line">动画可以一直运行下去，不需要触发。实现效果与过渡差不多</span><br></pre></td></tr></table></figure><p>使用一个动画的基本步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.通过 @keyframes 指定动画序列</span><br><span class="line">2.通过百分比或者 from/to 将动画分割成多个节点</span><br><span class="line">3.在各个节点中分别定义样式</span><br><span class="line">4.通过 animation 将动画应用于相应的元素</span><br></pre></td></tr></table></figure><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>animation 是一个复合属性，一共有8个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">animation-name: 动画名称，由@keyframes定义的</span><br><span class="line">animation-duration: 动画的持续时间 默认0s</span><br><span class="line">animation-timing-function: 动画的过渡类型 ease(默认) linear steps</span><br><span class="line">animation-delay: 动画的延迟时间 默认0s</span><br><span class="line">animation-iteration-count: 动画的循环次数 默认1次  infinite：无限循环</span><br><span class="line">animation-direction: 设置动画在循环中的方向 normal：正向(默认) reverse(反向) alternate(往复循环)</span><br><span class="line">animation-fill-mode: 设置动画结束时的状态 none：默认 backwards：动画结束时停留在开始状态 forwards: 动画结束时停留在结束的状态</span><br><span class="line">animation-play-state: 设置动画的状态。running：运动(默认) paused：暂停</span><br></pre></td></tr></table></figure><h3 id="动画库的使用"><a href="#动画库的使用" class="headerlink" title="动画库的使用"></a>动画库的使用</h3><p><a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener">https://daneden.github.io/animate.css/</a></p><h2 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h2><p>我们经常把网页常用的一些小的图标，做成精灵图，然后通过 background-position 去调整位置，但是这个需要引入图片，并且图片大小改变之后会失真。在CSS3中可以使用字体图片，即使用图标跟使用文字一样</p><p>优点：</p><p>1、将所有图标打包成字体库，减少请求</p><p>2、具有矢量性，可保证清晰度，可以修改文字的颜色或者样式</p><p>3、使用灵活，便于维护</p><p>阿里巴巴矢量图标：<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a></p><p>Font Awesome 使用 <a href="http://fontawesome.dashgame.com/" target="_blank" rel="noopener">http://fontawesome.dashgame.com/</a></p><h2 id="弹性布局-伸缩布局"><a href="#弹性布局-伸缩布局" class="headerlink" title="弹性布局(伸缩布局)"></a>弹性布局(伸缩布局)</h2><blockquote><p>布局：其实就是调整元素在水平和垂直方向上的布局方式</p></blockquote><p>CSS3 在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。</p><p>当给一个盒子设置了 display：flex 之后，这个盒子就有了 <strong>主轴</strong> 和 <strong>侧轴</strong>  的概念<br>主轴：默认是水平方向向右，子元素在主轴上排列<br>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向向下</p><p><img src="flex.png" alt></p><h3 id="给容器设置的样式"><a href="#给容器设置的样式" class="headerlink" title="给容器设置的样式"></a>给容器设置的样式</h3><ul><li>flex-direction</li></ul><p>用来调整主轴的方向，默认是水平方向，可选值有：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">row</span>：主轴方向为水平向右（默认）</span><br><span class="line"><span class="selector-tag">column</span>：主轴方向为竖直向下</span><br><span class="line"><span class="selector-tag">row-reverse</span>: 主轴方向为水平向左</span><br><span class="line"><span class="selector-tag">column-reverse</span>: 主轴方向是竖直向上</span><br></pre></td></tr></table></figure><ul><li>justify-content</li></ul><p>用来设置子元素在 <strong>主轴方向的对齐方式</strong> ，可选的值有：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-start</span>: 弹性盒子元素将向起始位置对齐</span><br><span class="line"><span class="selector-tag">flex-end</span>: 弹性盒子元素将向结束位置对齐</span><br><span class="line"><span class="selector-tag">center</span>: 弹性盒子元素将向行中间位置对齐</span><br><span class="line"><span class="selector-tag">space-between</span>: 第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的</span><br><span class="line"><span class="selector-tag">space-around</span>: 弹性盒子元素会平均地分布在行里（不会贴边）</span><br></pre></td></tr></table></figure><ul><li>align-items</li></ul><p>用于调整 <strong>侧轴的对其方式</strong> ，可选的值有：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-start</span>：元素在侧轴的起始位置对其</span><br><span class="line"><span class="selector-tag">flex-end</span>：元素在侧轴的结束位置对其</span><br><span class="line"><span class="selector-tag">center</span>：元素在侧轴上居中对其</span><br><span class="line"><span class="selector-tag">stretch</span>：元素的高度会被拉伸到最大（不能给死高度）</span><br></pre></td></tr></table></figure><ul><li>flex-wrap</li></ul><p>控制 flex 容器是单行或者多行，默认不换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nowrap</span>：不换行（默认），会压缩子盒子的宽度</span><br><span class="line"><span class="selector-tag">wrap</span>：当宽度不够的时候，会换行</span><br></pre></td></tr></table></figure><ul><li>align-content</li></ul><p>用来设置多行时侧轴的排列方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-start</span>：各行向侧轴的起始位置堆叠</span><br><span class="line"><span class="selector-tag">flex-end</span>：各行向弹性盒容器的结束位置堆叠</span><br><span class="line"><span class="selector-tag">center</span>：各行向弹性盒容器的中间位置堆叠</span><br><span class="line"><span class="selector-tag">space-between</span>：第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布</span><br><span class="line"><span class="selector-tag">space-around</span>：各行在侧轴中平均分布</span><br><span class="line"><span class="selector-tag">stretch</span>：拉伸，不设置高度的情况下</span><br></pre></td></tr></table></figure><p>align-items 与 align-content 的区别</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">align-items</span> 调整的是侧轴的对其方式，不换行一般用 <span class="selector-tag">align-items</span></span><br><span class="line"><span class="selector-tag">align-content</span>: 必须是多行才生效，如果单行，没有效果。换行了就用 <span class="selector-tag">align-content</span></span><br></pre></td></tr></table></figure><p>!&gt; 上述属性都是给父盒子设置的，这些样式影响的是所有的子元素，接下来的几个属性是给子盒子设置的，用来单独设置子元素的样式</p><h3 id="给子元素设置的样式"><a href="#给子元素设置的样式" class="headerlink" title="给子元素设置的样式"></a>给子元素设置的样式</h3><ul><li>flex</li></ul><p>用来设置子盒子如何分配主轴剩余空间</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: 1;</span><br></pre></td></tr></table></figure><ul><li>order</li></ul><p>定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">order</span>: 1;</span><br></pre></td></tr></table></figure><ul><li>align-self</li></ul><p>align-self 用于设置当前元素在侧轴的位置，是给子元素设置，优先级比 align-items 的优先级高</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取值与 <span class="selector-tag">align-items</span> 的取值一样</span><br></pre></td></tr></table></figure><p>阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p>【案例：6面神骰】</p><p>【案例：携程网】</p><p>【案例：360浏览器】</p><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><p>微调元素</p><ul><li>margin-top: - ;</li><li>transform：translateY();</li><li>position: relative; top: - ;</li></ul>]]></content>
      
      
      <categories>
          
          <category> html&amp;css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html&amp;css </tag>
            
            <tag> css3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 基本概念</title>
      <link href="/2018/html&amp;css/html5/"/>
      <url>/2018/html&amp;css/html5/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5-基本概念"><a href="#HTML5-基本概念" class="headerlink" title="HTML5 基本概念"></a>HTML5 基本概念</h1><h2 id="什么是HTML5？"><a href="#什么是HTML5？" class="headerlink" title="什么是HTML5？"></a>什么是HTML5？</h2><blockquote><p>HTML5并不仅仅是作为 <strong>HTML 标记语言的一个最新版本</strong>， 更重要的是它<strong>制定了 web 应用开发的一系列标准</strong>，成为第一个将 web 作为应用开发平台的 HTML 语言。</p></blockquote><p>HTML5 定义了一系列新元素，如 <strong>新语义标签、多媒体标</strong>  签等，可以帮助开发者开发更加丰富的应用，同时有令人眼花缭乱的 css3，还提供了一些 Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用，制作 webApp，甚至结合 Canvas 我们可开发网页游戏。</p><p>我们日常讨论的 H5 其实指的是一个泛称，它是由<strong>HTML5+CSS3+javascript</strong> 等技术组合而成的一个应用开发平台</p><p><img src="html5.png" alt="html5"></p><h2 id="HTML5-的历史"><a href="#HTML5-的历史" class="headerlink" title="HTML5 的历史"></a>HTML5 的历史</h2><p><img src="history.png" alt="HTML5的历史"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> WHATWG: Web Hypertext Application Technology Working。 WHATWG成立的原因是W3C意图放弃HTML，而力图发展XML技术。</span><br><span class="line"><span class="number">2.</span> HTML5 的第一份正式草案已于<span class="number">2008</span>年<span class="number">1</span>月<span class="number">22</span>日公布。</span><br><span class="line"><span class="number">3.</span> <span class="number">2014</span>年<span class="number">10</span>月<span class="number">29</span>日，万维网联盟宣布，经过接近<span class="number">8</span>年的艰苦努力，该标准规范终于制定完成。</span><br></pre></td></tr></table></figure><p>思考：问什么HTML5在2008年就发布草案了，到2014年才火起来？</p><p>因为移动端的推动，HTML在老的浏览器上兼容性很严重，并且HTML5很多新特性其实就是为移动端而出现的，可以说<strong>HTML5是为移动端而生的</strong> 。</p><h1 id="HTML5语义化标签"><a href="#HTML5语义化标签" class="headerlink" title="HTML5语义化标签"></a>HTML5语义化标签</h1><h2 id="常用语义化标签"><a href="#常用语义化标签" class="headerlink" title="常用语义化标签"></a>常用语义化标签</h2><blockquote><p>在HTML5之前，我们布局大多使用div，但是div并没有语义化，HTML5推出了一系列的语义化标签，可以用来表示header、footer等。</p></blockquote><p>HTML5新的语义化标签</p><p><code>header</code> 头部、<code>nav</code> 导航、<code>footer</code> 底部、<code>aside</code>  侧边栏、<code>article</code> 文章、<code>section</code>  区块、<code>main</code>   主体区域</p><p>本质上新语义标签与<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>没有区别，只是其具有语义性，使用时除了在 HTML 结构上需要注意外，其它和普通标签的使用无任何差别，<code>&lt;nav&gt;</code>完全可以理解成<code>&lt;div class=&quot;nav&quot;&gt;</code>。不要好奇，它只是一个标签！就是增加了语义性，更加利于 SEO 的优化。</p><p>html5 还推出了一些其他的标签：<a href="http://www.w3school.com.cn/tags/index.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/index.asp</a></p><h2 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h2><p>IE678 不识别这个标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">"header"</span>); <span class="comment">// 创建这个标签即可让IE678识别</span></span><br><span class="line"><span class="comment">// 创建的标签默认是行内样式。</span></span><br><span class="line"><span class="comment">// 还需给标签加一个 display:block 的属性。</span></span><br></pre></td></tr></table></figure><p>借助 <code>html5shiv.js</code></p><blockquote><p>我们每次都要去创建标签，并且还需要设置 display：block 属性，非常麻烦，因此我们可以引入一个第三方 js 文件，这个 js 文件的功能就是创建元素和设置 display 属性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- [<span class="keyword">if</span> lte IE <span class="number">8</span>] &gt;  <span class="comment">// lte ==&gt; 小于等于</span></span><br><span class="line">    &lt;script src=<span class="string">"js/html5shiv.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;! [endif] --&gt;</span><br><span class="line"><span class="comment">// 当 ie 浏览器的版本小于等于8的时候，才会引入 html5shiv.js</span></span><br><span class="line"><span class="comment">// css hack</span></span><br><span class="line"><span class="comment">// 条件注释 IE独有的注释</span></span><br></pre></td></tr></table></figure><h1 id="类名操作-重点"><a href="#类名操作-重点" class="headerlink" title="类名操作(重点)"></a>类名操作(重点)</h1><blockquote><p>js在H5中给所有的DOM对象新增了一个属性 classList</p><p>classList 是一个集合，会存储某个元素上所有的类名，使用classList来替代className操作class类</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加类</span></span><br><span class="line">div.classList.add(<span class="string">"classname"</span>)</span><br><span class="line"><span class="comment">// 移除类</span></span><br><span class="line">div.classList.remove(<span class="string">"classname"</span>)</span><br><span class="line"><span class="comment">// 切换类</span></span><br><span class="line">div.classList.toggle(<span class="string">"classname"</span>)</span><br><span class="line"><span class="comment">// 判断类</span></span><br><span class="line">div.classList.contains(<span class="string">"classname"</span>)</span><br></pre></td></tr></table></figure><p>【tab栏案例】</p><h1 id="自定义属性操作（重点）"><a href="#自定义属性操作（重点）" class="headerlink" title="自定义属性操作（重点）"></a>自定义属性操作（重点）</h1><blockquote><p>H5规定，以后但凡给标签增加自定义属性，都应该用 <code>data-</code> 开头 (规范)</p><p>H5给所有的DOM对象增加了一个 <code>dataset</code> 的属性，这个属性中会包含所有 data- 开头的属性</p></blockquote><ul><li>html 5 中操作自定义属性 <code>dataset</code> 属性</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">data-name</span>=<span class="string">"zs"</span> <span class="attr">data-age</span>=<span class="string">"10"</span> <span class="attr">data-user-name</span>=<span class="string">"ls"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">'#box'</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(box.dataset) <span class="comment">// DOMStringMap &#123;name: 'zs', age: '10', userName: 'ls'&#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(box.dataset.name) <span class="comment">// zs</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(box.dataset[<span class="string">'age'</span>]) <span class="comment">// 10</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(box.dataset.userName) <span class="comment">// ls</span></span></span><br><span class="line"><span class="javascript">    box.dataset.aaBb = <span class="string">'cc'</span> <span class="comment">// 在html结构中或添加 data-aa-bb="cc" 的自定义属性</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>html中属性是忽略大小写的，相当于是小写字母，如果需要大写，应使用中划线 <code>-</code> 进行分隔，在js中会转换成驼峰的形式，如<code>data-user-name ==&gt; userName</code></p><ul><li>jquery 中操作自定义属性</li></ul><p>jquery并没有把 <code>data-</code> 当成自定义属性来用，jq中封装了 <code>data()</code> 方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-id</span>=<span class="string">"1"</span> <span class="attr">data-name</span>=<span class="string">"zs"</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">data-a</span>=<span class="string">'&#123;"b":"c"&#125;'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($(<span class="string">'#box'</span>).data()) <span class="comment">// &#123;id: 1, name: "zs"&#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// console.log($('#box').attr()) // error</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(box.dataset) <span class="comment">// DOMStringMap&#123;id: "1", name: "zs"&#125;</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($(<span class="string">'#box'</span>).data(<span class="string">'id'</span>)) <span class="comment">// 1 =&gt; 获取到自定义属性</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#box'</span>).data(<span class="string">'id'</span>, <span class="number">2</span>) <span class="comment">// 并不会修改原标签中的自定义属性</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($(<span class="string">'#box'</span>).data(<span class="string">'id'</span>)) <span class="comment">// 2 =&gt; html中data-id依然是1</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($(<span class="string">'#box'</span>).attr(<span class="string">'data-id'</span>)) <span class="comment">// 1</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(box.dataset[<span class="string">'id'</span>]) <span class="comment">// 1 =&gt; 获取到的还是原来的 data-id</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#box'</span>).attr(<span class="string">'data-id'</span>, <span class="number">3</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($(<span class="string">'#box'</span>).data(<span class="string">'id'</span>)) <span class="comment">// 3</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(box.dataset[<span class="string">'id'</span>]) <span class="comment">// 3</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 属性里使用json语法，但通过data()设置的不能解析成对象</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#box'</span>).data(<span class="string">'d'</span>, <span class="string">'&#123;"e":"f"&#125;'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($(<span class="string">'#box'</span>).data(<span class="string">'a'</span>)) <span class="comment">// &#123;b: "c"&#125; =&gt; 对象</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($(<span class="string">'#box'</span>).data(<span class="string">'d'</span>)) <span class="comment">// '&#123;"e":"f"&#125;'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#box'</span>).removeData() <span class="comment">// 删除之前通过 data() 方法设置的数据</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>!&gt; jq 的 data() 方法内部使用了缓存来实现，该方法设置的属性只能通过该方法获取，在html页面中看不到属性值，通过原生 dataset 属性也获取不到值</p><h1 id="网络状态"><a href="#网络状态" class="headerlink" title="网络状态"></a>网络状态</h1><blockquote><p>在移动端，我们经常需要检测设置是在线还是离线，HTML5为此定义了一个 navigator.onLine 属性，这个属性用于检测设备是否联网。<strong>navigator.onLine</strong> 在不同浏览器中有细微的差别。</p></blockquote><h2 id="网络状态-1"><a href="#网络状态-1" class="headerlink" title="网络状态"></a>网络状态</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.onLine 返回用户当前的网络状况，是一个布尔值</span><br><span class="line"><span class="number">1.</span> 如果浏览器连不上网(包括局域网)，就是离线状态，也就是脱机状态，会返回 <span class="literal">false</span></span><br><span class="line"><span class="number">2.</span> 否则就是在线状态，返回 <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>注意：返回true不一定就是说一定能访问互联网，因为有可能连接的是局域网。但是返回false则表示一定连不上网。</strong></p><h2 id="监听网络变化"><a href="#监听网络变化" class="headerlink" title="监听网络变化"></a>监听网络变化</h2><blockquote><p>为了更好的确定网络是否连接，HTML5还定义了两个事件，用于监听网络状态的变化。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络连接时会被调用</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"online"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"online"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 当网络断开时会被调用</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"offline"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"offline"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h1><blockquote><p>在HTML规范中，增加了获取用户地理信息的API，这样使得我们可以基于用户位置开发互联网应用，即基于位置服务LBS(Location Base Service)</p></blockquote><h2 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h2><p>HTML5规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。<strong>在获取地理位置之前，会询问用户，只有在获得许可之后，才能获取到用户的位置信息。</strong></p><p>H5提供的获取地理位置信息并不是特别的精确，会一定的误差，如果需要非常精确的定位，还是需要使用安卓或者ios，访问基于操作系统的方法。 （小程序）</p><h2 id="相关的方法"><a href="#相关的方法" class="headerlink" title="相关的方法"></a>相关的方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// successCallback:获取成功后会调用,并返回一个position对象，里面包含了地理位置信息</span></span><br><span class="line"><span class="comment">// 获取失败了会调用，并返回error对象，里面包含了错误信息。</span></span><br><span class="line"><span class="comment">// 获取当前的地理位置信息</span></span><br><span class="line">navigator.geolocation.getCurrentPosition(successCallback, errorCallback)</span><br><span class="line"><span class="comment">// 重复的获取当前的地理位置信息</span></span><br><span class="line">navigator.geolocation.watchPosition(successCallback, errorCallback)</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(<span class="function"><span class="keyword">function</span>(<span class="params">position</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定位成功会调用该方</span></span><br><span class="line">    <span class="comment">// 法谷歌浏览器进行了限制，看不到，可以再IE浏览器下查看</span></span><br><span class="line">    <span class="comment">// position.coords.latitude 纬度</span></span><br><span class="line">    <span class="comment">// position.coords.longitude 经度</span></span><br><span class="line">    <span class="comment">// position.coords.accuracy 精度</span></span><br><span class="line">    <span class="comment">// position.coords.altitude 海拔高度</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定位失败会调用该方法</span></span><br><span class="line">    <span class="comment">// error 是错误信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>苹果浏览器对webkit定位权限进行了修改，所有定位请求的页面必须是https协议的。</strong></p><h2 id="百度地图、高德地图、腾讯地图"><a href="#百度地图、高德地图、腾讯地图" class="headerlink" title="百度地图、高德地图、腾讯地图"></a>百度地图、高德地图、腾讯地图</h2><blockquote><p>仅仅获取到经纬度对于用户来说意义并不大，因为用户也不知道经度和纬度表示的是地球上的哪一个地方，因为我们可以结合百度地图，准确的将用户的位置显示出来。</p></blockquote><p>百度地图官网：<a href="http://lbsyun.baidu.com/" target="_blank" rel="noopener">http://lbsyun.baidu.com/</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在开发中，找到javascript API</span><br><span class="line"><span class="number">2.</span> 直接查看示例demo</span><br><span class="line"><span class="number">3.</span> 复制相应的代码，替换掉秘钥就行，秘钥只需创建一个新的应用就可以了。</span><br></pre></td></tr></table></figure><h1 id="web-存储"><a href="#web-存储" class="headerlink" title="web 存储"></a>web 存储</h1><blockquote><p>在代码执行的时候，数据都是存储在内存中的，当页面关闭或者浏览器关闭的时候，内存就被释放掉了。数据只有存储在硬盘上，才不会被释放。</p></blockquote><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>特点：</p><ul><li>在浏览器端的存储数据的容器</li><li>大小 4k</li><li>生命周期，默认会话级别，但是可以设置过期时间</li><li>cookie 中的数据可以在同一个网站的页面共享</li><li>cookie 中的数据，在请求时会进行自动携带</li><li>不同浏览器的 cookie 不能共享</li><li>cookie 是以字符串形式存在的，这个字符串有固定的格式：key=value;key1=value1；在获取cookie内容时，一般需要通过正则或者字符串的方法进行处理，转换成对象，最终得到数据</li><li>一般用于存储 sessionId，可以实现登录状态保持 (会话保持)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=zhangsan'</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'age=18'</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'sex=23'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置过期时间</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'sex=12;max-age=3600'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取cookie</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">document</span>.cookie</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure><h2 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h2><blockquote><p>HTML5 规范提出使用 sessionStorage 和 localStorage 存储数据。设置、读取、删除操作很方便</p></blockquote><ul><li>sessionStorage 和 localStorage 特点<ul><li>都保存在客户端</li><li>大小为 5M 左右</li><li>使用方法相同</li><li>以键值对的方式，存储字符串格式的数据</li></ul></li></ul><ul><li>sessionStorage 和 localStorage 区别<ul><li>sessionStorage 生命周期默认为一个会话周期，且不能设置周期，一旦关闭浏览器，就销毁了，不能在多个窗口下共享数据</li><li>localStorage 永久生效，除非手动删除，可以多个窗口共享</li></ul></li></ul><ul><li>使用方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setItem(key, value) <span class="comment">// 设置存储内容</span></span><br><span class="line">getItem(key) <span class="comment">// 读取存储内容</span></span><br><span class="line">removeItem(key) <span class="comment">// 删除键值为key的存储内容</span></span><br><span class="line">clear() <span class="comment">// 清空所有存储内容（谨慎使用）</span></span><br></pre></td></tr></table></figure><p>存取复杂数据类型：先将复杂数据转换成 JSON 字符串 <code>JSON.stringify(obj/arr)</code> 在进行存储；使用时将 JSON  字符串转换成复杂数据类型 <code>JSON.parse( jsonStr )</code></p><p>【案例-换肤效果】</p><h2 id="Cookie-和-WebStorage-比较"><a href="#Cookie-和-WebStorage-比较" class="headerlink" title="Cookie 和 WebStorage 比较"></a>Cookie 和 WebStorage 比较</h2><p><strong>cookie</strong></p><ul><li>大小受限</li><li>用户可以操作（禁用）cookie，使功能受限</li><li>安全性较低</li><li>有些状态不可能保存在客户端。</li><li>每次访问都要传送 cookie 给服务器，浪费带宽</li></ul><p><strong>WebStorage</strong></p><ul><li>存储空间更大：cookie 为4KB，而 WebStorage 是 5MB</li><li>WebStorage 不会传送到服务器，存储在本地的数据可以直接获取，速度更快，并且减少了客户端和服务器端的交互，节省了网络流量</li><li>对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage 会非常方便</li><li>安全性：WebStorage  不会随着 HTTP header 发送到服务器端，所以安全性相对于 cookie 来说比较高一些，不会担心截获，但是仍然存在伪造问题</li><li>WebStorage 提供了一些方法，数据操作比 cookie 方便</li></ul><h1 id="自定义播放器"><a href="#自定义播放器" class="headerlink" title="自定义播放器"></a>自定义播放器</h1><p>全屏切换API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requestFullScreen 这个方法还没有标准化，需要添加私有前缀</span></span><br><span class="line">video.requestFullScreen()</span><br><span class="line">video.webkitRequestFullScreen()</span><br><span class="line">video.mozRequestFullScreen()</span><br></pre></td></tr></table></figure><p>video/audio 属性：</p><ul><li>currentTime: 设置或返回音频/视频中的当前播放位置（以秒计）</li><li>duration: 返回当前音频/视频的长度（以秒计）</li><li>autoplay: 默认 false 设置或返回是否在加载完成后随即播放音频/视频</li><li>volume: 设置或返回音频/视频的音量</li><li>paused: 设置或返回音频/视频是否暂停， true 指示音频/视频已暂停</li></ul><p>方法：</p><ul><li><p>load()： 重新加载音频/视频元素</p></li><li><p>play()： 开始播放音频/视频</p></li><li><p>pause()： 暂停当前播放的音频/视频</p></li></ul><p>事件：</p><ul><li>timeupdate:  播放进度更改时触发</li></ul><p>参考文档<br><a href="http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp</a></p><p>推荐：<a href="https://www.awesomes.cn/repo/videojs/video-js" target="_blank" rel="noopener">https://www.awesomes.cn/repo/videojs/video-js</a></p><h1 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h1><blockquote><p>通过 FileReader 对象我们可以读取本地存储的文件（用户通过input:file上传的文件），可以使用 File 对象来指定所要读取的文件或数据。其中File对象可以是来自用户在一个<code>&lt;input&gt;</code>元素上选择文件后返回的FileList 对象，也可以来自由拖放操作生成的  DataTransfer</p></blockquote><h2 id="files"><a href="#files" class="headerlink" title="files"></a>files</h2><p>对于file类型的input框，在这个DOM对象中，存在一个 files 属性，这个属性是 FileList 对象，是一个伪数组，里面存储着上传的所有文件，当 input 框指定了 multiple 属性之后，就可以上传多个文件了。</p><p>也就是说，通过files这个属性，我们就可以获取到所有上传的文件。</p><h2 id="file-对象"><a href="#file-对象" class="headerlink" title="file 对象"></a>file 对象</h2><p>File对象中包含了文件的最后修改时间、文件名、文件类型等信息。</p><h2 id="FileReader对象"><a href="#FileReader对象" class="headerlink" title="FileReader对象"></a>FileReader对象</h2><p>FileReader是一个HTML5新增的对象，用于读取文件（必须通过input:file上传）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = input.files[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 创建一个fileReader对象</span></span><br><span class="line"><span class="keyword">var</span> fr = <span class="keyword">new</span> FileReader</span><br><span class="line"><span class="comment">// 读取文件的两个方法</span></span><br><span class="line">fr.readAsText(file) 以文本的方式读取文件 ,文本文件</span><br><span class="line">fr.readAsDataURL(file) 以DataURL形式读取文件，图片，视频</span><br><span class="line"><span class="comment">// 文件读取完成事件：</span></span><br><span class="line">fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当文件读取完成，可以通过result属性获取结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(fr.result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例：图片预览</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. FileReader 是异步的</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>)</span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>)</span><br><span class="line">file.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(<span class="keyword">this</span>) <span class="comment">// file 中files 属性里面存储了所有上传的文件</span></span><br><span class="line">  <span class="comment">// 这个data就是我们上传的那个文件</span></span><br><span class="line">  <span class="keyword">var</span> data = file.files[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">// 1. 创建一个文件读取器</span></span><br><span class="line">  <span class="keyword">var</span> fr = <span class="keyword">new</span> FileReader()</span><br><span class="line">  <span class="comment">// 2. 让文件读取器读取整个文件</span></span><br><span class="line">  fr.readAsDataURL(data)</span><br><span class="line">  <span class="comment">// 3. 等待文件读取完</span></span><br><span class="line">  <span class="comment">// onload：文件读取完成后，就会触发</span></span><br><span class="line">  fr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 fr.result 就可以获取到最终的结果</span></span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">    img.src = fr.result</span><br><span class="line">    box.innerHTML = <span class="string">''</span></span><br><span class="line">    box.appendChild(img)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. URL.createObjectURL(file)  缺点： 1. 试验中  2. 同步（阻塞）</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">"file"</span>)</span><br><span class="line">file.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">this</span>.files[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> result = URL.createObjectURL(data)</span><br><span class="line">    img.src = result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> html&amp;css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html&amp;css </tag>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码规范及配置ESLint</title>
      <link href="/2018/tool/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%8F%8A%E9%85%8D%E7%BD%AEESLint/"/>
      <url>/2018/tool/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%8F%8A%E9%85%8D%E7%BD%AEESLint/</url>
      
        <content type="html"><![CDATA[<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><blockquote><p><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">Airbnb JavaScript Style Guide</a></p><p><a href="https://google.github.io/styleguide/jsguide" target="_blank" rel="noopener">Google JavaScript Style Guide</a></p><p><a href="https://github.com/standard/standard" target="_blank" rel="noopener">JavaScript Standard Style Guide</a></p></blockquote><h2 id="Vue-ESLint-Prettier"><a href="#Vue-ESLint-Prettier" class="headerlink" title="Vue + ESLint + Prettier"></a><code>Vue + ESLint + Prettier</code></h2><h3 id="安装-node"><a href="#安装-node" class="headerlink" title="安装 node"></a>安装 <code>node</code></h3><p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></p><h3 id="配置-ESlint"><a href="#配置-ESlint" class="headerlink" title="配置 ESlint"></a>配置 <code>ESlint</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ npm install eslint -g</span><br><span class="line">$ npm install eslint-plugin-html -g</span><br><span class="line"></span><br><span class="line">$ eslint -v</span><br><span class="line">$ eslint --init</span><br><span class="line"></span><br><span class="line"><span class="comment"># google 标准</span></span><br><span class="line"><span class="comment"># $ npm install eslint-config-google -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># airbnb 标准</span></span><br><span class="line"><span class="comment"># $ npm install eslint-config-airbnb eslint-plugin-jsx-a11y eslint-plugin-import eslint-plugin-react -g</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># standard 标准</span></span><br><span class="line">$ npm install eslint-plugin-standard eslint-config-standard eslint-plugin-node eslint-plugin-promise -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># vue</span></span><br><span class="line">$ npm install eslint-plugin-vue -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># es6 语法支持</span></span><br><span class="line">$ npm install babel-eslint vue-eslint-parser -g</span><br></pre></td></tr></table></figure><p><code>.eslintrc.json</code> 文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // plugin与extend的区别：extend提供的是eslint现有规则的一系列预设</span><br><span class="line">  // 而plugin则提供了除预设之外的自定义规则，当你在eslint的规则里找不到合适的的时候</span><br><span class="line">  "extends": ["google", "plugin: vue/essential"],</span><br><span class="line">  "plugins": ["html"],</span><br><span class="line">  "parserOptions": &#123;</span><br><span class="line">    "sourceType": "module"</span><br><span class="line">  &#125;,</span><br><span class="line">  "rules": &#123;</span><br><span class="line">    "valid-jsdoc": 2,</span><br><span class="line">    "require-jsdoc": 0,</span><br><span class="line">    "no-var": 0,</span><br><span class="line">    "vars-on-top": 0,</span><br><span class="line">    "eqeqeq": 2,</span><br><span class="line">    "space-before-function-paren": [2, "always"],</span><br><span class="line">    "semi": [2, "never"],</span><br><span class="line">    "comma-dangle": [2, "never"],</span><br><span class="line">    "linebreak-style": [2, "unix"],</span><br><span class="line">    "no-invalid-this": 0,</span><br><span class="line">    "max-len": 0,</span><br><span class="line">    "prefer-const": 0,</span><br><span class="line">    "arrow-parens": 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: [<span class="string">"standard"</span>, <span class="string">"plugin:vue/essential"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"html"</span>],</span><br><span class="line">  <span class="attr">"parser"</span>: <span class="string">"vue-eslint-parser"</span>,</span><br><span class="line">  <span class="attr">"parserOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">    <span class="attr">"ecmaVersion"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"node"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"rules"</span>: &#123;</span><br><span class="line">    <span class="attr">"no-new"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"no-undef"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"no-unused-vars"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"space-before-function-paren"</span>: [<span class="number">2</span>, <span class="string">"always"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vscode 插件安装 <code>ESLint</code></p><p>vscode配置 <code>User Settings</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"javascript.validate.enable"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"typescript.validate.enable"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"eslint.nodePath"</span>: <span class="string">"C:\\Program Files\\nodejs\\node.exe"</span>,</span><br><span class="line">  <span class="attr">"eslint.options"</span>: &#123;</span><br><span class="line">    <span class="attr">"configFile"</span>: <span class="string">"C:/Users/C/.vscode/.eslintrc.json"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"eslint.alwaysShowStatus"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"eslint.autoFixOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"eslint.validate"</span>: [</span><br><span class="line">    <span class="string">"javascript"</span>, <span class="string">"javascriptreact"</span>,</span><br><span class="line">    &#123;<span class="attr">"language"</span>: <span class="string">"html"</span>, <span class="attr">"autoFix"</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">"language"</span>: <span class="string">"vue"</span>, <span class="attr">"autoFix"</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-prettier"><a href="#配置-prettier" class="headerlink" title="配置 prettier"></a>配置 prettier</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install prettier -g</span><br><span class="line">$ npm install eslint-plugin-prettier -g</span><br></pre></td></tr></table></figure><p>vscode 插件安装 <code>prettier</code></p><p>vscode配置 <code>User Settings</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 禁用默认html格式化</span><br><span class="line">  "html.format.enable": false,</span><br><span class="line"></span><br><span class="line">  "prettier.semi": false,</span><br><span class="line">  "prettier.singleQuote": true,</span><br><span class="line">  "prettier.jsxSingleQuote": true,</span><br><span class="line">  "prettier.eslintIntegration": true,</span><br><span class="line">  "prettier.htmlWhitespaceSensitivity": "ignore",</span><br><span class="line">  // 标签换行长度</span><br><span class="line">  "prettier.printWidth": 800,</span><br><span class="line">  "prettier.bracketSpacing": true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vuter</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.js"</span>: <span class="string">"none"</span>,</span><br><span class="line">  // HTML Default Formatter</span><br><span class="line">  "vetur.format.defaultFormatter.html": "prettyhtml"</span><br><span class="line">  "vetur.format.defaultFormatterOptions": &#123;</span><br><span class="line">    "prettyhtml": &#123;</span><br><span class="line">      "printWidth": 1000,</span><br><span class="line">      "singleQuote": false,</span><br><span class="line">      "wrapAttributes": false,</span><br><span class="line">      "sortAttributes": false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ESLint-规则列表"><a href="#ESLint-规则列表" class="headerlink" title="ESLint 规则列表"></a>ESLint 规则列表</h2><p><code>.eslintrc.json</code> 规则值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;off&quot;或者0    // 关闭规则关闭</span><br><span class="line">&quot;warn&quot;或者1   // 在打开的规则作为警告（不影响退出代码）</span><br><span class="line">&quot;error&quot;或者2  // 把规则作为一个错误（退出代码触发时为1</span><br></pre></td></tr></table></figure><p>忽略检测警告</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略检测下一行</span></span><br><span class="line"><span class="comment">/* eslint-disable-next-line */</span></span><br><span class="line"><span class="comment">// 忽略当前整个文件</span></span><br><span class="line"><span class="comment">/* eslint-disable */</span></span><br><span class="line"><span class="comment">// 忽略 no-new 规则</span></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br></pre></td></tr></table></figure><p><a href="https://eslint.org/docs/rules/" target="_blank" rel="noopener">规则列表 https://eslint.org/docs/rules/</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">"rules": &#123;</span><br><span class="line">  "no-alert": 0,//禁止使用alert confirm prompt</span><br><span class="line">  "no-array-constructor": 2,//禁止使用数组构造器</span><br><span class="line">  "no-bitwise": 0,//禁止使用按位运算符</span><br><span class="line">  "no-caller": 1,//禁止使用arguments.caller或arguments.callee</span><br><span class="line">  "no-catch-shadow": 2,//禁止catch子句参数与外部作用域变量同名</span><br><span class="line">  "no-class-assign": 2,//禁止给类赋值</span><br><span class="line">  "no-cond-assign": 2,//禁止在条件表达式中使用赋值语句</span><br><span class="line">  "no-console": 2,//禁止使用console</span><br><span class="line">  "no-const-assign": 2,//禁止修改const声明的变量</span><br><span class="line">  "no-constant-condition": 2,//禁止在条件中使用常量表达式 if(true) if(1)</span><br><span class="line">  "no-continue": 0,//禁止使用continue</span><br><span class="line">  "no-control-regex": 2,//禁止在正则表达式中使用控制字符</span><br><span class="line">  "no-debugger": 2,//禁止使用debugger</span><br><span class="line">  "no-delete-var": 2,//不能对var声明的变量使用delete操作符</span><br><span class="line">  "no-div-regex": 1,//不能使用看起来像除法的正则表达式/=foo/</span><br><span class="line">  "no-dupe-keys": 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;</span><br><span class="line">  "no-dupe-args": 2,//函数参数不能重复</span><br><span class="line">  "no-duplicate-case": 2,//switch中的case标签不能重复</span><br><span class="line">  "no-else-return": 2,//如果if语句里面有return,后面不能跟else语句</span><br><span class="line">  "no-empty": 2,//块语句中的内容不能为空</span><br><span class="line">  "no-empty-character-class": 2,//正则表达式中的[]内容不能为空</span><br><span class="line">  "no-empty-label": 2,//禁止使用空label</span><br><span class="line">  "no-eq-null": 2,//禁止对null使用==或!=运算符</span><br><span class="line">  "no-eval": 1,//禁止使用eval</span><br><span class="line">  "no-ex-assign": 2,//禁止给catch语句中的异常参数赋值</span><br><span class="line">  "no-extend-native": 2,//禁止扩展native对象</span><br><span class="line">  "no-extra-bind": 2,//禁止不必要的函数绑定</span><br><span class="line">  "no-extra-boolean-cast": 2,//禁止不必要的bool转换</span><br><span class="line">  "no-extra-parens": 2,//禁止非必要的括号</span><br><span class="line">  "no-extra-semi": 2,//禁止多余的冒号</span><br><span class="line">  "no-fallthrough": 1,//禁止switch穿透</span><br><span class="line">  "no-floating-decimal": 2,//禁止省略浮点数中的0 .5 3.</span><br><span class="line">  "no-func-assign": 2,//禁止重复的函数声明</span><br><span class="line">  "no-implicit-coercion": 1,//禁止隐式转换</span><br><span class="line">  "no-implied-eval": 2,//禁止使用隐式eval</span><br><span class="line">  "no-inline-comments": 0,//禁止行内备注</span><br><span class="line">  "no-inner-declarations": [2, "functions"],//禁止在块语句中使用声明（变量或函数）</span><br><span class="line">  "no-invalid-regexp": 2,//禁止无效的正则表达式</span><br><span class="line">  "no-invalid-this": 2,//禁止无效的this，只能用在构造器，类，对象字面量</span><br><span class="line">  "no-irregular-whitespace": 2,//不能有不规则的空格</span><br><span class="line">  "no-iterator": 2,//禁止使用__iterator__ 属性</span><br><span class="line">  "no-label-var": 2,//label名不能与var声明的变量名相同</span><br><span class="line">  "no-labels": 2,//禁止标签声明</span><br><span class="line">  "no-lone-blocks": 2,//禁止不必要的嵌套块</span><br><span class="line">  "no-lonely-if": 2,//禁止else语句内只有if语句</span><br><span class="line">  "no-loop-func": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）</span><br><span class="line">  "no-mixed-requires": [0, false],//声明时不能混用声明类型</span><br><span class="line">  "no-mixed-spaces-and-tabs": [2, false],//禁止混用tab和空格</span><br><span class="line">  "linebreak-style": [0, "windows"],//换行风格</span><br><span class="line">  "no-multi-spaces": 1,//不能用多余的空格</span><br><span class="line">  "no-multi-str": 2,//字符串不能用\换行</span><br><span class="line">  "no-multiple-empty-lines": [1, &#123;"max": 2&#125;],//空行最多不能超过2行</span><br><span class="line">  "no-native-reassign": 2,//不能重写native对象</span><br><span class="line">  "no-negated-in-lhs": 2,//in 操作符的左边不能有!</span><br><span class="line">  "no-nested-ternary": 0,//禁止使用嵌套的三目运算</span><br><span class="line">  "no-new": 1,//禁止在使用new构造一个实例后不赋值</span><br><span class="line">  "no-new-func": 1,//禁止使用new Function</span><br><span class="line">  "no-new-object": 2,//禁止使用new Object()</span><br><span class="line">  "no-new-require": 2,//禁止使用new require</span><br><span class="line">  "no-new-wrappers": 2,//禁止使用new创建包装实例，new String new Boolean new Number</span><br><span class="line">  "no-obj-calls": 2,//不能调用内置的全局对象，比如Math() JSON()</span><br><span class="line">  "no-octal": 2,//禁止使用八进制数字</span><br><span class="line">  "no-octal-escape": 2,//禁止使用八进制转义序列</span><br><span class="line">  "no-param-reassign": 2,//禁止给参数重新赋值</span><br><span class="line">  "no-path-concat": 0,//node中不能使用__dirname或__filename做路径拼接</span><br><span class="line">  "no-plusplus": 0,//禁止使用++，--</span><br><span class="line">  "no-process-env": 0,//禁止使用process.env</span><br><span class="line">  "no-process-exit": 0,//禁止使用process.exit()</span><br><span class="line">  "no-proto": 2,//禁止使用__proto__属性</span><br><span class="line">  "no-redeclare": 2,//禁止重复声明变量</span><br><span class="line">  "no-regex-spaces": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/</span><br><span class="line">  "no-restricted-modules": 0,//如果禁用了指定模块，使用就会报错</span><br><span class="line">  "no-return-assign": 1,//return 语句中不能有赋值表达式</span><br><span class="line">  "no-script-url": 0,//禁止使用javascript:void(0)</span><br><span class="line">  "no-self-compare": 2,//不能比较自身</span><br><span class="line">  "no-sequences": 0,//禁止使用逗号运算符</span><br><span class="line">  "no-shadow": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名</span><br><span class="line">  "no-shadow-restricted-names": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用</span><br><span class="line">  "no-spaced-func": 2,//函数调用时 函数名与()之间不能有空格</span><br><span class="line">  "no-sparse-arrays": 2,//禁止稀疏数组， [1,,2]</span><br><span class="line">  "no-sync": 0,//nodejs 禁止同步方法</span><br><span class="line">  "no-ternary": 0,//禁止使用三目运算符</span><br><span class="line">  "no-trailing-spaces": 1,//一行结束后面不要有空格</span><br><span class="line">  "no-this-before-super": 0,//在调用super()之前不能使用this或super</span><br><span class="line">  "no-throw-literal": 2,//禁止抛出字面量错误 throw "error";</span><br><span class="line">  "no-undef": 1,//不能有未定义的变量</span><br><span class="line">  "no-undef-init": 2,//变量初始化时不能直接给它赋值为undefined</span><br><span class="line">  "no-undefined": 2,//不能使用undefined</span><br><span class="line">  "no-unexpected-multiline": 2,//避免多行表达式</span><br><span class="line">  "no-underscore-dangle": 1,//标识符不能以_开头或结尾</span><br><span class="line">  "no-unneeded-ternary": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;</span><br><span class="line">  "no-unreachable": 2,//不能有无法执行的代码</span><br><span class="line">  "no-unused-expressions": 2,//禁止无用的表达式</span><br><span class="line">  "no-unused-vars": [2, &#123;"vars": "all", "args": "after-used"&#125;],//不能有声明后未被使用的变量或参数</span><br><span class="line">  "no-use-before-define": 2,//未定义前不能使用</span><br><span class="line">  "no-useless-call": 2,//禁止不必要的call和apply</span><br><span class="line">  "no-void": 2,//禁用void操作符</span><br><span class="line">  "no-var": 0,//禁用var，用let和const代替</span><br><span class="line">  "no-warning-comments": [1, &#123; "terms": ["todo", "fixme", "xxx"], "location": "start" &#125;],//不能有警告备注</span><br><span class="line">  "no-with": 2,//禁用with</span><br><span class="line">  "array-bracket-spacing": [2, "never"],//是否允许非空数组里面有多余的空格</span><br><span class="line">  "arrow-parens": 0,//箭头函数用小括号括起来</span><br><span class="line">  "arrow-spacing": 0,//=&gt;的前/后括号</span><br><span class="line">  "accessor-pairs": 0,//在对象中使用getter/setter</span><br><span class="line">  "block-scoped-var": 0,//块语句中使用var</span><br><span class="line">  "brace-style": [1, "1tbs"],//大括号风格</span><br><span class="line">  "callback-return": 1,//避免多次调用回调什么的</span><br><span class="line">  "camelcase": 2,//强制驼峰法命名</span><br><span class="line">  "comma-dangle": [2, "never"],//对象字面量项尾不能有逗号</span><br><span class="line">  "comma-spacing": 0,//逗号前后的空格</span><br><span class="line">  "comma-style": [2, "last"],//逗号风格，换行时在行首还是行尾</span><br><span class="line">  "complexity": [0, 11],//循环复杂度</span><br><span class="line">  "computed-property-spacing": [0, "never"],//是否允许计算后的键名什么的</span><br><span class="line">  "consistent-return": 0,//return 后面是否允许省略</span><br><span class="line">  "consistent-this": [2, "that"],//this别名</span><br><span class="line">  "constructor-super": 0,//非派生类不能调用super，派生类必须调用super</span><br><span class="line">  "curly": [2, "all"],//必须使用 if()&#123;&#125; 中的&#123;&#125;</span><br><span class="line">  "default-case": 2,//switch语句最后必须有default</span><br><span class="line">  "dot-location": 0,//对象访问符的位置，换行的时候在行首还是行尾</span><br><span class="line">  "dot-notation": [0, &#123; "allowKeywords": true &#125;],//避免不必要的方括号</span><br><span class="line">  "eol-last": 0,//文件以单一的换行符结束</span><br><span class="line">  "eqeqeq": 2,//必须使用全等</span><br><span class="line">  "func-names": 0,//函数表达式必须有名字</span><br><span class="line">  "func-style": [0, "declaration"],//函数风格，规定只能使用函数声明/函数表达式</span><br><span class="line">  "generator-star-spacing": 0,//生成器函数*的前后空格</span><br><span class="line">  "guard-for-in": 0,//for in循环要用if语句过滤</span><br><span class="line">  "handle-callback-err": 0,//nodejs 处理错误</span><br><span class="line">  "id-length": 0,//变量名长度</span><br><span class="line">  "indent": [2, 4],//缩进风格</span><br><span class="line">  "init-declarations": 0,//声明时必须赋初值</span><br><span class="line">  "key-spacing": [0, &#123; "beforeColon": false, "afterColon": true &#125;],//对象字面量中冒号的前后空格</span><br><span class="line">  "lines-around-comment": 0,//行前/行后备注</span><br><span class="line">  "max-depth": [0, 4],//嵌套块深度</span><br><span class="line">  "max-len": [0, 80, 4],//字符串最大长度</span><br><span class="line">  "max-nested-callbacks": [0, 2],//回调嵌套深度</span><br><span class="line">  "max-params": [0, 3],//函数最多只能有3个参数</span><br><span class="line">  "max-statements": [0, 10],//函数内最多有几个声明</span><br><span class="line">  "new-cap": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用</span><br><span class="line">  "new-parens": 2,//new时必须加小括号</span><br><span class="line">  "newline-after-var": 2,//变量声明后是否需要空一行</span><br><span class="line">  "object-curly-spacing": [0, "never"],//大括号内是否允许不必要的空格</span><br><span class="line">  "object-shorthand": 0,//强制对象字面量缩写语法</span><br><span class="line">  "one-var": 1,//连续声明</span><br><span class="line">  "operator-assignment": [0, "always"],//赋值运算符 += -=什么的</span><br><span class="line">  "operator-linebreak": [2, "after"],//换行时运算符在行尾还是行首</span><br><span class="line">  "padded-blocks": 0,//块语句内行首行尾是否要空行</span><br><span class="line">  "prefer-const": 0,//首选const</span><br><span class="line">  "prefer-spread": 0,//首选展开运算</span><br><span class="line">  "prefer-reflect": 0,//首选Reflect的方法</span><br><span class="line">  "quotes": [1, "single"],//引号类型 `` "" ''</span><br><span class="line">  "quote-props":[2, "always"],//对象字面量中的属性名是否强制双引号</span><br><span class="line">  "radix": 2,//parseInt必须指定第二个参数</span><br><span class="line">  "id-match": 0,//命名检测</span><br><span class="line">  "require-yield": 0,//生成器函数必须有yield</span><br><span class="line">  "semi": [2, "always"],//语句强制分号结尾</span><br><span class="line">  "semi-spacing": [0, &#123;"before": false, "after": true&#125;],//分号前后空格</span><br><span class="line">  "sort-vars": 0,//变量声明时排序</span><br><span class="line">  "space-after-keywords": [0, "always"],//关键字后面是否要空一格</span><br><span class="line">  "space-before-blocks": [0, "always"],//不以新行开始的块&#123;前面要不要有空格</span><br><span class="line">  "space-before-function-paren": [0, "always"],//函数定义时括号前面要不要有空格</span><br><span class="line">  "space-in-parens": [0, "never"],//小括号里面要不要有空格</span><br><span class="line">  "space-infix-ops": 0,//中缀操作符周围要不要有空格</span><br><span class="line">  "space-return-throw-case": 2,//return throw case后面要不要加空格</span><br><span class="line">  "space-unary-ops": [0, &#123; "words": true, "nonwords": false &#125;],//一元运算符的前/后要不要加空格</span><br><span class="line">  "spaced-comment": 0,//注释风格要不要有空格什么的</span><br><span class="line">  "strict": 2,//使用严格模式</span><br><span class="line">  "use-isnan": 2,//禁止比较时使用NaN，只能用isNaN()</span><br><span class="line">  "valid-jsdoc": 0,//jsdoc规则</span><br><span class="line">  "valid-typeof": 2,//必须使用合法的typeof的值</span><br><span class="line">  "vars-on-top": 2,//var必须放在作用域顶部</span><br><span class="line">  "wrap-iife": [2, "inside"],//立即执行函数表达式的小括号风格</span><br><span class="line">  "wrap-regex": 0,//正则表达式字面量用小括号包起来</span><br><span class="line">  "yoda": [2, "never"]//禁止尤达条件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> esLint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遍历总结</title>
      <link href="/2018/other/%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93/"/>
      <url>/2018/other/%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="原生-js-中-for-语句"><a href="#原生-js-中-for-语句" class="headerlink" title="原生 js 中 for 语句"></a>原生 js 中 for 语句</h1><blockquote><p>循环  、遍历数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="comment">// 1. for循环使用分号分隔</span></span><br><span class="line"><span class="comment">// 2. for循环有2个分号，两个分号不能少</span></span><br><span class="line"><span class="keyword">for</span> (初始化语句; 判断语句; 自增语句) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历函数的参数(arguments)</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="原生-js-中数组的-forEach-方法"><a href="#原生-js-中数组的-forEach-方法" class="headerlink" title="原生 js 中数组的 forEach 方法"></a>原生 js 中数组的 forEach 方法</h1><blockquote><p>遍历数组</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">array.forEach (<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>), <span class="title">thisArg</span>)</span></span><br><span class="line"><span class="function">// <span class="title">item</span> 必需。数组中正在处理的当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span> 可选。数组中正在处理的当前元素的索引</span></span><br><span class="line"><span class="function">// <span class="title">arr</span> 可选。<span class="title">forEach</span>(<span class="params"></span>)方法正在操作的数组，就是当前数组</span></span><br><span class="line"><span class="function">// <span class="title">thisArg</span> 可选。当执行回调函数时用作<span class="title">this</span>的值</span></span><br><span class="line">var arr = ["zs", "ls", "ww"];</span><br><span class="line">arr.forEach (<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 返回值: undefined</span></span><br><span class="line"><span class="comment">// 不支持 return 操作输出，return 只用于控制循环是否跳出当前循环</span></span><br></pre></td></tr></table></figure><h1 id="原生-js-中-for…in-语句"><a href="#原生-js-中-for…in-语句" class="headerlink" title="原生 js 中 for…in 语句"></a>原生 js 中 for…in 语句</h1><blockquote><p>遍历对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 键</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[key]); <span class="comment">// 值</span></span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">"=="</span> + obj[key]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in 操作符：判断对象能否访问到该属性（不管这个属性是自己提供的，还是从原型上继承来的），如果可以访问到， 都会返回 true</span></span><br><span class="line"><span class="comment">// console.log("name" in obj) 返回布尔值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"name"</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'是'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="jquery-中的-each-方法"><a href="#jquery-中的-each-方法" class="headerlink" title="jquery 中的 each 方法"></a>jquery 中的 each 方法</h1><blockquote><p>遍历 jQuery 对象集合，为每个匹配的元素执行一个函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：</span></span><br><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// index 表示当前元素在所有匹配元素中的索引号</span></span><br><span class="line">    <span class="comment">// element 表示当前元素 dom对象</span></span><br><span class="line">    <span class="comment">// this 在函数内部，this指向了element</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">"li"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index, ele</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// $(ele).css("backgroundColor", arr[index]);</span></span><br><span class="line">    $(<span class="keyword">this</span>).css(<span class="string">"backgroundColor"</span>, arr[index]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="php-中-foreach-语句"><a href="#php-中-foreach-语句" class="headerlink" title="php 中 foreach 语句"></a>php 中 foreach 语句</h1><blockquote><p>用来遍历数组(关联数组和索引数组均可)。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $key =&gt; $value)&#123;</span><br><span class="line">    <span class="comment">// $arr: 要遍历的数组</span></span><br><span class="line">    <span class="comment">// $key: 键，可以是任意变量名</span></span><br><span class="line"><span class="comment">// $value: 值，可以是任意变量名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $value)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历关联数组</span></span><br><span class="line">$arr = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">"name"</span>=&gt;<span class="string">"zs"</span>,</span><br><span class="line">  <span class="string">"age"</span>=&gt;<span class="number">18</span>,</span><br><span class="line">  <span class="string">"sex"</span>=&gt;<span class="number">20</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">  <span class="keyword">echo</span> $k . <span class="string">"="</span> . $v . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ajax 笔记</title>
      <link href="/2018/javascript/ajax/"/>
      <url>/2018/javascript/ajax/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们使用 php 动态渲染页面时，有很多比较麻烦的地方。</p><ul><li>在前端写好页面以后，需要后台进行修改，意味这后端程序员也需要懂前端的知识，其实渲染的工作应该交给前端来做。</li><li>前端没有写好页面的话，后端无法开始工作，需要等待前端的页面完成之后才能开始工作，拖延项目的进度。</li><li>这种渲染，属于同步渲染，先获取数据, 如果数据获取的慢了, 会严重影响整个页面渲染速度, 且数据更新需要页面刷新</li></ul><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><blockquote><p>即 Asynchronous [e’sɪŋkrənəs] Javascript And XML， AJAX 不是一门新的语言，而是对现有技术的综合利用。 本质是在HTTP协议的基础上以异步的方式与服务器进行通信</p></blockquote><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p><strong>同步和异步概念：</strong></p><p>同步：指的就是事情要一件一件做。等做完前一件才能做后一件任务</p><p>异步：不受当前任务的影响，两件事情同时进行，做一件事情时，不影响另一件事情的进行</p><p>编程中：异步程序代码执行时不会阻塞其它程序代码执行，从而提升整体执行效率</p><p><strong>网页异步应用：</strong></p><ol><li>验证你的用户名是否已经存在（一边输入，一边获取你的信息，和后台比对）。</li><li>百度搜索提示，及相关内容展示（一边输入，一边找出了你可能要的内容）。</li><li>新浪微博评论（异步加载）。</li></ol><p>XMLHttpRequest 可以以异步方式的请求数据处理程序,  可实现对网页的部分更新， 而不是刷新整个页面</p><h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><blockquote><p>浏览器内建对象，用于与服务器通信(交换数据) ， 由此我们便可实现对网页的部分更新，而不是刷新整个页面。这个请求是异步的，即在往服务器发送请求时，并不会阻碍程序的运行，浏览器会继续渲染后续的结构。</p></blockquote><h3 id="发送-get-请求"><a href="#发送-get-请求" class="headerlink" title="发送 get 请求"></a>发送 get 请求</h3><p>XMLHttpRequest 以异步的方式发送 HTTP 请求，因此在发送请求时，一样需要遵循 HTTP 协议。</p><p><strong>使用 XMLHttpRequest 发送 get 请求的步骤</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 XMLHttpRequest 对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置请求行</span></span><br><span class="line"><span class="comment">// 第一个参数:请求方式  get/post</span></span><br><span class="line"><span class="comment">// 第二个参数:请求的地址 需要在url后面拼上参数列表</span></span><br><span class="line"><span class="comment">// 第三个参数：true 为异步，false为同步，默认为true，设为false没有意义</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"01.php?name=zs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置请求头(get不用设置)</span></span><br><span class="line"><span class="comment">// 请求头中可以设置 Content-Type,用以说明请求主体的内容是如何编码</span></span><br><span class="line"><span class="comment">// get 请求时没有请求体,无需设置请求头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 设置请求体</span></span><br><span class="line"><span class="comment">// get 请求的请求体为空,因为参数列表拼接到 url 后面了</span></span><br><span class="line">xhr.send(<span class="literal">null</span>); <span class="comment">// 参数为 null 或什么都不写</span></span><br></pre></td></tr></table></figure><p>注意点 :</p><ul><li>get 请求，设置请求行时，需要把参数列表拼接到 url 后面</li><li>get 请求不用设置请求头，不用说明请求主体的编码方式</li><li>get 请求的请求体为 null</li></ul><h3 id="发送-post-请求"><a href="#发送-post-请求" class="headerlink" title="发送 post 请求"></a>发送 post 请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 XMLHttpRequest 对象</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置请求行 post请求的参数列表在请求体</span></span><br><span class="line">xhr.open(<span class="string">"post"</span>, <span class="string">"02.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置请求头, post 请求必须要设置 content-type, 标记请求体内容的解析方式</span></span><br><span class="line"><span class="comment">// 如果不设置请求头,请求能够发送出去，但是后端无法解析获取数据</span></span><br><span class="line">xhr.setRequestHeader( <span class="string">"content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 设置请求体</span></span><br><span class="line">xhr.send( <span class="string">"name=Jepson&amp;age=18"</span> );</span><br></pre></td></tr></table></figure><p>注意点 :</p><ul><li>post 请求，设置请求行时，不拼接参数列表</li><li>post 必须设置请求头中的 content-type 为 <code>application/x-www-form-urlencoded</code>，  标记请求体解析方式</li><li>post 请求需要将参数列表设置到请求体中</li></ul><h3 id="获取响应-readyState"><a href="#获取响应-readyState" class="headerlink" title="获取响应 readyState"></a>获取响应 readyState</h3><p><code>readyState</code>：记录了 XMLHttpRequest 对象的当前状态</p><p>readyState 有五种可能的值：</p><ul><li>xhr.readyState = 0时，UNSENT open尚未调用</li><li>xhr.readyState = 1时，OPENED open已调用</li><li>xhr.readyState = 2时，HEADERS_RECEIVED 接收到头信息</li><li>xhr.readyState = 3时，LOADING 接收到响应主体</li><li><code>xhr.readyState = 4</code> 时，DONE 响应完成</li></ul><p>HTTP 响应分为 3 个部分，状态行、响应头、响应体。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给xhr注册一个 onreadystatechange 事件，当 xhr 的状态发生状态发生改变时，会触发这个事件。</span></span><br><span class="line"><span class="comment">// onreadystatechange 只会监听 2， 3， 4 的状态变化</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(xhr.readyState);</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="comment">//1. 获取状态行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"状态行:"</span>+xhr.status); <span class="comment">// 成功返回 200</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">//2. 获取响应头</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"所有的响应头:"</span>+xhr.getAllResponseHeaders());</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"指定响应头:"</span>+xhr.getResponseHeader(<span class="string">"content-type"</span>));</span><br><span class="line">            <span class="comment">//3. 获取响应体</span></span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>【判断用户名是否存在】</p><p>【用户登录案例】</p><p>【聊天机器人案例】</p><h2 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h2><blockquote><p>浏览器端只是负责用户的交互和数据的收集以及展示，真正的数据都是存储在服务器端的。</p><p>我们现在通过 ajax 的确可以返回一些简单的数据（一个字符串），但是在实际开发过程中，肯定会会设计到大量的复杂类型的数据传输，比如数组、对象等，但是每个编程语言的语法都不一样。</p><p>因此我们会采用通过的数据交换格式（ <code>XML</code> 、<code>JSON</code> ）来进行数据的交互。</p></blockquote><h3 id="XML-了解即可"><a href="#XML-了解即可" class="headerlink" title="XML(了解即可)"></a>XML(了解即可)</h3><p><strong>什么是XML</strong></p><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）</li><li>XML 是一种标记语言，很类似 HTML</li><li>XML 的设计宗旨是传输数据，而非显示数据</li><li>XML 标签没有被预定义。您需要自行定义标签。</li></ul><p><strong>语法规范</strong></p><ul><li>第一行必须是版本信息</li><li>必须有一个根元素（有且仅有一个）</li><li>标签不可有空格、不可以数字或 . 开头、大小写敏感</li><li>不可交叉嵌套，都是双标签，如果是单标签，必须闭合</li><li>属性双引号（浏览器自动修正成双引号了）</li><li>特殊符号要使用实体</li><li>注释和HTML一样</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">desc</span>&gt;</span>路人甲<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">desc</span>&gt;</span>路人乙<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>php 获取 xml 文件的内容</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意: 如果需要返回 xml 数据, 需要将 content-type 改成 text/xml, 不然浏览器以 text/html 解析</span></span><br><span class="line">header( <span class="string">'content-type:text/xml;charset=utf-8'</span> );</span><br><span class="line"><span class="comment">// file_get_content 用于获取文件的内容</span></span><br><span class="line"><span class="comment">// 参数: 文件的路径</span></span><br><span class="line">$result = file_get_content( <span class="string">"data.xml"</span> );</span><br><span class="line"><span class="keyword">echo</span> $result;</span><br></pre></td></tr></table></figure><p><strong>js 解析 xml</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取服务端返回的 xml 数据，需要使用 xhr.responseXML，这是一个 document 对象，可以使用 DOM 中的方法查找元素。</span></span><br><span class="line"><span class="keyword">var</span> data = xhr.responseXML;</span><br><span class="line"><span class="comment">// 获取所有的学生</span></span><br><span class="line"><span class="keyword">var</span> students = data.querySelectorAll(<span class="string">"student"</span>);</span><br></pre></td></tr></table></figure><p>缺点：虽然可以描述和传输复杂数据，但是其解析过于复杂,  并且体积较大，所以实现开发已经很少使用了。</p><h3 id="JSON-数据"><a href="#JSON-数据" class="headerlink" title="JSON 数据"></a>JSON 数据</h3><p><code>JSON</code> (JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript 规范，采用独立于编程语言的文本格式来存储和表示数据。</p><ul><li>数据在键值对中</li><li>数据由逗号分隔(最后一个 键值对不能带逗号)</li><li>花括号保存对象，方括号保存数组</li><li>键和值使用双引号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">'Hello'</span>, <span class="attr">b</span>: <span class="string">'World'</span>&#125;; <span class="comment">// 这是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个 JSON 字符串，本质是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="string">'&#123;"a": "Hello", "b": "World"&#125;'</span>;</span><br></pre></td></tr></table></figure><p><strong>JSON 数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，解析完成后就能很方便的使用了</strong></p><h4 id="php-处理-json"><a href="#php-处理-json" class="headerlink" title="php 处理 json"></a>php 处理 json</h4><ul><li>php关联数组 ==&gt;  json   ( json_encode )</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// php的关联数组</span></span><br><span class="line">$obj = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">"a"</span> =&gt; <span class="string">"hello"</span>,</span><br><span class="line">  <span class="string">"b"</span> =&gt; <span class="string">"world"</span>,</span><br><span class="line">  <span class="string">"name"</span> =&gt; <span class="string">"鹏鹏"</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// json字符串</span></span><br><span class="line">$json = json_encode( $obj );</span><br><span class="line"><span class="keyword">echo</span> $json;</span><br></pre></td></tr></table></figure><ul><li>json ==&gt; php对象/关联数组    ( json_decode )</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$json = <span class="string">'&#123;"a": "Hello", "b": "World"&#125;'</span>; <span class="comment">// json字符串</span></span><br><span class="line"><span class="comment">// 第一个参数：json字符串</span></span><br><span class="line"><span class="comment">// 第二个参数：</span></span><br><span class="line"><span class="comment">// false，将json转换成对象(默认)</span></span><br><span class="line"><span class="comment">// true：将json转换成数组(推荐)</span></span><br><span class="line">$obj = json_decode($json,<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">echo</span> $obj[<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过json文件获取到的内容就是一个json字符串。</span></span><br><span class="line">$data = file_get_contents(<span class="string">"data.json"</span>);</span><br><span class="line"><span class="comment">// 将json转换成数组</span></span><br><span class="line">$result = json_decode($data, <span class="keyword">true</span>);</span><br><span class="line">print_r($result);</span><br></pre></td></tr></table></figure><h4 id="JS-处理-json"><a href="#JS-处理-json" class="headerlink" title="JS 处理 json"></a>JS 处理 json</h4><ul><li><code>JSON.stringify(obj)</code> ：JS对象 ==&gt; JSON字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">'Hello'</span>, <span class="attr">b</span>: <span class="string">'World'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">JSON</span>.stringify(obj); <span class="comment">// '&#123;"a": "Hello", "b": "World"&#125;'</span></span><br></pre></td></tr></table></figure><ul><li><code>JSON.parse(obj)</code>  ：JSON字符串 ==&gt; JS对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">'&#123;"a": "Hello", "b": "World"&#125;'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(json); <span class="comment">// &#123;a: 'Hello', b: 'World'&#125;</span></span><br></pre></td></tr></table></figure><p>【案例：获取表格数据.html】</p><h2 id="兼容性处理-了解-不用处理"><a href="#兼容性处理-了解-不用处理" class="headerlink" title="兼容性处理 (了解, 不用处理)"></a>兼容性处理 (了解, 不用处理)</h2><p>现在一般最多兼容到 IE8,  这里以后见到了知道是在处理兼容性就行了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(XMLHttpRequest)&#123;</span><br><span class="line">  <span class="comment">//现代浏览器 IE7+</span></span><br><span class="line">  xhr = <span class="keyword">new</span>  XMLHttpRequest();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：</span></span><br><span class="line">  xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装-ajax-工具函数"><a href="#封装-ajax-工具函数" class="headerlink" title="封装 ajax 工具函数"></a>封装 ajax 工具函数</h2><blockquote><p>每次发送ajax请求，其实步骤都是一样的，重复了大量代码，我们完全可以封装成一个工具函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建xhr对象</span></span><br><span class="line"><span class="comment">//2. 设置请求行</span></span><br><span class="line"><span class="comment">//3. 设置请求头</span></span><br><span class="line"><span class="comment">//3. 设置请求体</span></span><br><span class="line"><span class="comment">//4. 监听响应状态</span></span><br><span class="line"><span class="comment">//5. 获取响应内容</span></span><br></pre></td></tr></table></figure><h3 id="参数提取"><a href="#参数提取" class="headerlink" title="参数提取"></a>参数提取</h3><table><thead><tr><th>参数名</th><th>参数类型</th><th>描述</th><th>传值</th><th>默认值</th></tr></thead><tbody><tr><td>type</td><td>string</td><td>请求方式</td><td>get/post</td><td>只要不传post，就是get</td></tr><tr><td>url</td><td>string</td><td>请求地址</td><td>接口地址</td><td>如果不传地址，不发送请求</td></tr><tr><td>async</td><td>boolean</td><td>是否异步</td><td>true/fase</td><td>只要不传false，那就是true，异步请求</td></tr><tr><td>data</td><td>object</td><td>请求数据</td><td><code>{key:value,key1:value2}</code></td><td>需要把这个对象拼接成参数的格式 uname=hucc&amp;upass=12345</td></tr><tr><td>dataType</td><td>string</td><td>返回的数据类型</td><td>xml/json/text</td><td>text</td></tr><tr><td>success</td><td>function</td><td>响应成功时调用</td><td>-</td><td>-</td></tr><tr><td>error</td><td>function</td><td>响应失败时调用</td><td>-</td><td>-</td></tr></tbody></table><h3 id="参数检测"><a href="#参数检测" class="headerlink" title="参数检测"></a>参数检测</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要求参数obj必须传递，否则直接不发送请求</span></span><br><span class="line"><span class="keyword">if</span>(!obj || <span class="keyword">typeof</span> obj !== <span class="string">"object"</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果type传递的是post，那就发送post请求，否则发送get请求</span></span><br><span class="line"><span class="keyword">var</span> type = obj.type == <span class="string">"post"</span>?<span class="string">"post"</span>:<span class="string">'get'</span>;</span><br><span class="line"><span class="keyword">var</span> url = obj.url;</span><br><span class="line"><span class="keyword">if</span>(!url)&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有当async传递了false，才会发送同步请求，不然只发送异步请求</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = obj.async == <span class="literal">false</span>? <span class="literal">false</span>:<span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="完整版本"><a href="#完整版本" class="headerlink" title="完整版本"></a>完整版本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = &#123;</span><br><span class="line">  ajax: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果options参数没有传递，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (!options || <span class="keyword">typeof</span> options !== <span class="string">"object"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理默认参数</span></span><br><span class="line">    <span class="comment">// 如果参数不是post，那就默认为get</span></span><br><span class="line">    <span class="keyword">var</span> type = options.type === <span class="string">"post"</span> ? <span class="string">"post"</span> : <span class="string">"get"</span>;</span><br><span class="line">    <span class="comment">// 如果没有传url，直接返回</span></span><br><span class="line">    <span class="keyword">var</span> url = option.url;</span><br><span class="line">      <span class="keyword">if</span>(!url) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 如果参数不是false，那就默认是true，发异步请求</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">async</span> = options.async == <span class="literal">false</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 把option.data对象中的数据拼接成键值对的字符串</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">this</span>.getData(options.data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求行</span></span><br><span class="line">    <span class="comment">// 如果是get请求，并且要上传参数，需要把参数拼接到url后面</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">"get"</span>) &#123;</span><br><span class="line">      url += <span class="string">"?"</span> + data;</span><br><span class="line">      data = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.open(type, url, <span class="keyword">async</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">"post"</span>) &#123;</span><br><span class="line">      xhr.setRequestHeader(<span class="string">"content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置请求参数</span></span><br><span class="line">    xhr.send(data);</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">//判断一下,如果dataType的值是json,就转成js对象.如果是xml,就返回dom对象,其他都是普通文本</span></span><br><span class="line">            <span class="keyword">if</span>(options.dateType === <span class="string">"json"</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(option.dataType === <span class="string">"xml"</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> result = xhr.responseXML;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> result = xhr.responseText;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">/*执行成功函数*/</span></span><br><span class="line">          options.success &amp;&amp; options.success(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          options.error &amp;&amp; options.error();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getData: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将obj对象转换成参数</span></span><br><span class="line">    <span class="comment">// 将对象转换成参数列表</span></span><br><span class="line">    <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">"object"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      arr.push(k + <span class="string">"="</span> + obj[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">"&amp;"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【登录案例】</p><h2 id="jQuery-中的-ajax方法"><a href="#jQuery-中的-ajax方法" class="headerlink" title="jQuery 中的 ajax方法"></a>jQuery 中的 ajax方法</h2><blockquote><p>jQuery为我们提供了更强大的Ajax封装</p></blockquote><h3 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax"></a>$.ajax</h3><p>参数列表</p><table><thead><tr><th>参数名称</th><th>描述</th><th>取值</th><th>示例</th></tr></thead><tbody><tr><td>url</td><td>接口地址</td><td></td><td>url:”02.php”</td></tr><tr><td>type</td><td>请求方式</td><td>get/post</td><td>type:”get”</td></tr><tr><td>timeout</td><td>超时时间</td><td>单位毫秒</td><td>timeout:5000</td></tr><tr><td>dataType</td><td>服务器返回的格式</td><td>json/xml/text(默认)</td><td>dataType:”json”</td></tr><tr><td>data</td><td>发送的请求数据</td><td>对象</td><td>data:{name:”zs”, age:18}</td></tr><tr><td>beforeSend</td><td>调用前的回调函数</td><td>function(){}</td><td>beforeSend:function(){ alert(1) }</td></tr><tr><td>success</td><td>成功的回调函数</td><td>function (data) {}</td><td>success:function (data) {}</td></tr><tr><td>error</td><td>失败的回调函数</td><td>function (error) {}</td><td>error:function(data) {}</td></tr><tr><td>complete</td><td>完成后的回调函数</td><td>function () {}</td><td>complete:function () {}</td></tr></tbody></table><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  type:<span class="string">"get"</span>, <span class="comment">// 请求类型</span></span><br><span class="line">  url:<span class="string">"02.php"</span>, <span class="comment">// 请求地址</span></span><br><span class="line">  data:&#123;<span class="attr">name</span>:<span class="string">"zs"</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;, <span class="comment">// 请求数据</span></span><br><span class="line">  dataType:<span class="string">"json"</span>, <span class="comment">// 希望接受的数据类型</span></span><br><span class="line">  timeout:<span class="number">5000</span>, <span class="comment">// 设置超时时间</span></span><br><span class="line">  beforeSend:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// alert("发送前调用");</span></span><br><span class="line">    <span class="comment">// jq的ajax方法中beforeSend函数中如果执行了return false,那么请求就不发送了</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success:<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果有 dataType:"json"，或后台有header(content-type: text/json)，res就是已经转换好的js对象</span></span><br><span class="line">    <span class="comment">// alert("成功时调用");</span></span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  error:<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// alert("失败时调用");</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;,</span><br><span class="line">  complete:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// alert("请求完成时调用"); // 不管成功失败都会执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>【案例：登录案例.html】</p><h2 id="接口化开发"><a href="#接口化开发" class="headerlink" title="接口化开发"></a>接口化开发</h2><p>请求地址即所谓的接口，通常我们所说的接口化开发，其实是指一个接口对应一个功能， 并且严格约束了<strong>请求参数</strong> 和<strong>响应结果</strong> 的格式，这样前后端在开发过程中，可以减少不必要的讨论， 从而并行开发，可以极大的提升开发效率，另外一个好处，当网站进行改版后，服务端接口进行调整时，并不影响到前端的功能。</p><h3 id="获取短信验证码"><a href="#获取短信验证码" class="headerlink" title="获取短信验证码"></a>获取短信验证码</h3><p>【案例：register】</p><p><strong>需求文档(产品)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">总需求：点击获取验证码按钮，向服务端发送请求, 调用服务器端短信接口, 服务器端根据传参, 调用第三方短信接口, 给手机发送验证码</span><br><span class="line"></span><br><span class="line">需求<span class="number">1</span>：格式校验</span><br><span class="line">(<span class="number">1</span>) 手机号码不能为空   如果为空提示<span class="string">"手机号不能为空"</span></span><br><span class="line">(<span class="number">2</span>) 手机号码格式必须正确, 提示<span class="string">"请输入正确的手机号码"</span></span><br><span class="line"></span><br><span class="line">需求<span class="number">2</span>：点击发送时，按钮显示为<span class="string">"发送中"</span>,并且不能重复提交请求</span><br><span class="line"></span><br><span class="line">需求<span class="number">3</span>：根据不同的响应结果，进行响应。</span><br><span class="line">(<span class="number">1</span>)如果接口调用成功</span><br><span class="line">   如果响应代码为<span class="number">100</span>，倒计时</span><br><span class="line">   如果响应代码为<span class="number">101</span>，提示手机号重复</span><br><span class="line">(<span class="number">2</span>)如果接口调用失败，告诉用户<span class="string">"服务器繁忙，请稍候再试"</span></span><br></pre></td></tr></table></figure><p><strong>接口文档</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">接口说明：获取短信验证码</span><br><span class="line">接口地址：getCode.php</span><br><span class="line">请求方式：<span class="keyword">get</span></span><br><span class="line">接口传参：mobile 手机号</span><br><span class="line">返回类型  json</span><br><span class="line">接口返回：&#123;</span><br><span class="line"><span class="string">"code"</span>:<span class="string">"101"</span>,</span><br><span class="line"><span class="string">"msg"</span>:<span class="string">"手机号码存在"</span>,</span><br><span class="line"><span class="string">"mobile"</span>:<span class="string">"18511249258"</span></span><br><span class="line">&#125;</span><br><span class="line">参数说明: code 当前业务逻辑的处理成功失败的标识  <span class="number">100</span>:成功   <span class="number">101</span>:手机号码存在</span><br><span class="line"> msg  当前系统返回给前端提示</span><br><span class="line"> mobile  当前的手机号码</span><br></pre></td></tr></table></figure><h3 id="注册接口"><a href="#注册接口" class="headerlink" title="注册接口"></a>注册接口</h3><p>【案例：register】</p><p><strong>表单序列化</strong> serialize</p><p>jquery提供了一个<code>serialize()</code>方法序列化表单，说白就是将表单中带有name属性的所有参数拼成一个格式为<code>name=value&amp;name1=value1</code>这样的字符串。方便我们获取表单的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serialize 方法将表单参数序列化成一个字符串。必须指定 name 属性</span></span><br><span class="line"><span class="comment">// name=pp&amp;pass=123456&amp;repass=123456&amp;mobile=15751776629&amp;code=1234</span></span><br><span class="line">$(<span class="string">'form'</span>).serialize();</span><br></pre></td></tr></table></figure><p>jquery的ajax方法，data参数能够直接识别表单序列化的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.post(&#123;</span><br><span class="line">  url:<span class="string">"register.php"</span>,</span><br><span class="line">  data:$(<span class="string">'form'</span>).serialize(),</span><br><span class="line">  dataType:<span class="string">'json'</span>,</span><br><span class="line">  success:<span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(info);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>需求文档</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">注册功能</span><br><span class="line">总需求：点击注册按钮，向服务端发送请求</span><br><span class="line"></span><br><span class="line">需求<span class="number">1</span>:表单校验</span><br><span class="line">    <span class="number">1.1</span> 用户名不能为空，否则提示<span class="string">"请输入用户名"</span></span><br><span class="line">    <span class="number">1.2</span> 密码不能为空，否则提示<span class="string">"请输入密码"</span></span><br><span class="line">    <span class="number">1.3</span> 确认密码必须与密码一直，否则提示<span class="string">"确认密码与密码不一致"</span></span><br><span class="line">    <span class="number">1.4</span> 手机号码不能为空，否则提示<span class="string">"请输入手机号码"</span>;</span><br><span class="line">    <span class="number">1.5</span> 手机号码格式必须正确，否则提示<span class="string">"手机号格式错误"</span></span><br><span class="line">    <span class="number">1.6</span> 短信验证码必须是<span class="number">4</span>位的数字，否则提示<span class="string">"验证码格式错误"</span></span><br><span class="line"></span><br><span class="line">需求<span class="number">2</span>：点击注册按钮时，按钮显示为<span class="string">"注册中..."</span>,并且不能重复提交请求</span><br><span class="line"></span><br><span class="line">需求<span class="number">3</span>：根据不同响应结果，处理响应</span><br><span class="line"><span class="number">3.1</span> 接口调用成功</span><br><span class="line">        <span class="number">100</span> 提示用户注册成功，<span class="number">3</span>s后跳转到首页</span><br><span class="line">        <span class="number">101</span> 提示用户<span class="string">"用户名已经存在"</span></span><br><span class="line">        <span class="number">102</span> 提示用户<span class="string">"验证码错误"</span></span><br><span class="line">    <span class="number">3.2</span> 接口调用失败，提示<span class="string">"服务器繁忙，请稍后再试"</span>,恢复按钮的值</span><br></pre></td></tr></table></figure><p><strong>接口文档</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">接口说明：注册</span><br><span class="line">接口地址：register.php</span><br><span class="line">请求方式：post</span><br><span class="line">接口传参：name:用户名 pass:密码 code:验证码  mobile:手机号</span><br><span class="line">返回类型  json</span><br><span class="line">接口返回：&#123;</span><br><span class="line"><span class="string">"code"</span>:<span class="string">"100"</span>,</span><br><span class="line"><span class="string">"msg"</span>:<span class="string">"注册成功"</span>,</span><br><span class="line"><span class="string">"name"</span>:<span class="string">"Jepson"</span></span><br><span class="line">&#125;</span><br><span class="line">参数说明:</span><br><span class="line">      code 当前业务逻辑的处理成功失败的标识  <span class="number">100</span>:成功  <span class="number">101</span>:用户存在 <span class="number">102</span>:验证码错误</span><br><span class="line">      msg  当前系统返回给前端提示</span><br><span class="line">      name: 注册的用户名</span><br></pre></td></tr></table></figure><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><blockquote><p>是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。</p></blockquote><h3 id="为什么要使用模板引擎"><a href="#为什么要使用模板引擎" class="headerlink" title="为什么要使用模板引擎"></a>为什么要使用模板引擎</h3><p>我们通过ajax获取到数据后，需要把数据渲染到页面，在学习模板引擎前，我们的做法是大量的拼接字符串，对于结构简单的页面，这么做还行 ，但是如果页面结构很复杂，使用拼串的话<strong>代码可阅读性非常的差，而且非常容易出错，后期代码维护也是相当的麻烦。</strong></p><p>总结来说拼串渲染两大缺点：</p><ol><li>js中大量充斥着 html 结构拼串代码， 很冗余， 可读性差</li><li>字符串拼接很麻烦， 且维护起来也很麻烦， 容易出错</li></ol><h3 id="常见的模板引擎"><a href="#常见的模板引擎" class="headerlink" title="常见的模板引擎"></a>常见的模板引擎</h3><p>BaiduTemplate：<a href="http://tangram.baidu.com/BaiduTemplate/" target="_blank" rel="noopener">http://tangram.baidu.com/BaiduTemplate/</a><br>velocity.js：<a href="https://github.com/shepherdwind/velocity.js/" target="_blank" rel="noopener">https://github.com/shepherdwind/velocity.js/</a><br>ArtTemplate：<a href="https://github.com/aui/artTemplate" target="_blank" rel="noopener">https://github.com/aui/artTemplate</a></p><p>artTemplate是使用最广泛，效率最高的模板引擎，需要大家掌握。</p><h3 id="artTemplate"><a href="#artTemplate" class="headerlink" title="artTemplate"></a>artTemplate</h3><p><a href="https://github.com/aui/art-template" target="_blank" rel="noopener">github地址</a></p><p><a href="https://aui.github.io/art-template/docs/" target="_blank" rel="noopener">中文api地址</a></p><h4 id="artTemplate-的基本使用"><a href="#artTemplate-的基本使用" class="headerlink" title="artTemplate 的基本使用"></a>artTemplate 的基本使用</h4><p><strong>1. 引入模板引擎的 js文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"template-web.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>2. 准备模板</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  指定了type为text/html后，这一段script标签并不会解析，也不会显示。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/html"</span> <span class="attr">id</span>=<span class="string">"myTmp"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：隔壁老王<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：18<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>技能：查水表<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>描述：年轻力气壮<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3. 准备数据</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 准备数据,数据是后台获取的，可以随时变化</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;</span><br><span class="line">  userName:<span class="string">"隔壁老王"</span>,</span><br><span class="line">  age:<span class="number">18</span>,</span><br><span class="line">  skill:<span class="string">"查水表"</span>,</span><br><span class="line">  desc:<span class="string">"年轻气壮"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 将模板与数据进行绑定</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数：模板的id</span></span><br><span class="line"><span class="comment">//第二个参数：数据</span></span><br><span class="line"><span class="comment">//返回值：根据模板生成的字符串。</span></span><br><span class="line"><span class="keyword">var</span> html = template(<span class="string">"myTmp"</span>, json);</span><br><span class="line"><span class="built_in">console</span>.log(html);</span><br></pre></td></tr></table></figure><p><strong>5. 修改模板</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/html"</span> <span class="attr">id</span>=<span class="string">"myTmp"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：&#123;&#123;userName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>技能：&#123;&#123;skill&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>描述：&#123;&#123;desc&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>6. 将数据显示到页面</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">"div"</span>);</span><br><span class="line">div.innerHTML = html;</span><br></pre></td></tr></table></figure><h4 id="artTemplate-标准语法"><a href="#artTemplate-标准语法" class="headerlink" title="artTemplate 标准语法"></a>artTemplate 标准语法</h4><p><strong>if 语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;if gender='男'&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"man"</span>&gt;</span></span><br><span class="line">&#123;&#123;else&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"woman"</span>&gt;</span></span><br><span class="line">&#123;&#123;/if&#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>each 语法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  1. &#123;&#123;each data&#125;&#125;  可以通过$value 和 $index获取值和下标</span></span><br><span class="line"><span class="comment">  2. &#123;&#123;each data v i&#125;&#125;  自己指定值为v，下标为i</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">&#123;&#123;each data v i&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123;v.url&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;&#123;v.src&#125;&#125;"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;v.content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果返回的数据是个数组，必须使用对象进行包裹，因为在&#123;&#123;&#125;&#125;中只写书写对象的属性。</span></span><br><span class="line"><span class="keyword">var</span> html = template(<span class="string">"navTmp"</span>, &#123;<span class="attr">data</span>:info&#125;);</span><br></pre></td></tr></table></figure><h2 id="瀑布流案例"><a href="#瀑布流案例" class="headerlink" title="瀑布流案例"></a>瀑布流案例</h2><h3 id="封装jQuery瀑布流插件"><a href="#封装jQuery瀑布流插件" class="headerlink" title="封装jQuery瀑布流插件"></a>封装jQuery瀑布流插件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特点分析：</span></span><br><span class="line"><span class="comment">// 1. 跟以前将的瀑布流不一样的是，这次的瀑布流固定版心为1200px</span></span><br><span class="line"><span class="comment">// 2. 瀑布流固定摆放5列，每一列的宽度固定为232px。</span></span><br><span class="line"><span class="comment">// 思路分析：</span></span><br><span class="line"><span class="comment">// 1. 计算每一列之间的缝隙</span></span><br><span class="line"><span class="comment">// 2. 初始化一个数组，用户存储每一列的高度 [0,0,0,0,0]</span></span><br><span class="line"><span class="comment">// 3. 查找数组的最小列，每次都把图片定位到最小列的位置</span></span><br><span class="line"><span class="comment">// 4. 更新数组最小列的高度（加上定位过来的图片的高度）</span></span><br></pre></td></tr></table></figure><p>代码参考：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$.fn.waterfall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $box = $(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">var</span> $item = $box.children();</span><br><span class="line">  <span class="keyword">var</span> boxWidth = $box.width();<span class="comment">//父盒子的宽度</span></span><br><span class="line">  <span class="keyword">var</span> itemWidth = <span class="number">232</span>;<span class="comment">//每个盒子固定宽度为232</span></span><br><span class="line">  <span class="keyword">var</span> columns = <span class="number">5</span>;<span class="comment">//固定摆放5列</span></span><br><span class="line">  <span class="keyword">var</span> gap = (boxWidth - columns * itemWidth) / (columns - <span class="number">1</span>);<span class="comment">//缝隙的宽度 10</span></span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]; <span class="comment">//初始化数组</span></span><br><span class="line">  $item.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//查找最小列</span></span><br><span class="line">    <span class="keyword">var</span> min = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> minIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (min &gt; arr[i]) &#123;</span><br><span class="line">        min = arr[i];</span><br><span class="line">        minIndex = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置位置</span></span><br><span class="line">    $(<span class="keyword">this</span>).css(&#123;</span><br><span class="line">      left: minIndex * (itemWidth + gap),</span><br><span class="line">      top: min</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//更新数组</span></span><br><span class="line">    arr[minIndex] = min + $(<span class="keyword">this</span>).outerHeight() + gap;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="瀑布流完整版"><a href="#瀑布流完整版" class="headerlink" title="瀑布流完整版"></a>瀑布流完整版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求分析：</span></span><br><span class="line"><span class="comment">// 1. 页面刚开始，没有任何一张图片。因此需要从通过ajax获取图片</span></span><br><span class="line"><span class="comment">// 2. 使用模版引擎将获取到的数据渲染到页面</span></span><br><span class="line"><span class="comment">// 3. 因为图片路径是从服务端获取的，加载需要时间，需要等待图片加载完成后才能使用瀑布流进行布局。</span></span><br><span class="line"><span class="comment">// 4. 给window注册scroll事件，当触底时，需要动态的加载图片。</span></span><br><span class="line"><span class="comment">// 5. 加载时，显示加载中的提示信息，并且要求不能重复发送ajax请求</span></span><br><span class="line"><span class="comment">// 6. 当服务端返回图片数量为0时，提示用户没有更多数据。</span></span><br></pre></td></tr></table></figure><h2 id="同源与跨域"><a href="#同源与跨域" class="headerlink" title="同源与跨域"></a>同源与跨域</h2><h3 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h3><h4 id="同源策略的基本概念"><a href="#同源策略的基本概念" class="headerlink" title="同源策略的基本概念"></a>同源策略的基本概念</h4><blockquote><p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。<br>同源策略：最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”：协议相同、域名相同、端口相同</p></blockquote><h4 id="同源策略的目的"><a href="#同源策略的目的" class="headerlink" title="同源策略的目的"></a>同源策略的目的</h4><blockquote><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p></blockquote><h4 id="同源策略的限制范围"><a href="#同源策略的限制范围" class="headerlink" title="同源策略的限制范围"></a>同源策略的限制范围</h4><blockquote><p>随着互联网的发展，“同源策略”越来越严格，目前，如果非同源，以下三种行为都将收到限制。</p></blockquote><ol><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM 无法获得</li><li>AJAX 请求响应被拦截</li></ol><p>虽然这些限制是很有必要的，但是也给我们日常开发带来不好的影响。比如实际开发过程中，往往都会把服务器端架设到一台甚至是一个集群的服务器中，把客户端页面放到另外一个单独的服务器。那么这时候就会出现不同源的情况，如果我们知道两个网站都是安全的话，我们是希望两个不同源的网站之间可以相互请求数据的。这就需要使用到 <strong>跨域</strong> 。</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="jsonp-无兼容性问题"><a href="#jsonp-无兼容性问题" class="headerlink" title="jsonp( 无兼容性问题 )"></a>jsonp( 无兼容性问题 )</h4><blockquote><p><code>JSONP(JSON with Padding)</code> 可用于解决主流浏览器的跨域数据访问的问题。</p><p>原理：服务端返回一个定义好的 js 函数的调用，并且将服务器的数据以该函数参数的形式传递过来，这个方法需要前后端配合</p></blockquote><ul><li><code>script</code> 标签是不受同源策略的限制的，它可以载入任意地方的 JavaScript 文件。类似的还有<code>img</code>和<code>link</code>标签</li></ul><h5 id="jsonp-演化过程1"><a href="#jsonp-演化过程1" class="headerlink" title="jsonp 演化过程1"></a>jsonp 演化过程1</h5><p>php 文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"content-type:text/html;charset=utf-8"</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"alert(1111)"</span>;</span><br></pre></td></tr></table></figure><p>html 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.api.com/testjs.php"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原理：其实src的路径是什么文件不重要，无论引入js文件还是php文件，最后返回给浏览器的都是字符串，因此我们script标签是可以引入一个php文件的。</p><h5 id="jsonp-演化过程2"><a href="#jsonp-演化过程2" class="headerlink" title="jsonp 演化过程2"></a>jsonp 演化过程2</h5><p>php 文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"content-type:text/html;charset=utf-8"</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"var a = 118;"</span>;</span><br></pre></td></tr></table></figure><p>html 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.api.com/testjs.php"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// a打印出来了118</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(a)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>我们现在做到了一件事情，从不同源的php文件中获取到了数据</strong></p><p>缺点：获取数据的 script 标签必须写在使用的 script 标签的前面，必须保证先有数据才能对数据进行渲染。</p><h5 id="jsonp-演化过程3"><a href="#jsonp-演化过程3" class="headerlink" title="jsonp 演化过程3"></a>jsonp 演化过程3</h5><p>php 代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"content-type:text/html;charset=utf-8"</span>);</span><br><span class="line">$arr = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">"name"</span>=&gt;<span class="string">"zs"</span>,</span><br><span class="line">  <span class="string">"age"</span>=&gt;<span class="number">18</span></span><br><span class="line">);</span><br><span class="line">$result = json_encode($arr);</span><br><span class="line"><span class="comment">// 这是一段js函数的调用的代码，$result就是我们想要的数据</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"func($result)"</span>;</span><br></pre></td></tr></table></figure><p>js 代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.api.com/testjs.php"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缺点：后端必须知道前端声明的方法的名字，后端才能调用。</p><h5 id="jsonp-演化过程4"><a href="#jsonp-演化过程4" class="headerlink" title="jsonp 演化过程4"></a>jsonp 演化过程4</h5><p>php代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"content-type:text/html;charset=utf-8"</span>);</span><br><span class="line">$arr = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">"name"</span>=&gt;<span class="string">"zs"</span>,</span><br><span class="line">  <span class="string">"age"</span>=&gt;<span class="number">18</span></span><br><span class="line">);</span><br><span class="line">$result = json_encode($arr);</span><br><span class="line"><span class="comment">// 这是一 段js函数的调用的代码，$result就是我们想要的数据</span></span><br><span class="line"><span class="keyword">echo</span> $_GET[<span class="string">'callback'</span>].<span class="string">"($result)"</span>;</span><br></pre></td></tr></table></figure><p>javascript代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>)</span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.src = <span class="string">'http://www.api.com/testjs.php?callback=fun'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>jsonp 的原理就是 <strong>借助 script 标签 src 请求资源时，不受同源策略的限制</strong></li><li>在服务端返回一个函数的调用，将数据作为当前调用函数的实参</li><li>在浏览器端，声明一个全局函数，通过形参就可以获取到服务端返回的对应的值</li></ol><h4 id="jquery-对于-jsonp-的封装"><a href="#jquery-对于-jsonp-的封装" class="headerlink" title="jquery 对于 jsonp 的封装"></a>jquery 对于 jsonp 的封装</h4><p>!&gt; jsonp 仅支持 get 请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用起来相当的简单，跟普通的get请求没有任何的区别，只需要把 dataType 固定成 jsonp 即可</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  type: <span class="string">'get'</span>,</span><br><span class="line">  url: <span class="string">'http://www.Jepson.com/testjs.php'</span>,</span><br><span class="line">  dataType: <span class="string">'jsonp'</span>,</span><br><span class="line">  data:&#123;</span><br><span class="line">    uname: <span class="string">'zs'</span>,</span><br><span class="line">    upass: <span class="string">'123456'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  success:<span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(info)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="XMLHttpRequest2-0"><a href="#XMLHttpRequest2-0" class="headerlink" title="XMLHttpRequest2.0"></a>XMLHttpRequest2.0</h2><blockquote><p>XMLHttpRequest 是一个 javascript 内置对象，使得 Javascript 可以进行异步的HTTP通信。2008年2月，就提出了XMLHttpRequest Level 2 草案。</p></blockquote><p>老版本的XMLHttpRequest的缺点：</p><ol><li>仅支持传输文本数据，无法传输二进制文件，比如图片视频等。</li><li>传输数据时，没有进度信息，只能提示完成与否。</li><li>受到了”同源策略”的限制</li></ol><p>新版本的功能：</p><ol><li>可以设置 timeout 超时时间</li><li>可以使用 formData 对象管理表单数据</li><li>允许请求不同域名下的数据（跨域）</li><li>支持上传二进制文件</li><li>可以获取数据传输的进度信息</li></ol><p><strong>注意：我们现在使用 new XMLHttpRequest 创建的对象就是2.0对象了，我们之前学的是1.0的语法，现在学习一些2.0的新特性即可。</strong></p><h3 id="timeout-设置超时"><a href="#timeout-设置超时" class="headerlink" title="timeout 设置超时"></a>timeout 设置超时</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.timeout = <span class="number">3000</span>; <span class="comment">// 设置超时时间</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"请求超时"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="formData-管理表单数据"><a href="#formData-管理表单数据" class="headerlink" title="formData 管理表单数据"></a>formData 管理表单数据</h3><p>formData 对象类似于 jquery 的 serialize 方法，序列化表单，实现表单的异步提交</p><p>!&gt;  但 serialize 方法无法实现文件上传</p><p>使用：</p><ol><li>实例化一个 formData 对象， new FormData(form); form 就是表单元素，DOM对象</li><li>formData 对象可以直接作为 xhr.send(formData) 的参数。注意此时数据是以二进制的形式进行传输。</li><li>formData 有一个 append 方法，可以添加参数。formData.append(“id”, “1111”);</li><li>这种方式只能以 <strong>post</strong> 形式传递，不需要设置请求头，浏览器会自动为我们设置一个合适的请求头。</li></ol><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用formData必须发送post请求</span></span><br><span class="line">  xhr.open(<span class="string">"post"</span>, <span class="string">"02-formData.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取表单元素</span></span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.querySelector(<span class="string">"#myForm"</span>);</span><br><span class="line"><span class="comment">// 3. 创建form对象，可以直接作为send的参数。</span></span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData(form);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. formData可以使用append方法添加参数</span></span><br><span class="line">formData.append(<span class="string">"id"</span>, <span class="string">"1111"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 发送，不需要指定请求头，浏览器会自动选择合适的请求头</span></span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure><p>如果要获取 <code>formData</code> 中的数据，可以使用 <code>formData.get(&#39;&#39;)</code> 获取</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>以前，文件上传需要借助表单进行上传，但是表单上传是同步的，也就是说文件上传时，页面需要提交和刷新，用户体验不友好，xhr2.0 中的 formData 对象支持文件的异步上传。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="comment">// 获取上传的文件，传递到后端</span></span><br><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">"file"</span>).files[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.dir(file);</span><br><span class="line">formData.append(<span class="string">"file"</span>, file);</span><br><span class="line">xhr.send(formData);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$(<span class="string">'#upload'</span>).on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// FormData 用于管理表单数据的</span></span><br><span class="line">  <span class="keyword">var</span>  form = <span class="built_in">document</span>.querySelector(<span class="string">"#form1"</span>);</span><br><span class="line">  <span class="keyword">var</span>  formData = <span class="keyword">new</span> FormData(form);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送给服务器</span></span><br><span class="line">  <span class="keyword">var</span>  xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'post'</span>,<span class="string">'upload.php'</span>);</span><br><span class="line">  xhr.send(formData); <span class="comment">// 直接发送 formData</span></span><br><span class="line"></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> r = xhr.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// jquery</span></span><br><span class="line">$(<span class="string">'#upload'</span>).on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 准备要上传的数据</span></span><br><span class="line">  <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">  <span class="comment">// 如果 formData 中有文件对象了，就不需要再添加了</span></span><br><span class="line">  formData.append(<span class="string">'file'</span>, <span class="keyword">this</span>.files[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 发送 AJAX 请求，上传文件</span></span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'upload.php'</span>,</span><br><span class="line">    contentType: <span class="literal">false</span>, <span class="comment">// 设置编码类型</span></span><br><span class="line">    processData: <span class="literal">false</span>, <span class="comment">// 设置传递值方式</span></span><br><span class="line">    data: formData,</span><br><span class="line">    type: <span class="string">'post'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>!&gt; 如果使用 <code>$.ajax</code> 发送 ， 需要添加如下两项参数<br>​    <code>contentType: false,</code>  设置编码类型<br>​    <code>processData: false,</code>  设置传递值方式</p><h3 id="显示文件进度信息"><a href="#显示文件进度信息" class="headerlink" title="显示文件进度信息"></a>显示文件进度信息</h3><p> xhr2.0 还支持获取上传文件的进度信息，因此我们可以根据进度信息可以实时的显示文件的上传进度。</p><ol><li>需要注册 <code>xhr.upload.onprogress = function(e){}</code> 事件，用于监听文件上传的进度。注意：需要在send之前注册。</li><li>上传的进度信息会存储事件对象 e 中</li><li><code>e.loaded</code> 表示已上传的大小；<code>e.total</code> 表示整个文件的大小</li></ol><p>代码参考：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xhr.upload.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  inner.style.width = (e.loaded/e.total*<span class="number">100</span>).toFixed(<span class="number">2</span>)+<span class="string">"%"</span>;</span><br><span class="line">  span.innerHTML = (e.loaded/e.total*<span class="number">100</span>).toFixed(<span class="number">2</span>)+<span class="string">"%"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// toFixed(2) 保留两位小数</span></span><br><span class="line"></span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure><p>默认上传文件限制 8M，需要配置 php.ini，允许 php上传大文件。</p><h3 id="跨域资源共享-CORS"><a href="#跨域资源共享-CORS" class="headerlink" title="跨域资源共享(CORS)"></a>跨域资源共享(CORS)</h3><h4 id="CORS-的使用"><a href="#CORS-的使用" class="headerlink" title="CORS 的使用"></a>CORS 的使用</h4><blockquote><p>新版本的XMLHttpRequest对象，可以向不同域名的服务器发出HTTP请求。这叫做<a href="http://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing" target="_blank" rel="noopener">“跨域资源共享”</a>（Cross-origin resource sharing，简称CORS）。</p></blockquote><p>跨域资源共享（CORS）的前提</p><ul><li>浏览器支持这个功能( 兼容性IE10+ )</li><li>服务器必须允许这种跨域</li></ul><p>服务器允许跨域的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许所有的域名访问这个接口</span></span><br><span class="line">header(<span class="string">"Access-Control-Allow-Origin:*"</span>);</span><br><span class="line"><span class="comment">// 允许 www.abc.com 这个域名访问这个接口</span></span><br><span class="line">header(<span class="string">"Access-Control-Allow-Origin:http://www.abc.com"</span>);</span><br></pre></td></tr></table></figure><h4 id="CORS-的具体流程（了解）"><a href="#CORS-的具体流程（了解）" class="headerlink" title="CORS 的具体流程（了解）"></a>CORS 的具体流程（了解）</h4><ol><li><p>浏览器发送跨域请求</p></li><li><p>服务器端收到一个跨域请求后，在响应头中添加Access-Control-Allow-Origin Header资源权限配置。发送响应</p></li><li><p>浏览器收到响应后，查看是否设置了<code>header(&#39;Access-Control-Allow-Origin:请求源域名或者*&#39;);</code></p><p>如果当前域已经得到授权，则将结果返回给浏览器，否则浏览器忽略此次响应</p></li></ol><p>结论：</p><ol><li><strong>跨域行为是浏览器行为，响应是回来了, 只是浏览器安全机制做了限制,  对于跨域响应内容进行了忽略。</strong></li><li><strong>服务器与服务器之间是不存在跨域问题的</strong></li></ol><h4 id="jsonp-与-cors-的对比"><a href="#jsonp-与-cors-的对比" class="headerlink" title="jsonp 与 cors 的对比"></a>jsonp 与 cors 的对比</h4><ul><li>jsonp 兼容性好，老版本浏览器也支持，但是 jsonp 仅支持 get 请求，发送的数据量有限，使用麻烦</li><li>cors 需要浏览器支持 cors 功能才行。使用简单，<strong>只要服务端设置允许跨域，对于客户端来说，跟普通的get、post请求并没有什么区别</strong></li><li>跨域的安全性问题：<strong>因为跨域是需要服务端配合控制的</strong> ，也就是说不论 jsonp 还是 cors，如果没有服务端的允许，浏览器是没法做到跨域的</li></ul><p>【案例：图灵机器人】</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP</title>
      <link href="/2018/php/php/"/>
      <url>/2018/php/php/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="什么是服务器？"><a href="#什么是服务器？" class="headerlink" title="什么是服务器？"></a>什么是服务器？</h3><blockquote><p>通过安装服务器软件，<strong>提供服务</strong> 的计算机</p></blockquote><p>   服务器可以从硬件、软件(系统软件、应用软件)几个角度描述。</p><p>   按硬件描述： 服务器就是一台超级计算机(配置很高)。<br>   按操作系统划分： 在硬件上安装了什么操作系统，就可以称为该系统的服务器<br>​                       例如:  linux服务器、windows服务器、unix服务器等。<br>   按软件划分： 在操作系统中安装了什么软件，就可以称作该软件的服务器 iis tomcat<br>​                       例如: <strong>web服务器</strong>、数据库服务器、邮件服务器等。</p><h3 id="什么是Web服务器"><a href="#什么是Web服务器" class="headerlink" title="什么是Web服务器"></a>什么是Web服务器</h3><p>Web服务器就是安装了Web服务软件，web服务器的作用是能够提供网站服务的服务器。淘宝、京东、新浪等等</p><p> 常见的Web软件：<br> <strong>Apache</strong>、Nginx、IIS、Tomcat、Node等。<br>Apache服务器、Nginx服务器、IIS服务器、Tomcat服务器、Node服务器</p><p>Apache是世界使用排名第一的Web服务器软件。我们将编写好的html、css、js等文件存入apache，就能够通过网络来访问这些文件了。</p><p>PS: web服务器又叫做http/httpd服务器</p><h2 id="phpStudy-介绍"><a href="#phpStudy-介绍" class="headerlink" title="phpStudy 介绍"></a>phpStudy 介绍</h2><blockquote><p>phpStudy是一个PHP调试环境的程序集成包</p><p>该程序包集成最新的 Apache+PHP+MySQL</p><p>安装phpStudy，一定不能有中文，否则肯定启动不起来</p></blockquote><p>*<em>注意: *</em>将要访问的文件(html,php,img等)，放到安装路径下的 <code>www</code> 目录下，通过浏览器就可以访问到了</p><h3 id="phpStudy的错误解决"><a href="#phpStudy的错误解决" class="headerlink" title="phpStudy的错误解决"></a>phpStudy的错误解决</h3><p>如果phpStudy启动发生错误，参数下列几点。</p><ul><li>一是防火墙拦截，</li></ul><ul><li>二是80端口已经被别的程序占用，如IIS等；</li></ul><ul><li>三是没有安装VC9运行库,php和apache都是VC9编译。</li></ul><h2 id="PHP-基础-重点"><a href="#PHP-基础-重点" class="headerlink" title="PHP 基础(重点)"></a>PHP 基础(重点)</h2><p>###PHP 简介</p><p> PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。主要适用于 <strong>Web领域的开发</strong> ，能够完成 <strong>动态网页</strong> 的制作。</p><p>###PHP 特点</p><ul><li>PHP 是目前最流行的网站开发语言（B/S结构）之一。</li><li>PHP 是一种在服务器端执行的嵌入 HTML 文档的脚本语言。</li><li>支持几乎所有流行的 <strong>数据库</strong> 以及操作系统。</li><li>源码开放、免费（free)</li><li>php 是世界上最好的语言</li></ul><p>###动态网站与静态网站(了解)</p><ul><li><p>静态网站：使用浏览器端语言进行编程，网站由静态代码（HTML,CSS,JS）组成。</p></li><li><p>动态网站 ：网页通过服务器的程序(php等)动态生成。用户可以和服务器进行交互（可以根据用户输入的不同信息，返回不同的运行结果）</p></li></ul><p><strong>总结</strong></p><pre><code>动态网站的 **动** 指的是网站 **数据的动** 而不是  **视觉上的动**</code></pre><p>###软件架构(了解)</p><blockquote><p>软件架构可以分为BS架构与CS架构</p></blockquote><p>####C/S架构</p><p>Client/Server架构，即客户端/服务器架构。需要安装对应的客户端软件，才能获取服务器的服务。</p><p>常见的CS架构：QQ、LOL、微信等</p><p>特点：</p><ul><li><p>需要安装才能使用</p></li><li><p>性能高效，使用更加稳定和流畅</p></li></ul><p>####B/S架构</p><p>Broswer/Server架构，即浏览器/服务器架构。随着Internet的兴起，无需安装专门客户端软件，通过浏览器去请求服务器；</p><ul><li>不需要安装，只需要浏览器即可。</li><li>相比CS架构，性能相对较差，没有那么流畅和稳定。</li></ul><h2 id="php-基本语法结构"><a href="#php-基本语法结构" class="headerlink" title="php 基本语法结构"></a>php 基本语法结构</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免使用中文目录和中文文件名</span></span><br><span class="line"><span class="comment">// 文件以.php后缀结尾，所有程序包含在<span class="meta">&lt;?php</span> 这里是代码 <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">// php页面无法直接打开需要运行在服务器环境当中</span></span><br><span class="line"><span class="comment">// 末尾必须加分号，不然就报错了（最后一行可以不加分号）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出中文乱码问题：如果使用 echo 输出中文，可能会乱码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">// 解决中文乱码的问题</span></span><br><span class="line">    header(<span class="string">"content-Type:text/html;charset=utf-8"</span>); <span class="comment">// 返回HTML文档文本并设置编码集</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"大家好，我是一名摄影工作者"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>##PHP运行原理</p><p>###HTML运行原理</p><p><img src="HTML%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt></p><p>1) 在浏览器的URL地址栏中输入 <a href="http://www.baidu.com/index.html" target="_blank" rel="noopener">www.baidu.com/index.html</a> 地址，点回车。请求就发送给百度服务器。<br>2) 百度服务器找到index.html文件，并将文件的内容返回给浏览器<br>3) 浏览器接收到index.html中的内容，渲染到页面上。</p><p>同理: localhost/a.html ,  则会返回 本机web服务器根目录下 a.html文件的内容。浏览器拿到内容后进行渲染。</p><p>###PHP运行原理</p><p> apache 不认识 php<br> 浏览器也不认识 php</p><p> <img src="PHP%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt></p><p> 1) 在浏览器地址栏中输入 localhost/index.php ,点回车之后。将请求发送给apache服务器。<br> 2) 服务器找到 index.php文件之后，转发给php解释器<br> 3) php解释器将index.php文件中的php代码全部转为字符串，再返回给apache<br> 4) apache将处理好的字符串返回给浏览器，浏览器渲染后就可以看到页面</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>php 是一门弱类型语法，变量的类型可以随意改变。<br>变量其实就是存储数据的容器</p></blockquote><p><strong>变量的命名规则</strong></p><ul><li>不需要关键字进行声明，变量在第一次赋值的时候被创建</li><li>必须以 <code>$</code> 符号开始</li><li><code>$</code> 后面的命名规则与js的变量命名规则一致。</li></ul><h3 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h3><p><strong>声明变量</strong></p><p>声明变量的时候也一定要同时赋值,否则变量无法声明成功</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量在声明的时候一定要同时赋值,否则变量无法声明成功</span></span><br><span class="line">$name = <span class="string">"呵呵"</span>;</span><br><span class="line"><span class="keyword">echo</span> $name;</span><br></pre></td></tr></table></figure><p><strong>删除变量 unset()</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unset</span>($name); <span class="comment">// 销毁指定的变量</span></span><br></pre></td></tr></table></figure><p><strong>判断变量是否设置值 isset()</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">isset</span>($name);</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">isset</span>($name); <span class="comment">// 用 echo 打印，如果为 true 会打印出 1 ， 如果为 false 打印空</span></span><br><span class="line">var_dump(<span class="keyword">isset</span>($name)); <span class="comment">// 会打印出 bool(true)/bool(false)</span></span><br></pre></td></tr></table></figure><p>变量未设置或者设置为null，返回false（认为变量没有设置），其余情况全部为true。一般用来判断变量是否设置，因为变量未设置，无法直接使用。(变量先赋值，在使用！） </p><p><strong>判断变量是否为空 empty()</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(<span class="keyword">empty</span>($name)); <span class="comment">// 为空打印出 bool(true)，不为空则打印 bool(false)</span></span><br></pre></td></tr></table></figure><p>PHP中认为变量的值为：<code>&quot;&quot;</code>、<code>0</code>、<code>&quot;0&quot;</code>、<code>null</code>、<code>false</code>、<code>[]</code> 时，变量虽然赋值了，但是无实际的意义。为空。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>php数据类型:  8种数据类型</p><p>基本数据类型: 布尔, 字符串, 整数, 浮点数</p><p>复合数据类型:数组, 对象</p><p>特殊的类型:resource(资源) null</p></blockquote><h3 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h3><h4 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. echo 输出简单数据类型</span></span><br><span class="line"><span class="comment">//2. print_r 输出数据结构，一般用于输出复杂类型。</span></span><br><span class="line">print_r($arr); <span class="comment">// print_r 是一个函数，不要忘记小括号</span></span><br><span class="line"><span class="comment">//3. var_dump 输出完整的数据结构，包括类型，一般用于精准调试</span></span><br><span class="line">var_dump($arr);</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$str = <span class="string">"php是世界上是最好的语言"</span>;</span><br><span class="line"><span class="keyword">echo</span> $str;</span><br></pre></td></tr></table></figure><p><strong>字符串连接符</strong></p><p>php中，<code>+</code> 号只有算数的功能，并不能拼串，拼串使用 <code>.</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$name = <span class="string">"大象"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"大家好，我是"</span> . $name . <span class="string">"，今年18岁"</span>;</span><br></pre></td></tr></table></figure><p><strong>php 中的单引号与双引号</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 字符串的定义可以使用单引号，也可以使用双引号</span></span><br><span class="line"><span class="comment">//2. 双引号可以解析变量</span></span><br><span class="line"><span class="comment">//3. 单引号的性能会高于双引号（了解）</span></span><br><span class="line"></span><br><span class="line">$name = <span class="string">"大象"</span>;</span><br><span class="line">$desc = <span class="string">'很帅'</span>;</span><br><span class="line">$str = <span class="string">'$name 很帅'</span>;</span><br><span class="line"><span class="keyword">echo</span> $str; <span class="comment">// $name 很帅</span></span><br><span class="line">$str = <span class="string">"$name 很帅"</span>;</span><br><span class="line"><span class="keyword">echo</span> $str; <span class="comment">// 大象 很帅</span></span><br></pre></td></tr></table></figure><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">echo</span> $num;</span><br></pre></td></tr></table></figure><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$float = <span class="number">11.11</span>;</span><br><span class="line"><span class="keyword">echo</span> $float;</span><br></pre></td></tr></table></figure><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 当布尔类型值为true时，输出1</span></span><br><span class="line"><span class="keyword">echo</span> $flag;</span><br><span class="line">$flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 当布尔类型为false时，输出空字符串</span></span><br><span class="line"><span class="keyword">echo</span> $flag;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>在 php 中，数组分为两种，<strong>索引数组</strong> 和 <strong>关联数组</strong></p><p>计算数组长度的方法：count(数组名)；</p></blockquote><p><strong>索引数组（类似与JS中的数组）</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="string">"张飞"</span>,<span class="string">"赵云"</span>,<span class="string">"马超"</span>);</span><br><span class="line"><span class="keyword">echo</span> $arr; <span class="comment">// Array // echo 只能打印基本数据类型</span></span><br><span class="line"><span class="comment">// 使用 print_r() 打印</span></span><br><span class="line">print_r($arr); <span class="comment">// Array ([0] =&gt; 张飞 [1] =&gt; 赵云 [2] =&gt; 马超)</span></span><br><span class="line"><span class="keyword">echo</span> $arr[<span class="number">0</span>]; <span class="comment">// 张飞</span></span><br></pre></td></tr></table></figure><p><strong>关联数组（类似与JS中的对象）</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性名必须用引号引起来</span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="string">"name"</span>=&gt;<span class="string">"zhangsan"</span>, <span class="string">"age"</span>=&gt;<span class="number">18</span>);</span><br><span class="line">print_r($arr); <span class="comment">// Array ( [name] =&gt; zhangsan [age] =&gt; 18 )</span></span><br><span class="line"><span class="keyword">echo</span> $arr[<span class="string">"name"</span>];</span><br></pre></td></tr></table></figure><p><strong>二维数组与多维数组</strong></p><p>数组中的每个元素又是一个数组<br>二维数组的存取元素，需要两次访问，依次确定行和列 <code>$arr[x][y]</code>;</p><blockquote><p>多维数组数组里面嵌套了两层以上的数组</p></blockquote><h3 id="对象-了解"><a href="#对象-了解" class="headerlink" title="对象(了解)"></a>对象(了解)</h3><blockquote><p>在php以及其他高级语言中，都有类的概念，表示一类对象，跟js中构造函数类似。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类（类似js的构造函数）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> $name = <span class="string">"小明"</span>;</span><br><span class="line">  <span class="keyword">private</span> $sex = <span class="string">"男"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$zs = <span class="keyword">new</span> Person;</span><br><span class="line">print_r($zs);</span><br><span class="line"><span class="comment">//打印对象的结构信息 Person Object ([name] =&gt; 小明[sex:Person:private] =&gt; 男 )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $zs-&gt;name; <span class="comment">// 对象中取值用 -&gt;</span></span><br><span class="line"><span class="keyword">echo</span> $zs-&gt;sex; <span class="comment">// 私有属性，无法获取</span></span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="分支结构-if-switch"><a href="#分支结构-if-switch" class="headerlink" title="分支结构(if/switch)"></a>分支结构(if/switch)</h3><p>基本上来说，所有语言的if..else语法都是一样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">if</span> ($age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"终于可以抽烟喝酒烫头了"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"哎......"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//===================</span></span><br><span class="line"><span class="keyword">switch</span>(变量)&#123;</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">程序块<span class="number">1</span>；</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">程序块<span class="number">2</span>；</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">程序块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环结构-while-for-do…while"><a href="#循环结构-while-for-do…while" class="headerlink" title="循环结构(while / for / do…while)"></a>循环结构(while / for / do…while)</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(判断表达式)&#123;</span><br><span class="line">程序块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(赋值表达式; 判断表达式; 步进表达式)&#123;</span><br><span class="line">程序块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">程序块</span><br><span class="line">&#125; <span class="keyword">while</span>(判断表达式)</span><br></pre></td></tr></table></figure><p><strong>遍历索引数组</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$arr = <span class="keyword">array</span>(<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="string">"王五"</span>, <span class="string">"赵六"</span>, <span class="string">"田七"</span>, <span class="string">"王八"</span>);</span><br><span class="line"><span class="comment">// 获取数组的长度： count($arr)</span></span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; count($arr); $i++) &#123;</span><br><span class="line">  <span class="keyword">echo</span> $arr[$i];</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="foreach-语句结构"><a href="#foreach-语句结构" class="headerlink" title="foreach 语句结构"></a>foreach 语句结构</h3><blockquote><p>用来遍历数组(关联数组和索引数组均可)。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $key =&gt; $value)&#123;</span><br><span class="line">程序体</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $value)&#123;</span><br><span class="line">程序体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>$arr</code> :  要遍历的数组</p><p> <code>$key</code>:  键，可以是任意变量名</p><p> <code>$value</code>:  值，可以是任意变量名</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历关联数组</span></span><br><span class="line">$arr = <span class="keyword">array</span>(</span><br><span class="line">  <span class="string">"name"</span>=&gt;<span class="string">"zs"</span>,</span><br><span class="line">  <span class="string">"age"</span>=&gt;<span class="number">18</span>,</span><br><span class="line">  <span class="string">"sex"</span>=&gt;<span class="number">20</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">  <span class="keyword">echo</span> $k . <span class="string">"="</span> . $v . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote><p>注意，在php中函数不能重复声明</p></blockquote><p>php 中函数的语法与js中函数的语法基本一样，不同点在于</p><ol><li>函数名大小写不敏感</li><li>函数的形参可以设置默认值</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    header(<span class="string">"content-Type:text/html;charset=utf-8"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> <span class="params">($name=<span class="string">"周杰伦"</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"大家好，我是$name"</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        [<span class="keyword">return</span> 返回值;]</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello(); <span class="comment">// 不传参数，会使用默认值</span></span><br><span class="line">    sayHello(<span class="string">"大象"</span>); <span class="comment">// 传参数，默认值不生效</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ol><li>在 php 中函数不能重复声明</li><li>函数体内的变量只在函数体内有效</li><li>函数体外的变量只在函数体外有效</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $age = <span class="number">18</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $name = <span class="string">'大象'</span>;</span><br><span class="line">    <span class="keyword">echo</span> $name;  <span class="comment">// 有效</span></span><br><span class="line">    <span class="keyword">echo</span> $age;  <span class="comment">// 无效</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="keyword">echo</span> $name;  <span class="comment">// 无效</span></span><br><span class="line">    <span class="keyword">echo</span> $age; <span class="comment">// 有效</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>保存不会发生改变的数据(如：3.1415， 路径等)时，最好使用常量。</p><p> 常量的使用方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(常量名, 常量值, [是否区分大小写]);</span><br><span class="line"><span class="comment">// 默认 false 区分大小写， true 不区分大小写</span></span><br><span class="line">define(<span class="string">"PI"</span>, <span class="number">3.1415</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">echo</span> PI;</span><br><span class="line"><span class="keyword">echo</span> pi;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong>  一般在实际工作中，常量都用大写，<strong>常量不能被重新赋值</strong></p><h2 id="PHP内置函数"><a href="#PHP内置函数" class="headerlink" title="PHP内置函数"></a>PHP内置函数</h2><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul><li>max(),min()   分别返回一组数的最大值及最小值；</li><li>abs() 返回绝对值。</li><li>floor() 向下取整。</li><li>ceil()  向上取整。</li><li>round() 四舍五入。</li><li>rand()  返回随机整数，可以取到两端的值。</li></ul><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><ul><li><p><code>time()</code>  返回当前的时间戳 (1970到现在的时间的秒数)</p></li><li><p><code>date(format,time)</code>  格式化一个本地时间或日期</p><p>格式：Y(年) m(月)  d(日)   H(时)  i(分)  s秒</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$time = time(); <span class="comment">// 获取时间戳</span></span><br><span class="line"><span class="keyword">echo</span> date(<span class="string">'Y-m-d H:i:s'</span>,$time); <span class="comment">// 格式化时间戳</span></span><br><span class="line"><span class="comment">// Y, m, d, H, i, s 分别代表 年 月 日 时 分 秒</span></span><br></pre></td></tr></table></figure><p>默认时区会不太正确,  我们在东八区, 比0时区会多八小时</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">路径: D:\phpStudy\php\php<span class="number">-5.4</span><span class="number">.45</span></span><br><span class="line">在php.ini里加上找到date.timezone项，设置date.timezone = <span class="string">"PRC"</span>，重启环境就ok了。</span><br><span class="line">PRC: 中华人民共和国</span><br></pre></td></tr></table></figure><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><ul><li><code>str_replace(查找的值，替换的值，执行替换操作的字符)</code>    字符串替换（会把符合的值全部替换）</li><li><code>trim(字符串);</code>  去除首尾空白字符</li><li><code>explode(分割符，执行分割的字符串);</code>  使用一个字符分割一个字符串，返回一个数组(类似split)</li><li><code>implode(连接符，执行连接的数组);</code>   将数组根据连接符拼接成字符串(类似join)</li><li><code>substr(字符串，起始索引，截取长度);</code>  截取字符串，注意中文占3个字节长度</li><li><code>strchr(字符串，标识字符);</code>   从左向右找标识字符，返回该字符后全部字符(包括该字符)</li><li><code>strrchr(字符串，标识字符);</code>   从右向左找标识字符，返回该字符后全部字符(包括该字符) <strong>主要用于获取后缀名</strong></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>查找数组中是否含有指定内容</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in_array(查找的内容, 数组)   如果查找到返回 true ，查找不到返回 false</span></span><br><span class="line">result = in_array($uname, $arr);</span><br><span class="line"><span class="comment">// 可用来判断用户名是否已存在数据库中</span></span><br></pre></td></tr></table></figure><p><strong>从数组中随机获取数据</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array_rand(被操作的数据, 数据长度) 返回一个随机的下标</span></span><br><span class="line">$arr = array_rand($results, <span class="number">2</span>); <span class="comment">// 返回一个数组，随机两个下标</span></span><br><span class="line">$index = array_rand($results, <span class="number">1</span>); <span class="comment">// 返回一个随机的下标</span></span><br><span class="line">$results[$index]; <span class="comment">// 用来随机获取数组中的一项</span></span><br></pre></td></tr></table></figure><h2 id="页面动态渲染"><a href="#页面动态渲染" class="headerlink" title="页面动态渲染"></a>页面动态渲染</h2><ul><li><p>PHP本身支持与HTML混编</p></li><li><p>混编的文件后缀必须为 .php， Apache 才会调用 PHP 解析</p></li><li><p>PHP与HTML混编时，服务器中的 PHP 引擎 只会执行php标签内部的PHP代码，非PHP的代码(PHP标签外部的内容)直接忽略，最后会将PHP的执行结果和非PHP代码 一起返回给浏览器,由浏览器进行解析</p></li><li><p>一个php页面当中,可以写多个php语法结构,但是php语法结构 <strong>不能嵌套</strong></p></li></ul>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    header(<span class="string">'content-type:text/html;charset=utf-8'</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="number">2</span>+<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// php的引擎 只会执行php代码块中代码，代码块外面的代码会被忽略最后 服务器会将php执行的结果和代码块外面的内容一起返回给浏览器，由浏览器进行解析</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">// 在php语法结构外面， 可以写 html ，会直接在浏览器中渲染</span></span><br><span class="line">&lt;a href=<span class="string">"http://www.baidu.com"</span>&gt;百度一下&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="include-文件引入"><a href="#include-文件引入" class="headerlink" title="include 文件引入"></a>include 文件引入</h2><p><strong>介绍</strong>：不同的页面中有相同的代码部分，可以将其分离为单个文件。需要调用时，<strong>include 引入对应的文件即可调用</strong>。提高代码的复用率。类似于 js 中 script 标签导入, 可以用于函数复用</p><p><strong>语法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以是html、php或其他类型的页面</span></span><br><span class="line">include | include_once   <span class="string">"文件的路径"</span></span><br></pre></td></tr></table></figure><p><strong>include 与 include_once 区别</strong></p><ul><li>include  可以重复引入文件</li><li>include_once  只引入一次，防止多次引入文件</li><li>如果文件中有函数，include 重复引入会报错，include_once 不会报错</li></ul><h2 id="PHP-数据读写到文件-数据持久化"><a href="#PHP-数据读写到文件-数据持久化" class="headerlink" title="PHP 数据读写到文件(数据持久化)"></a>PHP 数据读写到文件(数据持久化)</h2><p>程序运行过程中，数据存储在内存中的，程序结束, 数据会销毁</p><p>如果希望可以永久存储某些数据，可以将数据存储在硬盘上（存储在文件中）</p><p>将数据由内存存储到硬盘的过程，称为数据持久化；</p><ul><li><p><code>file_get_contents(path)</code>   根据路径读取文件内容, 返回一个字符串</p></li><li><p><code>file_put_contents(path,$str)</code>  将一个字符串写入到一个文件中。(只能存储字符串)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file_put_contents(string $file, string $data[, constants flag]);</span><br><span class="line">参数<span class="number">1</span>: 文件路径</span><br><span class="line">参数<span class="number">2</span>: 要写入文件的字符串</span><br><span class="line">参数<span class="number">3</span>: 可选参数，默认不写，新内容覆盖原文件中的内容；FILE_APPEND 是向文件中追加内容</span><br><span class="line">返回值: 写入文件的字符串长度(不用记)</span><br></pre></td></tr></table></figure></li></ul><p>使用 <code>file_put_contents</code> 存储数组的时候，会丢失数据</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$arr = [<span class="string">'zs'</span>, <span class="string">'ls'</span>, <span class="string">'ww'</span>];</span><br><span class="line">$arr1 = [<span class="string">'name'</span>=&gt;<span class="string">'zs'</span>, <span class="string">'age'</span>=&gt;<span class="number">18</span>];</span><br><span class="line">file_put_contents(<span class="string">"02-test.txt"</span>, $arr); <span class="comment">// zslsww</span></span><br><span class="line">file_put_contents(<span class="string">"02-test.txt"</span>, $arr1); <span class="comment">// zs18</span></span><br></pre></td></tr></table></figure><p>把一个数组，转成一个 json 格式的字符串</p><ul><li><code>json_encode($data)</code>   将PHP数组转成JSON格式字符串。</li><li><code>json_decode($str,true)</code>  将 JSON 字符串, 转换为 PHP 数组。（不传true, 有可能转完之后是个对象, 传了true,一定是数组）</li></ul><h2 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h2><blockquote><p>表单（form）：表单用于收集用户输入信息，并将数据提交给服务器。是一种常见的与服务端数据交互的一种方式</p></blockquote><ol><li><code>action</code>: 指定表单的提交地址（如果提交到当前页面，action 可以为空）</li><li><code>method</code>: 指定表单的提交方式，get/post，默认 get</li><li><code>input</code> 的数据想要提交到后台，必须指定 name 属性，后台通过 name 属性获取值</li><li>想要提交表单，不能使用 <code>input:button</code> 必须使用 <code>input:submit</code></li></ol><h3 id="php-获取表单数据"><a href="#php-获取表单数据" class="headerlink" title="php 获取表单数据"></a>php 获取表单数据</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $_GET 是 PHP 系统提供的一个超全局变量，是一个数组，里面存放了表单通过 get 方式提交的数据</span></span><br><span class="line"><span class="comment">// $_POST 是 PHP 系统提供的一个超全局变量，是一个数组，里面存放了表单通过 post 方式提交的数据</span></span><br></pre></td></tr></table></figure><p><strong>get 与 post 的区别</strong></p><ul><li><code>get</code> 方式<br>数据会拼接在 url 地址的后面 (?username=pp&amp;password=123456)<br>地址栏有长度限制，因此 get 方式提交数据大小不会超过 4k</li><li><code>post</code> 方式<br>数据不会在 url 中显示，相比 get 方式，post 更安全<br>提交的数据没有大小限制，可用于文件上传</li></ul><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><strong>html要求</strong></p><ul><li><p>文件上传的提交方式必须是 <code>post</code> 方式</p></li><li><p>需要给 <code>form</code> 指定 <code>enctype=&quot;multipart/form-data&quot;</code></p></li><li><p>指定 <code>name</code> 属性，后台才能获取到</p></li></ul><p><strong>php 相关</strong></p><ul><li><p>文件上传时，通过 <code>$_FILES</code> 才能获取到，这是一个二维数组。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [photo] =&gt; <span class="keyword">Array</span></span><br><span class="line">        (</span><br><span class="line">            [name] =&gt; <span class="number">001.</span>jpg   <span class="comment">// 文件名字</span></span><br><span class="line">            [type] =&gt; image/jpeg  <span class="comment">// 文件类型</span></span><br><span class="line">            <span class="comment">// 上传图片保存的位置</span></span><br><span class="line">            [tmp_name] =&gt; C:\Users\Jepson\AppData\Local\Temp\phpF2A0.tmp</span><br><span class="line">            [error] =&gt; <span class="number">0</span>     <span class="comment">// 上传错误码, 错误码为 0 表示没有错误</span></span><br><span class="line">            [size] =&gt; <span class="number">6000</span>   <span class="comment">// 文件大小, 单位字节, 大小 6kb 左右</span></span><br><span class="line">        )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>上传文件时，文件会临时保存在服务器上，如果文件最终没有保存，那么临时文件会被删除，保证服务器安全。</p></li><li><p><code>sleep(10)</code> 可以让代码延迟10秒钟才执行。</p></li><li><p><code>move_uploaded_file($path, $newPath);</code> 可以转存临时文件，真正把文件存储起来</p></li><li><p><code>unlink(filename,context)</code> 删除文件，若成功，则返回 true，失败则返回 false</p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存图片的完整代码</span></span><br><span class="line"><span class="comment">// 思路:</span></span><br><span class="line"><span class="comment">// 1. 在文件上传成功的情况下, 进行图片的保存   error == 0</span></span><br><span class="line"><span class="comment">// 2. 获取临时文件路径</span></span><br><span class="line"><span class="comment">// 3. 随机生成新的文件名, 注意文件中后缀名是不能改变的</span></span><br><span class="line"><span class="comment">// 4. 根据新的文件名, 转移临时文件</span></span><br><span class="line"></span><br><span class="line">$file = $_FILES[<span class="string">'photo'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断上传是否成功</span></span><br><span class="line"><span class="keyword">if</span> ( $file[<span class="string">'error'</span>] == <span class="number">0</span> ) &#123; <span class="comment">// 上传成功</span></span><br><span class="line">  <span class="comment">// 1. 获取临时文件路径</span></span><br><span class="line">  $ftemp = $file[<span class="string">'tmp_name'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 随机生成新的文件名, 后缀不能随便起, 要获取一下</span></span><br><span class="line">  $name = $file[<span class="string">'name'</span>];</span><br><span class="line">  $text = strrchr($name, <span class="string">'.'</span>);</span><br><span class="line">  <span class="comment">// 为了防止重复, 生成随机的文件名以当前时间秒数+随机数组成</span></span><br><span class="line">  $newName = time().rand(<span class="number">10000</span>,<span class="number">99990</span>).$text;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 进行转存</span></span><br><span class="line">  move_uploaded_file($ftemp, <span class="string">"./upload/$newName"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="学生信息管理系统1-0"><a href="#学生信息管理系统1-0" class="headerlink" title="学生信息管理系统1.0"></a>学生信息管理系统1.0</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ul><li>学生添加功能</li><li>展示学生信息功能</li><li>删除学生信息</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array_splice(数组, 开始的下标, 截取长度) 将匹配到的数据截取掉，会改变原来的数组</span></span><br><span class="line">array_splice($arr, $_GET[<span class="string">"index"</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加内容到数组：将 $stuArr 添加到数组 $arr 中</span></span><br><span class="line">$arr[] = $stuArr;</span><br></pre></td></tr></table></figure><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p><strong>协议：</strong></p><blockquote><p>协议，就是事先的一种约定、规则、规范、标准</p></blockquote><p> <strong>常见协议</strong></p><ul><li>HTTP、HTTPS 超文本传输协议</li><li>FTP 文件传输协议</li><li>SMTP 简单邮件传输协议</li></ul><p><strong>HTTP 协议</strong></p><p>HTTP 协议即超文本传输协议,  是一个 [浏览器端] 和 [服务器端] 请求和响应的标准</p><ul><li>常用请求方法  GET, POST</li><li>请求 (request)：<code>请求行、请求头、请求主体</code>。</li><li>响应 (response)：<code>状态行、响应头、响应主体</code>。</li></ul><h3 id="请求和请求报文"><a href="#请求和请求报文" class="headerlink" title="请求和请求报文"></a>请求和请求报文</h3><p>​    请求由浏览器发起，其规范格式为：请求行、请求头、请求主体。</p><p><strong>get 请求的请求报文</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------------------请求行--------------------------------</span></span><br><span class="line"><span class="comment">// GET 请求方式</span></span><br><span class="line"><span class="comment">// /day02/01.php?username=pp&amp;password=123456    请求路径+参数（注意点）</span></span><br><span class="line"><span class="comment">// HTTP/1.1 HTTP的版本号</span></span><br><span class="line">GET /day03/<span class="number">01.</span>php?username=pp&amp;password=<span class="number">123456</span> HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------请求头--------------------------------</span></span><br><span class="line"><span class="comment">// Host:主机地址</span></span><br><span class="line">Host: www.study.com</span><br><span class="line"><span class="comment">// HTTP1.1版本默认开启，建立过连接后，TCP连接不会断开，下次连接可以继续使用（底层，不用管）</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="comment">// chrome浏览器自己增加的，不用管</span></span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line"><span class="comment">// 浏览器的代理字符串（版本信息）</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; WOW64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">58.0</span><span class="number">.3029</span><span class="number">.96</span> Safari/<span class="number">537.36</span></span><br><span class="line"><span class="comment">// 浏览器端可以接受的类型。</span></span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,<span class="string">`*/*`</span>;q=<span class="number">0.8</span></span><br><span class="line"><span class="comment">// 从哪个页面发出的请求</span></span><br><span class="line">Referer: http: <span class="comment">// www.study.com/day02/01-login.html</span></span><br><span class="line"><span class="comment">// 检查浏览器支持的压缩方式</span></span><br><span class="line">Accept-Encoding: gzip, deflate, sdch</span><br><span class="line"><span class="comment">// 浏览器支持的语言，优先中文。</span></span><br><span class="line">Accept-Language: zh-CN,zh;q=<span class="number">0.8</span>,en;q=<span class="number">0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------请求主体-------------------------------------</span></span><br><span class="line"><span class="comment">// get 请求没有请求体，因为要传递的数据已经拼接到了请求主头中</span></span><br></pre></td></tr></table></figure><p><strong>POST 请求的请求报文</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----------------------请求行---------------------------------------------</span></span><br><span class="line">POST /day02/<span class="number">01.</span>php HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------请求头--------------------------------------------</span></span><br><span class="line">Host: www.study.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="comment">// 传递的参数的长度</span></span><br><span class="line">Content-Length: <span class="number">29</span></span><br><span class="line">Cache-Control: max-age=<span class="number">0</span></span><br><span class="line">Origin: http: <span class="comment">// www.study.com</span></span><br><span class="line">Upgrade-Insecure-Requests: <span class="number">1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; WOW64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">58.0</span><span class="number">.3029</span><span class="number">.96</span> Safari/<span class="number">537.36</span></span><br><span class="line"><span class="comment">// 内容类型：表单数据，如果是post请求，必须指定这个属性。</span></span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,<span class="string">`*/*`</span>;q=<span class="number">0.8</span></span><br><span class="line">Referer: http: <span class="comment">// www.study.com/day02/01-login.html</span></span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=<span class="number">0.8</span>,en;q=<span class="number">0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------------------请求体------------------------------------------</span></span><br><span class="line">username=pp&amp;password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><p><strong><code>GET</code> 请求与 <code>POST</code> 请求的对比</strong></p><ul><li>GET 请求没有请求体，因为 GET 请求的参数拼接到地址栏中了</li><li>POST 请求有请求体，就是传递的参数。</li></ul><h3 id="响应与响应报文"><a href="#响应与响应报文" class="headerlink" title="响应与响应报文"></a>响应与响应报文</h3><p>​    响应由服务器发出，其规范格式为：响应行(状态行)、响应头、响应主体。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------------响应行（状态行）-------------------------------</span></span><br><span class="line"><span class="comment">// HTTP/1.1  HTTP版本</span></span><br><span class="line"><span class="comment">// 200 响应的状态</span></span><br><span class="line"><span class="comment">// 200表示成功</span></span><br><span class="line"><span class="comment">// 302页面重定向</span></span><br><span class="line"><span class="comment">// 304表示文档未修改</span></span><br><span class="line"><span class="comment">// 404表示找不到资源</span></span><br><span class="line"><span class="comment">// 500表示服务端错误</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------响应头-----------------------------------------------</span></span><br><span class="line"><span class="built_in">Date</span>: Thu, <span class="number">22</span> Jun <span class="number">2017</span> <span class="number">16</span>:<span class="number">51</span>:<span class="number">22</span> GMT <span class="comment">// 服务器的时间</span></span><br><span class="line">Server: Apache/<span class="number">2.4</span><span class="number">.23</span> (Win32) OpenSSL/<span class="number">1.0</span><span class="number">.2</span>j PHP/<span class="number">5.4</span><span class="number">.45</span>  <span class="comment">// 服务器的版本信息</span></span><br><span class="line">X-Powered-By: PHP/<span class="number">5.4</span><span class="number">.45</span>  <span class="comment">// 后台编程语言信息</span></span><br><span class="line">Content-Length: <span class="number">18</span>   <span class="comment">// 服务器的响应主体长度</span></span><br><span class="line"><span class="comment">// 内容类型，告诉浏览器该如何解析响应结果</span></span><br><span class="line">Content-Type: text/html;charset=utf<span class="number">-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------响应主体------------------------------------------------</span></span><br><span class="line">用户登录成功</span><br></pre></td></tr></table></figure><h2 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a>Mysql数据库</h2><h3 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h3><p>专门用来存储、管理数据的仓库 英文：Database, DB。</p><h3 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h3><ul><li><p>关系型数据库: 基于表，表与表之间可以存在关系，可以进行多表查询的存储方式，适合较为复杂的存储</p><p>如: MySQL, SQL Server, oracle</p><p>表结构:</p><p> 每一行代表一条数据 — <strong>记录</strong></p><p> 每一列都是一类数据 — <strong>字段</strong></p><table><thead><tr><th><strong>订单编号</strong></th><th><strong>商品名称</strong></th><th><strong>价格</strong></th><th><strong>数量</strong></th></tr></thead><tbody><tr><td>100123</td><td>华为mate10</td><td>4999</td><td>2</td></tr><tr><td>100124</td><td>花裙子</td><td>499</td><td>1</td></tr></tbody></table></li><li><table><thead><tr><th>订单编号</th><th>用户</th><th>配送地址</th></tr></thead><tbody><tr><td>100123</td><td>隔壁老王</td><td>北京市京顺路99号</td></tr><tr><td>100124</td><td>隔壁老宋</td><td>北京市清华大学1号楼</td></tr></tbody></table></li></ul><ul><li><p>非关系型数据库: 基于键值对的存储方式，数据之间没有耦合性，特点执行效率高</p><p>如：mongodb</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似对象的键值对形式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"username"</span>: <span class="string">"gblw"</span>,</span><br><span class="line">    <span class="string">"password"</span>: <span class="number">123456</span>,</span><br><span class="line">    <span class="string">"uid"</span>: <span class="number">007</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="MySQL-数据库软件"><a href="#MySQL-数据库软件" class="headerlink" title="MySQL 数据库软件"></a>MySQL 数据库软件</h3><blockquote><p>MySQL 数据库软件中可以有多个数据库,每一个数据库中可以有多个表</p></blockquote><h4 id="可视化工具-navicat"><a href="#可视化工具-navicat" class="headerlink" title="可视化工具 navicat"></a>可视化工具 navicat</h4><blockquote><p>MySQL 只是一个数据库软件，如果我们要创建数据库，或对数据库进行增删改查，刚开始可以用可视化工具来操作，让我们更加直观的了解数据库</p></blockquote><h5 id="安装-navicat"><a href="#安装-navicat" class="headerlink" title="安装 navicat"></a>安装 navicat</h5><h5 id="让-navicat-和-MySQL-建立连接"><a href="#让-navicat-和-MySQL-建立连接" class="headerlink" title="让 navicat 和 MySQL 建立连接"></a>让 navicat 和 MySQL 建立连接</h5><p>点击左上角 连接 =&gt; MySQL =&gt; 常规 =&gt; 端口 3306 =&gt;</p><h4 id="数据库表的操作"><a href="#数据库表的操作" class="headerlink" title="数据库表的操作"></a>数据库表的操作</h4><h5 id="数据库的数据类型"><a href="#数据库的数据类型" class="headerlink" title="数据库的数据类型"></a>数据库的数据类型</h5><blockquote><p>也就是数据库中可以存储的数据类型(又叫做字段类型)</p></blockquote><p><strong>字段类型</strong></p><ul><li><p>整型 <code>int</code></p><p>​    存储如年龄，产品数量，编号等。</p></li><li><p>小数类型  <code>float</code>  ,  <code>decimal</code></p><blockquote><p>重量，工资，奖金，价格等使用decimal类型，实现小数的精确存储,一般用来存储与钱有关的数字。3.333333331</p></blockquote></li><li><p>字符串型  <code>varchar(M)</code>，<code>char(M)</code></p><ul><li><p>M 为该字段可以存储的最多字符数(字节) ，如varchar(10)最大可以存储10个字节</p></li><li><p>varchar 一般用来存储长度变化比较大的字符串，如文章标题，商品名称</p></li><li><p>char 存储长度比较固定的字符串，如手机号，身份证号，序列号，邮编</p></li><li><p>此外可以使用text类型，存储较长的字符串，无需指定字符串的具体长度</p></li></ul></li><li><p>日期时间型 <code>datetime</code>,  <code>date(年月日)</code>，<code>time(时分秒)</code></p></li></ul><p><strong>字段约束</strong></p><p>字段约束: 字段数据的属性规则（特征）</p><ol><li><p><code>not null</code> 不为空，可以限制字段值不能为空</p></li><li><p><code>default</code>  默认值，可以设置字段的默认值，在没有录入时自动使用默认值填充。</p></li><li><p><code>primary key</code>  主键 ：唯一标识，不能重复，不能为空</p><p>设置字段为主键，主键字段的值不能重复，不能为空。而且一个数据表中只能设置一个字段为主键，作为每行记录的唯一身份信息（索引）。</p></li><li><p><code>auto_increment</code>  自动增长</p><p>设置字段为自动增长，默认从1开始自动分配编号。自增长字段必须为一个key（索引，数据结构，便于快速查找数据，相当于书的目录），一般与 primary key 结合使用。类型必须为整型。</p></li><li><p><code>unique key</code>  不能重复</p><p>唯一键，设置字段的值为唯一的，可以设置多个字段为唯一键。唯一键字段的值可以为空。</p></li></ol><h5 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h5><blockquote><p>注意 创建表时，每个表必须有一个主键</p></blockquote><h2 id="SQL-操作数据库的语言"><a href="#SQL-操作数据库的语言" class="headerlink" title="SQL-操作数据库的语言"></a>SQL-操作数据库的语言</h2><blockquote><p>SQL：structured Query Language 结构化查询语言。</p></blockquote><ul><li>通过这个语言可以对数据库进行增删改查</li></ul><p>SQL编写注意点:  注释用 <code>--</code> , 语句结束加分号 <code>;</code></p><h3 id="基本用法：增删改查"><a href="#基本用法：增删改查" class="headerlink" title="基本用法：增删改查"></a>基本用法：增删改查</h3><ol><li>插入数据 <code>insert</code></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- insert into 表名 (字段列表) values (值列表)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> book (<span class="keyword">name</span>, age, sex) <span class="keyword">values</span> (<span class="string">'zs'</span>,<span class="string">'18'</span>,<span class="string">'m'</span>);</span><br></pre></td></tr></table></figure><ol><li>修改数据 <code>update</code></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- update 表名 set 字段名称1=值1,字段名称2=值2,... where 条件</span></span><br><span class="line"><span class="comment">-- 如果不加条件会修改表中所有对应的字段</span></span><br><span class="line"><span class="keyword">update</span> book <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'ls'</span>, age=<span class="string">'30'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><ol><li>删除数据 <code>delete</code></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- delete from 表名 where 条件</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> book <span class="comment">-- 会删除所有数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> book <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><ol><li>查询数据 select</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- select 字段列表 from 表名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, age <span class="keyword">from</span> book <span class="comment">-- 只查询表中 name 和 author 的信息</span></span><br><span class="line"><span class="comment">-- select * from 表名 where 条件  * 表示所有字段</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> book <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'zs'</span> <span class="keyword">and</span> age=<span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><ul><li><p><code>where</code> 条件</p><p>查询时，不添加 where 条件,  返回数据表所有行。需要添加限定条件，只返回需要的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- select  字段列表 from  表名 where 条件；</span></span><br><span class="line"><span class="comment">-- 条件 : =, &gt;, &lt;, &gt;=, &lt;=, and, or</span></span><br></pre></td></tr></table></figure></li><li><p><code>like</code> 模糊匹配  % 通配符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找姓张的人</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'张%'</span>;​</span><br></pre></td></tr></table></figure></li><li><p><code>in</code> 语法：一次查询多个符合条件的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- select * from 表名 where 字段 in (value1,value2,value3);</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> stu <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="string">'zs'</span>, <span class="string">'ls'</span>, <span class="string">'ww'</span>); <span class="comment">-- 查找name值为zs, ls, ww 的数据</span></span><br></pre></td></tr></table></figure></li><li><p><code>count()</code>  获取返回数据的总条数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询满足条件数据的总条数</span></span><br><span class="line"><span class="comment">-- select count(*) from 表名 where 条件</span></span><br></pre></td></tr></table></figure></li><li><p><code>order</code> 排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- select * from 表名 order by  字段名称;     默认升序</span></span><br><span class="line"><span class="comment">-- select * from 表名 order by  age;  -- 按照年龄来排序</span></span><br><span class="line"><span class="comment">-- select * from 表名 order by 字段名称 desc;      desc 表示降序</span></span><br></pre></td></tr></table></figure></li><li><p><code>limit</code> 对结果集进行截取 一般用于取数据的前几条</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- select *  from  表名  limit 截取的起始索引，截取的长度</span></span><br></pre></td></tr></table></figure></li><li><p>联合查询（多个表联合查询）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A <span class="keyword">join</span> 表B <span class="keyword">on</span> 表A.字段=表B.字段 <span class="keyword">where</span> 条件</span><br><span class="line"><span class="keyword">join</span> 将表A和表B联合起来</span><br><span class="line"><span class="keyword">on</span> 根据什么字段把表A和表B联合起来</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> *  <span class="keyword">from</span>  teacher  <span class="keyword">join</span> <span class="keyword">class</span>  <span class="keyword">on</span> class.id=teacher.classid;  <span class="comment">-- 老师表和班级表联合查询</span></span><br><span class="line"><span class="keyword">select</span> teacher.*, class.classname  <span class="keyword">from</span>  teacher  <span class="keyword">join</span> <span class="keyword">class</span>  <span class="keyword">on</span> class.id=teacher.classid;   <span class="comment">-- 老师表和班级表联合查询,但只显示老师表的全部内容和班级表的名称</span></span><br><span class="line"><span class="comment">-- 注意: 多表联合查询时,字段要写明是那个表的字段 如  表.字段名</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="PHP-操作数据库"><a href="#PHP-操作数据库" class="headerlink" title="PHP 操作数据库"></a>PHP 操作数据库</h2><h3 id="连接数据库基本步骤"><a href="#连接数据库基本步骤" class="headerlink" title="连接数据库基本步骤"></a>连接数据库基本步骤</h3><ol><li>连接数据库</li><li>准备sql语句</li><li>执行sql语句</li><li>获取执行的结果并分析</li><li>关闭数据库</li></ol><h3 id="操作数据库常用-API"><a href="#操作数据库常用-API" class="headerlink" title="操作数据库常用 API"></a>操作数据库常用 API</h3><ul><li><p><code>mysqli_connect(IP, 用户名，密码，数据库名)，端口号</code>  连接数据库</p></li><li><p><code>mysqli_query($link, $sql)</code> 执行SQL语句</p></li><li><p><code>mysqli_error($link);</code> 返回错误描述</p></li><li><p><code>mysqli_close($link);</code>  关闭连接</p></li><li><p><code>mysqli_fetch_assoc($res);</code> 从结果集中取得一行作为关联数组返回</p></li><li><p><code>mysqli_num_rows($res);</code> 返回结果集的行数</p></li></ul><h3 id="sql-操作"><a href="#sql-操作" class="headerlink" title="sql 操作"></a>sql 操作</h3><ul><li>使用 PHP 发送 SQL 语句前，可以先打印 SQL 语句，检查语句的正确性。</li><li>修改数据库的数据时, 使用变量拼接SQL语句=，字段的值为字符串类型时，需要在变量的两侧使用单、双引号包裹。可以将所有的字段外面都使用双引号包含。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 连接数据库</span></span><br><span class="line"><span class="comment">// mysqli_connect(ip地址, 用户名, 密码, 数据库的名称, 端口号);</span></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//    1. 连接成功, 返回一个数据库连接对象</span></span><br><span class="line"><span class="comment">//    2. 连接失败, 返回 false</span></span><br><span class="line"><span class="comment">// @ 表示错误抑制符, 可以抑制错误的输出</span></span><br><span class="line">$link = @ mysqli_connect(<span class="string">'127.0.0.1'</span>, <span class="string">'root'</span>, <span class="string">'root'</span>, <span class="string">'study'</span>, <span class="number">3306</span>);</span><br><span class="line"><span class="comment">// var_dump($link);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数据库连接失败</span></span><br><span class="line"><span class="keyword">if</span> ( !$link ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据库连接失败"</span>；</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序结束, die 方法, 终止当前程序执行, 输出一段语句</span></span><br><span class="line"><span class="keyword">die</span>(<span class="string">"数据库连接失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"数据库连接成功&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 准备 sql 语句: 删除一条数据</span></span><br><span class="line">$sql = <span class="string">"delete from stu where id = 14"</span>;</span><br><span class="line">$name = <span class="string">"gblw"</span>;</span><br><span class="line">$age = <span class="number">31</span>;</span><br><span class="line">$sq2 = <span class="string">"insert into stu (name, age) values ('$name', $age)"</span>;</span><br><span class="line"><span class="comment">// sql 语句一般用双引号包裹</span></span><br><span class="line"><span class="comment">// 如果语句中含有拼接的变量，需要用单引号包裹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 让数据库执行 sql 语句, 并分析结果</span></span><br><span class="line"><span class="comment">// mysqli_query(数据库连接对象, 要执行的sql语句)</span></span><br><span class="line"><span class="comment">// 非查询语句：执行成功返回 true, 执行失败返回 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 根据结果不同做逻辑判断</span></span><br><span class="line"><span class="keyword">if</span> ( mysqli_query( $link, $sql ) ) &#123;</span><br><span class="line">    <span class="comment">// 如果删除的数据不存在，也会返回 true，</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"删除成功"</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// sql 语句错误，才会返回 false</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"删除失败"</span>;</span><br><span class="line">    <span class="comment">// mysqli_error 可以查看错误消息</span></span><br><span class="line">    <span class="keyword">echo</span> mysqli_error($link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询语句： 成功返回结果集, 失败返回 false</span></span><br><span class="line"><span class="comment">// 数据查询不到也会返回结果集，只是数据条数为 0，sql 语句有错误才会返回 false</span></span><br><span class="line">$res2 = mysqli_query( $link, $sq2 );</span><br><span class="line"><span class="comment">// $res2 是返回的结果集,是一个对象，表面上看没有我们要的数据,如果我们想要数据,需要调用mysqli_fetch_assoc($res2)去获取</span></span><br><span class="line"><span class="comment">// 结果集中 field_count 表示字段数，num_rows 表示查询到的数据条数</span></span><br><span class="line"><span class="comment">// 注意: mysqli_fetch_assoc($res2)执行一次,只会从结果集中拿一条数据出来(执行几次就拿出几条数据)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 根据结果不同做逻辑判断</span></span><br><span class="line"><span class="keyword">if</span> ( !$res ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> mysqli_error( $link );</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">'数据库查询失败'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mysqli_fetch_assoc 查询成功, 从结果集中取数据, 以关联数组的形式返回</span></span><br><span class="line"><span class="comment">// 一次只取一条数据, 如果没取到, 返回 null</span></span><br><span class="line">$arr = [];</span><br><span class="line"><span class="keyword">while</span>( $row = mysqli_fetch_assoc( $res ) ) &#123;</span><br><span class="line">    <span class="comment">// 将值推到数组中</span></span><br><span class="line">    $arr[] = $row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以采用 for 循环遍历</span></span><br><span class="line"><span class="comment">// mysqli_num_rows($res) 方法返回获取到的数据条数 ，</span></span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; mysqli_num_rows($res); $i++)&#123;</span><br><span class="line">    <span class="comment">// echo $i;</span></span><br><span class="line">    $arr[] =  mysqli_fetch_assoc($res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// echo '&lt;pre&gt;';</span></span><br><span class="line"><span class="comment">// print_r($arr);</span></span><br><span class="line"><span class="comment">// echo '&lt;/pre&gt;';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 关闭数据库连接 (挂电话)</span></span><br><span class="line">mysqli_close( $link );</span><br></pre></td></tr></table></figure><h3 id="数据库工具函数的封装"><a href="#数据库工具函数的封装" class="headerlink" title="数据库工具函数的封装"></a>数据库工具函数的封装</h3><blockquote><p>为了提高代码的复用性，把数据增删改的操作封装成一个方法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line">define( <span class="string">'HOST'</span>, <span class="string">'127.0.0.1'</span> );</span><br><span class="line">define( <span class="string">'UNAME'</span>, <span class="string">'root'</span> );</span><br><span class="line">define( <span class="string">'PWD'</span>, <span class="string">'root'</span> );</span><br><span class="line">define( <span class="string">'DB'</span>, <span class="string">'test02'</span> );</span><br><span class="line">define( <span class="string">'PORT'</span>, <span class="number">3306</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非查询语句封装</span></span><br><span class="line"><span class="comment">// 封装一个执行非查询语句的方法, 提高代码的复用性</span></span><br><span class="line"><span class="comment">// 参数: $sql 要执行的 sql 语句</span></span><br><span class="line"><span class="comment">// 返回值: true / false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_exec</span><span class="params">( $sql )</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 连接数据库</span></span><br><span class="line">  $link = @ mysqli_connect( HOST, UNAME, PWD, DB, PORT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>( !$link ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'数据库连接失败'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 准备 sql 语句, 就是传递过来的 $sql</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 执行 sql 语句, 分析结果</span></span><br><span class="line">  <span class="keyword">if</span> ( mysqli_query( $link, $sql ) ) &#123;</span><br><span class="line">    <span class="comment">// 执行成功</span></span><br><span class="line">    mysqli_close( $link ); <span class="comment">// 关闭数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行失败</span></span><br><span class="line">    mysqli_close( $link ); <span class="comment">// 关闭数据库</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询语句的封装</span></span><br><span class="line"><span class="comment">// 参数: $sql 要执行的 sql 语句</span></span><br><span class="line"><span class="comment">// 返回值:</span></span><br><span class="line"><span class="comment">//    (1) 成功, 返回数据(二维数组)</span></span><br><span class="line"><span class="comment">//    (2) 失败, 返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_query</span><span class="params">( $sql )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 建立连接</span></span><br><span class="line">  $link = @ mysqli_connect( HOST, UNAME, PWD, DB, PORT );</span><br><span class="line">  <span class="keyword">if</span> ( !$link ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"数据库连接失败"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 准备 sql 语句 $sql</span></span><br><span class="line">  <span class="comment">// 3. 执行 sql 语句, 分析结果</span></span><br><span class="line">  $res = mysqli_query( $link, $sql );  <span class="comment">// 结果集 或者 false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !$res ) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"获取数据失败&lt;br&gt;"</span>;</span><br><span class="line">    <span class="keyword">echo</span> mysqli_error($link);</span><br><span class="line">    mysqli_close( $link );</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到结果集, 将结果集的所有内容取出到数组中</span></span><br><span class="line">  $arr = [];</span><br><span class="line">  <span class="keyword">while</span> ( $row = mysqli_fetch_assoc($res) ) &#123;</span><br><span class="line">    $arr[] = $row;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mysqli_close( $link );</span><br><span class="line">  <span class="keyword">return</span> $arr; <span class="comment">// 返回结果数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="学生管理系统2-0"><a href="#学生管理系统2-0" class="headerlink" title="学生管理系统2.0"></a>学生管理系统2.0</h2><h3 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h3><ul><li>添加学生功能</li><li>展示学生列表功能</li><li>删除学生功能</li><li>查看学生详情</li><li>更新学生数据</li></ul><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p><strong>注册功能思路：</strong></p><ol><li>表单设计，点击提交按钮向服务器提交表单数据</li><li>在后台获取表单提交的数据，保存到数据库中<ul><li>先获取表单的标签的数据</li><li>保存上传的图片（并保存图片存储的路径）</li><li>将表单的数据和图片的路径一起保存到数据库中</li></ul></li><li>保存完成，跳转到列表页，查看新添加的数据</li></ol><p><strong>展示功能思路：</strong></p><ol><li>先从数据库中获取数据（二维数组arr）</li><li>遍历二维数组，将数组中数据渲染到页面中</li></ol><p><strong>删除功能思路：</strong></p><ol><li>获取要删除数据的id</li><li>根据id删除数据库中指定的数据</li><li>删除完毕，返回列表页</li></ol><p><strong>详情展示功能</strong></p><ol><li>获取要查看详情数据的id</li><li>根据id通过联合查询，获取到需要用数据</li><li>把数据显示在页面中</li><li>点击返回按钮，可以返回到列表页</li></ol><p><strong>更新数据思路：</strong><br>更新数据的思路=先渲染  再  提交</p><ol><li>获取要查看详情数据的id</li><li>把对应id的数据填充到修改页面中</li><li>点击修改按钮，获取表单的数据，提交给服务器</li><li>在服务器更新数据</li><li>更新完成后跳转到列表页</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">隐藏域表单：和其他表单标签一样，只是看不到而已</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"id"</span>  <span class="attr">value</span>=<span class="string">"&lt;?php echo $data['id'] ?&gt;"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 高级</title>
      <link href="/2018/javascript/javascript%E9%AB%98%E7%BA%A7/"/>
      <url>/2018/javascript/javascript%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-高级"><a href="#JavaScript-高级" class="headerlink" title="JavaScript 高级"></a>JavaScript 高级</h1><h2 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h2><p><img src="dagang.png" alt="课程大纲"></p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>Everything is object （万物皆对象）</p></blockquote><p>对象到底是什么，我们可以从两次层次来理解</p><p><strong>(1) 对象是具体事物的抽象</strong></p><p>一本书、一辆汽车、一个人都可以是对象，当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程</p><p>问： 书是对象吗</p><p><strong>(2)对象是无序键值对的集合，其属性可以包含基本值、对象或者函数</strong></p><p>每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型</p><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想</p><p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务<br>因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目</p><p><strong>面向对象与面向过程：</strong></p><ul><li>面向过程就是亲历亲为，事无巨细，有条不紊，面向过程是解决问题的一种思维方式，（执行者的角度）<ul><li>关注点在于解决问题的过程（先xx，然后xx，在xx）</li></ul></li><li>面向对象就是找一个对象，让她去做这件事情（指挥者的角度）<ul><li>关注点在找到能解决问题的对象上</li></ul></li><li>面向对象不是面向过程的替代，而是面向过程的封装</li></ul><p><strong>面向对象的特性：</strong></p><ul><li>封装性<ul><li>将功能的具体实现，全部封装到对象的内部，外界使用对象时，只需要关注对象提供的方法如何使用，而不需要关心对象的内部具体实现，这就是封装</li></ul></li><li>继承性<ul><li>在 js 中，继承的概念很简单，一个对象没有的一些属性和方法，另外一个对象有，拿过来用，就实现了继承</li><li><strong>注意：在其他语言里面，继承是类与类之间的关系，在 js 中，是对象与对象之间的关系</strong></li></ul></li><li>[多态性]<ul><li>多态是在强类型的语言中才有的；js 是弱类型语言，所以 js 不支持多态</li></ul></li></ul><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><h3 id="内置构造函数创建"><a href="#内置构造函数创建" class="headerlink" title="内置构造函数创建"></a>内置构造函数创建</h3><p>我们可以直接通过 <code>new Object()</code> 创建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 js 中，对象有动态特性，可以随时的给一个对象增加属性或者删除属性</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">'zs'</span></span><br><span class="line">person.age = <span class="number">18</span></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：麻烦，每个属性都需要添加</p><h3 id="对象字面量创建"><a href="#对象字面量创建" class="headerlink" title="对象字面量创建"></a>对象字面量创建</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：无法批量生成多个对象，代码冗余</p><h3 id="简单改进：工厂函数"><a href="#简单改进：工厂函数" class="headerlink" title="简单改进：工厂函数"></a>简单改进：工厂函数</h3><p>我们可以写一个函数，解决代码重复问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后生成实例对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">'zs'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">'ls'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>缺点：没有解决对象识别的问题，创建出来的对象都是Object类型的</p><h3 id="继续改进：自定义构造函数"><a href="#继续改进：自定义构造函数" class="headerlink" title="继续改进：自定义构造函数"></a>继续改进：自定义构造函数</h3><p>构造函数是一个函数，用于实例化对象，需要配合 new 操作符使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'zs'</span>, <span class="number">18</span>)</span><br><span class="line">p1.sayName() <span class="comment">// zs</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'ls'</span>, <span class="number">23</span>)</span><br><span class="line">p2.sayName() <span class="comment">// ls</span></span><br></pre></td></tr></table></figure><h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><p>使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'zs'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'ls'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>解决方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayHello = sayHello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'zs'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'ls'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>缺点：会暴漏很多的函数，容易造成全局变量污染</p><blockquote><p> 术语：</p><ol><li>实例（实例对象）：通过构造函数创建出来的对象，叫做实例，实例可以有多个</li><li>实例化：构造函数创建对象的过程</li><li>成员：对象的属性和方法</li></ol></blockquote><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型基本概念"><a href="#原型基本概念" class="headerlink" title="原型基本概念"></a>原型基本概念</h3><p>Javascript 规定，每一个函数都有一个 <code>prototype</code> 属性，属性值是一个对象，这个对象就叫做原型（原型对象），这个对象的所有属性和方法，都会被构造函数的实例继承</p><p>这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 <code>prototype</code> 对象上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(...)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(...)</span><br><span class="line"><span class="built_in">console</span>.log(p1.sayName === p2.sayName) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这时所有实例的 <code>sayName()</code> 方法，其实都指向同一个内存地址</p><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p>任意对象都有 <code>__proto__</code> 属性，这个属性指向了构造函数的 prototype 属性，也就是原型对象</p><p>获取原型对象：</p><ul><li>通过 <code>构造函数.prototype</code> 可以获取</li><li>通过 <code>实例.__proto__</code> 可以获取（隐式原型）</li><li>它们指向了同一个对象 <code>构造函数.prototype === 实例.__proto__</code></li></ul><p><strong>注意：<code>__proto__</code>是浏览器的一个隐藏（私有）属性，IE浏览器不支持，不要通过它来修改原型里的内容，如果要修改原型中的内容，使用 <code>构造函数.prototype</code> 去修改</strong></p><h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>默认情况下，原型对象中只包含了一个属性：constructor，constructor 属性指向了当前原型对象的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor) <span class="comment">// 构造函数本身</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="comment">// p 实例对象没有constructor 属性， 该属性来源于原型上</span></span><br><span class="line"><span class="built_in">console</span>.log(p.constructor == Person.prototype.constructor) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="构造函数、实例、原型三者之间的关系"><a href="#构造函数、实例、原型三者之间的关系" class="headerlink" title="构造函数、实例、原型三者之间的关系"></a>构造函数、实例、原型三者之间的关系</h3><p>构造函数：构造函数就是一个函数，配合 new 可以新建对象</p><p>实例：通过构造函数实例化出来的对象我们把它叫做构造函数的实例。一个构造函数可以有很多实例</p><p>原型：每一个构造函数都有一个属性<code>prototype</code>，函数的 prototype 属性值就是原型。通过构造函数创建出来的实例能够直接使用原型上的属性和方法</p><p><img src="sanjiao.png" alt="sanjiao"></p><p>原型三角关系：</p><ul><li><p>构造函数和原型：配偶关系</p><ul><li>构造函数（妈妈），通过 prototype 属性访问原型（爸爸）</li><li>原型通过 constructor 属性访问到构造函数</li></ul></li><li><p>构造函数 和 实例对象：母子关系</p><ul><li>构造函数可以创建实例对象</li><li>实例对象不能直接访问到构造函数</li></ul></li><li><p>原型 和 实例对象关系：父子关系</p><ul><li>实例对象可以直接访问到原型上的所有成员</li><li>实例对象可以间接的访问到构造函数（通过原型上的 constructor 属性）</li></ul></li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="原型链概念"><a href="#原型链概念" class="headerlink" title="原型链概念"></a>原型链概念</h3><p>任何一个对象，都有原型对象，原型对象本身又是一个对象，所以原型对象也有自己的原型对象，这样形成的链式结构，就是原型链</p><p>绘制对象的原型链结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// p ==&gt; Person.prototype  ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="comment">// o ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="comment">// arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Math 是个内置对象，不是个构造函数</span></span><br><span class="line"><span class="comment">// Math ==&gt; Object.prototype ==&gt; null</span></span><br></pre></td></tr></table></figure><p>总结：Object.prototype 是原型链的尽头，Object.prototype 的原型是 null</p><p><img src="proto.png" alt></p><h3 id="属性查找原则"><a href="#属性查找原则" class="headerlink" title="属性查找原则"></a>属性查找原则</h3><p><strong>属性搜索（查找）原则： 沿着原型链进行查找</strong></p><ol><li>首先在当前对象上查找是否有该属性，如果有，直接返回属性值</li><li>如果没有，去对象的原型上查找，如果有，直接返回属性值</li><li>如果也没有， 沿着原型链进行查找，直到 Object.prototype ，如果找到了，就返回属性值，如果还没有，返回 undefined</li></ol><p><strong>属性修改（设置）原则：</strong></p><ol><li>只会修改对象自身的属性</li><li>如果自身没有这个属性，那么就会添加这个属性，并不会修改原型中的属性</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'zs'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.gender = <span class="string">'male'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'ls'</span>, <span class="number">19</span>)</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// p 的原型链：</span></span><br><span class="line"><span class="comment">// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// ls</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age) <span class="comment">// 19</span></span><br><span class="line"><span class="built_in">console</span>.log(p.gender) <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(p.sex) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// p1 对象依旧有 name 和age 属性， 只不过属性值都是 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.gender) <span class="comment">// male</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.sex) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">p.gender = <span class="string">'不详'</span></span><br><span class="line"><span class="built_in">console</span>.log(p.gender) <span class="comment">// 不详</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">'ww'</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// ww</span></span><br></pre></td></tr></table></figure><h3 id="Object-prototype-成员介绍"><a href="#Object-prototype-成员介绍" class="headerlink" title="Object.prototype 成员介绍"></a>Object.prototype 成员介绍</h3><blockquote><p>任何对象的原型链上都有 Object.prototype，根据属性搜索原则(沿着原型链进行查找)，任何对象都可以访问到 Object.prototype 上的成员</p></blockquote><p>constructor：指向了构造函数 Object</p><h4 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a><code>hasOwnProperty</code></h4><p><code>hasOwnProperty()</code> 方法会返回一个布尔值，判断对象自身是否具有该属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断name属性是不是obj自己提供的</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'name'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'toString'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong><code>hasOwnProperty</code> 与 <code>in</code> 的区别</strong></p><ol><li><p><code>in</code> 操作符：判断对象能否访问到该属性（不管这个属性是自己提供的，还是从原型上继承来的），如果可以访问到， 都会返回 true</p></li><li><p><code>hasOwnProperty</code>：该属性必须是自己提供，才返回 true，否则返回 false</p></li></ol><p><strong>hasOwnProperty 的使用场景</strong>：用在for…in 循环中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> p) &#123;</span><br><span class="line">  <span class="comment">// 可以遍历到对象自身的属性以及对象原型链上的属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只遍历得到对象自身的属性，if 条件过滤下</span></span><br><span class="line">  <span class="comment">// if (p.hasOwnProperty(k)) &#123;</span></span><br><span class="line">  <span class="comment">// console.log(k)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf"></a><code>isPrototypeOf</code></h4><p><code>isPrototypeOf()</code> 方法用于测试一个对象是否存在于另一个对象的原型链上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 A 对象是否在 B 对象的原型链上</span></span><br><span class="line"><span class="comment">// 返回值：true，在原型链上  false：不在原型链上</span></span><br><span class="line">A.isPrototetypeOf(B)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line"><span class="comment">// p 的原型链：</span></span><br><span class="line"><span class="comment">// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.isPrototypeOf(p)) <span class="comment">// false Person 是构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(p)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(p)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong><code>isPropertyOf</code> 与 <code>instanceof</code> 运算符的区别</strong></p><p><code>instanceof</code> 运算符用来测试一个对象的原型链中是否存在一个构造函数的 <code>prototype</code> 属性。作用和isPrototypeOf 类似</p><p>语法： 实例对象 instanceof 构造函数</p><p>作用：构造函数的 prototype 属性是否在实例对象的原型链上</p><ul><li>A.isPrototypeOf(B)  判断A是否在B的原型链上                          A： 是一个原型对象</li><li>B instanceof A         判断A的prototype是否在B的原型链上     A：是一个构造函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isPrototypeOf([])) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.isPrototypeOf([])) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>.prototype) <span class="comment">// 语法错误，instanceof 的右边是个构造函数</span></span><br></pre></td></tr></table></figure><h4 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable"></a><code>propertyIsEnumerable</code></h4><p><code>propertyIsEnumerable()</code> 方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">19</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'lw'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.propertyIsEnumerable(<span class="string">'name'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.propertyIsEnumerable(<span class="string">'age'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>拓展：给对象添加不可遍历的属性 : <code>Object.defineProperty()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法： Object.defineProperty(obj, prop, desc)</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// obj： 给哪个对象添加属性</span></span><br><span class="line"><span class="comment">// prop：属性， 类型是字符串</span></span><br><span class="line"><span class="comment">// desc： 属性描述符， 类型是个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作用： 定义对象的属性特征</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给obj 添加一个不可遍历的 gender 属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'gender'</span>, &#123;</span><br><span class="line">  value: <span class="string">'female'</span>, <span class="comment">// 配置该属性的默认值</span></span><br><span class="line">  writable: <span class="literal">true</span>, <span class="comment">// 配置该属性是否可以被修改， 默认值是false， 不可修改</span></span><br><span class="line">  enumerable: <span class="literal">true</span> <span class="comment">// 配置该属性是否可遍历， 默认值是false， 不可遍历</span></span><br><span class="line">&#125;)</span><br><span class="line">obj.gender = <span class="string">'male'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj.propertyIsEnumerable(<span class="string">'gender'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="toString-toLocaleString"><a href="#toString-toLocaleString" class="headerlink" title="toString/toLocaleString"></a>toString/toLocaleString</h4><p>返回对象的字符串格式</p><blockquote><p>每个内置对象的原型上都有属于自己的 toString 方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()) <span class="comment">// '[object Object]'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.toLocaleString()) <span class="comment">// '[object Object]'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// arr ==&gt;  Array.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="comment">//           toString()         toString()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype) <span class="comment">// 含有自己的 toString 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// '1,2,3'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toLocaleString()) <span class="comment">// '1,2,3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">//  date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="comment">//           toString()          toString()</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype) <span class="comment">// 含有自己的 toString 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toString()) <span class="comment">// Wed Oct 10 2018 16:00:51 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toLocaleString()) <span class="comment">// 2018/10/10 下午4:00:51 得到的是本地时间格式</span></span><br></pre></td></tr></table></figure><h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h4><p>语法： 对象.valueOf()</p><p>作用： 返回对象的原始值（简单数据类型），默认的 valueOf 方法（Object.prototype 上的valueOf 方法）只会返回对象自身；日期对象的 valueOf 方法返回的是时间戳，因为 Date 的原型链上有自己的 valueOf 方法，该valueOf 的作用就是返回日期的时间戳</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  age: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.valueOf()) <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">// arr ==&gt;  Array.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.valueOf()) <span class="comment">// arr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="comment">// date 原型链</span></span><br><span class="line"><span class="comment">// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.prototype) <span class="comment">// 含有 valueOf 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(date.valueOf()) <span class="comment">// 时间戳</span></span><br></pre></td></tr></table></figure><h4 id="valueOf-和-toString-的应用"><a href="#valueOf-和-toString-的应用" class="headerlink" title="valueOf 和 toString 的应用"></a>valueOf 和 toString 的应用</h4><p>当对象在参与运算和比较的时候，js 内部会自动的调用 valueOf 和 toString 方法</p><p> 调用规则：</p><ol><li><p>默认先调用 vauleOf， 尝试将对象转成简单数据类型， 如果没有转成简单数据类型， 会继续在调用 toString 方法</p></li><li><p>如果 valueOf 和 toString 方法都没有转成简单数据类型，会报错</p></li></ol><h2 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h2><p>沙箱其实就是一个独立的环境，这个环境中任何的改变，都不会对外部环境产生影响</p><p>函数自调用一样，在自调用函数内部的变量是不会影响到外部的，因此<strong>函数自调用模式也叫沙箱模式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"这是fn函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><ol><li>代码写在自调用函数里面，减少全局污染</li><li>想要在外面使用 fn 函数，可将 fn 暴露到全局 <code>window.fn = fn;</code>  将fn函数的地址赋值给了 window上的 fn 属性</li><li>一般，我们一个js文件只会暴露一个核心的功能（函数、方法）： 目的还是为了减少全局污染</li></ol><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><ul><li>语法：<code>&#39;use strict&#39;</code></li><li>作用：让js引擎以更加严格的模式执行js代码</li><li>最佳实践：在某个函数内部开启严格模式，而不是在全局环境中开启</li><li>注意：<ul><li>严格模式只对当前作用域起作用</li><li>应该<strong>在当前作用域最顶端使用<code>use strict</code>，否则严格模式无效</strong></li></ul></li><li>使用严格模式好处：<ul><li>规范</li><li>提高代码执行效率</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格模式应该配合沙箱模式一起使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 沙箱模式 + 严格模式：</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span></span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="严格模式规定"><a href="#严格模式规定" class="headerlink" title="严格模式规定"></a>严格模式规定</h3><ul><li>变量必须显示声明</li><li>函数参数不能重名</li><li>禁止使用八进制</li><li>不能使用保留字作为变量名称：<code>implements, interface, let, package, private, protected, public, static, yield</code></li><li>如果不符合上述规范，会直接报错</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>继承：子承父业</p></blockquote><p>在 js 中的继承概念非常简单，拿来主义：一个对象自己没有的属性和方法，另一个对象有，拿过来使用，就实现了继承。</p><p>继承的目的：让一个对象可以使用另一个对象的属性和方法。</p><h3 id="混入式继承（mixin）"><a href="#混入式继承（mixin）" class="headerlink" title="混入式继承（mixin）"></a>混入式继承（mixin）</h3><blockquote><p>把一个对象中的属性和方法拷贝到另一个对象中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ls = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  extend: <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 只拷贝对象obj自身的成员，原型链上的成员不用拷贝给this</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">      <span class="keyword">this</span>[k] = obj[k]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>一个对象可以访问构造函数的原型中的属性和方法，那么如果想要让一个对象增加某些属性和方法，</p><p>只需要把这些属性和方法放到原型对象中即可。这样就实现了继承, 称之为原型链继承</p><ul><li>直接给原型增加属性和方法</li><li>原型替换（注意：constructor）</li><li>mixin+原型替换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 直接给原型增加属性和方法（麻烦）</span></span><br><span class="line">Person.prototype.color = <span class="string">'lime'</span></span><br><span class="line">Person.prototype.legs = <span class="number">2</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sayHi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 原型替换，将原型替换成一个对象</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="comment">// 手动添加一个constructor属性，如果不手动添加，会找到 Object 的 constructor 属性</span></span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line"></span><br><span class="line">  color: 'lime',</span><br><span class="line">  legs: 2,</span><br><span class="line">  sayHi: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sayHi'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 原型链 + 混入式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> lw = &#123;</span><br><span class="line">  skill: <span class="string">'翻墙'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给原型添加 extend 方法  -- 混入式继承</span></span><br><span class="line">Person.prototype.extend = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">      <span class="keyword">this</span>[k] = obj[k]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把 lw 的成员添加到了 Person 的原型上， Person 的实例就可以访问到原型上的这个成员</span></span><br><span class="line">Person.prototype.extend(lw)</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype)</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p.skill)</span><br></pre></td></tr></table></figure><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><blockquote><p>最初是由道格拉斯丶克罗克福德发布的一篇文章提出的，ECMAScript5 新增了 Object.create() 方法来规范化了这种继承</p></blockquote><p>ES5 中新增了一个方法 <code>Object.create()</code>，方法会使用指定的原型对象及其属性去创建一个新的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：proto 一个对象</span></span><br><span class="line"><span class="comment">// 返回值：obj 新对象，新对象的原型就是 proto</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(proto)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="定义函数的三种方式"><a href="#定义函数的三种方式" class="headerlink" title="定义函数的三种方式"></a>定义函数的三种方式</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn() <span class="comment">// 函数声明可以先调用，在声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'这是函数声明'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'这是函数表达式'</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 函数表达式必须先声明，再调用</span></span><br></pre></td></tr></table></figure><h4 id="构造函数-Function"><a href="#构造函数-Function" class="headerlink" title="构造函数 Function"></a>构造函数 Function</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数也是对象，可以使用 Function 构造函数 new 出来</span></span><br><span class="line"><span class="comment">// 相当于var fn = function () &#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法：new Function(arg1,arg2,arg3..,body)</span></span><br><span class="line"><span class="comment">// 1. 所有的参数都是字符串类型</span></span><br><span class="line"><span class="comment">// 2. 前面可以定义任意多个形参，最后一个参数是代码体</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'alert(1)'</span>)</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a1'</span>, <span class="string">'a2'</span>, <span class="string">'alert(a1 + a2)'</span>)</span><br><span class="line">fn1(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>【案例：代码实时预览效果.html】</p><h4 id="eval-函数–了解"><a href="#eval-函数–了解" class="headerlink" title="eval 函数–了解"></a>eval 函数–了解</h4><blockquote><p>eval 可以和 new Function 一样，执行字符串代码</p></blockquote><p>注意：eval 函数的功能非常的强大，但是实际使用的情况并不多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var num = 10; console.log(num)'</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><ul><li>eval 形式的代码难以阅读</li><li>eval 形式的代码无法打断点，因为本质还是还是一个字符串</li><li>在浏览器端执行任意的 JavaScript 会带来潜在的安全风险，恶意的 JavaScript 代码可能会破坏应用，特别是在用它执行用户输入数据的情况下。可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）<br><a href="http://qingbob.com/Excess-XSS/" target="_blank" rel="noopener">推荐了解下xss攻击</a></li></ul><h3 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h3><p>分析 this 的指向问题</p><ol><li>任何函数都有属于自己的 this</li><li>this 是动态的，this 在函数声明的时候是确定不了的，只有当函数被调用了才能够确定 this 的指向，this 的指向和函数在哪被调用没有关系</li></ol><p>分析 this 的问题的思路：</p><ol><li>this 是属于哪个函数</li><li><strong>这个函数是何种调用模式</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数：当一个函数不是一个对象的属性时，我们称之为函数</span><br><span class="line">方法：当一个函数被保存为对象的一个属性时，我们称之为方法</span><br></pre></td></tr></table></figure><h4 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h4><p><font color="red">如果一个函数不是一个对象的属性时，就是被当做一个函数来进行调用的。此时 this 指向了 window</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数名() 的调用方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 指向window</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><h4 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h4><p><font color="red">当一个函数被保存为对象的一个属性时，我们称之为一个方法。当一个方法被调用时，this 被绑定到当前对象</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过点语法或者中括号语法来访问方法，都是属于方法调用模式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  fn: f</span><br><span class="line">&#125;</span><br><span class="line">obj.fn() <span class="comment">// obj</span></span><br><span class="line">obj[<span class="string">'fn'</span>]() <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [f, <span class="number">10</span>, <span class="number">30</span>]</span><br><span class="line"><span class="comment">// 也是方法调用模式</span></span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">// arr</span></span><br></pre></td></tr></table></figure><h4 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h4><p><font color="red">如果函数是通过 new 关键字进行调用的，此时 this 被绑定到创建出来的新对象上</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Person() <span class="comment">// this 指向 window</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person() <span class="comment">// this 指向 p</span></span><br></pre></td></tr></table></figure><p><strong>总结：分析 this 的问题，主要就是区分函数的调用模式，看函数是怎么被调用的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析思路：1. 看 this 是哪个函数的  2. 看这个函数是怎么调用的，处于什么调用模式</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">38</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = obj.getAge</span><br><span class="line">f() <span class="comment">// window ==&gt; 38</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">38</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age) <span class="comment">// obj ==&gt; 18</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.age) <span class="comment">// window ==&gt; 38</span></span><br><span class="line">    &#125;</span><br><span class="line">    foo()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getAge()</span><br><span class="line"><span class="comment">// obj['getAg']()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [fn, <span class="string">'222'</span>]</span><br><span class="line">fn() <span class="comment">// 10</span></span><br><span class="line">arr[<span class="number">0</span>]() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">5</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn() <span class="comment">// window ==&gt; 10</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]() <span class="comment">// argument ==&gt; 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.method(fn, <span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="方法借用模式"><a href="#方法借用模式" class="headerlink" title="方法借用模式"></a>方法借用模式</h4><blockquote><p>上下文调用模式也叫方法借用模式，分为 apply，call ，bind</p><p>使用方法：<code>函数.call()</code> 或者 <code>函数.apply()</code></p></blockquote><p>任何函数都可以调用 apply，call ，bind 这三个方法</p><h5 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call 方法</h5><p>call 方法可以调用一个函数，并且可以指定这个函数的 <code>this</code> 指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call 方法也可以和 () 一样，进行函数调用</span></span><br><span class="line"><span class="comment">// 第一个参数：指定函数的 this，如果不传，则 this 指向 window</span></span><br><span class="line"><span class="comment">// 其余参数：和函数的参数列表一模一样</span></span><br><span class="line"><span class="keyword">var</span> zs = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello ,我是'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// zs.sayHi()</span></span><br><span class="line"><span class="keyword">var</span> ls = &#123;</span><br><span class="line">  name: <span class="string">'ls'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ls 借用 zs 的 sayHi 方法</span></span><br><span class="line">zs.sayHi.call(ls)</span><br></pre></td></tr></table></figure><h5 id="伪数组与数组"><a href="#伪数组与数组" class="headerlink" title="伪数组与数组"></a>伪数组与数组</h5><blockquote><p>伪数组也叫类数组</p></blockquote><ol><li>伪数组其实就是一个对象，但是跟数组一样，伪数组也会有<code>length</code>属性，也有<code>0, 1, 2, 3</code>等属性</li><li>伪数组并没有数组的方法，不能使用<code>push/pop</code>等方法</li><li>伪数组可以跟数组一样进行遍历，通过下标操作</li><li>常见的伪数组：<code>arguments</code>、<code>document.getElementsByTagName的返回值</code>、<code>jQuery对象</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'zs'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'ls'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'ww'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>伪数组借用数组的方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给 obj 添加一项 3: 'zl'</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(obj, <span class="string">'zl'</span>)</span><br><span class="line"><span class="comment">// 把 obj 中的每一项使用 '-' 拼接起来返回一个字符串</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(obj, <span class="string">'-'</span>)</span><br></pre></td></tr></table></figure><ul><li>将伪数组转换成真数组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(obj)</span><br></pre></td></tr></table></figure><h5 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a>apply 方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apply 的语法：</span><br><span class="line">apply(thisArg, 实参列表)</span><br><span class="line">thisArg ==&gt; 改变函数内的 this 指向的</span><br><span class="line">实参列表 ==&gt; 是一个数组或者是伪数组</span><br></pre></td></tr></table></figure><blockquote><p><code>apply()</code>方法的作用和 <code>call()</code>方法类似，只有一个区别，就是<code>apply()</code>方法接受的是<strong>一个包含多个参数的数组</strong>。而<code>call()</code>方法接受的是<strong>若干个参数的列表</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. apply 能够调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. apply 改变 this 指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]) <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. apply 第二个参数是数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(n1 + n2)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(&#123; <span class="attr">name</span>: <span class="string">'zs'</span> &#125;, [<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">// &#123;name: 'zs'&#125;, 30</span></span><br><span class="line"><span class="comment">// apply 的特性： 平铺性，把数组中的每一项取出来作为函数的实参</span></span><br><span class="line"><span class="comment">// fn.call(&#123;name: 'ls'&#125;, 10, 20) // &#123;&#125;, 30</span></span><br></pre></td></tr></table></figure><p>call 和 apply 的使用场景：</p><ul><li>如果参数比较少，使用 call 会更加简洁</li><li>如果参数存放在数组中，此时需要使用 apply</li></ul><p>课后练习：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">求数组的最大值和最小值</span><br><span class="line">封装一个函数，能够打印出来所有的参数</span><br></pre></td></tr></table></figure><h5 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h5><p>*<em>bind() *</em>方法创建一个新的函数、可以绑定新的函数的<code>this</code>指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值：新的函数(不会被调用)</span></span><br><span class="line"><span class="comment">// 参数：新函数的 this 指向，当绑定了新函数的 this 指向后，无论使用何种调用模式，this 都不会改变</span></span><br><span class="line"><span class="comment">// var newFn = fn.bind(window)</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newFn = fn.bind([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// newFn 是 bind 创建并返回出来的</span></span><br><span class="line"><span class="built_in">console</span>.log(newFn)</span><br><span class="line">newFn() <span class="comment">// this ==&gt; [1,2,3]</span></span><br></pre></td></tr></table></figure><h4 id="几种特殊的-this-指向"><a href="#几种特殊的-this-指向" class="headerlink" title="几种特殊的 this 指向"></a>几种特殊的 this 指向</h4><ul><li>定时器中的 this 指向了window，因为定时器的 function 最终是由 window 来调用的</li><li>事件中的 this 指向的是当前的元素，在事件触发的时候，浏览器让当前元素调用了 function</li></ul><h3 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h3><blockquote><p>函数是由 new Function 创建出来的，因此函数也是一个对象，<code>所有的函数都是 new Function 的实例</code></p></blockquote><h4 id="函数的原型链结构"><a href="#函数的原型链结构" class="headerlink" title="函数的原型链结构"></a>函数的原型链结构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部：var Person = new Function()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// Person 实例对象的原型链：</span></span><br><span class="line"><span class="comment">// Person ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null</span></span><br><span class="line"><span class="comment">// Function.prototype 原型类型是个函数</span></span><br><span class="line"><span class="built_in">console</span>.dir(<span class="built_in">Function</span>.prototype)</span><br></pre></td></tr></table></figure><p><img src="function.jpg" alt></p><h4 id="Function-prototype-成员"><a href="#Function-prototype-成员" class="headerlink" title="Function.prototype 成员"></a>Function.prototype 成员</h4><ul><li>arguments：获取函数的实参，已经被废弃了，现在推荐的做法是使用函数内部可用的 <code>arguments</code>对象来访问函数的实参<ul><li>（废弃的意思：已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性）</li></ul></li><li>length：获取形参的长度</li><li>name：获取函数的名字，此属性不允许修改</li><li>caller: 用于获取当前函数是在哪个函数中调用的，已经被废弃了</li><li>constructor：指向当前构造函数，Function</li><li>call：调用函数，重新指定 this</li><li>apply：调用函数，重新指定 this</li><li>bind：重新指向 this，返回一个新的函数，不调用</li><li>toString :  得到函数的字符串格式</li></ul><p>案例【封装getType函数（获取数据类型）】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, <span class="number">-1</span>) <span class="comment">// '[object 构造函数]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整版原型链"><a href="#完整版原型链" class="headerlink" title="完整版原型链"></a>完整版原型链</h4><blockquote><p>绘制完整版原型链的目的是辅助大家理解 js 中对象的继承关系</p></blockquote><p><img src="full.png" alt></p><p>总结：</p><ol><li>所有函数都是 new Function 创建出来的，因此 <code>所有函数.__proto__</code> 都是 <code>Function.prototype</code></li><li>所有对象都是 new Object 创建出来的，因此 <code>所有对象.__proto__</code> 都是 <code>Object.prototype</code></li></ol><h3 id="预解析与作用域"><a href="#预解析与作用域" class="headerlink" title="预解析与作用域"></a>预解析与作用域</h3><h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><blockquote><p>预解析：预先解析</p></blockquote><p>js执行代码分为两个过程：</p><ul><li>预解析过程（变量与函数提升）</li><li>代码一行一行执行</li></ul><p>预解析过程：JavaScript解析器在执行代码前，会把所有变量的声明和函数的声明提升到当前作用域的顶部。例如<code>var a = 11</code>其实会分为<code>var a</code> 和<code>a = 11</code>两部分，其中<code>var a;</code>会被提升。</p><p>预解析规则：</p><ol><li>函数优先，先提升 function，后提升 var</li><li>遇到重名的 var 会被忽略</li><li>遇到重名的 function 会被覆盖</li></ol><ul><li>思考以下代码的结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a 函数体</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaaaa'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'a'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'abc'</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p><strong>推荐：不要在一个作用域内重复的声明相同的变量和函数</strong></p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><blockquote><p>作用域：变量起作用的区域，也就是说：变量定义后，可以在哪个范围内使用该变量</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">11</span> <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">22</span> <span class="comment">// 局部变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 全局变量在任何地方都能访问到</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br></pre></td></tr></table></figure><p>编程语言中，作用域规则分为两种：</p><ul><li>词法作用域</li><li>块级作用域 — js没有块级作用域</li></ul><blockquote><ol><li><p>全局变量：在函数外使用 var 声明的变量， 在任何地方都可以访问到</p></li><li><p>局部变量：在函数内使用 var 声明的变量，只能在函数内部访问到</p></li><li><p>自由变量：对于一个函数来说，函数内部没有声明该变量，但在函数内部有访问该变量。对于这个函数来说， 该变量就是一个自由变量。</p></li></ol></blockquote><p>在 js 里只有函数可以形成作用域，所有 <strong>词法作用域</strong> 又叫函数作用域。</p><p>因为函数能够形成作用域，所以函数内部声明的变量函数外部无法访问</p><p><strong>函数作用域是在函数定义的时候作用域就确定下来了，和函数在哪调用无关</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">456</span></span><br><span class="line">  f1()</span><br><span class="line">&#125;</span><br><span class="line">f2() <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><blockquote><p>作用域链：只要是函数，就会形成一个作用域，如果这个函数被嵌套在其他函数中，那么外部函数也有自己的作用域，这个一直往上到全局环境，就形成了一个作用域链。</p></blockquote><p><code>变量的搜索原则</code>：</p><ol><li>从当前作用域开始查找是否声明了该变量，如果存在，那么就直接返回这个变量的值。</li><li>如果不存在，就会往上一层作用域查询，如果存在，就返回。</li><li>如果不存在，一直查询到全局作用域，如果存在，就返回。如果在全局中也没有找到该变量会<strong>报错</strong></li></ol><h4 id="作用域链练习"><a href="#作用域链练习" class="headerlink" title="作用域链练习"></a>作用域链练习</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">fn1()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 -- 改造上面的面试题</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">fn1()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 10</span></span><br><span class="line">  num = <span class="number">20</span></span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">// 456 undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">456</span></span><br><span class="line">  f1(num)</span><br><span class="line">  f1()</span><br><span class="line">&#125;</span><br><span class="line">f2()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">num1</span>) </span>&#123;</span><br><span class="line">  num1 = <span class="number">100</span></span><br><span class="line">  num2 = <span class="number">200</span></span><br><span class="line">  num3 = <span class="number">300</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1) <span class="comment">// 100</span></span><br><span class="line">  <span class="built_in">console</span>.log(num2) <span class="comment">// 200</span></span><br><span class="line">  <span class="built_in">console</span>.log(num3) <span class="comment">// 300</span></span><br><span class="line">  <span class="keyword">var</span> num3</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(num1) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 200</span></span><br><span class="line"><span class="built_in">console</span>.log(num3) <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">100</span></span><br><span class="line">  num++</span><br><span class="line">  <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 101</span></span><br><span class="line">fn() <span class="comment">// 101</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.</span></span><br><span class="line"><span class="keyword">var</span> color = <span class="string">'red'</span> <span class="comment">// blue</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> anotherColor = <span class="string">'blue'</span> <span class="comment">// red</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmpColor = color <span class="comment">// red</span></span><br><span class="line">    color = anotherColor</span><br><span class="line">    anotherColor = tmpColor <span class="comment">// red</span></span><br><span class="line">    <span class="built_in">console</span>.log(anotherColor) <span class="comment">// red</span></span><br><span class="line">  &#125;</span><br><span class="line">  inner()</span><br><span class="line">&#125;</span><br><span class="line">outer()</span><br><span class="line"><span class="built_in">console</span>.log(color) <span class="comment">// blue</span></span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><blockquote><p>递归函数：函数内部直接或者间接的调用自己</p></blockquote><p>递归的要求：</p><ol><li>自己调用自己（直接或者间接）</li><li>要有结束条件（出口）</li></ol><p>递归函数主要是<code>化归思想</code>，将一个复杂的问题简单化，主要用于解决数学中的一些问题居多。</p><ul><li>把要解决的问题，归结为已经解决的问题上。</li><li>一定要考虑什么时候结束让函数结束，也就是停止递归（一定要有已知条件）</li></ul><p>练习：</p><ul><li>计算1-100之间所有数的和</li><li>计算斐波那契数列</li></ul><h4 id="实现缓存"><a href="#实现缓存" class="headerlink" title="实现缓存"></a>实现缓存</h4><blockquote><p>缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据</p></blockquote><p>计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。</p><p>初级优化：</p><p>使用缓存的基本步骤：</p><ul><li>如果要获取数据，先查询缓存，如果有就直接使用</li><li>如果没有，就进行计算，并且将计算后的结果放到缓存中，方便下次使用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">var</span> fbi = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[n]) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[n]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = fbi(n - <span class="number">1</span>) + fbi(n - <span class="number">2</span>)</span><br><span class="line">    arr[n] = temp <span class="comment">// 存入缓存</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包的基本概念"><a href="#闭包的基本概念" class="headerlink" title="闭包的基本概念"></a>闭包的基本概念</h3><p><code>闭包（closure）</code>是 JavaScript 语言的一个难点，也是 JavaScript 的一个特色，很多高级的应用都要依靠闭包来实现</p><blockquote><p>闭包是函数和声明该函数的词法环境的组合</p></blockquote><p>在JavaScript中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，产生闭包</p><p>*<em>闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用 *</em></p><p>产生闭包的条件：有两个函数，是嵌套关系，内部函数引用了外部函数的变量，这样就会形成闭包</p><p>闭包的作用：</p><ul><li>私有变量，保护数据安全</li><li>持久化维持数据</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包的基本模型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line">  <span class="comment">// function inner () &#123;</span></span><br><span class="line">  <span class="comment">//   num++</span></span><br><span class="line">  <span class="comment">//   console.log(num)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// return inner  // 把inner函数给返回出去，让外部能够调用inner函数</span></span><br><span class="line">  <span class="comment">// 上面的简写</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    num++</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>需求：统计一个函数的调用次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我被调用了，调用次数是'</span> + count)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// 缺点：count是全局变量，不安全</span></span><br></pre></td></tr></table></figure><p>使用闭包解决这个问题！！！！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span> <span class="comment">// 私有变量, 将 count 保护起来了</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'当前count'</span> + count)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> add</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = outer()</span><br><span class="line">result()</span><br></pre></td></tr></table></figure><p>【案例：银行存钱取钱】</p><h4 id="缓存的私有化"><a href="#缓存的私有化" class="headerlink" title="缓存的私有化"></a>缓存的私有化</h4><blockquote><p>缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据。</p></blockquote><p>计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。</p><p>缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fbi = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[n]) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr[n]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> temp = fbi(n - <span class="number">1</span>) + fbi(n - <span class="number">2</span>)</span><br><span class="line">      arr[n] = temp <span class="comment">//存入缓存</span></span><br><span class="line">      <span class="keyword">return</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fbi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fbi = outer()</span><br><span class="line"><span class="built_in">console</span>.log(fbi(<span class="number">40</span>))</span><br></pre></td></tr></table></figure><h3 id="闭包存在的问题"><a href="#闭包存在的问题" class="headerlink" title="闭包存在的问题"></a>闭包存在的问题</h3><blockquote><p>正常情况下：函数在调用的时候，去开辟一块内存空间用来执行内部的代码，当函数调用结束的时候，要销毁开辟的空间，节省内存</p><p>闭包占用的内存是不会被释放的，因此，如果滥用闭包，会造成内存泄漏的问题。闭包很强大，但是只有在必须使用闭包的时候才使用</p></blockquote><h4 id="js的垃圾回收机制-了解"><a href="#js的垃圾回收机制-了解" class="headerlink" title="js的垃圾回收机制(了解)"></a>js的垃圾回收机制(了解)</h4><ul><li>内存：计算机中所有程序的运行都是在<code>内存</code> 中进行的，因此内存的性能对计算机的影响非常大，运行程序需要消耗内存，当程序结束时，内存会得到释放。</li><li>javascript 分配内存：当我们定义变量，javascript 自动分配内存存储数据。无论是值类型或者是引用类型，都需要存储在内存中。</li><li>垃圾回收：当代码执行结束，分配的内存已经不需要了，这时候需要将内存进行回收，在 javascript语言中，<code>垃圾回收机器</code>会帮我们回收<code>不再需要使用</code>的内存。</li></ul><h5 id="引用记数法清除"><a href="#引用记数法清除" class="headerlink" title="引用记数法清除"></a>引用记数法清除</h5><p>引用记数垃圾收集：如果没有引用指向某个对象（或者是函数作用域），那么这个对象或者函数作用域就会被垃圾回收机制回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象被 o 变量引用，引用记数 1</span></span><br><span class="line"><span class="keyword">var</span> obj = o <span class="comment">// 变量被 o 和 obj 引用，引用记数 2</span></span><br><span class="line">o = <span class="number">1</span> <span class="comment">// o 不在引用对象了，引用记数 1</span></span><br><span class="line">obj = <span class="literal">null</span> <span class="comment">// obj 不在引用对象了，引用记数 0，可以被垃圾回收了</span></span><br></pre></td></tr></table></figure><p>引用计数法无法解决循环引用导致的内存泄露</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj1 = &#123;&#125; <span class="comment">// 引用计数为 2</span></span><br><span class="line">    <span class="keyword">var</span> obj2 = &#123;&#125; <span class="comment">// 引用计数为 2</span></span><br><span class="line">    obj1.a = obj2</span><br><span class="line">    obj2.b = obj1</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 销毁fn调用开辟的空间， 但是由于引用计数考虑到两个对象都不是零引用的对象，就不能够被垃圾回收机制给回收掉</span></span><br></pre></td></tr></table></figure><h5 id="标记清除法清除"><a href="#标记清除法清除" class="headerlink" title="标记清除法清除"></a>标记清除法清除</h5><p>使用引用计数法进行垃圾回收的时候，会出现循环引用导致内存泄漏的问题。因此现代的浏览器都采用标记清除法来进行垃圾回收。</p><p>这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象 Window）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p><p><strong>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。</strong></p><h4 id="闭包占用内存释放"><a href="#闭包占用内存释放" class="headerlink" title="闭包占用内存释放"></a>闭包占用内存释放</h4><p>当闭包的功能不在需要使用了，将这个变量指向 <code>null</code>， 这样闭包占用的内存就可以被回收掉了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count++</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行次数'</span> + count)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = outer()</span><br><span class="line">result()</span><br><span class="line">result = <span class="literal">null</span> <span class="comment">// 当函数 fn 没有被变量引用了，那么函数 fn 就会被回收，函数 fn 一旦被回收，那么 outer调用形成的作用域也就得到了释放</span></span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串（数据验证）、将匹配的子串替换（数据删除或替换）或者从某个串中取出符合某个条件的子串等（数据提取）。</p></blockquote><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><ul><li>构造函数的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegExp  （regular expression）</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/a/</span>); <span class="comment">// 匹配字母中有a</span></span><br></pre></td></tr></table></figure><ul><li>正则字面量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a/</span></span><br></pre></td></tr></table></figure><p>正则有 test 方法，作用是测试字符串是否符合正则表达式的规律，如果符合， 返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'abc'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">'def'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><blockquote><p>正则表达式由一些普通字符和元字符组成，普通字符包括大小写字母、数字等，而元字符则具有特殊的含义。</p></blockquote><h4 id="常见元字符"><a href="#常见元字符" class="headerlink" title="常见元字符"></a>常见元字符</h4><ul><li><p><code>\d</code>    匹配一个数字字符。等价于 <code>[0-9]</code></p></li><li><p><code>\D</code>    匹配一个非数字字符。等价于 <code>[^0-9]</code></p></li><li><p><code>\w</code>    匹配包括下划线的任何单词字符。等价于<code>[A-Za-z0-9_]</code></p></li><li><p><code>\W</code>    匹配任何非单词字符。等价于 <code>[^A-Za-z0-9_]</code></p></li><li><p><code>\s</code>    匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[\f\n\r\t\v]</code></p></li><li><p><code>\S</code>    匹配任何非空白字符。等价于 <code>[^\f\n\r\t\v]</code></p></li><li><p><code>\</code> 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。<code>\\</code> 匹配 <code>\</code>，<code>\(</code> 则匹配 <code>(</code>。</p></li><li><p><code>.</code> 匹配除换行符 <code>\n</code> 之外的任何单字符。要匹配包括 ‘\n’ 在内的任何字符，可用<code>(.|\n)</code></p></li></ul><ul><li><p><code>|</code> 指明两项之间的一个选择。，优先级最低，| 的左右都是单独的整体</p></li><li><p><code>()</code> 优先级最高，标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。使用 $0…$9 属性。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code> 。每个()就是一个子匹配 ‘\1’和’$1’用来指定第一个子匹配</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/f|boot/; <span class="comment">// 匹配 `f` 和 `boot`</span></span><br><span class="line">/(f|b)oot/; <span class="comment">// 匹配 `foot` 和 `boot`</span></span><br></pre></td></tr></table></figure><h4 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h4><ul><li><code>\f</code>    匹配一个换页符</li><li><code>\n</code>    匹配一个换行符</li><li><code>\r</code>    匹配一个回车符</li><li><code>\t</code>    匹配一个制表符</li><li><code>\v</code>    匹配一个垂直制表符</li></ul><h4 id="字符类的元字符"><a href="#字符类的元字符" class="headerlink" title="字符类的元字符"></a>字符类的元字符</h4><ul><li><code>[]</code> 在正则表达式中表示 <strong>单个</strong> 字符的位置，[] 里面写这个位置可以出现的字符。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[abc]/; <span class="comment">// 匹配 a,b,c 任意一个字符</span></span><br></pre></td></tr></table></figure><ul><li><code>[^]</code> 在中扩号中的 <code>^</code> 表示非的意思。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ^ 在方括号表达式开头中使用，此时它表示不接受该字符集合</span></span><br><span class="line">/[^abc]/; <span class="comment">// 匹配除了a，b，c以外的其他字符</span></span><br></pre></td></tr></table></figure><ul><li><code>[a-z]</code> <code>[1-9]</code>表示范围</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/[a-z]/; <span class="comment">// 小写字母</span></span><br><span class="line">/[A-Z]/; <span class="comment">// 大写字母</span></span><br><span class="line">/[<span class="number">0</span><span class="number">-9</span>]/; <span class="comment">// 数字</span></span><br><span class="line">/[a-zA-Z0<span class="number">-9</span>]/; <span class="comment">// 所有的小写字母和大写字母以及数字</span></span><br></pre></td></tr></table></figure><h4 id="边界类元字符"><a href="#边界类元字符" class="headerlink" title="边界类元字符"></a>边界类元字符</h4><blockquote><p>我们前面学习的正则只要有满足的条件的就会返回true，并不能做到精确的匹配。</p></blockquote><ul><li><p><code>^</code> 匹配输入字符串的开始位置</p></li><li><p><code>$</code> 匹配输入字符串的结尾位置</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/^chuan/; <span class="comment">// 以chuan开头</span></span><br><span class="line">/chuan$/; <span class="comment">// 以chuan结尾</span></span><br><span class="line">/^chuan$/; <span class="comment">// 精确匹配 chuan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//精确匹配chuan,表示必须是这个</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^chuan$/</span>.test(<span class="string">"chuanchuan"</span>)); <span class="comment">// fasle</span></span><br></pre></td></tr></table></figure><blockquote><p>以后表单校验要精确匹配</p></blockquote><ul><li><code>\b</code> 匹配一个字边界，即字与空格间的位置。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。<ul><li>Chapter：<br><code>/\bCha/</code> : 匹配Chapter的开头三个字符<br><code>/ter\b/</code> : 匹配Chapter的结尾三个字符</li></ul></li><li><code>\B</code> 表示非单词边界。位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。<br>下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt<br><code>/\Bapt/</code></li></ul><h4 id="量词类元字符"><a href="#量词类元字符" class="headerlink" title="量词类元字符"></a>量词类元字符</h4><blockquote><p>量词用来控制出现的次数，一般来说量词和边界会一起使用</p></blockquote><ul><li><code>*</code> 匹配前面的子表达式零次或多次，等价于 <code>{0,}</code></li><li><code>+</code> 匹配前面的子表达式一次或多次，等价于 <code>{1,}</code></li><li><code>?</code> 匹配前面的子表达式零次或一次，等价于 <code>{0,1}</code> 。当该字符紧跟在任何一个其他限制符 (<code>*</code>, <code>+</code>,<code>?</code>, <code>{n}</code>, <code>{n,}</code>, <code>{n,m})</code> 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串</li><li><code>{n}</code> n 是一个非负整数。匹配确定的 <code>n</code> 次。</li><li><code>{n,}</code> n 是一个非负整数。至少匹配 <code>n</code> 次。</li><li><code>{n,m}</code> <code>m</code> 和 <code>n</code> 均为非负整数，其中<code>n</code> &lt;= <code>m</code>。最少匹配 <code>n</code> 次且最多匹配 <code>m</code> 次。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125; 就近修饰单个字符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/chuan&#123;2&#125;/</span>.test(<span class="string">"chuanchuan"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/(chuan)&#123;2&#125;/</span>.test(<span class="string">"chuanchuan"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/chuan&#123;2&#125;/</span>.test(<span class="string">"chuann"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h4><ul><li><code>g</code> 全局标记，指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配</li><li><code>i</code> 标记指定不区分大小写。表达式的结尾处</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>从高到低的优先级顺序：</p><ol><li><strong><code>\</code></strong>    转义符</li><li><strong><code>()</code></strong>, <strong><code>(?:)</code></strong> , <strong><code>(?=)</code></strong>, <strong><code>[]</code></strong>    圆括号和方括号</li><li><strong><code>*</code></strong>, <strong><code>+</code></strong> , <strong><code>?</code></strong>, <strong><code>{n}</code></strong>, <strong><code>{n,}</code></strong>, <strong><code>{n,m}</code></strong>    限定符</li><li><strong><code>^</code></strong>, <strong><code>$</code></strong>, <strong><code>\任何元字符、任何字符</code></strong>    定位点和序列（即：位置和顺序）</li><li><strong><code>|</code></strong>    替换，”或”操作</li></ol><blockquote><p>字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</p></blockquote><h3 id="正则的使用"><a href="#正则的使用" class="headerlink" title="正则的使用"></a>正则的使用</h3><h4 id="字符串使用正则"><a href="#字符串使用正则" class="headerlink" title="字符串使用正则"></a>字符串使用正则</h4><ul><li><code>replace()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"   123AD  asadf   asadfasf  adf  "</span>;</span><br><span class="line"><span class="comment">// 1. 替换掉字符串中的所有空白</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/\s/g</span>, <span class="string">""</span>); <span class="comment">// g: global, 全局搜索</span></span><br><span class="line"><span class="comment">// 2. 将所有的ad替换成xx</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/ad/g</span>, <span class="string">"xx"</span>);</span><br><span class="line"><span class="comment">// 3. 将所有的ad/AD替换成xx</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/ad/gi</span>, <span class="string">"xx"</span>); <span class="comment">// i： ignore 忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"abc,efg,123,abc,123,a"</span></span><br><span class="line"><span class="comment">// 4. 所有的逗号替换成句号</span></span><br><span class="line"><span class="keyword">var</span> str2 = str.replace(<span class="regexp">/,/g</span> , <span class="string">"。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">'[&#123;"name":"张三",score:80&#125;,&#123;"name":"张三",score:90&#125;,&#123;"name":"张三",score:81&#125;]'</span>;</span><br><span class="line"><span class="comment">// 5. 把所有成绩都修改成100分</span></span><br><span class="line"><span class="keyword">var</span> str2 = jsonStr.replace(<span class="regexp">/\d&#123;1,2&#125;/g</span>, <span class="string">"100"</span>);</span><br></pre></td></tr></table></figure><ul><li><code>match()</code>  ==&gt; 匹配， 匹配符合正则表达式的字符</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str2 = <span class="string">"zs的手机号是18938383838, ls的手机号13989907890， ww的手机号是13848962389，zl的手机号是18970890908"</span>;</span><br><span class="line"><span class="comment">// 需求： 匹配出来所有的手机号, 返回了一个数组</span></span><br><span class="line"><span class="keyword">var</span> str3 = str2.match(<span class="regexp">/1[3-9]\d&#123;9&#125;/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str3);</span><br></pre></td></tr></table></figure><h4 id="正则的方法"><a href="#正则的方法" class="headerlink" title="正则的方法"></a>正则的方法</h4><ul><li><p>test() ==&gt; 测试字符串是否符合正则表达式的规律，符合，就返回true</p></li><li><p>exec() ==&gt; 提取，提取字符串中符合正则表达式的字符，需要用括号分组， 如果没有进行分组，返回的是符合整个正则表达式的字符</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"今天是2018-10-16，我这里的需求是提取出年月日"</span>;</span><br><span class="line"><span class="comment">// var reg = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/;  ==&gt;  符合整个正则表达式的字符</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;  <span class="comment">// ==&gt; 有分组存在 ，默认组名为 undefined</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;  <span class="comment">// ?&lt;组名&gt; 添加组名</span></span><br><span class="line"><span class="keyword">var</span> ret = reg.exec(str); <span class="comment">// 提取出分组的内容以下标的形式存在返回的数组里面</span></span><br><span class="line"><span class="keyword">var</span> ret2 = reg2.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(ret);</span><br><span class="line"><span class="built_in">console</span>.log(ret2);</span><br><span class="line"><span class="comment">// index 代表 匹配到 ret 在 str 中的下标</span></span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li><code>[xyz]</code>    字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</li><li><code>[^xyz]</code>    负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</li><li><code>[a-z]</code> 匹配所有小写字母</li><li><code>[-a-z]</code> 或 <code>[a-z-]</code> 匹配所有小写字母和 <code>-</code></li><li><code>[A-Za-z0-9]</code> 匹配任何大写字母小写字母和数字</li><li><code>\b([a-z]+)\1\b/gi</code>    一个单词连续出现的位置。</li><li>将通用资源指示符 (URI) 分解为其组件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"https://www.baidu.com:80/index.html"</span>;</span><br><span class="line"><span class="keyword">var</span> patt1 = <span class="regexp">/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/</span>;</span><br><span class="line">arr = str.match(patt1);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length ; i++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(arr[i]);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//https://www.baidu.com:80/index.html</span></span><br><span class="line"><span class="comment">//https</span></span><br><span class="line"><span class="comment">//www.baidu.com</span></span><br><span class="line"><span class="comment">//:80</span></span><br><span class="line"><span class="comment">///index.html</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery-fileupload</title>
      <link href="/2018/jquery/jquery-fileupload%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/jquery/jquery-fileupload%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="jquery-fileupload"><a href="#jquery-fileupload" class="headerlink" title="jquery-fileupload"></a>jquery-fileupload</h1><p>github地址：<a href="https://github.com/blueimp/jQuery-File-Upload" target="_blank" rel="noopener">https://github.com/blueimp/jQuery-File-Upload</a></p><p>中文文档：<a href="http://www.jq22.com/jquery-info230" target="_blank" rel="noopener">http://www.jq22.com/jquery-info230</a></p><h2 id="引包"><a href="#引包" class="headerlink" title="引包"></a>引包</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jquery-fileupload依赖与jquery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jquery ui小部件，上传插件依赖了jquery ui的小部件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vendor/jquery.ui.widget.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果上传图片需要跨域，那么需要引入这个js文件，如果不跨域，则不需要引入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.iframe-transport.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jquery上传插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.fileupload.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html结构"><a href="#html结构" class="headerlink" title="html结构"></a>html结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- name指定图片上传时的name属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- data-url指定图片上传时的接口地址 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- multiple指定多文件上传 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"fileupload"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"files"</span> <span class="attr">data-url</span>=<span class="string">"server/php/"</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><p>multiple 上传多文件（实质上是发送多次单文件异步上传请求）</p><h2 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#fileupload'</span>).fileupload(&#123;</span><br><span class="line">      dataType: <span class="string">'json'</span>,</span><br><span class="line">      <span class="comment">// e：事件对象</span></span><br><span class="line">      <span class="comment">// data：图片上传后的对象，通过data.result.picAddr 可以获取上传后的图片地址</span></span><br><span class="line">      done: <span class="function"><span class="keyword">function</span> (<span class="params">e, data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery 中 AJAX 的全局事件</title>
      <link href="/2018/jquery/jquery%E4%B8%ADAJAX%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6/"/>
      <url>/2018/jquery/jquery%E4%B8%ADAJAX%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="jquery-中-AJAX-的全局事件"><a href="#jquery-中-AJAX-的全局事件" class="headerlink" title="jquery 中 AJAX 的全局事件"></a>jquery 中 AJAX 的全局事件</h2><blockquote><p>ajax 提供了6个全局函数，会被页面中所有的 ajax 请求触发，在不同时间点会触发不同的全局事件。</p></blockquote><p><a href="https://api.jquery.com/category/ajax/global-ajax-event-handlers/" target="_blank" rel="noopener">https://api.jquery.com/category/ajax/global-ajax-event-handlers/</a></p><p>在页面中会有很多的ajax请求，但是这些ajax请求都有相同的消息机制，比如我们需要在ajax请求发送之前弹出了一个提示框，提示”正在读取数据….” 在ajax请求成功时显示”获取数据成功…”,在ajax结束后隐藏提示框。如果不使用全局事件，那么需要在每一个ajax的beforeSend、success、complete回调函数中都加上相同的代码。</p><ul><li>jquery 的全局事件需要给 <code>document</code> 注册（固定写法）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ajaxStart(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>全局事件的执行时机</li></ul><ol><li><code>ajaxStart</code>： 在第一个 ajax 请求开始时触发 first start</li><li><code>ajaxSend</code>： 在一个ajax请求开始之前触发（在beforeSend回调函数之后）one start</li><li><code>ajaxSuccess</code>： 在一个ajax请求成功之后触发（在 success 回调函数之后触发）one success</li><li><code>ajaxComplete</code>： 在一个ajax请求完成时触发（在complete回调函数之后触发） one complete</li><li><code>ajaxError</code>： 在一个 ajax 请求失败时触发（在error回调函数之后触发）</li><li><code>ajaxStop</code>： 在所有的 ajax 请求完成之后触发 all complete</li></ol><p>若$.ajax() global 参数设置为 false，则 ajax 全局事件不会被触发，global 参数默认为 true</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery</title>
      <link href="/2018/jquery/jquery/"/>
      <url>/2018/jquery/jquery/</url>
      
        <content type="html"><![CDATA[<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h2 id="jQuery-基本介绍"><a href="#jQuery-基本介绍" class="headerlink" title="jQuery 基本介绍"></a>jQuery 基本介绍</h2><h3 id="为什么要学-jQuery"><a href="#为什么要学-jQuery" class="headerlink" title="为什么要学 jQuery"></a>为什么要学 jQuery</h3><p>使用 JS 操作 DOM 的时候，会遇到以下的一些缺点：</p><ul><li>获取元素的方法太少且长，麻烦</li><li>遍历伪数组很麻烦，通常要嵌套一大堆的 for 循环。注册的事件会覆盖</li><li>有兼容性问题</li><li>实现动画很麻烦</li></ul><h3 id="jQuery-初体验"><a href="#jQuery-初体验" class="headerlink" title="jQuery 初体验"></a>jQuery 初体验</h3><p>【让div显示与设置内容】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#btn1'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。</span></span><br><span class="line">    <span class="comment">// show() 显示元素</span></span><br><span class="line">    $(<span class="string">'div'</span>).show(<span class="number">200</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  $(<span class="string">'#btn2'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// text() 设置文本内容</span></span><br><span class="line">    $(<span class="string">'div'</span>).text(<span class="string">'我是内容'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  $(<span class="string">'#btn3'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// css(name, value);  设置样式</span></span><br><span class="line">    <span class="comment">// name: 设置什么样式</span></span><br><span class="line">    <span class="comment">// value ： 设置的值是多少</span></span><br><span class="line">    $(<span class="string">'div'</span>).css(<span class="string">'fontSize'</span>, <span class="number">30</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>使用 jQuery 的优点</strong></p><ul><li>获取元素的方式非常的简单，而且非常的丰富</li><li>jQuery 的隐式迭代特性，不再需要书写 for 循环语句</li><li>使用 jQuery 完全不用考虑兼容性问题</li><li>jQuery 提供了一系列动画相关的函数，使用非常方便</li><li>代码简单、粗暴</li></ul><p><strong>什么是 jQuery</strong></p><blockquote><p>jQuery 是一个快速的、轻量的、功能丰富的 js 库</p></blockquote><p>jQuery 的官网 <a href="http://jquery.com/" target="_blank" rel="noopener">http://jquery.com/</a></p><p>js 库：把一些常用到的方法写到一个单独的 js 文件，使用的时候直接去引用这 js 文件就可以了。（animate.js、common.js）</p><h3 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h3><p>官网下载地址：<a href="http://jquery.com/download/" target="_blank" rel="noopener">http://jquery.com/download/</a></p><p>jQuery 版本有很多，分为 1.x 2.x 3.x</p><p>大版本分类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.x 版本：能够兼容IE678浏览器（最终版本1.12.4）</span><br><span class="line">2.x 版本：不兼容IE678浏览器（最终版本2.2.4）</span><br><span class="line">3.x 版本：不兼容IE678，更加的精简（在国内不流行，因为国内使用 jQuery 的主要目的就是兼容IE678）,3.x 版本只是在原来的基础上增加了一些新的特性</span><br></pre></td></tr></table></figure><p>关于压缩版和未压缩版</p><ul><li><code>jquery.min.js</code>：压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，采用了代码混淆，基本没有可阅读性</li><li><code>jquery.js</code>：未压缩版本，适用于学习与开发环境，源码清晰，易阅读</li></ul><h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><p>入口函数的好处：</p><ul><li>等待文档加载完成，不论代码是写在 body、head 中都可以正常去获取到元素</li><li>形成了一个沙箱，防止全局变量污染</li></ul><p>两种写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>原生 JavaScript 的入口函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>jQuery 入口函数与 js 入口函数的对比</p><ul><li>JavaScript 的入口函数要等到页面中所有资源（包括图片、文件等外部资源）加载完成才开始执行。jQuery 的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。所以 jQuery 的入口函数要比 js 入口函数先执行</li><li>window.onload 存在覆盖问题；jq 的入口函数不存在覆盖问题</li></ul><h3 id="jQuery-使用步骤"><a href="#jQuery-使用步骤" class="headerlink" title="jQuery 使用步骤"></a>jQuery 使用步骤</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引包（引入js文件） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'jquery.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 写上入口函数</span></span></span><br><span class="line"><span class="javascript">  $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 或者</span></span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在入口函数内部实现功能</span></span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="jquery-中的-符号"><a href="#jquery-中的-符号" class="headerlink" title="jquery 中的 $ 符号"></a>jquery 中的 $ 符号</h3><p>$ 来源于  jQuery ， 是个函数（查看jQuery源码中最后几行代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jquery 和 $ 是等价的</span></span><br><span class="line">jQuery === $ <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>作用</strong>：根据参数的不同， 作用是不同的</p><ul><li><p>参数是个函数  <code>$(function(){})</code> 作用是入口函数</p></li><li><p>参数是个 dom 对象  <code>$(document)</code> 作用是 dom 转 jq</p></li><li><p>参数是选择器  <code>$(&#39;body&#39;)</code>  作用是获取元素</p></li><li><p>参数是个 html 字符串 <code>$(&#39;&lt;a&gt;123&lt;/a&gt;&#39;)</code>  作用是创建节点</p></li></ul><h3 id="jQuery-对象与-DOM-对象"><a href="#jQuery-对象与-DOM-对象" class="headerlink" title="jQuery 对象与 DOM 对象"></a>jQuery 对象与 DOM 对象</h3><p><strong>基本概念：</strong></p><ol><li><code>DOM 对象</code>：使用 JavaScript 中的方法获取页面中的元素返回的对象就是 Dom 对象</li><li><code>jQuery 对象</code>：jquery 对象就是使用 jquery 的方法获取页面中的元素返回的对象</li><li>jQuery 对象其实就是 DOM 对象的包装集（包装了 DOM 对象的集合），是一个 <strong>伪数组</strong></li></ol><p><strong>jQuery 对象与 DOM 对象的区别：</strong></p><ol><li>DOM 对象与 jQuery 对象的方法不能混用。dom 对象不能使用 jq 对象的方法，jq 对象也不能使用 dom 对象的属性和方法</li><li>DOM 对象可以和 jQuery 对象可以相互转化</li></ol><ul><li>DOM 对象转换成 jQuery 对象：【联想记忆：花钱】</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 dom 对象作为参数传递到 $() 里面去， 那么这个整体就是个jq对象</span></span><br><span class="line"><span class="keyword">var</span> $obj = $(domObj)</span><br></pre></td></tr></table></figure><ul><li>jQuery 对象转换成 DOM 对象：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 $()  来获取到的元素返回的对象就是jq对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $li = $(<span class="string">'li'</span>)</span><br><span class="line"><span class="comment">// 第一种方法,通过下标取出（推荐使用）</span></span><br><span class="line">$li[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line">$li.get(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>【练习：隔行变色案例】</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h3><p>jQuery 选择器是 jQuery 为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery 选择器返回的是 jQuery 对象</p><p>jQuery 选择器有很多，基本兼容了 CSS1 到 CSS3 所有的选择器，并且 jQuery 还添加了很多更加复杂的选择器</p><h3 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h3><p>jQuery 完全兼容 css 选择器</p><table><thead><tr><th>名称</th><th>用法</th><th align="left">描述</th></tr></thead><tbody><tr><td>ID选择器</td><td>$(‘#id’)</td><td align="left">获取指定 id 的元素</td></tr><tr><td>类选择器</td><td>$(‘.class’)</td><td align="left">获取同一类 class 的元素</td></tr><tr><td>标签选择器</td><td>$(‘div’)</td><td align="left">获取同一类标签的所有元素</td></tr><tr><td>并集选择器</td><td>$(‘div, p, li’)</td><td align="left">使用逗号分隔，只要符合条件之一就可</td></tr><tr><td>交集选择器</td><td>$(‘div.redClass’)</td><td align="left">获取 class 为 redClass 的 div 元素</td></tr><tr><td>子代选择器</td><td>$(‘ul&gt;li’)</td><td align="left">使用 &gt; 号，获取儿子层级的元素，注意，并不会获取孙子层级的元素</td></tr><tr><td>后代选择器</td><td>$(‘ul li’)</td><td align="left">使用空格，代表后代选择器，获取 ul 下的所有 li 元素，包括孙子等</td></tr></tbody></table><h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><p>这类选择器都带冒号 <code>:</code></p><table><thead><tr><th>名称</th><th>用法</th><th align="left">描述</th></tr></thead><tbody><tr><td><code>:eq(index)</code></td><td>$(‘li:eq(2)’)</td><td align="left">获取 li 元素中，选择索引号为 2 的元素，索引号 index 从 0 开始</td></tr><tr><td><code>:odd</code></td><td>$(‘li:odd’)</td><td align="left">获取 li 元素中，选择索引号为奇数的元素</td></tr><tr><td><code>:even</code></td><td>$(‘li:even’)</td><td align="left">获取 li 元素中，选择索引号为偶数的元素</td></tr><tr><td><code>:first</code></td><td>$(‘li:first’)</td><td align="left">获取 li 元素中的第一个</td></tr><tr><td><code>:last</code></td><td>$(‘li:last’)</td><td align="left">获取 li 元素中的最后一个</td></tr></tbody></table><p>【案例：隔行变色】</p><h3 id="筛选选择器-方法"><a href="#筛选选择器-方法" class="headerlink" title="筛选选择器(方法)"></a>筛选选择器(方法)</h3><p>筛选选择器的功能与过滤选择器有点类似，但是用法不一样，<code>筛选选择器</code> 主要是方法</p><table><thead><tr><th>名称</th><th>用法</th><th align="left">描述</th></tr></thead><tbody><tr><td><code>children(selector)</code></td><td>$(‘ul’).children(‘li’)</td><td align="left">获取当前元素的所有子元素中的 li 元素</td></tr><tr><td><code>find(selector)</code></td><td>$(‘ul’).find(‘li’)</td><td align="left">获取当前元素中的后代元素中的 li 元素</td></tr><tr><td><code>siblings(selector)</code></td><td>$(‘#first’).siblings(‘li’)</td><td align="left">查找兄弟节点，不包括自己本身</td></tr><tr><td><code>parent()</code></td><td>$(‘#first’).parent()</td><td align="left">查找父亲</td></tr><tr><td><code>parents()</code></td><td>$(‘#first’).parents(‘’)</td><td align="left">查找所有祖宗（参数 指定具体祖宗）</td></tr><tr><td><code>eq(index)</code></td><td>$(‘li’).eq(2)</td><td align="left">相当于<code>$(&#39;li:eq(2)&#39;)</code>，index从 0 开始</td></tr><tr><td><code>next()</code></td><td>$(‘li’).next()</td><td align="left">找下一个兄弟</td></tr><tr><td><code>nextAll()</code></td><td>$(‘li’).nextAll()</td><td align="left">找后面所有的兄弟</td></tr><tr><td><code>prev()</code></td><td>$(‘li’).prev()</td><td align="left">找上一个兄弟</td></tr><tr><td><code>prevAll()</code></td><td>$(‘li’).prevAll()</td><td align="left">找前面所有的兄弟</td></tr></tbody></table><p>【案例：下拉菜单】<br>【案例：突出展示】<br>【案例：手风琴】<br>【案例：淘宝精品】</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="mouseover-与-mouseenter"><a href="#mouseover-与-mouseenter" class="headerlink" title="mouseover 与 mouseenter"></a><code>mouseover</code> 与 <code>mouseenter</code></h4><ul><li>mouseover 和 mouseoverenter 都有鼠标经过的意思，但是在注册鼠标经过事件的时候，推荐使用<code>mouseenter</code></li></ul><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=jquery_event_mouseenter_mouseover" target="_blank" rel="noopener">mouseenter 与 mouseover 的不同</a></p><ul><li><p>mouseover 与 mouseout 是一对事件，当鼠标经过当前元素或者当前元素的子元素的时候，会触发【事件冒泡】。</p></li><li><p>mouseenter 与 mouseleave 是一对事件，只有当鼠标经过当前元素时，事件会触发，鼠标经过子元素，mousenter 事件是不会触发的</p></li></ul><h4 id="index-方法"><a href="#index-方法" class="headerlink" title="index 方法"></a>index 方法</h4><p><code>index()</code> 方法返回的是当前元素在所有兄弟元素里面的索引</p><h4 id="区分-jQuery-与-Javascript"><a href="#区分-jQuery-与-Javascript" class="headerlink" title="区分 jQuery 与 Javascript"></a>区分 jQuery 与 Javascript</h4><p>JavaScript 是一门编程语言，jQuery 仅仅是用 JavaScript 实现的一个 JavaScript 库，目的是简化我们的开发</p><h2 id="jQuery-样式操作"><a href="#jQuery-样式操作" class="headerlink" title="jQuery 样式操作"></a>jQuery 样式操作</h2><h3 id="css-操作"><a href="#css-操作" class="headerlink" title="css 操作"></a>css 操作</h3><p>功能：设置或者修改样式，操作的是 style 属性</p><p>设置单个样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name：需要设置的样式名称</span></span><br><span class="line"><span class="comment">// value：对应的样式值</span></span><br><span class="line">css(name, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line">$(<span class="string">'#one'</span>).css(<span class="string">'background'</span>, <span class="string">'gray'</span>) <span class="comment">// 将背景色修改为灰色</span></span><br></pre></td></tr></table></figure><p>设置多个样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一个对象，对象中包含了需要设置的样式名和样式值</span></span><br><span class="line">css(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用案例</span></span><br><span class="line">$(<span class="string">'#one'</span>).css(&#123;</span><br><span class="line">  background: <span class="string">'gray'</span>,</span><br><span class="line">  width: <span class="string">'400px'</span>,</span><br><span class="line">  height: <span class="string">'200px'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>获取样式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name: 需要获取的样式名称</span></span><br><span class="line">css(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例</span></span><br><span class="line">$(<span class="string">'div'</span>).css(<span class="string">'background-color'</span>)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值</li><li>获取操作的时候，如果是多个元素，那么只会返回第一个元素的值</li></ul><h3 id="class-操作"><a href="#class-操作" class="headerlink" title="class 操作"></a>class 操作</h3><ul><li>添加样式类</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给所有的 div 添加 one 的样式</span></span><br><span class="line">$(<span class="string">'div'</span>).addClass(<span class="string">'one'</span>)</span><br></pre></td></tr></table></figure><ul><li>移除样式类</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除 div 中 one 类名</span></span><br><span class="line">$(<span class="string">'div'</span>).removeClass(<span class="string">'one'</span>)</span><br></pre></td></tr></table></figure><ul><li>判断是否有某个样式类</li></ul><p>判断标准是： 只要有一个元素有指定的类名，就返回 true，所有的元素都没有该类名，就返回 false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否有 one 的样式类</span></span><br><span class="line">$(<span class="string">'div'</span>).hasClass(<span class="string">'one'</span>)</span><br></pre></td></tr></table></figure><ul><li>切换样式类</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果有，移除该类，如果没有，添加该类</span></span><br><span class="line">$(<span class="string">'div'</span>).toggleClass(<span class="string">'one'</span>)</span><br></pre></td></tr></table></figure><p>【案例：tab栏切换案例.html】</p><h2 id="jQuery-属性操作"><a href="#jQuery-属性操作" class="headerlink" title="jQuery 属性操作"></a>jQuery 属性操作</h2><h3 id="attr-操作"><a href="#attr-操作" class="headerlink" title="attr 操作"></a>attr 操作</h3><p>设置单个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：需要设置的属性名</span></span><br><span class="line"><span class="comment">// 第二个参数：对应的属性值</span></span><br><span class="line">attr(name, value)</span><br><span class="line"><span class="comment">// 用法举例</span></span><br><span class="line">$(<span class="string">'img'</span>).attr(<span class="string">'title'</span>, <span class="string">'哈哈'</span>)</span><br></pre></td></tr></table></figure><p>设置多个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一个对象，包含了需要设置的属性名和属性值</span></span><br><span class="line">$(<span class="string">'img'</span>).attr(&#123;</span><br><span class="line">  title: <span class="string">'hello'</span>,</span><br><span class="line">  alt: <span class="string">'hello'</span>,</span><br><span class="line">  style: <span class="string">'opacity: .5'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>获取属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传需要获取的属性名称，返回对应的属性值</span></span><br><span class="line"><span class="keyword">var</span> oTitle = $(<span class="string">'img'</span>).attr(<span class="string">'title'</span>)</span><br></pre></td></tr></table></figure><p>移除属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：需要移除的属性名</span></span><br><span class="line">$(<span class="string">'img'</span>).removeAttr(<span class="string">'title'</span>)</span><br></pre></td></tr></table></figure><p>【案例：美女相册.html】</p><h3 id="prop-操作"><a href="#prop-操作" class="headerlink" title="prop 操作"></a>prop 操作</h3><p>在jQuery1.6之后，对于 checked、selected、disabled 这类 boolean 类型的属性来说，不能用 attr 方法，只能用 prop 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置属性</span></span><br><span class="line">$(<span class="string">'input:checked'</span>).prop(<span class="string">'checked'</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 获取属性</span></span><br><span class="line">$(<span class="string">'input:checked'</span>).prop(<span class="string">'checked'</span>) <span class="comment">// 返回 true 或者 false</span></span><br></pre></td></tr></table></figure><p>【案例：表格全选案例.html】</p><h2 id="jQuery-动画"><a href="#jQuery-动画" class="headerlink" title="jQuery 动画"></a>jQuery 动画</h2><p>jquery 提供了三组基本动画，这些动画都是标准的、有规律的效果，jquery 还提供了自定义动画的功能</p><h3 id="三组基本动画"><a href="#三组基本动画" class="headerlink" title="三组基本动画"></a>三组基本动画</h3><ul><li>显示 (show) 与隐藏 (hide) 与切换 (slideToggle)</li><li>上滑 (slideUp) 与下滑 (slideDown) 与切换 (slideToggle)，效果与卷帘门类似</li><li>淡入 (fadeIn) 与淡出 (fadeOut) 与切换 (fadeToggle)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// show() 系列</span></span><br><span class="line">show([speed], [easing], [callback])</span><br><span class="line"><span class="comment">// speed(可选)：动画的执行时间</span></span><br><span class="line"><span class="comment">// 1.如果不传，就没有动画效果。如果是 slide 和 fade 系列，会默认为 normal</span></span><br><span class="line"><span class="comment">// 2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐)</span></span><br><span class="line"><span class="comment">// 3.固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal</span></span><br><span class="line"><span class="comment">// easing(可选)：动画效果，默认是 swing，秋千，提供了一个 linear 匀速的效果</span></span><br><span class="line"><span class="comment">// callback(可选)：执行完动画后执行的回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slide 系列，参数使用和show 是一样的，不传参数，默认有动画效果</span></span><br><span class="line">slideDown([speed], [easing], [callback])</span><br><span class="line"></span><br><span class="line"><span class="comment">// fade 系列，参数使用和 show 是一样的，不传参数，默认有动画效果</span></span><br><span class="line">fadeIn([speed], [easing], [callback])</span><br></pre></td></tr></table></figure><p>【案例：下拉菜单动画版.html】<br>【案例：京东轮播图(呼吸灯).html】</p><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><p>animate：自定义动画（只支持数值型的动画）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(selector).animate(&#123; params &#125;, [speed], [easing], [callback])</span><br><span class="line"><span class="comment">// &#123;params&#125;：要执行动画的 CSS 属性，带数字（必选），多个属性会同时执行</span></span><br><span class="line"><span class="comment">// speed：执行动画时长（可选）</span></span><br><span class="line"><span class="comment">// easing: 执行效果，默认为swing（缓动）  linear（匀速）</span></span><br><span class="line"><span class="comment">// callback：动画执行完后立即执行的回调函数（可选）</span></span><br></pre></td></tr></table></figure><h3 id="动画队列与停止动画"><a href="#动画队列与停止动画" class="headerlink" title="动画队列与停止动画"></a>动画队列与停止动画</h3><p>在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有顺序的执行效果</span></span><br><span class="line"><span class="comment">// 动画队列：</span></span><br><span class="line"><span class="comment">// 像链式编程一样，通过 . 继续写动画，给元素添加了多个动画, 这多个动画会添加到元素的动画队列里面，按照顺序依次执行</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'div'</span>)</span><br><span class="line">    .animate(&#123; <span class="attr">left</span>: <span class="number">800</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">    .animate(&#123; <span class="attr">top</span>: <span class="number">300</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">    .animate(&#123; <span class="attr">borderRadius</span>: <span class="number">50</span> &#125;, <span class="number">1000</span>)</span><br><span class="line">    .slideUp(<span class="number">2000</span>)</span><br><span class="line">    .slideDown(<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 好处：可以有顺序的执行动画效果</span></span><br><span class="line"><span class="comment">// 坏处：bug 给元素不停的添加动画，元素就不停的运动</span></span><br></pre></td></tr></table></figure><ul><li>stop 方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止当前正在执行的动画，如果元素的动画队列里面有后续动画，后续动画会执行</span></span><br><span class="line">stop(clearQueue, jumpToEnd)</span><br><span class="line"><span class="comment">// 第一个参数：可选，是否清除队列，true，表示清除掉，默认 false</span></span><br><span class="line"><span class="comment">// 第二个参数：可选，是否跳转到当前正在执行的动画的最终效果，true，表示跳转， 默认false</span></span><br></pre></td></tr></table></figure><p>【案例：手风琴特效】<br>【案例：音乐导航】</p><h2 id="jQuery-节点操作"><a href="#jQuery-节点操作" class="headerlink" title="jQuery 节点操作"></a>jQuery 节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $()</span></span><br><span class="line"><span class="comment">// 括号内写 html 格式的字符串</span></span><br><span class="line">$(<span class="string">'&lt;span&gt;这是一个span元素&lt;/span&gt;'</span>)</span><br></pre></td></tr></table></figure><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append</span></span><br><span class="line">A.append(B) <span class="comment">// 把 B 添加到 A 里面去，B 作为 A 的最后一个子元素</span></span><br><span class="line"><span class="comment">// appendTo</span></span><br><span class="line">B.appendTo(A) <span class="comment">// 作用同上，写法不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// prepend</span></span><br><span class="line">A.prepend(B) <span class="comment">// 把 B 添加到 A 里面去，B 作为 A 的第一个子元素</span></span><br><span class="line"><span class="comment">// prependTo</span></span><br><span class="line">B.prependTo(A) <span class="comment">// 作用同上，写法不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">A.after(B) <span class="comment">// 把 B 作为 A 的兄弟，添加在 A 的后面</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line">A.before(B) <span class="comment">// 把 B 作为 A 的兄弟，添加在 A 的前面</span></span><br></pre></td></tr></table></figure><p>【案例：城市选择案例】</p><h3 id="清空节点与删除节点"><a href="#清空节点与删除节点" class="headerlink" title="清空节点与删除节点"></a>清空节点与删除节点</h3><p>empty：清空指定节点的所有元素，自身保留(清理门户)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).empty() <span class="comment">// 清空 div 的所有内容（推荐使用，会清除子元素上绑定的内容，源码）</span></span><br><span class="line">$(<span class="string">'div'</span>).html(<span class="string">''</span>) <span class="comment">// 使用 html 方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除</span></span><br></pre></td></tr></table></figure><p>remove：删除节点，会把元素自身给删除掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).remove() <span class="comment">// 删除 div 节点</span></span><br></pre></td></tr></table></figure><h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><p>clone：克隆元素节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).clone() <span class="comment">// 返回复制的 div 新元素，（默认不显示，需要配合 append 方法）</span></span><br><span class="line"><span class="comment">// 新元素和原来的元素没有任何关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// clone(布尔类型参数)， 参数为true， 克隆元素的事件，默认值是false</span></span><br></pre></td></tr></table></figure><h2 id="jQuery-特殊属性操作"><a href="#jQuery-特殊属性操作" class="headerlink" title="jQuery 特殊属性操作"></a>jQuery 特殊属性操作</h2><h3 id="val"><a href="#val" class="headerlink" title="val()"></a>val()</h3><p>val 方法用于设置和获取表单元素的值，例如 input、textarea 的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">$(<span class="string">'#name'</span>).val(<span class="string">'张三'</span>)</span><br><span class="line"><span class="comment">// 获取值</span></span><br><span class="line">$(<span class="string">'#name'</span>).val()</span><br></pre></td></tr></table></figure><p>【案例：搜索框】</p><h3 id="html-与-text"><a href="#html-与-text" class="headerlink" title="html() 与 text()"></a>html() 与 text()</h3><p>html 方法相当于 innerHTML，text 方法相当于 innerText</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置内容</span></span><br><span class="line">$(<span class="string">'div'</span>).html(<span class="string">'&lt;span&gt;这是一段内容&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line">$(<span class="string">'div'</span>).html()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置内容</span></span><br><span class="line">$(<span class="string">'div'</span>).text(<span class="string">'&lt;span&gt;这是一段内容&lt;/span&gt;'</span>)</span><br><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line">$(<span class="string">'div'</span>).text()</span><br></pre></td></tr></table></figure><p><strong>区别</strong>：html 方法会识别 html 标签，text 方法会将内容直接当成字符串，并不会识别 html 标签</p><h3 id="width-与-height"><a href="#width-与-height" class="headerlink" title="width() 与 height()"></a>width() 与 height()</h3><p>设置或者获取 <strong>内容区域</strong> 的宽度和高度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数表示设置</span></span><br><span class="line">$(<span class="string">'div'</span>).width(<span class="number">200</span>)</span><br><span class="line">$(<span class="string">'div'</span>).height(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带参数表示获取</span></span><br><span class="line">$(<span class="string">'div'</span>).width()</span><br><span class="line">$(<span class="string">'div'</span>).height()</span><br></pre></td></tr></table></figure><p>获取 <strong>内容区域 + padding</strong> 的宽度和高度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).innerWidth()</span><br><span class="line">$(<span class="string">'div'</span>).innerHeight()</span><br></pre></td></tr></table></figure><p>获取 <strong>内容区域 + padding + border</strong> 的宽度和高度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).outerWidth()</span><br><span class="line">$(<span class="string">'div'</span>).outerHeight()</span><br></pre></td></tr></table></figure><p>获取 <strong>内容区域 + padding + border + margin</strong> 的宽度和高度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入参数true</span></span><br><span class="line">$(<span class="string">'div'</span>).outerWidth(<span class="literal">true</span>)</span><br><span class="line">$(<span class="string">'div'</span>).outerHeight(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>获取网页的可视区宽高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).width()</span><br><span class="line">$(<span class="built_in">window</span>).height()</span><br></pre></td></tr></table></figure><h3 id="scrollTop-与-scrollLeft"><a href="#scrollTop-与-scrollLeft" class="headerlink" title="scrollTop 与 scrollLeft"></a>scrollTop 与 scrollLeft</h3><p>设置或者获取垂直滚动条的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参表示设置，不传参表示获取</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollTop(<span class="number">2000</span>)</span><br><span class="line">$(<span class="built_in">window</span>).scrollLeft()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时的去获取到页面垂直卷曲的距离</span></span><br><span class="line">$(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log($(<span class="built_in">window</span>).scrollTop())</span><br><span class="line">  <span class="built_in">console</span>.log($(<span class="built_in">window</span>).scrollLeft())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>返回顶部固定写法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$goTop.click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'html, body'</span>).animate(</span><br><span class="line">    &#123;</span><br><span class="line">      scrollTop: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>【案例：固定菜单栏案例】<br>【案例：小火箭返航案例】</p><h3 id="offset-方法与-position-方法"><a href="#offset-方法与-position-方法" class="headerlink" title="offset 方法与 position 方法"></a>offset 方法与 position 方法</h3><p>offset 方法获取元素距离 document 的位置，position 方法获取的是元素距离有定位的父元素的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取元素距离 document 的位置，和父元素没有关系，返回值为对象：&#123;left:100, top:100&#125;</span></span><br><span class="line">$(selector).offset()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取相对于其最近的有定位的父元素的位置，返回值为对象</span></span><br><span class="line">$(selector).position()</span><br></pre></td></tr></table></figure><h2 id="jQuery-事件机制"><a href="#jQuery-事件机制" class="headerlink" title="jQuery 事件机制"></a>jQuery 事件机制</h2><p>JavaScript 中已经学习过了事件，但是 jQuery 对 JavaScript 事件进行了封装，增加并扩展了事件处理机制。jQuery 不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。</p><h3 id="jQuery-事件发展历程-了解"><a href="#jQuery-事件发展历程-了解" class="headerlink" title="jQuery 事件发展历程(了解)"></a>jQuery 事件发展历程(了解)</h3><p>简单事件绑定&gt;&gt; bind 事件绑定&gt;&gt; delegate 事件绑定 &gt;&gt;on 事件绑定(推荐)</p><ul><li>简单方式事件注册</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jq 中简单方式注册相同的事件是不会被覆盖的</span></span><br><span class="line">$(<span class="string">'div'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="string">'div'</span>).click(<span class="literal">null</span>) <span class="comment">// alert('2') 依然会执行</span></span><br></pre></td></tr></table></figure><p>缺点：不能同时注册多个事件，无法解绑事件</p><ul><li>bind 方式注册事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：事件类型，如果需要给元素注册多个事件，可以用空格隔开写上多个事件名</span></span><br><span class="line"><span class="comment">// 第二个参数：事件处理函数</span></span><br><span class="line">$(<span class="string">'p'</span>).bind(<span class="string">'click mouseenter'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 事件响应方法</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>unbind  解绑事件（不用）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).unbind() <span class="comment">// 不传参数解绑所有的事件</span></span><br><span class="line">$(<span class="string">'div'</span>).unbind(<span class="string">'click'</span>) <span class="comment">// 解绑指定的事件</span></span><br></pre></td></tr></table></figure><p>缺点：不支持动态事件绑定</p><ul><li><p>delegate 注册委托事件</p><p>事件是注册给父元素的，由子元素去触发该事件</p><p>原理： 事件冒泡</p><p>优点：节省内存，支持动态绑定</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：要绑定事件的元素</span></span><br><span class="line"><span class="comment">// 第二个参数：事件类型</span></span><br><span class="line"><span class="comment">// 第三个参数：事件处理函数</span></span><br><span class="line">$(<span class="string">'div'</span>).delegate(<span class="string">'p'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 事件注册给了父元素 div，为所有的子元素 p 绑定事件， 由 p 去触发事件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>undelegate 解绑事件（不用）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).undelegate() <span class="comment">// 解绑所有的 delegate 事件</span></span><br><span class="line">$(<span class="string">'div'</span>).undelegate( <span class="string">'click'</span> ) <span class="comment">// 解绑所有的 click 事件</span></span><br></pre></td></tr></table></figure><p>缺点：只能注册委托事件，因此注册时间需要记得方法太多了</p><h3 id="on-注册事件-重点"><a href="#on-注册事件-重点" class="headerlink" title="on 注册事件(重点)"></a>on 注册事件(重点)</h3><p>jQuery 1.7 之后，jQuery 用 on 统一了所有事件的处理方法，强烈建议使用</p><ul><li>on 注册简单事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示给 $('div') 绑定事件，并且由自己触发，不支持动态绑定</span></span><br><span class="line">$(<span class="string">'div'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>on 注册委托事件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示给 $('div') 绑定代理事件，必须是它的内部元素 span 才能触发这个事件，支持动态绑定</span></span><br><span class="line">$(<span class="string">'div'</span>).on(<span class="string">'click'</span>, <span class="string">'span'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br></pre></td></tr></table></figure><ul><li>on 注册事件的语法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）</span></span><br><span class="line"><span class="comment">// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行</span></span><br><span class="line"><span class="comment">// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）</span></span><br><span class="line"><span class="comment">// 第四个参数：handler，事件处理函数</span></span><br><span class="line">$(selector).on(events[,selector][,data],handler)</span><br></pre></td></tr></table></figure><h3 id="off-解绑事件"><a href="#off-解绑事件" class="headerlink" title="off 解绑事件"></a>off 解绑事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解绑匹配元素的所有事件，父元素子元素的所有事件都解绑了</span></span><br><span class="line">$(<span class="string">'div'</span>).off()</span><br><span class="line"><span class="comment">// 解绑匹配元素的所有 click 事件</span></span><br><span class="line">$(<span class="string">'div'</span>).off(<span class="string">'click'</span>)</span><br><span class="line"><span class="comment">// 解绑子元素 p 的所有 click 事件, 父元素的click事件不会被解绑</span></span><br><span class="line">$(<span class="string">'div'</span>).off(<span class="string">'click'</span>, <span class="string">'p'</span>)</span><br></pre></td></tr></table></figure><h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击 div 触发事件</span></span><br><span class="line">$(<span class="string">'div'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可由其他元素触发 div 的事件</span></span><br><span class="line"><span class="comment">// 点击 btn 触发 div 的 click 事件</span></span><br><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $('div').click() // 触发 div 的 click 事件</span></span><br><span class="line">  $(<span class="string">'div'</span>).trigger(<span class="string">'click'</span>) <span class="comment">// trigger(type) 触发 div 的 click 事件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="jQuery-事件对象"><a href="#jQuery-事件对象" class="headerlink" title="jQuery 事件对象"></a>jQuery 事件对象</h3><p>jQuery 事件对象其实就是js事件对象的一个封装，处理了兼容性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// screenX 和 screenY 对应屏幕最左上角的值</span></span><br><span class="line"><span class="comment">// clientX 和 clientY 距离页面左上角的位置（忽视滚动条）</span></span><br><span class="line"><span class="comment">// pageX 和 pageY 距离页面最顶部的左上角的位置（会计算滚动条的距离）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// event.keyCode 按下的键盘代码</span></span><br><span class="line"><span class="comment">// event.data 存储绑定事件时传递的附加数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// event.stopPropagation() 阻止事件冒泡行为</span></span><br><span class="line"><span class="comment">// event.preventDefault() 阻止浏览器默认行为</span></span><br><span class="line"><span class="comment">// return false 既能阻止事件冒泡，又能阻止浏览器默认行为</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>js</code> 中的 <code>return false</code> 只能起到阻止浏览器的默认行为，<code>jquery</code> 中的 <code>return false</code>  既能阻止事件冒泡也能阻止浏览器的默认行为</p><p>【案例：钢琴版导航（加强)】</p><p>【案例：弹幕效果】</p><h2 id="jQuery-特点"><a href="#jQuery-特点" class="headerlink" title="jQuery 特点"></a>jQuery 特点</h2><h3 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>隐式迭代：jQuery 在设置属性时会自动的遍历，因此我们不需要再遍历</p><ol><li>jQuery 在执行设置性操作时，会给所有的元素都设置上相同的值</li><li>jQuery 在执行获取性操作时，只会返回第一个元素对应的值</li><li>如果想要给每一个元素都设置不同的值，需要手动进行遍历 jQuery 对象</li></ol><h4 id="each方法"><a href="#each方法" class="headerlink" title="each方法"></a>each方法</h4><p>遍历 jQuery 对象集合，为每个匹配的元素执行一个函数</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(selector).each(<span class="function"><span class="keyword">function</span> (<span class="params">index, element</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// index 表示当前元素在所有匹配元素中的索引号</span></span><br><span class="line">  <span class="comment">// element 表示当前元素</span></span><br><span class="line">  <span class="comment">// this 在函数内部，this指向了element</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">'li'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">index, ele</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $(ele).css('backgroundColor', arr[index])</span></span><br><span class="line">  $(<span class="keyword">this</span>).css(<span class="string">'backgroundColor'</span>, arr[index])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><p>链式编程的原理：设置性操作会返回一个 jQuery 对象，因此可以继续调用 jQuery 的方法</p><ol><li>设置操作的时候，可以使用链式编程</li><li>获取操作的时候，无法使用链式编程，（因为没有返回jq对象）</li><li>链式编程不要太长，因为代码可读性差</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prevObject: 返回上一次找到的jq对象</span><br><span class="line">end() <span class="comment">// 上一次返回的 jq 对象（封装了 prevObject 属性）</span></span><br></pre></td></tr></table></figure><p>【案例：五角星评分案例.html】</p><h3 id="多库共存"><a href="#多库共存" class="headerlink" title="多库共存"></a>多库共存</h3><p>jQuery 使用 <code>$</code>作为标示符，但是如果与其他框架中的 <code>$</code> 冲突时，jQuery 可以释放 <code>$</code> 符的控制权</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// noConflict() // 返回 $ 的功能</span></span><br><span class="line"><span class="keyword">var</span> c = $.noConflict() <span class="comment">// 释放 $ 的控制权,并且把 $ 的能力给了 c</span></span><br></pre></td></tr></table></figure><h2 id="jQuery-插件"><a href="#jQuery-插件" class="headerlink" title="jQuery 插件"></a>jQuery 插件</h2><p>插件：其实就是个 js 库，依赖于 jquery，而且在 jquery 的基础上新增一些功能</p><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 先引入jQuery文件</span><br><span class="line">2. 在引入插件（如果有用到css的话，需要引入css）</span><br><span class="line">3. 使用插件</span><br></pre></td></tr></table></figure><p>常用插件的使用</p><ul><li><p><a href="https://github.com/jquery/jquery-color" target="_blank" rel="noopener">jquery.color.js</a></p><p>animate 只支持数值型的动画，色值型的不支持，这个插件就可以让animate 做色值型的动画</p></li><li><p><a href="https://github.com/tuupola/jquery_lazyload" target="_blank" rel="noopener">jquery.lazyload.js</a></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="comment">// html图片调用方法</span></span><br><span class="line"><span class="comment">// 为图片加入样式 lazy 图片路径引用方法用 data-original</span></span><br><span class="line"><span class="comment">// &lt;img class='lazy' data-original='img/1.jpg'&gt;</span></span><br><span class="line"><span class="comment">// js出始化lazyload并设置图片显示方式</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'img.lazy'</span>).lazyload(&#123;</span><br><span class="line">    effect: <span class="string">'fadeIn'</span>,</span><br><span class="line">    placeholder: <span class="string">'img/2.jpg'</span>, <span class="comment">// 用图片提前占位,待图片加载时,占位图则会隐藏</span></span><br><span class="line">    effect: <span class="string">'fadeIn'</span>, <span class="comment">// 载入使用何种效果</span></span><br><span class="line">    threshold: <span class="number">200</span>, <span class="comment">// 表示滚动条在离目标位置200的高度时开始加载图片,可以做到不让用户察觉</span></span><br><span class="line">    event: <span class="string">'click'</span> <span class="comment">// 事件触发时才加载</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="制作-jQuery-插件"><a href="#制作-jQuery-插件" class="headerlink" title="制作 jQuery 插件"></a>制作 jQuery 插件</h3><p>制作 jQuery 插件的核心思想：给 jQuery 的原型增加方法即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.fn.pluginName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>制作基本的jQuery插件（jquery.bgc.js）</li><li>制作手风琴插件</li></ul><h2 id="jQuery-架构"><a href="#jQuery-架构" class="headerlink" title="jQuery 架构"></a>jQuery 架构</h2><p>看源码学习推荐看 1.7.0 版本，源码比较清晰</p><h3 id="jq-的基本架构"><a href="#jq-的基本架构" class="headerlink" title="jq 的基本架构"></a>jq 的基本架构</h3><p>沙箱 ，减少全局污染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(undefined)</span></span><br><span class="line">  <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 往外暴露</span></span><br><span class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"><span class="keyword">var</span> jq = <span class="keyword">new</span> jQuery() <span class="comment">// ==&gt; 得到一个jq的实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log(jq)</span><br></pre></td></tr></table></figure><p>参数 <code>window</code> 的作用：</p><ul><li>减少对 window 的搜索过程</li><li>有利于代码压缩</li></ul><p>参数 <code>undefined</code> 的作用：</p><ul><li>参数 <code>undefined</code> 的值是 <code>undefined</code></li><li><code>undefined</code> 这个数据类型的值在ie678 中是可以被修改的，现在有 <code>undefined</code> 形参在这，在沙箱里面去使用 <code>undefined</code> 的时候，就不会去引用外面被修改的 <code>undefined</code> 的值</li></ul><h3 id="省去-new-操作"><a href="#省去-new-操作" class="headerlink" title="省去 new 操作"></a>省去 new 操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省去 new 操作，得到一个jq的实例对象</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// jQuery 是 工厂函数， 里面干啥？</span></span><br><span class="line">  <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return new 构造函数</span></span><br><span class="line">    <span class="comment">// 在 jq 里面，真正的构造函数是 init，而且 init 方法放在 jq 的原型上</span></span><br><span class="line">    <span class="comment">// jQuery.fn.init ==&gt; 是从 jq 的原型上拿 init 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector) <span class="comment">// init 何种调用模式， 构造函数模式</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    <span class="comment">// 原型替换</span></span><br><span class="line">    <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">    init: function (selector) &#123;</span><br><span class="line">      <span class="comment">// init 是真正的构造函数</span></span><br><span class="line">      <span class="comment">// 获取元素</span></span><br><span class="line">      <span class="keyword">var</span> ele = <span class="built_in">document</span>.querySelectorAll(selector)</span><br><span class="line">      <span class="comment">// this ==&gt; init的实例对象</span></span><br><span class="line">      ;[].push.apply(<span class="keyword">this</span>, ele)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    css: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'css is ok'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 init 的构造函数的 prototype 改成 jquery 的原型</span></span><br><span class="line"><span class="comment">// 目的： 让 init 的实例对象可以访问 jq 原型上的方法</span></span><br><span class="line">jQuery.fn.init.prototype = jQuery.fn</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'div'</span>) <span class="comment">// init实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log($div)</span><br><span class="line">$div.css()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Api</title>
      <link href="/2018/javascript/webapi/"/>
      <url>/2018/javascript/webapi/</url>
      
        <content type="html"><![CDATA[<h1 id="Web-Api-基本概念"><a href="#Web-Api-基本概念" class="headerlink" title="Web Api 基本概念"></a>Web Api 基本概念</h1><p><strong>API</strong>（Application Programming Interface,应用程序编程接口）</p><p><strong>API 是一些预先定义的方法，这些方法能够实现某些特定的功能</strong></p><ul><li>任何开发语言都会提供自己的API</li><li>API的特征输入和输出(参数/返回值)</li></ul><p>通俗的讲，API就是编程语言给我提供的一些 <code>工具</code>，通过这些<code>工具</code>，我们可以非常轻易的完成一些功能。</p><p><strong>Web API</strong> : 是浏览器提供的 <strong>一套操作网页(web)的方法(API)</strong>,  通过这套API我们可以非常轻松的操作<code>页面的元素</code>和<code>浏览器的一些功能</code></p><p>*<em>ECMAScript - JavaScript的核心 *</em></p><ul><li>ECMAScript是一套标准, 规范了语言的基本语法和数据类型</li><li>与具体实现无关</li></ul><p><strong>DOM</strong> - 文档对象模型</p><ul><li>一套操作页面元素的API</li><li>通过DOM提供的API可以获取/操作网页上的元素</li></ul><p><strong>BOM - 浏览器对象模型</strong></p><ul><li>一套操作浏览器功能的API</li><li>通过BOM可以操作浏览器窗口, 比如刷新、控制浏览器跳转等</li></ul><h1 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM  文档对象模型"></a>DOM  文档对象模型</h1><h2 id="DOM-基本概念"><a href="#DOM-基本概念" class="headerlink" title="DOM 基本概念"></a>DOM 基本概念</h2><blockquote><p>DOM ( Document Object Model ) 文档对象模型，是<code>W3C组织</code>推荐的一套操作网页元素的API</p></blockquote><p>DOM又称为文档树模型，因为整个HTML文档是一个树形的结构</p><p><strong>DOM中常见的概念</strong> :</p><ul><li><p><strong>文档 <code>document</code></strong> : 一个网页可以称为文档；（换句话说：操作页面，其实就是操作document）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>)</span><br><span class="line"><span class="comment">// DOM 会把整个网页当成一个对象，我们操作这个网页，只要操作这个document对象</span></span><br><span class="line"><span class="comment">// DOM 会把网页中的所有的东西都当作对象</span></span><br></pre></td></tr></table></figure></li><li><p><strong>节点<code>node</code></strong> : 网页中的所有内容都是节点 (标签、属性、文本)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>  ul: 标签节点 class="box": 属性节点</span><br><span class="line">    <span class="comment">&lt;!-- 这是一些测试 --&gt;</span>  注释节点</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  测试:文本节点</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>元素 <code>element</code></strong> : 网页中的<strong>标签节点</strong></p></li></ul><h2 id="获取元素的方法"><a href="#获取元素的方法" class="headerlink" title="获取元素的方法"></a>获取元素的方法</h2><ul><li><strong>document.getElementById()</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过id 获取元素</span></span><br><span class="line"><span class="comment">// 参数 : 字符串类型的id</span></span><br><span class="line"><span class="comment">// 返回值 : 一个元素（dom对象）</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">console</span>.dir(div) <span class="comment">// 以对象的形式显示</span></span><br><span class="line"><span class="built_in">console</span>.log(div) <span class="comment">// 以内容的形式显示</span></span><br></pre></td></tr></table></figure><p>​    <strong>关于<code>console.log()</code>和<code>console.dir()</code>的区别</strong></p><p>​    <code>console.log()</code> ：打印一个元素的时候，是以标签的形式进行展示的</p><p>​    <code>console.dir()</code> ：打印一个元素的时候，是以对象的形式进行展示的</p><ul><li><strong>getElementsByClassName()</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类名获取元素</span></span><br><span class="line"><span class="comment">// 参数：字符串类型的类名</span></span><br><span class="line"><span class="comment">// 返回值：伪数组</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">"class"</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>getElementsByTagName()</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过标签名获取元素</span></span><br><span class="line"><span class="comment">// 参数：标签名字符串</span></span><br><span class="line"><span class="comment">// 返回值：伪数组</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>getElementsByName()</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过name属性值获取元素</span></span><br><span class="line"><span class="comment">// 参数 : name值</span></span><br><span class="line"><span class="comment">// 返回值 : 伪数组</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.getElementsByName(<span class="string">"aa"</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>querySelector()</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据css选择器获取元素 (重点)</span></span><br><span class="line"><span class="comment">// 参数：是一个css选择器</span></span><br><span class="line"><span class="comment">// 返回值：只会返回一个对象，如果有很多个，会返回第一个</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#box"</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>querySelectorAll()</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据css选择器获取元素 (重点)</span></span><br><span class="line"><span class="comment">// 参数：是一个css选择器</span></span><br><span class="line"><span class="comment">// 返回值：伪数组</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">".box"</span>)</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><p><code>getElementById()</code> 只能由 <code>document</code> 调用，如果通过其他元素调用会报错，其他方法可由已经获取到的dom对象调用</p></li><li><p><code>querySelector</code>和 <code>getElementById</code>如果获取不到元素会返回 null；<code>getElementsByClassName</code> 、<code>getElementsByTagName</code> 、<code>getElementsByName</code> 、<code>querySelectorAll</code> 如果没有获取到元素也会返回一个伪数组，只不过伪数组长度为0</p></li><li><p>伪数组不是数组，不能使用属性的方法，但是可以跟数组一样进行遍历和使用下标进行操作；伪数组不能直接注册事件，需要遍历后拿到标签再注册事件</p></li><li><p>在DOM中, 获取元素操作需要写在html内容的后面，保证页面加载完成之后才能获取到内容</p></li></ul><h2 id="事件学习"><a href="#事件学习" class="headerlink" title="事件学习"></a>事件学习</h2><h3 id="认识事件"><a href="#认识事件" class="headerlink" title="认识事件"></a>认识事件</h3><blockquote><p>事件：理解为浏览器的感知系统  ,  触发 –&gt; 响应机制，javascript是基于事件驱动的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击事件</span></span><br><span class="line"><span class="comment">// 结构 : 事件源.onclick = function () &#123;..&#125;</span></span><br></pre></td></tr></table></figure><p> 事件三要素 :  事件源  + 事件名称 +  事件处理函数</p><ul><li>事件源 : 给谁注册事件 ( 按钮  btn )</li><li>事件名称 : 注册了什么事件 ( click事件 )</li><li>事件处理函数 : 事件触发后要执行的代码(函数形式)</li></ul><p>注意：事件处理函数并不会立马执行，而是当事件触发的时候才会执行（浏览器会自动调用）</p><p>注册事件的基本语法 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>)</span><br><span class="line"><span class="comment">//on:当  click:点击   当按钮被点击的时候触发</span></span><br><span class="line">box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'代码会在box被点击后执行'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>两种按钮</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>点亮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"哈"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">都是可点击的普通按钮</span><br><span class="line">一个是文字显示在标签内容里, 而且还可以放其他标签</span><br><span class="line">一个是文字显示在vaue中</span><br></pre></td></tr></table></figure><h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><ul><li><code>focus</code>  :  获得焦点</li><li><code>blur</code>  :  失去焦点</li></ul><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ul><li><code>click</code> : 单击</li><li><code>dblclick</code> ：双击</li><li><code>mouseover/mouseout</code> :  进入/离开元素</li><li><code>mouseenter/mouseleave</code> :  进入/离开元素</li><li><code>mousedown</code> ：按下</li><li><code>mouseup</code>  ：抬起/释放</li><li><code>mousemove</code> ：移动</li></ul><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><ul><li><code>keydown/keypress</code> ：按下</li><li><code>keyup</code>： 释放</li></ul><h3 id="事件中的this"><a href="#事件中的this" class="headerlink" title="事件中的this"></a>事件中的this</h3><blockquote><p>this 指向注册事件的事件源</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 给 btn 注册的事件，因此 this 表示 btn</span></span><br><span class="line">  <span class="keyword">this</span>.value = <span class="string">'哈哈'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 给多个按钮注册点击事件，点击的那个变成红色 --&gt;</span></span><br><span class="line">.red &#123;</span><br><span class="line">    background: red</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 给多个按钮注册点击事件，点击的那个变成红色，其他的恢复默认</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// console.log(i) // 点击按钮时打印 2</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// btns[i].className = 'red' // 此时 i = 2，报错</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                btns[i].className = <span class="string">''</span>  <span class="comment">// 恢复默认样式 ，排他思想</span></span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.className = <span class="string">'red'</span> <span class="comment">// 给自己添加样式</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 2. 点击按钮，显示对应的图片  1-6</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"第一张"</span> <span class="attr">title</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"img"</span> <span class="attr">src</span>=<span class="string">"images/1.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="阻止浏览器默认行为"><a href="#阻止浏览器默认行为" class="headerlink" title="阻止浏览器默认行为"></a>阻止浏览器默认行为</h2><blockquote><p>对于 a 标签来说，默认的行为就是进行页面跳转，如果不想让 a 标签进行跳转，可以在注册事件中使用<code>return false</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"link"</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>这是a<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">'link'</span>)</span></span><br><span class="line"><span class="javascript">    link.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">'呵呵'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 阻止页面跳转</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>e.preventDefault() 只会阻止浏览器的默认行为，并不会停止函数执行</li><li>return false后的代码不在执行</li><li>在jQuery中，<code>return false</code>在调用时会执行3个单独的操作：<ol><li><code>event.preventDefault()</code></li><li><code>event.stopPropagation()</code></li><li>停止回调执行并在调用时立即返回</li></ol></li></ol><h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><ul><li>在DOM中，页面标签的属性和DOM对象的属性是一一对应的，因此我们可以通过修改DOM对象的属性来修改标签的属性</li></ul><h3 id="普通标签属性"><a href="#普通标签属性" class="headerlink" title="普通标签属性"></a>普通标签属性</h3><ul><li><p>常见的属性有：src、title、src、href、class、id等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 js 中 class 是关键字，因此对应的是 className 属性</span></span><br><span class="line">div.className = <span class="string">'hg'</span> <span class="comment">// 修改类名会把原类名直接覆盖掉</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="表单属性操作"><a href="#表单属性操作" class="headerlink" title="表单属性操作"></a>表单属性操作</h3><ul><li>常见的表单属性有：disabled、type、value、checked、selected</li><li>对于disabled、checked、selected三个属性来说，比较特殊。在DOM对象中，这些属性是一个布尔类型的属性，值只有 true 或者 false</li></ul><p>!&gt; reset() 方法可把表单中的元素重置为它们的默认值</p><p>【案例：禁用文本框】</p><p>【案例：随机下拉框选中】</p><p>【案例：表格全选案例】</p><h3 id="标签的自定义属性"><a href="#标签的自定义属性" class="headerlink" title="标签的自定义属性"></a>标签的自定义属性</h3><blockquote><p>我们之前讨论的属性，都是HTML规范中，标签本来就有的属性，对于标签自定义的一些属性，比较特殊</p></blockquote><p>在html页面中，定义一个自定义属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span> <span class="attr">aa</span>=<span class="string">"bb"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在对应的DOM对象中是不存在的，在DOM对象中只会存在固定的那些属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(box.aa) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>attribute 方法</strong></p><blockquote><p>attribute 系列方法用于设置标签的属性，不管是自定义的还是固有的属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取标签的属性</span></span><br><span class="line">box.getAttribute(属性名)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置标签的属性</span></span><br><span class="line">box.setAttribute(属性名, 属性值)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标签的属性</span></span><br><span class="line">box.removeAttribute(属性名)</span><br></pre></td></tr></table></figure><p>区别 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;div a="1" id="box"&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 直接给标签里只能添加固有的属性 title 等 标签+对象里都有显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 给标签添加自定义属性--标签上显示</span></span><br><span class="line"><span class="built_in">console</span>.log(box.a) <span class="comment">// undefined =&gt; 对象中不显示</span></span><br><span class="line"><span class="built_in">console</span>.log(box.getAttribute(<span class="string">'a'</span>)) <span class="comment">// 1 =&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 给对象添加自定义属性 -- 标签中不显示</span></span><br><span class="line">box.b = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(box.b) <span class="comment">// 2 =&gt; 对象中显示</span></span><br><span class="line"><span class="built_in">console</span>.log(box.getAttribute(<span class="string">'b'</span>)) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Attribute方法</span></span><br><span class="line">box.setAttribute(<span class="string">'c'</span>, <span class="number">3</span>) <span class="comment">// 标签中显示</span></span><br><span class="line"><span class="built_in">console</span>.dir(box)</span><br><span class="line"><span class="built_in">console</span>.log(box.c) <span class="comment">// undefined =&gt;对象中不显示</span></span><br><span class="line"><span class="built_in">console</span>.log(box.getAttribute(<span class="string">'c'</span>)) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(box.attributes) <span class="comment">// &#123;0: a, 1: id, 2: c, a: a, id: id, c: c, length: 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(box.attributes.c) <span class="comment">// c='3'</span></span><br></pre></td></tr></table></figure><h3 id="tab-栏案例-重点"><a href="#tab-栏案例-重点" class="headerlink" title="tab 栏案例 (重点)"></a>tab 栏案例 (重点)</h3><p><strong>[案例：获取当前元素的索引] (超级重要)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：</span></span><br><span class="line"><span class="comment">// 存</span></span><br><span class="line">btns[i].setAttribute(<span class="string">'index'</span>, i)</span><br><span class="line"><span class="comment">// 取</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.getAttribute(<span class="string">'index'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line"><span class="comment">// 存</span></span><br><span class="line">btns[i].index = i</span><br><span class="line"><span class="comment">// 取</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.index)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区别在于: 第一个显示在标签内  第二个不显示在标签内 推荐第二种</span></span><br></pre></td></tr></table></figure><p><strong>【案例：tab栏切换】</strong></p><h2 id="标签的内容属性"><a href="#标签的内容属性" class="headerlink" title="标签的内容属性"></a>标签的内容属性</h2><h3 id="innerText-和-innerHTML"><a href="#innerText-和-innerHTML" class="headerlink" title="innerText 和 innerHTML"></a>innerText 和 innerHTML</h3><ul><li>共同点 : 都是用来获取和设置标签的内容的</li><li>区别：<ul><li>innerHTML 能够识别标签，标签能够生效</li><li>innerText 只识别文本，标签会被转义</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>)</span><br><span class="line"><span class="comment">// 获取内容</span></span><br><span class="line"><span class="comment">// 获取标签内容的时候，只会获取文本，标签扔掉了</span></span><br><span class="line"><span class="built_in">console</span>.log(div.innerText) <span class="comment">// 哈哈</span></span><br><span class="line"><span class="comment">// 获取标签内容的时候，不管标签还是文本，都能获取到</span></span><br><span class="line"><span class="built_in">console</span>.log(div.innerHTML) <span class="comment">// &lt;h1&gt;哈哈&lt;/h1&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置内容</span></span><br><span class="line"><span class="comment">// 设置标签内容的时候，覆盖原来内容，对标签进行转义</span></span><br><span class="line">div.innerText = <span class="string">'&lt;h1&gt;嘿嘿&lt;/h1&gt;'</span></span><br><span class="line"><span class="comment">// 设置内容的时候，覆盖原来内容，标签也能生效，浏览器能解析这个标签</span></span><br><span class="line">div.innerHTML = <span class="string">'&lt;h1&gt;嘿嘿&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure><blockquote><p>浏览器兼容性：指网页在各种浏览器上的显示效果不一致。或者是一些属性和方法在低版本的浏览器中不支持</p></blockquote><ul><li>innerText 是 IE 提出来的属性，因此低版本的火狐浏览器不支持这个属性。</li><li>火狐有一个 textContent 属性，效果跟 innerText 一样，但是IE678不支持这个属性</li></ul><p>书写 innerText 的兼容性代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInnerText</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> element.innerText === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> element.innerText</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element.textContent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行内样式操作（style属性）"><a href="#行内样式操作（style属性）" class="headerlink" title="行内样式操作（style属性）"></a>行内样式操作（style属性）</h2><blockquote><p>标签不仅可以通过class属性操作样式 (嵌套样式)，还可以通过style属性操作样式 (行内样式)。</p><p>同样的DOM对象可以通过className操作样式  (嵌套样式)，也可以通过style属性操作样  (行内样式)。</p><p>css : 嵌套样式   =&gt;  js :  类名 div.className = ‘red’</p><p>css : 行内样式   =&gt;  js :  style对象  div.style.color = ‘red’</p></blockquote><h3 id="样式属性"><a href="#样式属性" class="headerlink" title="样式属性"></a>样式属性</h3><ul><li>style 属性是一个对象，里面存储了所有行内样式的键值对</li><li>style 属性只能获取和设置<strong>行内样式</strong>，嵌套样式通过 style 获取不到</li><li>如果样式的名字带 <code>-</code> ，比如 background-color ，在 style 对象中使用backgroundColor  =&gt;  （因为 <code>-</code> 在js中不是一个合法的标识符）</li><li>style 设置的样式是行内样式，优先级要高于通过 className 设置的样式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">"color:red;background-color:blue;"</span>&gt;哈哈&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">var div = document.querySelector('div')</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 获取样式</span></span><br><span class="line"><span class="regexp">console.log(div.style)</span></span><br><span class="line"><span class="regexp">console.log(div.style.color) /</span><span class="regexp">/ red</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 设置样式</span></span><br><span class="line"><span class="regexp">div.style.width = '200px'</span></span><br><span class="line"><span class="regexp">div.style.height = '200px'</span></span><br><span class="line"><span class="regexp">div.style.fontSize = '100px'</span></span><br><span class="line"><span class="regexp">div.className = 'box'</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>getComputedStyle 获取元素计算后的样式</strong></p><p>语法： <code>window.getComputedStyle( 获取的元素， 伪类)</code></p><p>​    伪类  ==&gt;  ::after ::before，如果写上了伪类，表示要获取元素的伪类的样式，如果不需要获取的话，该参数写 null</p><p>​    返回值： 返回一个样式对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span><br><span class="line">&gt;  <span class="comment">// 获取元素自身的</span></span><br><span class="line">&gt;  <span class="keyword">var</span> ret = <span class="built_in">window</span>.getComputedStyle(div, <span class="literal">null</span>).fontSize</span><br><span class="line">&gt;  <span class="keyword">var</span> ret1 = <span class="built_in">window</span>.getComputedStyle(div, <span class="literal">null</span>).backgroundColor</span><br><span class="line">&gt;  <span class="comment">// 推荐：对于复合样式，需要获取什么样式，写具体的样式名，这样能更好的兼容更多浏览器</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;  <span class="comment">// 获取伪类的</span></span><br><span class="line">&gt;  <span class="keyword">var</span> ret2 = <span class="built_in">window</span>.getComputedStyle(div, <span class="string">'::after'</span>).width</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>​</p><h3 id="关于-body-的样式操作"><a href="#关于-body-的样式操作" class="headerlink" title="关于 body 的样式操作"></a>关于 body 的样式操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bd = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bd) <span class="comment">// 通过 querySelector 获取 body 元素</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body) <span class="comment">// 直接获取 body 元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.documentElement <span class="comment">// 可以获取 html 元素</span></span><br><span class="line"><span class="built_in">document</span>.head <span class="comment">// 直接获取 head 元素</span></span><br><span class="line"><span class="built_in">document</span>.title <span class="comment">// 获取的是 title 中的文本</span></span><br></pre></td></tr></table></figure><p><strong>【案例：开关灯案例】</strong></p><p><strong>【案例：随机背景颜色案例】</strong></p><p><strong>【案例：百度换肤】</strong></p><h3 id="关于-cssText-了解"><a href="#关于-cssText-了解" class="headerlink" title="关于 cssText  (了解)"></a>关于 cssText  (了解)</h3><blockquote><p>使用 cssText 可以设置 style 的属性值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px; height: 100px"</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 优点：可以一次性设置多个值</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 缺点：会覆盖整个style属性且不利于阅读</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="javascript">  div.style.cssText = <span class="string">'background:red;color:yellow'</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="节点操作-超级重要"><a href="#节点操作-超级重要" class="headerlink" title="节点操作 (超级重要)"></a>节点操作 (超级重要)</h2><h3 id="节点属性-了解"><a href="#节点属性-了解" class="headerlink" title="节点属性 (了解)"></a>节点属性 (了解)</h3><p><strong>节点分类：</strong></p><p>​    元素节点、文本节点、属性节点、注释节点</p><p><strong>节点常用的属性</strong></p><ul><li><p>childNodes :  获取所有的子节点</p></li><li><p><strong>nodeType</strong>:  节点类型：元素节点 = 1  属性-2(过时)   注释-8  文本-3</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType" target="_blank" rel="noopener">nodeType链接-MDN</a></p></li><li><p><strong>nodeName</strong>: 节点名称</p></li><li><p><strong>nodeValue</strong>: 节点值</p></li></ul><h3 id="节点查找-重点"><a href="#节点查找-重点" class="headerlink" title="节点查找 (重点)"></a>节点查找 (重点)</h3><h4 id="孩子节点"><a href="#孩子节点" class="headerlink" title="孩子节点"></a>孩子节点</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下面是li --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>导航1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>导航2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>导航3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>导航4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>)</span></span><br><span class="line"><span class="javascript"><span class="comment">// 获取ul所有的子节点（包括了元素节点和其他很多类型的节点，基本不常用）</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(ul.childNodes)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取第一个子节点  (不常用)</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(ul.firstChild)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取最后一个子节点  (不常用)</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(ul.lastChild)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取所有的子元素，兼容性：IE678会把注释节点算上</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(ul.children)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取第一个子元素 有兼容性问题（IE678）</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(ul.firstElementChild)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取最后一个子元素 有兼容性问题（IE678）</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(ul.lastElementChild)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取第n个子元素 有兼容性问题（IE678）</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(ul.children[n])</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><ul><li><code>nextSibling</code> : 下一个兄弟节点  (基本不常用)</li><li><code>nextElementSibling</code> : 下一个兄弟元素（IE678不兼容）</li><li><code>previousSibling</code> : 上一个兄弟节点  (基本不常用)</li><li><code>previousElementSibling</code> : 上一个兄弟元素 有兼容性问题 可以封装一个兼容性方法</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>导航1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"p"</span>&gt;</span>导航2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>导航3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> p2 = <span class="built_in">document</span>.querySelector(<span class="string">'.p'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(p2)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(p2.nextSibling)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(p2.nextElementSibling)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(p2.previousSibling)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(p2.previousElementSibling)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>【案例1：表单校验】</strong></p><h4 id="父亲节点"><a href="#父亲节点" class="headerlink" title="父亲节点"></a>父亲节点</h4><ul><li><code>parentNode</code> : 父节点（没有兼容性问题）</li><li><code>parentElement</code> : 父元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.parentNode // 获取父节点</span><br></pre></td></tr></table></figure><h3 id="添加节点-重点"><a href="#添加节点-重点" class="headerlink" title="添加节点 (重点)"></a>添加节点 (重点)</h3><h4 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild()"></a>appendChild()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用：在子元素的最后添加一个元素</span></span><br><span class="line"><span class="comment">// 语法：parent.appendChild(newChild)</span></span><br><span class="line"><span class="comment">// 父元素.appendChild(新子元素)</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> : 如果 newChild 已经存在于DOM树中，则它会被从原始位置删除</p></blockquote><h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore()"></a>insertBefore()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用：在某个子元素之前添加一个元素</span></span><br><span class="line"><span class="comment">// 语法：parent.insertBefore(newChild, refChild)</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>必须要父节点来调用，newChild 为需要添加的那个节点，refChild 为添加到哪一个节点的前面</li><li>没有 <code>insertAfter()</code></li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素添加到最后</span></span><br><span class="line">div.appendChild(p) <span class="comment">// (常用)</span></span><br><span class="line">div.insertBefore(p, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素添加到 s1 之前(常用)</span></span><br><span class="line">div.insertBefore(p, s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素添加到 s1 之后</span></span><br><span class="line"><span class="comment">// 没有 insertAfter</span></span><br><span class="line">div.insertBefore(p, s1.nextElementSibling)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素添加到最前</span></span><br><span class="line">div.insertBefore(p, div.children[<span class="number">0</span>]) <span class="comment">// (常用)</span></span><br><span class="line">div.insertBefore(p, div.firstElementChild)</span><br></pre></td></tr></table></figure><h3 id="克隆节点-重点"><a href="#克隆节点-重点" class="headerlink" title="克隆节点 (重点)"></a>克隆节点 (重点)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：var newNode = 节点.cloneNode([isDeep])</span></span><br><span class="line"><span class="comment">// isDeep参数：false / true</span></span><br><span class="line"><span class="comment">// false：默认值：是浅复制，只会复制标签节点本身，不会复制节点的孩子</span></span><br><span class="line"><span class="comment">// true:   深度复制，会复制标签，还会复制标签的所有内容</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>克隆出来的节点跟原来的节点没有关系了，修改了也不会相互影响</li><li>如果克隆的节点带了id，我们需要给id重新设置一个值，不让id冲突</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newNode = div.cloneNode(<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newNode)</span><br></pre></td></tr></table></figure><h3 id="创建节点-3种方式-重点"><a href="#创建节点-3种方式-重点" class="headerlink" title="创建节点(3种方式)  (重点)"></a>创建节点(3种方式)  (重点)</h3><h4 id="document-write（基本不用）"><a href="#document-write（基本不用）" class="headerlink" title="document.write（基本不用）"></a>document.write（基本不用）</h4><p>可以生成新的节点，但是不推荐使用。如果页面已经加载完成了，再用document.write写内容的话，会把之前的页面给覆盖掉</p><blockquote><p>原理：页面从上往下加载的时候，会开启一个文档流，当页面加载完，文档流就会关闭。document.write 的本意就是在文档流上写入内容。如果页面没加载完成，文档流还是开着的，document.write直接在这个文档流上写东西，如果页面加载完成了，还是用document.write写东西，会重新开启一个新的文档流，往新的文档流上写东西，旧的文档流就被新的文档流覆盖了。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'呵呵'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="innerHTML-偶尔用"><a href="#innerHTML-偶尔用" class="headerlink" title="innerHTML (偶尔用)"></a>innerHTML (偶尔用)</h4><p>innerHTML也可以创建节点</p><blockquote><p>使用 innerHTML 创建节点时，如果原来有内容的话，会把原先的内容覆盖</p><p>慎用：很容易出现效率问题</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.innerHTML = <span class="string">'&lt;h1&gt;哈哈&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure><h4 id="createElement-常用"><a href="#createElement-常用" class="headerlink" title="createElement  (常用)"></a>createElement  (常用)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：var element = document.createElement('tagName')</span></span><br><span class="line"><span class="comment">// 返回：一个元素</span></span><br><span class="line"><span class="comment">// 需要配合 appendChild 和 innerText 来使用</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">var</span> h1 = <span class="built_in">document</span>.createElement(<span class="string">'h1'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(h1)</span><br><span class="line">h1.style.background = <span class="string">'red'</span></span><br><span class="line">h1.innerText = <span class="string">'哈'</span></span><br><span class="line">div.appendChild(h1)</span><br></pre></td></tr></table></figure><h3 id="删除节点-重点"><a href="#删除节点-重点" class="headerlink" title="删除节点 (重点)"></a>删除节点 (重点)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：parent.removeChild(child)</span></span><br><span class="line"><span class="comment">// 解析：父元素.removeChild(子元素)</span></span><br><span class="line"><span class="comment">// 功能：由父元素调用，删除里面的一个子元素</span></span><br><span class="line"></span><br><span class="line">div.removeChild(p)</span><br><span class="line">p.parentNode.removeChild(p)</span><br></pre></td></tr></table></figure><p><strong>【案例 : 节点操作-删除节点】</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 使用 children 和 TagName  =&gt;  需要配合 i--</span><br><span class="line"><span class="comment">// 原因 :动态计算 , 每删除一个,都会重新分配一次下标</span></span><br><span class="line"><span class="number">2.</span> 使用 querySelectorAll(<span class="string">'li'</span>) =&gt;  ok的</span><br><span class="line"><span class="comment">// 原因 : 静态计算</span></span><br></pre></td></tr></table></figure><p> <strong>[案例 : 许愿墙案例]</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能<span class="number">1</span> : 克隆<span class="number">10</span>个tip, 并且随机分布</span><br><span class="line">功能<span class="number">2</span> : 点击提高层级</span><br><span class="line">功能<span class="number">3</span> : 点击x, 删除当前tip</span><br><span class="line">功能<span class="number">4</span> : 双击tip头部,删除当前tip</span><br></pre></td></tr></table></figure><h3 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：</span></span><br><span class="line"><span class="comment">// newChild 为用来替换 oldChild 的新节点</span></span><br><span class="line">parentNode.replaceChild(newChild,  oldChild)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> : 如果 newChild 已经存在于DOM树中，则它会被从原始位置删除</p></blockquote><h3 id="节点操作综合案例"><a href="#节点操作综合案例" class="headerlink" title="节点操作综合案例"></a>节点操作综合案例</h3><p>【动态生成表格】</p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><blockquote><p>BOM（Browser Object Model）：浏览器对象模型，提供了一套操作浏览器功能的工具</p></blockquote><p><img src="2.png" alt></p><p><strong>重点</strong> ：定时器、 offset系列</p><h2 id="window"><a href="#window" class="headerlink" title="window"></a><code>window</code></h2><ul><li>window 对象是一个全局对象，也可以说是 JavaScript 中的顶级对象</li><li>所有定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法</li><li>像 document、alert()、console.log() 这些都是 window 的属性，其实 BOM 中基本所有的属性和方法都是 window 的</li><li>window 对象下的属性和方法调用的时候可以省略 window</li></ul><h3 id="onload（掌握）"><a href="#onload（掌握）" class="headerlink" title=".onload（掌握）"></a>.onload（掌握）</h3><blockquote><p>window.onload 事件会在  <strong>窗体加载完成</strong>  后执行，通常我们称之为入口函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//代码会在窗体加载完成后执行。</span></span><br><span class="line"><span class="comment">//窗体加载完成 包括文档树(DOM html)的加载、还有图片、文件的加载完成。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果有图片加载，那么代码一定要写到window.onload里面，否则会出现图片没有加载完成，获取到的宽度和高度不对的情况。</p><p>浏览器会对页面的加载做优化，在加载图片的时候，图片的引入会延迟。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"./01.png"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(img.width)</span><br><span class="line">  <span class="built_in">console</span>.log(img.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="open-与-close-了解"><a href="#open-与-close-了解" class="headerlink" title=".open() 与 .close() (了解)"></a>.open() 与 .close() (了解)</h3><ul><li>window.open() 打开一个窗口</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：window.open(url, [name], [features])</span></span><br><span class="line"><span class="comment">// 参数1：需要载入的 url 地址</span></span><br><span class="line"><span class="comment">// 参数2：新窗口的名称或者 targt 属性</span></span><br><span class="line"><span class="comment">// _blank:如果指定为 _blank，表示在新的窗口打开</span></span><br><span class="line"><span class="comment">// 参数3：窗口的属性，指定窗口的大小</span></span><br><span class="line"><span class="comment">// 返回值：会返回刚刚创建的那个窗口，在 window.close() 时使用</span></span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">var</span> newWin = <span class="built_in">window</span>.open(<span class="string">'http://www.baidu.com'</span>, <span class="string">'_blank'</span>, <span class="string">'width=300,height=300'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数配置：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open</span></span><br></pre></td></tr></table></figure><ul><li>window.close() 关闭窗口</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newWin.close() <span class="comment">// newWin 是刚刚创建的那个窗口</span></span><br><span class="line"><span class="built_in">window</span>.close() <span class="comment">// 把当前窗口给关闭</span></span><br></pre></td></tr></table></figure><h2 id="延时器与定时器-重点"><a href="#延时器与定时器-重点" class="headerlink" title="延时器与定时器  (重点)"></a>延时器与定时器  (重点)</h2><h3 id="setTimeout-延时器"><a href="#setTimeout-延时器" class="headerlink" title="setTimeout 延时器"></a>setTimeout 延时器</h3><blockquote><p>可以在延迟一定时间后执行指定的代码</p></blockquote><p><strong>设置延时器</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法: setTimeOut(callback,time)</span></span><br><span class="line"><span class="comment">// 参数1: 回调函数, 时间到了就会执行</span></span><br><span class="line"><span class="comment">// 参数2: 延时的时间  毫秒为单位 1s = 1000毫秒</span></span><br><span class="line"><span class="comment">// 返回 : 延时器的id,用于清除</span></span><br><span class="line"><span class="keyword">var</span> timer = setTimeOut(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//1秒后将执行一次</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p><strong>清除延时器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法 : clearTimeOut(timerId)</span></span><br><span class="line"><span class="comment">// 参数 : 延时器id</span></span><br><span class="line"><span class="comment">// 示例 :</span></span><br><span class="line">clearTimeOut(timer) <span class="comment">// 清除上面定义的延时器</span></span><br></pre></td></tr></table></figure><h3 id="setInterval-定时器"><a href="#setInterval-定时器" class="headerlink" title="setInterval  定时器"></a>setInterval  定时器</h3><blockquote><p>setInterval 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间间隔。  (每隔一段时间执行一段代码)</p><p>定时器除非清除，否则会一直执行下去。</p></blockquote><p><strong>设置定时器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法 :var timerId = setInterval(func,dealy)</span></span><br><span class="line"><span class="comment">// 参数1 ： 重复执行的函数</span></span><br><span class="line"><span class="comment">// 参数2 : 每次间隔的毫秒数</span></span><br><span class="line"><span class="comment">// 返回 : 定时器的id,  用于清除</span></span><br><span class="line"><span class="comment">// 示例 :</span></span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1s 之后开始重复执行</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p><strong>清除定时器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法 : clearInterval(intervalId)</span></span><br><span class="line"><span class="comment">// 参数 : 定时器id</span></span><br><span class="line"><span class="comment">// 示例 :</span></span><br><span class="line">clearInterval(timerId) <span class="comment">// 清除上面的定时器</span></span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>【短信验证码案例.html】</p><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><blockquote><p>location 对象也是 window 的一个属性</p><p>location 其实对应的就是浏览器中的地址栏</p></blockquote><h3 id="常用属性和方法"><a href="#常用属性和方法" class="headerlink" title="常用属性和方法"></a>常用属性和方法</h3><ul><li>location.href :  控制地址栏的地址，实现页面跳转</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">location.href = <span class="string">'http://www.baidu.com'</span> <span class="comment">// 点击页面跳转到百度首页</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[案例 : 注册成功，3秒后跳转]</p><blockquote><p><strong>页面跳转：</strong></p><p><code>location.href = &#39;url地址&#39;</code></p><p><code>location.assign(&#39;url地址&#39;)</code></p><p><code>location.replace(&#39;url地址&#39;)</code>  (不记录历史)</p></blockquote><ul><li>location.reload()  让页面重新加载</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">location.reload() <span class="comment">// 重新刷新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>location 的其他值</p><blockquote><p><code>http://www.bbb.com:8080/index.html?id=666&amp;psd=123#xxx</code></p><ul><li>location.hash  //哈希值 其实就是锚点     ==&gt; #xxx</li><li>location.host  //服务器 服务器名+端口号  =&gt; <a href="http://www.bbb.com:8080" target="_blank" rel="noopener">www.bbb.com:8080</a></li><li>location.hostname //服务器名            =&gt;  <a href="http://www.bbb.com" target="_blank" rel="noopener">www.bbb.com</a></li><li>location.pathname //路径名             =&gt; index.html</li><li>location.port //端口                   =&gt; 8080</li><li>location.protocol //协议               =&gt; http</li><li><strong>location.search</strong> //参数                 =&gt; ?id=666&amp;psd=123</li></ul></blockquote></li></ul><h2 id="其他对象"><a href="#其他对象" class="headerlink" title="其他对象"></a>其他对象</h2><ul><li>history 对象表示页面的历史</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随便打开一个网页 可以演示</span></span><br><span class="line"><span class="comment">// 后退：</span></span><br><span class="line">history.back()</span><br><span class="line">history.go(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 前进：</span></span><br><span class="line">history.forward()</span><br><span class="line">history.go(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>screen 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(screen.width) <span class="comment">// 屏幕的宽度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.height) <span class="comment">// 屏幕的高度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.availWidth) <span class="comment">// 浏览器可占用的宽度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.availHeight) <span class="comment">// 浏览器可占用的高度</span></span><br></pre></td></tr></table></figure><h2 id="缓动动画"><a href="#缓动动画" class="headerlink" title="缓动动画"></a>缓动动画</h2><h3 id="缓动动画初体验"><a href="#缓动动画初体验" class="headerlink" title="缓动动画初体验"></a>缓动动画初体验</h3><p>动画公式 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> step = (target-current)/<span class="number">10</span></span><br><span class="line">current += step</span><br></pre></td></tr></table></figure><p>[案例演示 : ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 三步走</span><br><span class="line">- 获取当前位置</span><br><span class="line">- 累加小碎步</span><br><span class="line">- 重复赋值回去</span><br><span class="line">2. 定时器</span><br></pre></td></tr></table></figure><p><strong>缺点</strong> : 打开控制台, 查看盒子的结构行内样式left, 发现并没有跑到400px, 只能跑到396.4/395.5</p><p><strong>原因</strong> : offsetLeft获取值的时候, 只会获取整数 ,  (对小数部分会四舍五入,整数有时候往上取整,有时候往下取整);   <strong>可以在获取的offset地方打印查看</strong></p><h3 id="缓动动画-移动400位置"><a href="#缓动动画-移动400位置" class="headerlink" title="缓动动画 - 移动400位置"></a>缓动动画 - 移动400位置</h3><p>动画公式 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> step =  (target-current)/<span class="number">10</span></span><br><span class="line">    step = <span class="built_in">Math</span>.ceil(step) <span class="comment">// 往上取整</span></span><br><span class="line">current += step</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么往上取整 :</span></span><br><span class="line"><span class="comment">// 1. 如果不取整，赋值为小数的话,下次取值还是会取个 整数回来，这就是之前的缺点</span></span><br><span class="line"><span class="comment">// 2. 往上取整的额原因是：(400-395)/10 = 0.5 如果往下取整为0，那就不会走了，所以</span></span><br><span class="line"><span class="comment">// 为了保证可以走，往上取整 取 1  步数 为 1</span></span><br></pre></td></tr></table></figure><p>案例演示 注意点 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>查看位置 : left有时候为 <span class="number">395.5</span>/ <span class="number">396.4</span></span><br><span class="line"><span class="number">2.</span>打印: <span class="function"><span class="params">offsetLeft</span>  =&gt;</span> <span class="number">395</span> / <span class="number">396</span></span><br><span class="line"><span class="number">3.</span>step为整数  往上取整</span><br></pre></td></tr></table></figure><h3 id="缓动动画-回到0点位置"><a href="#缓动动画-回到0点位置" class="headerlink" title="缓动动画 - 回到0点位置"></a>缓动动画 - 回到0点位置</h3><p>动画公式 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> step =  (target-current)/<span class="number">10</span></span><br><span class="line">    step = <span class="built_in">Math</span>.floor(step) <span class="comment">//往下取整</span></span><br><span class="line"> current += step</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么往下取整 :</span></span><br><span class="line"><span class="comment">// 1. 如果不取整，赋值为小数的话,下次取值还是会取个整数回来，这就是之前的缺点</span></span><br><span class="line"><span class="comment">// 2. 往上取整的额原因是 : (0-5)/10 = -0.5 如果往上取整为0  那就不会走了，所以</span></span><br><span class="line"><span class="comment">// 为了保证可以走，往下取整 : 取 -1    步数 为 -1</span></span><br></pre></td></tr></table></figure><p>案例演示注意点 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 先把盒子 设置 left : <span class="number">400</span>px 位置;  回到<span class="number">0</span>位置</span><br><span class="line"><span class="number">2.</span> 查看位置 : left有时候为 <span class="number">4.5</span></span><br><span class="line"><span class="number">3.</span> 打印: <span class="function"><span class="params">offsetLeft</span>  =&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="number">4.</span> step为整数  往下取整</span><br></pre></td></tr></table></figure><h3 id="缓动动画-封装函数"><a href="#缓动动画-封装函数" class="headerlink" title="缓动动画 - 封装函数"></a>缓动动画 - 封装函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span> (<span class="params">element, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.timerId) &#123;</span><br><span class="line">        clearInterval(element.timerId)</span><br><span class="line">&#125;</span><br><span class="line">    element.timerId = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前位置</span></span><br><span class="line">        <span class="keyword">var</span> current = element.offsetLeft</span><br><span class="line">        <span class="comment">// 2. 累加小碎步</span></span><br><span class="line">        <span class="keyword">var</span> step = (target - current) / <span class="number">10</span></span><br><span class="line">        <span class="comment">// 往上取整 ? 为什么，因为 0.5 如果网下取整也是0 ，不会走</span></span><br><span class="line">        step = step &gt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(step) : <span class="built_in">Math</span>.floor(step)</span><br><span class="line">        current += step <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// 3. 重新赋值</span></span><br><span class="line">        element.style.left = current + <span class="string">'px'</span> <span class="comment">//400</span></span><br><span class="line">        <span class="keyword">if</span> (current == target) &#123;</span><br><span class="line">          clearInterval(element.timerId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[案例 : 筋斗云]</p><p>[案例：开机提示关闭]</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><h3 id="事件对象的概述"><a href="#事件对象的概述" class="headerlink" title="事件对象的概述"></a>事件对象的概述</h3><blockquote><p>在<strong>触发某个事件</strong>的时候，都会产生一个<strong>事件对象 Event</strong>，这个对象中<strong>包含所有与事件相关的一些信息</strong>，包括触发事件的元素，事件的类型以及其他与事件相关的信息</p></blockquote><p><strong>鼠标</strong>事件<strong>触发</strong>时，事件对象中会包含<strong>鼠标的位置信息</strong>。</p><p><strong>键盘</strong>事件<strong>触发</strong>时，事件对象中会包含<strong>按下的键相关的信息</strong>。</p><h3 id="获取事件对象"><a href="#获取事件对象" class="headerlink" title="获取事件对象"></a>获取事件对象</h3><p><strong>现代浏览器获取 : (掌握)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给一个形参即可</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// e 就是事件对象，里面包含了事件触发时的一些信息</span></span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>低版本浏览器 (ie678):  (了解)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// IE678 通过 window.event 获取事件对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>兼容性 :</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 只要用到了事件对象，就要记得处理浏览器兼容性</span></span><br><span class="line">    <span class="comment">// 低版本IE event 不存在为undefined</span></span><br><span class="line">e = e || <span class="built_in">window</span>.event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件对象的常用属性"><a href="#事件对象的常用属性" class="headerlink" title="事件对象的常用属性"></a>事件对象的常用属性</h3><blockquote><p>事件对象中有很多很多的属性，但是很多属性并不常用。我们经常用到的是<strong>鼠标位置信息</strong>和<strong>键盘码</strong>相关的信息</p></blockquote><h4 id="鼠标位置信息"><a href="#鼠标位置信息" class="headerlink" title="鼠标位置信息"></a>鼠标位置信息</h4><ul><li><code>clientX</code> 与 <code>clientY</code> ： 相对于<strong>浏览器可视区</strong>左上角的位置（不随滚动条滚动而改变）</li><li><code>pageX</code> 与 <code>pageY</code> ：相对于<strong>网页内容</strong>（文档document）左上角的位置</li><li><code>screenX</code> 与 <code>screenY</code> ：相对于<strong>屏幕</strong>左上角的位置</li><li><code>offsetX</code> 与 <code>offsetY</code> ：鼠标相对于<strong>事件源</strong>左上角的位置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.clientX, e.clientY)</span><br><span class="line">    <span class="built_in">console</span>.log(e.pageX, e.pageY)</span><br><span class="line">    <span class="built_in">console</span>.log(e.screenX, e.screenY)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="client%E5%92%8Cpage%E5%92%8Cscreen.png" alt></p><p><strong>[案例 : 拖拽案例]</strong></p><h4 id="键盘码"><a href="#键盘码" class="headerlink" title="键盘码"></a>键盘码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键盘按下的那个键的键盘码</span></span><br><span class="line">e.keyCode</span><br></pre></td></tr></table></figure><h3 id="注册事件的两种方式"><a href="#注册事件的两种方式" class="headerlink" title="注册事件的两种方式"></a>注册事件的两种方式</h3><h4 id="on-事件名称"><a href="#on-事件名称" class="headerlink" title="on + 事件名称"></a>on + 事件名称</h4><blockquote><p>onclick、onmouseover 这种 on+事件名称的方式注册事件几乎所有的浏览器都支持</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line">box.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 事件处理程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line">box.onclick = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>on+事件名称注册事件的缺点：同一个元素同一类型的事件，只能注册一个，如果注册了多个，会出现覆盖问题</p><h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h4><blockquote><p>现代浏览器支持的注册事件的新方式，这种方式注册的事件不会出现覆盖问题</p></blockquote><p><strong>addEventListener 的语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type：事件的类型：click mouseover  字符串类型，不带 on</span></span><br><span class="line"><span class="comment">// fn：函数，每次点击，执行这个函数</span></span><br><span class="line"><span class="comment">// useCapture: 可选，true：事件在捕获阶段执行，false: 事件在冒泡阶段执行(默认)</span></span><br><span class="line">element.addEventListener(type, fn, useCapture)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p><strong>removeEventListen的语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type：事件的类型</span></span><br><span class="line"><span class="comment">// fn：要移除的那个函数</span></span><br><span class="line">element.removeEventListener(type, fn)</span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>, fn)</span><br><span class="line"><span class="comment">// 注意 : 如果想让注册的事件能移除，不能用匿名函数</span></span><br></pre></td></tr></table></figure><p>低版本浏览器兼容问题:  (了解)</p><blockquote><p>IE678不支持addEventListener与removeEventListen两个方法，但是支持attachEvent与detachEvnet</p></blockquote><p>attachEvent的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type: 事件类型，需要加上on</span></span><br><span class="line"><span class="comment">// fn: 需要执行的那个事件</span></span><br><span class="line">attachEvent(type, fn)</span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>detachEvent的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detachEvent(type, fn)</span><br></pre></td></tr></table></figure><h4 id="兼容性封装（了解）"><a href="#兼容性封装（了解）" class="headerlink" title="兼容性封装（了解）"></a>兼容性封装（了解）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 能力检测</span></span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">        element.addEventListener(type, fn)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">        element.attachEvent(<span class="string">'on'</span>+type, fn)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果都不行，那就用on方式</span></span><br><span class="line">        element[<span class="string">'on'</span>+type] = fn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">element, type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">        element.removeEventListener(type, fn, <span class="literal">false</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent)&#123;</span><br><span class="line">        element.detachEvent(<span class="string">'on'</span>+type, fn)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        element[<span class="string">'on'</span>+type] = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><blockquote><p>当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为冒泡</p><p>说白了就是：<strong>当我们触发了子元素的某个事件后，父元素对应的事件也会触发</strong></p></blockquote><p>on 创建的事件默认为冒泡，无法修改</p><p><strong>[案例 : 弹窗案例]</strong></p><h4 id="阻止事件冒泡-掌握"><a href="#阻止事件冒泡-掌握" class="headerlink" title="阻止事件冒泡  (掌握)"></a>阻止事件冒泡  (掌握)</h4><p><strong>代码 :   e.stopPropagation()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 因为是事件的冒泡，因事件引起，也要因事件停止</span></span><br><span class="line">father/son/sun.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.stopPropagation()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数3：true =&gt; 捕获 ， false =&gt; 冒泡（默认）</span></span><br><span class="line">father/son/sun.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, 参数<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻止事件冒泡的兼容性封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopPropagation</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e &amp;&amp; e.stopPropagation) &#123;</span><br><span class="line">        e.stopPropagation() <span class="comment">// 标准浏览器</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.event.cancelBubble = <span class="literal">true</span> <span class="comment">// 兼容IE的方式来取消事件冒泡</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件捕获-了解"><a href="#事件捕获-了解" class="headerlink" title="事件捕获  (了解)"></a>事件捕获  (了解)</h3><blockquote><p>事件冒泡是 ie 提出来的</p><p>​    路径 :  触发事件的目标元素(son) &gt; you &gt; father &gt; body &gt; document</p><p>事件捕获是火狐提出来的</p><p>   路径 : document &gt; body &gt;  father &gt;you  &gt; 触发事件的目标元素 (son)</p><p>解析 : 事件的处理将从DOM层次的根开始，而不是从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 addEventListener 第三个参数为 true 时，表示事件捕获</span></span><br><span class="line">arr[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h3 id="事件流的三个阶段-掌握"><a href="#事件流的三个阶段-掌握" class="headerlink" title="事件流的三个阶段 (掌握)"></a>事件流的三个阶段 (掌握)</h3><blockquote><ol><li>事件的捕获阶段</li><li>事件的目标阶段（触发自己的事件）</li><li>事件的冒泡阶段</li></ol></blockquote><p>事件有三个阶段  :</p><ul><li>捕获事件和冒泡事件都存在的话，首先发生的是捕获阶段，然后是目标阶段，最后才是冒泡阶段</li><li>addEventListener 第三个参数为是否捕获</li><li>如果为true时，表示该事件在捕获阶段发生</li><li>如果为false时，表示该事件在冒泡阶段发生</li><li>某一个事件只会执行一次</li></ul><h2 id="三大系列"><a href="#三大系列" class="headerlink" title="三大系列"></a>三大系列</h2><h3 id="offset-系列-重要"><a href="#offset-系列-重要" class="headerlink" title="offset 系列 (重要)"></a>offset 系列 (重要)</h3><blockquote><p>offset 系列用于用于<strong>获取元素自身的大小和位置</strong>，在webapi中有广泛应用<br>offset 系列主要有：offsetHeight、offsetWidth、offsetParent、offsetLeft、offsetTop</p></blockquote><p><strong>offsetHeight 与 offsetWidth</strong></p><ul><li>获取元素真实的高度和宽度 （内容大小 + border + padding）（关注盒子本身，不关注盒子内部内容）</li><li>获取到的是数值类型，方便计算</li><li>offsetHeight 与 offsetWidth 是只读属性，不能设置</li></ul><blockquote><p>style.height 与 style.width</p><ul><li>只能获取和设置行内样式</li><li>不包括内边距、边框和外边距</li><li>获取到的是字符串类型，需要转换</li></ul></blockquote><p><strong>offsetParent</strong></p><ul><li>获取离当前元素最近的<strong>定位父元素</strong>(absolute、relative)，如果没有，那就找body</li></ul><blockquote><p>parentNode : 父节点（没有兼容性问题）</p><p>parentElement : 父元素</p></blockquote><p><strong>offsetLeft 与 offsetTop</strong></p><ul><li>获取元素自身与 offsetParent 真实的距离</li><li>获取到的是数值类型，方便计算</li><li>只读属性，只能获取，不能设置</li></ul><blockquote><p>style.left 与 style.top</p><ul><li>只能获取和设置行内样式</li><li>获取到的是字符串，需要转换</li></ul></blockquote><p><img src="offset.png" alt="offset"></p><h3 id="scroll-系列-掌握1个"><a href="#scroll-系列-掌握1个" class="headerlink" title="scroll 系列 (掌握1个)"></a>scroll 系列 (掌握1个)</h3><blockquote><p>scroll 系列是用来获取<strong>盒子内容的大小和位置</strong></p><p>scroll 系列主要有 :  scrollWidth、scrollHeight、scrollLeft、scrollTop</p></blockquote><p><strong>scrollWidth 与 scrollHeight</strong></p><ul><li>scrollWidth 与 scrollHeight 是盒子内容的宽度和高度。与盒子大小无关，仅仅与<strong>盒子的内容</strong>有关系（padding + 内容）</li><li>如果内容没有溢出，scrollHeight 就是盒子高度 (scrollWidth同理)  =&gt; 与clientHeight、clientWidth相同</li><li>如果内容超过盒子，scrollHieght 就是内容高度 (scrollWidth同理)</li></ul><p><strong>scrollTop</strong></p><ul><li>scrollTop 用于获取内容垂直滚动的像素数。如果没有滚动条，那么scrollTop值是0</li><li>内容超过盒子，盒子设置 overflow: scroll 就可出现滚动条</li><li>此属性是可读写的</li></ul><p><strong>scrollLeft</strong></p><ul><li>scrollLeft 用于获取内容水平滚动的像素数</li><li>此属性是可读写的</li><li>浏览器切忌这种出现水平滚动条，用户体验极差，避免</li></ul><p><strong>scrollX 与 scrollY</strong></p><ul><li>scrollY：文档在垂直方向已滚动的像素值<br>pageYOffset 属性是 scrollY 属性的别名<br>为了跨浏览器兼容，请使用 window.pageYOffset 代替 window.scrollY</li></ul><p><img src="scroll.png" alt="scroll"></p><p><strong>onscroll 事件</strong></p><p>对于有滚动条的盒子，可以使用 onscroll 注册滚动事件，每滚动一像素，就会触发该事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = doucment.getElementById(<span class="string">'div'</span>)</span><br><span class="line">div.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(div.scrollLeft)</span><br><span class="line">    <span class="built_in">console</span>.log(div.scrollTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景 :  获取页面被卷去的高度和宽度</strong></p><blockquote><p>通常来说，scroll 家族用的最多的地方就是用来获取页面 <strong>被卷去的高度</strong>，非常的常用</p></blockquote><ul><li>对于老式的浏览器，需要获取 html 或者 body 的 scrollTop</li><li>对于现在浏览器，使用 window.pageYOffset 进行获取</li></ul><p>页面被卷去的高度和宽度的兼容性封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给整个页面注册滚动事件</span></span><br><span class="line"><span class="built_in">document</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> scrollTop = <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop || <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> scrollLeft = <span class="built_in">window</span>.pageXOffset || <span class="built_in">document</span>.documentElement.scrollLeft || <span class="built_in">document</span>.body.scrollLeft || <span class="number">0</span></span><br><span class="line">    <span class="built_in">console</span>.log(scrollLeft,scrollTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[案例 : 固定导航案例]</strong></p><h3 id="client-家族"><a href="#client-家族" class="headerlink" title="client 家族"></a>client 家族</h3><blockquote><p>clien t家族用于获取盒子可视区的大小 (内容 + padding)</p><p>client 家族有 clientWidth、clientHeight、clientLeft、clientTop</p></blockquote><p><strong>clientWidth、clientHeight  可视区宽高</strong></p><p><img src="client1.png" alt="client1"></p><p><strong>clientTop</strong> 与 <strong>clientLeft</strong> 完全没有用，他们就是borderTop与borderLeft</p><p><strong>onresize 事件：onresize 事件会在窗口被调整大小的时候发生。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 事件处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景 : client 系列一般用来获取页面的可视区宽高</strong></p><blockquote><p>低版本浏览器 :  获取的html 和 body</p><p>高版本的浏览器 : window.innerWidth  (掌握)（只读属性）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为求的是窗口大小所以用 window</span></span><br><span class="line"><span class="built_in">window</span>.onresize =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> W = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth</span><br><span class="line">    <span class="built_in">console</span>.log(W)</span><br><span class="line">    <span class="keyword">var</span> H = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">    <span class="built_in">console</span>.log(H)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webapi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime 插件、快捷键</title>
      <link href="/2018/tool/Sublime%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2018/tool/Sublime%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="sublime-插件、快捷键"><a href="#sublime-插件、快捷键" class="headerlink" title="sublime 插件、快捷键"></a>sublime 插件、快捷键</h1><hr><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li><p><a href="https://packagecontrol.io/packages/Sublime%20Tutor" target="_blank" rel="noopener">Sublime Tutor</a> ：键盘快捷方式教程<br>Help &gt; Sublime Tutor</p></li><li><p>AlignTab ：自定义快捷键</p></li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li><code>Ctrl + X</code>    如果已经选中文本，则剪切该文本。如果未选中任何文本，则剪切光标所在行</li><li><code>Ctrl + Z</code>    撤消</li><li><code>Ctrl + Shift + V</code>    缩进粘贴</li><li><code>Ctrl + Shift + Z</code> 或 <code>Ctrl + Y</code>    恢复</li><li><code>Ctrl + L</code>    Select line - Repeat to select next lines</li><li><code>Ctrl + D</code>    Select word - Repeat select others occurrences</li><li><code>Ctrl + Shift + D</code>    如果已经选中文本，则复制该文本。如果未选中任何文本，则复制光标所在行</li><li><code>Ctrl + Enter</code>    Insert line after</li><li><code>Ctrl + Shift + Enter</code>    Insert line before</li><li><code>Alt + F3</code>    选择所有相同单词的实例</li><li><code>Tab</code> 或 <code>Ctrl + ]</code>    缩进</li><li><code>Shift + Tab</code> 或 <code>Ctrl + [</code>    取消缩进</li><li><code>Ctrl + Shift + K</code>    Delete Line</li><li><code>Ctrl + KK</code>    Delete from cursor to end of line</li><li><code>Ctrl + K + Backspace</code>     Delete from cursor to start of line</li><li><code>Alt + Shift + W</code>    使用标签包裹选中部分</li><li><code>Ctrl + ←</code>    移动光标至上一个词</li><li><code>Ctrl + →</code>    移动光标至下一个词</li><li><code>Ctrl + Shift + ↓</code>    Move line/selection down</li><li><code>Ctrl + Shift + ↑</code>    Move line/selection up</li><li><code>Home</code>    移动光标至行首</li><li><code>End</code>    移动光标至行尾</li><li><code>Ctrl + Home</code>    移动光标至文档开头</li><li><code>Ctrl + End</code>    移动光标至文档结尾</li><li><code>Ctrl + M</code>    跳转到左/右圆括号、方括号、大括号</li><li><code>Ctrl + Shift + M</code>    选择括号内的内容</li><li><code>Ctrl + R</code>    跳转到定义</li><li><code>Ctrl + /</code>    Comment/un-comment current line</li><li><code>Ctrl + Shift + /</code>    Block comment current selection</li><li><code>Ctrl + N</code>    新建标签</li><li><code>Ctrl + PgUp</code>    向左切换标签</li><li><code>Ctrl + PgDn</code>    向右切换标签</li><li><code>Ctrl + W</code>    关闭标签</li><li><code>Ctrl + Shift + T</code>    重新打开标签</li><li><code>Shift + 鼠标右键</code>    竖向选择</li><li><code>Ctrl + Shift + &#39;</code>    选择与光标关联的开始和结束标签</li><li><code>Ctrl + Shift + A</code>    选择容器内内容</li><li><code>Ctrl + Shift + ;</code>    移除与你的光标相关的父标签(清除标记)</li><li><code>Ctrl + Shift + Y</code>    计算数学表达式</li><li><code>Alt + ↓&amp;↑</code>    以0.1的步长改变数字</li><li><code>Alt + Shift + ↓&amp;↑</code>    以10的步长改变数字</li><li><code>Ctrl + ↓&amp;↑</code>    以1的步长改变数字</li><li><code>Ctrl+K+U</code> <code>Ctrl+K+L</code>    改变大小写</li></ul><p><a href="http://sublime.emptystack.net/" target="_blank" rel="noopener">http://sublime.emptystack.net/</a></p><h2 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h2><p>1.</p><blockquote><p>“Error: 404 Not Found<br>Sorry, the requested URL ‘<a href="http://127.0.0.1:51004/view/29&#39;" target="_blank" rel="noopener">http://127.0.0.1:51004/view/29&#39;</a> caused an error:<br>‘buffer_id(29) is not valid (closed or unsupported file format)’<br>NOTE: If you run multiple instances of Sublime Text, you may want to adjust the server_port option in order to get this plugin work again.”</p></blockquote><p>Quick Fix 1: Remove Strikethrough Extension</p><p><code>Sublime Text &gt; Preferences &gt; Package Settings &gt; OmniMarkupPreviewer &gt; Settings - User</code><br>paste the following to remove the strikeout package.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "renderer_options-MarkdownRenderer": &#123;</span><br><span class="line">        "<span class="selector-tag">extensions</span>": <span class="selector-attr">["tables", "fenced_code", "codehilite"]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Quick Fix 2: Fix the Strikethrough Extension (if you need it)</p><p>Find the python-markdown sublime package.</p><p><code>/Packages/OmniMarkupPreviewer/OmniMarkupLib/Renderers/libs/mdx_strikeout.py</code></p><p>Replace the makeExtension() method with the following:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeExtension</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> StrikeoutExtension(*args, **kwargs)</span><br><span class="line">Save, quit <span class="keyword">and</span> reload Sublime Text.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 语法</title>
      <link href="/2018/tool/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/tool/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h2><p>待…</p><h2 id="Markdown使用技巧"><a href="#Markdown使用技巧" class="headerlink" title="Markdown使用技巧"></a>Markdown使用技巧</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul><li>方法1：连续两个以上空格+回车</li><li>方法2：使用html语言换行标签：<code>&lt;br&gt;</code></li></ul><h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><ul><li>使用align属性</li><li>使用<code>&lt;center&gt;</code>标签（HTML5 不支持）</li></ul><h3 id="首行缩进两个字符"><a href="#首行缩进两个字符" class="headerlink" title="首行缩进两个字符"></a>首行缩进两个字符</h3><ul><li><code>&amp;nbsp;</code> 不换行空格，全称No-Break Space</li><li><code>&amp;ensp;</code> 半角的空格，全称是En Space</li><li><code>&amp;emsp;</code> 全角的空格，全称是Em Space，占据的宽度正好是1个中文宽度</li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li><code>*斜体*或_斜体_</code></li><li><code>**粗体**</code></li><li><code>***加粗斜体***</code></li><li><code>~~删除线~~</code></li><li>字号与颜色：使用内嵌HTML</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#0099ff</span> <span class="attr">size</span>=<span class="string">3</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span>color=#0099ff size=3 face="黑体"<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<font color="#0099ff" size="3" face="黑体">color=#0099ff size=3 face=”黑体”</font></p><h3 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h3><p>使用内嵌 HTML 借助 table，tr，td 等表格标签的 bgcolor 属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">orange</span>&gt;</span>背景色是：orange<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果：<table><tr><td bgcolor="orange">背景色是：orange</td></tr></table></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>在一行中用三个以上的星号 <code>*</code> 、减号 <code>-</code> 、底线 <code>_</code> 来建立一个分隔线，中间用空格隔开，行内不能有其他东西。（除第一个符号的左侧最多添加三个空格外三个相同符号两侧可以添加任意多个空格）</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><ul><li>行内式：<code>[文字](url &quot;title&quot;)</code></li><li>参考式：<code>[文字][1]</code>  <code>[1]:url &quot;title&quot;</code></li><li>自动链接：<code>&lt;url&gt;</code>，将链接用&lt;&gt;包起来，Markdown 会自动把它转成链接。</li></ul><h3 id="图片："><a href="#图片：" class="headerlink" title="图片："></a>图片：</h3><ul><li>行内式：<code>![alt_text](url &quot;title&quot;)</code></li></ul><blockquote><p><code>alt_text</code>：图片的 alt 标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据 <code>alt_text</code> 里面的关键词搜索到图片。 url：可以是图片的本地地址或者是网址。”title”：鼠标悬置于图片上会出现的标题文字，可以不写。</p></blockquote><ul><li><p>参考式：同上</p></li><li><p>使用 img 标签：<code>&lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;</code>，<code>&lt;div align=center&gt;&lt;/div&gt;</code> 实现居中</p></li></ul><h3 id="折叠按钮"><a href="#折叠按钮" class="headerlink" title="折叠按钮"></a>折叠按钮</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span></span><br><span class="line">    点击展开</span><br><span class="line">  <span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内部展示内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><details>  <summary>    点击展开  </summary><p>设置小三角样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">summary</span><span class="selector-pseudo">::-webkit-details-marker</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#42b983</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="Markdown-编辑器"><a href="#Markdown-编辑器" class="headerlink" title="Markdown 编辑器"></a>Markdown 编辑器</h2><p><a href="https://www.typora.io/" target="_blank" rel="noopener">typora</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>版本控制系统</title>
      <link href="/2018/tool/git/"/>
      <url>/2018/tool/git/</url>
      
        <content type="html"><![CDATA[<h1 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h1><h2 id="为什么要有版本控制系统"><a href="#为什么要有版本控制系统" class="headerlink" title="为什么要有版本控制系统"></a>为什么要有版本控制系统</h2><p>在开发过程中，经常需要对一个文件进行修改甚至删除，但是我们又希望能够保存这个文件的历史记录，如果通过备份，那么管理起来会非常的复杂</p><h2 id="什么是版本控制系统"><a href="#什么是版本控制系统" class="headerlink" title="什么是版本控制系统"></a>什么是版本控制系统</h2><blockquote><p>版本控制系统（Version Control System）:是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p></blockquote><p>版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。</p><h2 id="版本控制系统的分类"><a href="#版本控制系统的分类" class="headerlink" title="版本控制系统的分类"></a>版本控制系统的分类</h2><p>参考文章：<a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">关于版本控制的介绍</a></p><h3 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h3><p><img src="git1.png" alt></p><p>本地版本控制系统就是在一台机器上，记录版本的不同变化，保证内容不会丢失</p><ol><li>如果多人开发，每个人都在不同的系统和电脑上开发，没办法协同工作。</li></ol><h3 id="集中式版本控制系統"><a href="#集中式版本控制系統" class="headerlink" title="集中式版本控制系統"></a>集中式版本控制系統</h3><p><img src="git2.png" alt></p><p><code>svn</code> 是集中式的版本控制系统，集中式版本控制系统都有一个单一的集中管理的服务器（中央服务器），保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p><ol><li>需要一个中央服务器来管理代码的的版本和备份</li><li>所有的用户电脑都是从中央服务器获取代码或者是将本地的代码提交到中央服务器</li><li>依赖与网络环境，如果连不上中央服务器，就无法提交和获取代码。</li></ol><h3 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h3><p><img src="git3.png" alt></p><p><code>git</code> 是分布式的版本控制系统。分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份</p><ol><li>需要一台服务器作为代码仓库</li><li>每个用户电脑都是一个服务器（代码仓库），并且和代码仓库是镜像的，用户修改和获取代码都是提交到自己的服务器当中。</li><li>不需要网络就可以进行工作。</li><li>当连接网络时，用户可以选择将自己的服务器与代码仓库进行同步。</li></ol><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><hr><h2 id="Git-核心概念"><a href="#Git-核心概念" class="headerlink" title="Git 核心概念"></a>Git 核心概念</h2><ul><li><p><strong><code>WorkSpace</code></strong>：工作区，即从仓库中checkout出来的，需要通过Git进行版本控制的目录和文件，可以简单的理解为在电脑里真实看到的文件；</p></li><li><p><strong><code>Stage(Index)</code></strong>：暂存区，或者叫做待提交更新区；在提交进入Repository之前，可以把所有的更新放在暂存区, 用 <code>git add</code> 的文件都在这里；</p></li><li><p><strong><code>Repository(Remote/Local)</code></strong>：仓库，一个存放在远端／本地的版本库，用 <code>git commit</code> 提交的文件就到Local Repository,用 <code>git push</code> 提交的文件就到Remote Repository；</p></li><li><p><strong><code>.git</code></strong>：存放Git管理信息的目录，初始化仓库的时候会自动创建。</p></li></ul><blockquote><p><img src="git.jpg" alt></p></blockquote><blockquote><p><img src="github-flows.png" alt></p></blockquote><h2 id="Git-初始设置"><a href="#Git-初始设置" class="headerlink" title="Git 初始设置"></a>Git 初始设置</h2><h3 id="设置用户名和邮箱"><a href="#设置用户名和邮箱" class="headerlink" title="设置用户名和邮箱"></a>设置用户名和邮箱</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户名使用英文</span></span><br><span class="line"><span class="comment"># --global 全局设置</span></span><br><span class="line">git config --global user.name <span class="string">'your_name'</span></span><br><span class="line">git config --global user.email <span class="string">'your_email@example.com'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看账号信息</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置信息</span></span><br><span class="line">git config --<span class="built_in">unset</span> -- user.name</span><br></pre></td></tr></table></figure><p>全局设置会在<code>~/.gitconfig</code>中以如下形式输出设置文件，可以直接编辑这个文件来修改设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = your_name</span><br><span class="line">email = your_email@example.com</span><br></pre></td></tr></table></figure><p>每个仓库的 Git 配置文件都放在 <code>.git/config</code> 文件中，可以直接修改此文件<br><code>$ cat .git/config</code> 查看配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决中文变成数字加百分号，也可以在设置中将编码修改为 utf-8</span></span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="设置-SSH-Key"><a href="#设置-SSH-Key" class="headerlink" title="设置 SSH Key"></a>设置 SSH Key</h3><p>GitHub 上连接已有仓库时的认证，是通过使用了 SSH 的公开密钥认证方式进行的。现在我们来创建公开密钥认证所需的 SSH Key，并将其添加至 GitHub</p><p>运行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key(/Users/your_user_directory/.ssh/id_rsa):按回车键</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):输入密码</span><br><span class="line">Enter same passphrase again:再次输入密码</span><br></pre></td></tr></table></figure><p>输入密码后会出现以下结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/your_user_directory/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/your_user_directory/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:SHA256:hbn1zPihlVDe/Y2FvzzZU8l+AOSlVRlaOmro/nTQDGg cui3155@gmail.com(fingerprint值+your_email@example.com)</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|            o o++|</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">|        . . .   +|</span></span><br><span class="line"><span class="string">|         ...     |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></table></figure><p><code>id_rsa</code> 文件是私有密钥，<code>id_rsa.pub</code> 是公开密钥</p><h3 id="添加公开密钥"><a href="#添加公开密钥" class="headerlink" title="添加公开密钥"></a>添加公开密钥</h3><p>在 GitHub 中添加公开密钥，今后就可以用私有密钥进行认证了<br>点击右上角的账户设定按钮（Account Settings），选择 SSH Keys 菜单。点击 AddSSH Key 之后，在 Title 中输入适当的密钥名称。Key 部分请粘贴 id_rsa.pub 文件里的内容</p><p><code>id_rsa.pub</code> 的内容可以用如下方法查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa公开密钥的内容your_email@example.com</span><br></pre></td></tr></table></figure><p>完成以上设置后，就可以用手中的私人密钥与 GitHub 进行认证和通信了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">The authenticity of host <span class="string">'github.com (192.30.255.113)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is (fingerprint值).</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?输入yes</span></span><br><span class="line"><span class="string">Warning: Permanently added '</span>github.com,192.30.255.113<span class="string">' (RSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">Enter passphrase for key '</span>/c/Users/C.DESKTOP-3S4APJ4/.ssh/id_rsa<span class="string">':</span></span><br></pre></td></tr></table></figure><p>出现如下结果即为成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi cuilongjin! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><h3 id="提高命令输出的可读性"><a href="#提高命令输出的可读性" class="headerlink" title="提高命令输出的可读性"></a>提高命令输出的可读性</h3><p>将 <code>color.ui</code> 设置为 <code>auto</code> 可以让命令的输出拥有更高的可读性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>~/.gitconfig</code> 中会增加下面一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[color]</span><br><span class="line">ui = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样一来，各种命令的输出就会变得更容易分辨。</p><h3 id="文件名大小写问题"><a href="#文件名大小写问题" class="headerlink" title="文件名大小写问题"></a>文件名大小写问题</h3><p>git 默认对文件名大小写不敏感</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 git 大小写敏感</span></span><br><span class="line">git config core.ignorecase <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者先删除文件在添加进去</span></span><br></pre></td></tr></table></figure><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>通过 Gravatar 服务</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 st 别名表示 status</span></span><br><span class="line">git config --global alias.st status</span><br><span class="line"></span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.unstage <span class="string">'reset HEAD'</span></span><br><span class="line">git config --global alias.last <span class="string">'log -1'</span></span><br><span class="line"></span><br><span class="line">git config --global alias.lg <span class="string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br></pre></td></tr></table></figure><h3 id="搭建-Git-服务器"><a href="#搭建-Git-服务器" class="headerlink" title="搭建 Git 服务器"></a>搭建 Git 服务器</h3><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">搭建Git服务器</a></p><h3 id="配置多用户"><a href="#配置多用户" class="headerlink" title="配置多用户"></a>配置多用户</h3><p>根据不同邮箱生成对应的私钥公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C email</span><br></pre></td></tr></table></figure><p>将公钥上传到对应的用户账号中</p><p>在 <code>.ssh</code> 目录创建 <code>config</code> 文件，配置私钥对应的服务器，每个账号单独配置一个 Host，每个 Host 要取一个别名，每个 Host 主要配置 HostName 和 IdentityFile 两个属性即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 配置用户1</span><br><span class="line">Host github</span><br><span class="line">HostName github.com</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line">User cuilongjin</span><br><span class="line"></span><br><span class="line"># 配置用户2</span><br><span class="line">Host gitlab</span><br><span class="line">HostName git.gitlab.net</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_gitlab</span><br><span class="line">User cuilongjin</span><br></pre></td></tr></table></figure><p>Host 的名字可以任意，不过这个会影响 git 相关命令，例如：</p><p>Host mygithub 这样定义的话，命令如下</p><p><code>git clone git@mygithub:cuilongjin/cuilongjin.git</code></p><p>即 git@ 后面紧跟的名字改为 mygithub</p><p>执行 <code>ssh -T git@github</code>、<code>ssh -T git@gitlab</code> 测试是否成功</p><p>配置局部 git 用户名和邮箱，如果没有局部配置，默认用全局配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name <span class="string">"Your name"</span></span><br><span class="line">git config user.email <span class="string">"your_email@gmail.com"</span></span><br></pre></td></tr></table></figure><p>或者直接找到 <code>.git/config</code> 文件，添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">name = Your name</span><br><span class="line">email = your_email@gmail.com</span><br></pre></td></tr></table></figure><h2 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir project</span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><p>如果初始化成功，执行了 <code>git init</code> 命令的目录下就会生成 <code>.git</code>  目录。这个 <code>.git</code> 目录里存储着管理当前目录内容所需的仓库数据。</p><blockquote><p><code>mkdir project</code> 命令创建 project 空文件夹</p><ul><li><code>pwd</code> 命令用于显示当前目录</li></ul></blockquote><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将指定文件夹添加到暂存区（目录中的所有文件，包括新增/修改/删除的文件）--not-all 忽略删除的</span></span><br><span class="line">git add 目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 指定文件 添加到暂存区 （文件可以是新增/修改/删除的）</span></span><br><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录下所有的js文件添加到暂存区（文件可以是新增/修改的，不包括删除的）</span></span><br><span class="line">git add *.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录及子目录下件 （文件可以是新增/修改/删除的）</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前仓库下所有的文件 （文件可以是新增/修改/删除的）</span></span><br><span class="line">git add -A</span><br><span class="line">git add --all</span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将文件从暂存区提交到仓库</span></span><br><span class="line">git commit -m <span class="string">'提交说明'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是一个已经暂存过的文件，可以快速提交，如果是未追踪的文件，那么命令将不生效。</span></span><br><span class="line">git commit -a -m <span class="string">'提交说明'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改最近的一次提交说明， 如果提交说明不小心输错了，可以使用这个命令</span></span><br><span class="line">git commit --amend -m <span class="string">'提交说明'</span></span><br></pre></td></tr></table></figure><p>-m 参数后的 <code>&#39;First commit&#39;</code> 称作提交信息，是对这个提交的概述,如果想要记述得更加详细，请不加 <code>-m</code> ，直接执行 <code>git commit</code> 命令，执行后编辑器就会启动。<br>在编辑器中记述提交信息的格式如下:<br>​    第一行：用一行文字简述提交的更改内容<br>​    第二行：空行<br>​    第三行以后：记述更改的原因和详细内容</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 README.md 文件作为管理对象</span></span><br><span class="line">touch README.md</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化日志输出格式</span></span><br><span class="line">git stauts -s (short)</span><br></pre></td></tr></table></figure><p><code>git status</code> 命令可以让我们时刻掌握仓库当前的状态，但不能看到具体修改了什么内容，需要用 <code>git diff</code> 这个命令来查看具体修改内容。</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前工作树和最新add之间（暂存区）的差别（difference）</span></span><br><span class="line">git diff</span><br><span class="line"><span class="comment"># 如果尚未用 `git add` 命令向暂存区添加任何东西，则程序只会显示工作树与最新提交状态之间的差别</span></span><br><span class="line"><span class="comment"># “+”号标出的是新添加的行，被删除的行则用“-”号标出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看README.md文件的修改</span></span><br><span class="line">git diff -- README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看工作树和最新提交的差别</span></span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂存区与仓库区的不同</span></span><br><span class="line">git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个版本之间的不同</span></span><br><span class="line">git diff c265262 de4845b</span><br></pre></td></tr></table></figure><blockquote><p>HEAD 是指向当前分支中最新一次提交的指针</p></blockquote><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前版本之前的提交信息</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">commit 9f129bae19b2c82fb4e98cde5890e52a6c546922</span><br><span class="line">Author: cuilongjin &lt;cuilongjin@gmail.com&gt;</span><br><span class="line">Date:   Sun Oct 8 22:08:39 2017 +0900</span><br><span class="line">    First commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只显示提交信息的第一行</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment"># 完整显示版本号</span></span><br><span class="line">git <span class="built_in">log</span> --oneline  <span class="comment"># 只显示前7位版本号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定目录、文件的日志</span></span><br><span class="line">git <span class="built_in">log</span> 目录名或文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件的改动（q键退出命令）</span></span><br><span class="line">git <span class="built_in">log</span> -p 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有曾经提交的版本（包括被删除的）</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reset -h<span class="string">'查看帮助'</span></span><br><span class="line">--mixed<span class="string">'reset HEAD and index'</span>(默认)</span><br><span class="line">--soft<span class="string">'reset only HEAD'</span></span><br><span class="line">--hard  <span class="string">'reset HEAD, index and working tree'</span></span><br><span class="line">--merge <span class="string">'reset HEAD, index and working tree'</span></span><br><span class="line">--keep <span class="string">'reset HEAD but keep local changes'</span></span><br></pre></td></tr></table></figure><blockquote><ol><li><code>HEAD</code> 表示当前版本，上一个版本就是 <code>HEAD^</code> ，上上一个版本就是 <code>HEAD^^</code> ，当然往上100个版本写100个^比较容易数不过来，所以写成 <code>HEAD~100</code> 。</li><li>使用 <code>commit_id</code> 回退 , <code>git reflog</code> 用来记录你的每一次命令和 <code>commit_id</code></li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br><span class="line">git reset --hard commit_id</span><br><span class="line">git reset HEAD [file]</span><br></pre></td></tr></table></figure><h3 id="git-checkout-–file"><a href="#git-checkout-–file" class="headerlink" title="git checkout –file"></a>git checkout –file</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- README.md</span><br></pre></td></tr></table></figure><p>把 README.md 文件在 <code>工作区的修改全部撤销</code> ，<strong>用版本库里的版本替换工作区的版本</strong></p><p>这里有两种情况：</p><ol><li><p>一种是 README.md 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态</p></li><li><p>一种是 README.md 已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态</p></li></ol><p>总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态，可用于<strong>撤销文件修改或恢复误删文件</strong></p><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:cuilongjin/git_test.git</span><br></pre></td></tr></table></figure><p>添加后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看远程库的信息</span></span><br><span class="line">git remote -v</span><br><span class="line">origin  git@github.com:cuilongjin/git_test.git (fetch)</span><br><span class="line">origin  git@github.com:cuilongjin/git_test.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定远程库的详细信息</span></span><br><span class="line">git remote show &lt;远程库&gt;</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的 origin 的地址。如果没有推送权限，就看不到 push 的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除已有的 GitHub 远程库</span></span><br><span class="line">git remote rm origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程库名称</span></span><br><span class="line">git remote rename &lt;原远程库名&gt; &lt;新远程库名&gt;</span><br></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取远程仓库的更新，并且与本地的分支进行合并</span></span><br><span class="line">git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略</span></span><br><span class="line">git pull origin next 等同于 git fetch origin &amp;&amp; git merge origin/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支</span></span><br><span class="line"><span class="comment"># 加上参数 -p 就会在本地删除远程已经删除的分支</span></span><br><span class="line">$ git pull -p</span><br><span class="line"><span class="comment"># 等同于下面的命令</span></span><br><span class="line">$ git fetch --prune origin </span><br><span class="line">$ git fetch -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并 pull 两个不同的项目出现 fatal: refusing to merge unrelated histories</span></span><br><span class="line">git pull origin master ----allow-unrelated-histories</span><br></pre></td></tr></table></figure><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次推送分支时，加上 -u 参数，git 会把本地分支和远程分支关联起来，在以后的推送或者拉取时就可以简化命令</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有本地分支，表示删除远程分支</span></span><br><span class="line">git push origin :master</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">$ git push origin --delete master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以强制覆盖的方式推送修改后的 repo （重新上传 repo）（不指定分支即所有分支）</span></span><br><span class="line">git push origin --force --all</span><br></pre></td></tr></table></figure><blockquote><p>remote: error: GH007: Your push would publish a private email address.<br>解决方法——<a href="http://github.com/settings/emails" target="_blank" rel="noopener">http://github.com/settings/emails</a> 把Keep my email address private这一项去掉勾选即可。</p></blockquote><p>如果推送失败，则因为远程分支比你的本地更新，需要先用 <code>git pull</code> 拉取远程的新提交</p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:cuilongjin/仓库名.git [指定文件夹]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认远程主机为 origin ， -o 指定主机名</span></span><br><span class="line">git <span class="built_in">clone</span> --o origin1 git@github.com:cuilongjin/仓库名.git</span><br></pre></td></tr></table></figure><p>Git 支持多种协议，包括 https，但通过 ssh 支持的原生 git 协议速度最快</p><p>从远程库 clone 时，默认情况下，只能看到本地的 master 分支<br>要在 dev 分支上开发，就必须创建远程 origin 的 dev 分支到本地，于是用这个命令创建本地 dev 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地 dev 分支与远程 origin/dev 分支的链接</span></span><br><span class="line">git branch --<span class="built_in">set</span>-upstream dev origin/dev</span><br></pre></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将某个远程仓库的更新，全部取回本地。默认取回所有分支（branch）的更新</span></span><br><span class="line">git fetch &lt;远程仓库&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回特定分支的更新</span></span><br><span class="line">git fetch &lt;远程仓库&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>git fetch 和 git pull 区别</p><ul><li><p>git pull 获取远程仓库的更新，并且与本地的分支进行合并</p></li><li><p>git fetch 所取回的更新，在本地主机上要用 “远程仓库/分支名” 的形式读取，即不会与本地分支合并</p></li></ul><h3 id="git-忽视文件"><a href="#git-忽视文件" class="headerlink" title="git 忽视文件"></a>git 忽视文件</h3><p>在仓库中，有些文件是不想被 git 管理的，比如数据的配置密码、写代码的一些思路等。git 可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了</p><p>忽略文件的原则是：</p><ul><li>忽略操作系统自动生成的文件，比如缩略图等</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 .class 文件</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件</li></ul><p>在仓库的根目录创建一个<code>.gitignore</code>的文件，文件名是固定的</p><p>将不需要被 git 管理的文件路径添加到<code>.gitignore</code>中，把 <code>.gitignore</code> 也提交到 Git，Git 就会自动忽略这些文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 忽视 index.txt 文件</span><br><span class="line">index.txt</span><br><span class="line"></span><br><span class="line"># 忽视 .gitignore 文件</span><br><span class="line">.gitignore</span><br><span class="line"></span><br><span class="line"># 忽视 css 下的 index.css 文件</span><br><span class="line">css/index.css</span><br><span class="line"></span><br><span class="line"># 忽视 css 下的所有的 css 文件</span><br><span class="line">css/*.css</span><br><span class="line"></span><br><span class="line"># 忽视 css 下的所有文件</span><br><span class="line">css/*.*</span><br><span class="line"></span><br><span class="line"># 忽视 css 文件夹</span><br><span class="line">css</span><br></pre></td></tr></table></figure><p>GitHub 已经为我们准备了各种配置文件 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><p>强制添加被 .gitignore 忽略的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 强制添加被.gitignore忽略的文件</span></span><br><span class="line">git add -f &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查哪个规则忽略了此文件，以便修订规则</span></span><br><span class="line">git check-ignore -v &lt;file&gt;</span><br><span class="line">.gitignore:x:xxx.xx    xxxxxx</span><br></pre></td></tr></table></figure><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>在 git 中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git 中使用 HEAD 指向当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br><span class="line">* master</span><br><span class="line"></span><br><span class="line">-r 参数查看远程分支</span><br><span class="line">-a 查看所有分支(远程分支会用红色表示出来)</span><br></pre></td></tr></table></figure><p><code>*</code>（星号）表示当前所在的分支</p><ul><li>git checkout -b 创建、切换分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 branch 为基础创建名为 feature-A 的分支</span></span><br><span class="line">git checkout -b feature-A &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>连续执行下面两条命令也能收到同样效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 feature-A 分支</span></span><br><span class="line">git branch feature-A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前分支切换为 feature-A 分支</span></span><br><span class="line">git checkout feature-A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换回上一个分支</span></span><br><span class="line">git checkout -</span><br></pre></td></tr></table></figure><ul><li>git branch -d 删除分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除本地 feature-A 分支</span></span><br><span class="line">git branch -d feature-A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行删除本地 feature-A 分支</span></span><br><span class="line">git branch -D feature-A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程 feature-A 分支</span></span><br><span class="line">git push origin :feature-A</span><br><span class="line">或 git push origin --delete feature-A</span><br></pre></td></tr></table></figure><ul><li>git branch -m 重命名分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名本地分支</span></span><br><span class="line">git branch -m old_branch new_branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名远程分支</span></span><br><span class="line"><span class="comment"># 重命名本地分支 -&gt; 删除远程分支 -&gt; 推送到远程分支</span></span><br></pre></td></tr></table></figure><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>合并分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 feature-A 合并到 master 上</span></span><br><span class="line"><span class="comment"># 首先切换到 master 分支，然后执行</span></span><br><span class="line">git merge [--squash] [--no-ff] -m <span class="string">"描述"</span> feature-A</span><br><span class="line">--squash <span class="comment"># 只是将&lt;branch&gt;中的修改内容迁移过来，而不保留其中的commit历史</span></span><br><span class="line">--no-ff <span class="comment"># 创建合并提交，为了在历史记录中明确记录下本次分支合并</span></span><br></pre></td></tr></table></figure><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把当前工作现场“储藏”起来</span></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看存储的工作现场</span></span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure><p>恢复工作现场</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复工作现场，stash 内容并不删除</span></span><br><span class="line">git stash apply</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 stash 内容</span></span><br><span class="line">git stash drop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复的同时把 stash 内容也删了</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>恢复指定的 stash，用命令：<code>git stash apply stash@{0}</code></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="noopener">廖雪峰Git教程创建与合并分支</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758410364457b9e3d821f4244beb0fd69c61a185ae0000" target="_blank" rel="noopener">廖雪峰Git教程分支管理策略</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="noopener">廖雪峰Git教程Bug分支</a></p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><ul><li>创建标签</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先切换到需要打标签的分支上</span></span><br><span class="line"><span class="comment"># 默认标签是打在最新提交的 commit 上的</span></span><br><span class="line">git tag v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对指定某一次提交打标签</span></span><br><span class="line">git tag v1.0 &lt;commit id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字</span></span><br><span class="line">git tag -a v1.0 -m <span class="string">"version1.0 released"</span> &lt;commit id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 -s 用私钥签名一个标签(需配置gpg密钥对)</span></span><br><span class="line">git tag -s v1.0 -m <span class="string">"signed version1.0 released"</span> &lt;commit id&gt;</span><br></pre></td></tr></table></figure><ul><li>查看标签</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有标签</span></span><br><span class="line">git tag</span><br><span class="line">v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有标签信息</span></span><br><span class="line">git show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 v1.0 标签信息</span></span><br><span class="line">git show v1.0</span><br><span class="line">commit id:xxx</span><br><span class="line">Author:xxx</span><br><span class="line">Date:xxx</span><br></pre></td></tr></table></figure><ul><li>推送标签到远程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推送 v1.0 标签到远程</span></span><br><span class="line">git push origin v1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送全部尚未推送的本地标签到远程</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><ul><li>删除标签</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除本地标签 v1.0</span></span><br><span class="line">git tag -d v1.0</span><br><span class="line"><span class="comment"># 删除远程标签 v1.0</span></span><br><span class="line">git push origin :refs/tags/v1.0</span><br><span class="line">或 git push origin --delete tag v1.0</span><br></pre></td></tr></table></figure><h2 id="git-修改提交历史"><a href="#git-修改提交历史" class="headerlink" title="git 修改提交历史"></a>git 修改提交历史</h2><p>修改最后一条 commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>修改多条 commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3 修改最近三次提交</span><br><span class="line">git rebase -i --root 修改所有提交</span><br></pre></td></tr></table></figure><p>Commands</p><p><strong>p</strong>, pick = use commit: 直接使用commit 不做任何修改，其中p 是pick的缩写，以下雷同；</p><p><strong>r</strong>, reword = use commit, but edit the commit message: 使用commit，但是会更改commit 信息；</p><p><strong>e</strong>, edit = use commit, but stop for amending :使用commit，但是遇到此命令时会停止合并；</p><p><strong>s</strong>, squash = use commit, but meld into previous commit: 使用commit,但是会合并到前一个commit中；</p><p><strong>f</strong>, fixup = like “squash”, but discard this commit’s log message：和squash类似，但是会抛弃commit的log信息</p><p><strong>x</strong>, exec = run command (the rest of the line) using shell：使用shell运行命令</p><p><strong>d</strong>, drop = remove commit：丢弃commit</p><p><a href="https://www.jianshu.com/p/67f20d19605a" target="_blank" rel="noopener">https://www.jianshu.com/p/67f20d19605a</a></p><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="git-add-的时候遇到warning-LF-will-be-replaced-by-CRLF-in-……"><a href="#git-add-的时候遇到warning-LF-will-be-replaced-by-CRLF-in-……" class="headerlink" title="git add .的时候遇到warning: LF will be replaced by CRLF in ……`"></a>git add .<code>的时候遇到</code>warning: LF will be replaced by CRLF in ……`</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git config core.autocrlf</span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># true：添加文件到git仓库时，git将其视为文本文件。他将把crlf变成lf</span></span><br><span class="line"><span class="comment"># false：line-endings将不做转换操作。文本文件保持原来的样子</span></span><br><span class="line"><span class="comment"># input：把crlf转成lf，当有人Check代码时还是lf方式。因此在window操作系统下，不要使用这个设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CRLF (carriagereturnlinefeed)：表示句尾使用回车换行两个字符(即Windows编程时使用"\r\n"换行)</span></span><br><span class="line"><span class="comment"># LF(line feed)：表示句尾只使用换行(Unix Style)</span></span><br><span class="line"><span class="comment"># CR：表示只使用回车</span></span><br></pre></td></tr></table></figure><h3 id="Git-永久删除文件-包括历史记录"><a href="#Git-永久删除文件-包括历史记录" class="headerlink" title="Git 永久删除文件(包括历史记录)"></a>Git 永久删除文件(包括历史记录)</h3><p><a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/" target="_blank" rel="noopener">https://help.github.com/articles/removing-sensitive-data-from-a-repository/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在仓库的根目录执行</span></span><br><span class="line">git filter-branch --force --index-filter <span class="string">'git rm --cached --ignore-unmatch 文件路径'</span> --prune-empty --tag-name-filter cat -- --all</span><br><span class="line"><span class="comment"># 文件路径相对于git仓库根目录</span></span><br><span class="line"><span class="comment"># 删除文件夹 添加 -r 命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以强制覆盖的方式推送修改后的 repo （不指定分支即所有分支）（重新上传 repo）</span></span><br><span class="line">git push origin --force --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制推送 tags</span></span><br><span class="line">git push origin --force --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理和回收空间</span></span><br><span class="line">rm -rf .git/refs/original/</span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git gc --prune=now</span><br><span class="line">git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure><p>重新<a href="https://git-scm.com/book/en/Git-Branching-Rebasing" target="_blank" rel="noopener">绑定</a>，而不是合并创建的旧（受污染）存储库历史记录中的任何分支</p><ul><li>git 修改已提交的某一次的邮箱和用户信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --env-filter \</span><br><span class="line"><span class="string">"GIT_AUTHOR_NAME='Newname'; GIT_AUTHOR_EMAIL='newemail'; \</span></span><br><span class="line"><span class="string">GIT_COMMITTER_NAME='committed-name'; GIT_COMMITTER_EMAIL='committed-email';"</span> HEAD</span><br></pre></td></tr></table></figure><h3 id="fork-的项目-A-与原项目-B-保持同步"><a href="#fork-的项目-A-与原项目-B-保持同步" class="headerlink" title="fork 的项目( A )与原项目 (B) 保持同步"></a>fork 的项目( A )与原项目 (B) 保持同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 A 克隆到本地做中转</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 B 远程仓库地址并拉取</span></span><br><span class="line">git remote add update &lt;B 远程仓库地址&gt;</span><br><span class="line">git fetch update master:updated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并并解决冲突</span></span><br><span class="line">git merge updated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接合并远程分支</span></span><br><span class="line">git merge update/master</span><br></pre></td></tr></table></figure><h3 id="远程分支删除以后，本地显示仍然存在的解决办法"><a href="#远程分支删除以后，本地显示仍然存在的解决办法" class="headerlink" title="远程分支删除以后，本地显示仍然存在的解决办法"></a>远程分支删除以后，本地显示仍然存在的解决办法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有分支：</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令查看远程分支和本地分支的对应关系</span></span><br><span class="line">git remote show origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 会看到</span></span><br><span class="line">refs/remotes/origin/&lt;branch&gt; stale (use <span class="string">'git remote prune'</span> to remove)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行下面命令同步删除</span></span><br><span class="line">git remote prune origin</span><br><span class="line">或者</span><br><span class="line">git fetch -p</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2018/linux/linux/"/>
      <url>/2018/linux/linux/</url>
      
        <content type="html"><![CDATA[<h3 id="linux-目录表"><a href="#linux-目录表" class="headerlink" title="linux 目录表"></a>linux 目录表</h3><p>/ 根目录</p><p>/bin 、 /usr/bin 可执行二进制文件目录，如常用的命令ls cat等</p><p>/boot 放置系统启动时用到的一些文件，如内核文件</p><p>/dev 存放系统下的设备文件，访问该目录下的文件，相当于访问某个设备，常用的是挂载光驱<code>mount /dev/cdrom/mnt</code></p><p>/etc 系统配置文件，重要的配置文件有</p><h3 id="文件大小表示方式"><a href="#文件大小表示方式" class="headerlink" title="文件大小表示方式"></a>文件大小表示方式</h3><table><thead><tr><th>单位</th><th>英文</th></tr></thead><tbody><tr><td>字节</td><td>B (Byte)</td></tr><tr><td>千</td><td>K (KibiByte)</td></tr><tr><td>兆</td><td>M (MebiByte)</td></tr><tr><td>千兆</td><td>G (GigaByte)</td></tr><tr><td>太</td><td>T (TeraByte)</td></tr><tr><td>拍</td><td>P (PetaByte)</td></tr><tr><td>艾</td><td>E (ExaByte)</td></tr><tr><td>泽</td><td>Z (ZettaByte)</td></tr><tr><td>尧</td><td>Y (YottaByte)</td></tr></tbody></table><h3 id="linux-常用命令"><a href="#linux-常用命令" class="headerlink" title="linux 常用命令"></a>linux 常用命令</h3><table><thead><tr><th>命令</th><th></th><th>作用</th></tr></thead><tbody><tr><td>ls</td><td>list</td><td>查看当前文件夹下的内容</td></tr><tr><td>pwd</td><td>print work directory</td><td>查看当前所在文件夹</td></tr><tr><td>cd[目录名]</td><td>change directory</td><td>切换文件夹</td></tr><tr><td>touch[文件名]</td><td>touch</td><td>如果文件不存在，新建文件<br>如果文件已经存在，修改文件的末次修改日期</td></tr><tr><td>mkdir[目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td>rm[文件名]</td><td>remove</td><td>删除指定的文件名</td></tr><tr><td>clear</td><td></td><td>清屏</td></tr></tbody></table><p><strong>ls 常用选项</strong></p><ul><li><p><code>-a</code> 显示所有目录和文件，包括隐藏文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -a</span></span><br><span class="line">. .. .xxx.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以.开头的文件/文件夹为隐藏文件/文件夹</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> . 代表当前目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .. 代表上一级目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 蓝色为目录，白色为文件</span></span><br></pre></td></tr></table></figure></li><li><p><code>-l</code> 以列表方式显示文件的详细信息</p></li><li><p><code>-h</code> 配合-l 以人性化的方式显示文件大小</p></li></ul><p>选项可以合写，无顺序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -alh</span></span><br></pre></td></tr></table></figure><p>ls <strong>通配符</strong></p><ul><li><code>*</code> 代表任意个数个字符</li><li><code>？</code>代表任意一个字符</li><li><code>[]</code> 表示可以匹配字符组中的任意一个</li><li><code>[abc]</code> 匹配<code>a</code>、<code>b</code>、<code>c</code> 中的任意一个</li><li><code>[a-f]</code> 匹配 <code>a-f</code> 任意一个字符</li></ul><p><strong>cd 常用选项</strong></p><ul><li><p><code>cd</code>/<code>cd ~</code> 切换到当前用户的主目录</p></li><li><p><code>cd ..</code> 切换到上一级目录</p></li><li><p><code>cd -</code>  在最近两次工作目录间切换</p></li></ul><p><strong>mkdir</strong></p><ul><li><code>-p</code> 可以递归创建目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> madir -p a/b/c</span></span><br></pre></td></tr></table></figure><blockquote><p>同一目录下文件夹名称不能和文件名同名</p></blockquote><p><strong>rm</strong></p><blockquote><p>删除时直接删除，不放入回收站</p></blockquote><ul><li><p><code>-f</code> 强制删除，忽略不存在的文件，无需提示</p></li><li><p><code>-r</code> 递归的删除目录下的内容，或用于删除文件夹</p></li></ul><h3 id="终端命令格式"><a href="#终端命令格式" class="headerlink" title="终端命令格式"></a>终端命令格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> [-options][paramete]</span><br></pre></td></tr></table></figure><p>command : 命令名，相应功能的英文单词或单词缩写<br>-options： 选项<br>paramete ：参数</p><h3 id="查阅帮助信息"><a href="#查阅帮助信息" class="headerlink" title="查阅帮助信息"></a>查阅帮助信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> --<span class="built_in">help</span></span><br><span class="line">$ man <span class="built_in">command</span></span><br><span class="line"><span class="comment"># man 是manual缩写,手册</span></span><br><span class="line"><span class="comment"># 使用man 时的操作键</span></span><br><span class="line"><span class="comment">#空格 显示手册的下一屏</span></span><br><span class="line"><span class="comment">#enter 一次滚动手册页的一行</span></span><br><span class="line"><span class="comment">#b 回滚一屏</span></span><br><span class="line"><span class="comment">#f 前滚一屏</span></span><br><span class="line"><span class="comment">#q 退出</span></span><br><span class="line"><span class="comment">#/word 搜索word字符串</span></span><br></pre></td></tr></table></figure><h3 id="终端技巧"><a href="#终端技巧" class="headerlink" title="终端技巧"></a>终端技巧</h3><ul><li><p>自动补全</p><p>在敲出 文件/目录/命令的前几个字母后，按下 <code>tab</code> 键</p><ul><li>如果输入没有歧义，系统会自动补全</li><li>如果输入有歧义，再按一下 <code>tab</code> 键，系统会提示可能存在的命令</li></ul></li><li><p>曾经使用过的命令</p><p>按上下键可在曾经使用过的命令间切换，<code>Ctrl+c</code> 退出选择</p></li></ul><h3 id="文件和目录常用命令"><a href="#文件和目录常用命令" class="headerlink" title="文件和目录常用命令"></a>文件和目录常用命令</h3><h4 id="拷贝和移动文件"><a href="#拷贝和移动文件" class="headerlink" title="拷贝和移动文件"></a>拷贝和移动文件</h4><ul><li><p><code>tree [目录名]</code>：  以树状图列出文件目录结构</p><p>  <code>-d</code>  只显示目录，不显示文件</p></li><li><p><code>cp 源文件 目标文件</code>： copy 复制文件或者目录</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cp  ~/Documemt/readme.txt  ./readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 ~/Documemt/ 目录下的 readme.txt 文件复制到./目录下并以readme.txt命名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不修改文件名，只需要写目标路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp  ~/Documemt/readme.txt  ./</span></span><br></pre></td></tr></table></figure><pre><code>`-i` ：覆盖文件前提示 y 覆盖 n 不覆盖`-r` ：若给出的源文件是目录文件，将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</code></pre><ul><li><code>mv 源文件 目标文件</code>：move 移动文件或目录/ 文件或目录重命名</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv  ~/Documemt/readme.txt  ./</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 ~/Documemt/ 目录下的 readme.txt 文件移动到./目录下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv readme.txt demo.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将readme.txt文件名修改为demo.txt</span></span><br></pre></td></tr></table></figure><pre><code>`-i` ：覆盖文件前提示 y 覆盖 n 不覆盖</code></pre><h4 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h4><ul><li><p><code>cat</code> 文件名： <code>concatenate</code> 查看文件内容、创建文件、文件合并、追加文件内容等功能，会<strong>一次显示所有内容</strong>，适合内容较少的文本文件</p><p><code>-b</code>：对非空输出行编号</p><p><code>-n</code>：对输出的所有行编号</p><blockquote><p>linux 中还有一个 <code>nl</code>  命令和 <code>cat -b</code> 的效果等价</p></blockquote></li><li><p><code>more</code> 文件名：<strong>分屏显示文件内容</strong> ，按空格显示下一屏，适合查看内容较多的文本</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 more 时的操作键  和 man 相同</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 空格 显示手册的下一屏</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> enter 一次滚动手册页的一行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> b 回滚一屏</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> f 前滚一屏</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> q 退出</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /word 搜索word字符串</span></span><br></pre></td></tr></table></figure><ul><li><p><code>grep</code> 搜索文本 文件名： 搜索文本文件内容，输出包含该文本的行</p><blockquote><p>linux 中的文本搜索工具，允许对文本文件进行模式查找（正则表达式），如果搜索文本中间有空格可以使用引号包裹</p></blockquote><p><code>-n</code> 显示匹配行和行号</p><p><code>-v</code> 显示不包含匹配文本的所有行（相当于求反）</p><p><code>-i</code> 忽略大小写</p><p><code>^a</code> 行首，搜索以a开头的行</p><p><code>ke$</code> 行尾，搜索以ke结束的行</p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p><code>echo 文字内容</code> ：会在终端中显示参数指定的文本，通常会和重定向联合使用</p></li><li><p>重定向  <code>&gt;</code> 和 <code>&gt;&gt;</code>：</p></li></ul><blockquote><p>linux 允许将命令执行结果重定向到一个文件，将本应显示在终端上的内容输出/追加到指定文件中，保存命令输出结果</p></blockquote><p><code>&gt;</code> 表示输出，会覆盖文件原有的内容</p><p><code>&gt;&gt;</code> 表示追加，会将文件追加到已有文件的末尾</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建 a 文件并将 “hello world”输出到 a 文件中 ，与touch区别</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hello world &gt; a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将命令 “ls -lh” 的结果输出到 a 文件中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lh &gt; a</span></span><br></pre></td></tr></table></figure><ul><li>管道 <code>|</code></li></ul><blockquote><p>linux 允许将一个命令的输出通过管道作为另一个命令的输入，另一个命令对第一个命令的输出进行二次处理</p><p>可以理解为现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 <code>|</code> 的左右分为两端，左端塞东西（写），右端取东西（读）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> more：分屏显示内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分屏显示命令 “ls -lha” 的输出结果</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lha ~ | more</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> grep：在命令执行结果的基础上查询指定文本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找 “ls -lha ~” 的结果中包含Do的行并显示</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lha ~ | grep Do</span></span><br></pre></td></tr></table></figure><h3 id="远程管理命令"><a href="#远程管理命令" class="headerlink" title="远程管理命令"></a>远程管理命令</h3><h4 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h4><p><code>shutdown 选项 时间</code></p><pre><code>`-r`  重新启动</code></pre><blockquote><p>不指定选项和参数，默认表示一分钟之后关闭电脑</p><p>远程维护服务器时，最好不要关闭系统，而应该重新启动系统</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 常用命令示例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新启动电脑，now 表示现在</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown -r now</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统在今天20:00 关机</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown 20:00</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 系统十分钟后自动关机</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown +10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消关机计划</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> shutdown -c</span></span><br></pre></td></tr></table></figure><h4 id="查看或配置网卡信息"><a href="#查看或配置网卡信息" class="headerlink" title="查看或配置网卡信息"></a>查看或配置网卡信息</h4><p><code>ifconfig</code>:  <code>configure a network interface</code> 查看/配置计算机当前的网卡配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看网卡配置信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看网卡对应的IP地址</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ifconfig | grep inet</span></span><br></pre></td></tr></table></figure><blockquote><p> 在linux中物理网卡通常以 <code>ensxx</code> 表示</p><p>127.0.0.1 本地环回/环回地址，一般用来测试本机网卡是否正常</p></blockquote><p><code>ping ip地址</code>： <code>ping</code> 检测到目标 ip 地址连接是否正常</p><pre><code>ping 127.0.0.1 检查本地网卡是否工作正常</code></pre><h4 id="远程登录和复制文件"><a href="#远程登录和复制文件" class="headerlink" title="远程登录和复制文件"></a>远程登录和复制文件</h4><ul><li><p><code>ssh 用户名@ip</code> ：<code>secure shell</code> 关机/重新启动</p></li><li><p><code>scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径</code>：<code>secure copy</code>  远程复制文件</p></li></ul><p><strong>SSH</strong> ：SSH 客户端是一种使用Secure Shell (SSH) 协议连接到远程计算机的软件协议</p><ul><li><p>数据传输是加密的，可以防止远程管理过程中的信息泄露，也能防止DNS欺骗和IP欺骗</p></li><li><p>数据传输是压缩的，可以提高传输速度</p></li></ul><blockquote><p> 有关 ssh 配置信息都保存在用户家目录下的 <code>.ssh</code>目录下</p></blockquote><h5 id="域名和端口号"><a href="#域名和端口号" class="headerlink" title="域名和端口号"></a>域名和端口号</h5><p><code>域名</code>：由一串用点分割的名字组成，例如 <code>www.baidu.com</code> ，是IP地址的别名，方便记忆</p><p><code>端口号</code>：通过IP地址可以找到网络上的计算机，通过端口号可以找到计算机上运行的程序</p><blockquote><p>SSH服务器默认端口号为22，Web服务器为80，HTTPS为443，FTP服务器为21，如果没有指定端口号，使用默认端口号</p></blockquote><h5 id="SSH-基本使用"><a href="#SSH-基本使用" class="headerlink" title="SSH 基本使用"></a>SSH 基本使用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh [-p port] user@remote</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> user 远程服务器上的用户名，如果不指定默认当前用户</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> remote 远程机器的地址，可以是IP/域名，或者别名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> port 是SSH server 监听的端口，如果不指定，默认22</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 <span class="built_in">exit</span> 退出当前用户登录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ssh 在 linux 或 Unix 系统下可直接使用，win下需要安装软件 putty xshell</span></span><br></pre></td></tr></table></figure><h5 id="scp-基本使用"><a href="#scp-基本使用" class="headerlink" title="scp 基本使用"></a>scp 基本使用</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从远程服务器拷贝文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scp user@remote ip:文件名或路径 文件名或路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 复制目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -P 指定端口是要用大写的 P</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传文件到服务器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scp 文件名或路径 user@remote ip:文件名或路径</span></span><br></pre></td></tr></table></figure><blockquote><p><code>scp</code>  命令只能在 <code>Linux</code> 或 <code>Unix</code> 下使用</p></blockquote><p>在win系统中需安装filezilla 使用FTP进行文件传输</p><p>FileZilla 传输文件时，使用的是 <code>FTP</code> 服务而不是 <code>SSH</code> 服务，因此端口号应该为 <code>21</code></p><h5 id="ssh高级"><a href="#ssh高级" class="headerlink" title="ssh高级"></a>ssh高级</h5><ul><li>免密码登陆</li></ul><p>配置公钥：执行 <code>ssh-keygen</code> 即可生成 ssh 钥匙，一路回车即可</p><p>​    <code>id_rsa.pub</code> 公钥 、 <code>id_rsa</code> 私钥</p><p>上传公钥到服务器：执行 <code>ssh-copy-id -p port user@remote</code>，公钥保存在服务器 <code>.ssh</code> 目录下</p><p>​    <code>authorized_keys</code></p><blockquote><p> 本地使用私钥对数据进行加密/解密，服务器使用公钥对数据进行加密/解密</p><p>非对称加密算法</p><p>使用公钥加密的数据，需要使用私钥解密</p><p>使用公私钥加密的数据，需要使用公钥解密</p></blockquote><ul><li>配置别名</li></ul><p><code>~/.ssh/config</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host vultr</span><br><span class="line">HostName ip地址</span><br><span class="line">User root</span><br><span class="line">port 22</span><br></pre></td></tr></table></figure><p>直接使用 <code>ssh vultr</code> 即可实现登陆，<code>scp</code> 同样适用</p><h3 id="用户和权限的相关命令"><a href="#用户和权限的相关命令" class="headerlink" title="用户和权限的相关命令"></a>用户和权限的相关命令</h3><h4 id="用户和权限的基本概念"><a href="#用户和权限的基本概念" class="headerlink" title="用户和权限的基本概念"></a>用户和权限的基本概念</h4><ul><li><p>用户管理包括 <strong>用户</strong> 和 <strong>组</strong> 管理</p></li><li><p>在linux中可以指定每一个用户针对不同的文件或目录不同的权限</p></li><li><p>对<strong>文件/目录的权限</strong>包括</p></li></ul><table><thead><tr><th>权限</th><th>英文</th><th>缩写</th><th>数字代号</th></tr></thead><tbody><tr><td>读</td><td>red</td><td>r</td><td>4</td></tr><tr><td>写</td><td>write</td><td>w</td><td>2</td></tr><tr><td>执行</td><td>excute</td><td>x</td><td>1</td></tr><tr><td>无</td><td></td><td>-</td><td>0</td></tr></tbody></table><p><strong>组</strong>：实际工作中，可以预先对组设置好权限，然后将不同的用户添加到不同的组中（简化了用户权限设置）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls -l 扩展</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">-rw-rw-r-- 1 用户名 组名 大小 时间 名称</span><br><span class="line">drwxrwxr-x 2</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>-</td><td>rw-</td><td>rw-</td><td>r–</td><td>1</td><td>用户名</td><td>组名</td></tr><tr><td>d</td><td>rwx</td><td>rwx</td><td>r-x</td><td>2</td><td></td><td></td></tr><tr><td>文件/目录</td><td>当前用户权限</td><td>当前组所对应的权限</td><td>其他用户权限</td><td>硬链接数</td><td></td><td></td></tr></tbody></table><p>硬链接数：表示有多少种方式可以访问到当前目录/文件，文件的硬链接数通常为1，目录的硬链接数取决于该目录有多少个子目录。</p><h4 id="修改文件-目录权限-chomd"><a href="#修改文件-目录权限-chomd" class="headerlink" title="修改文件/目录权限 chomd"></a>修改文件/目录权限 <code>chomd</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +/-rwx 文件名|目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> + 增加权限  - 删除权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接修改文件/目录的读、写、执行权限，但不能精确到 拥有者/组/其他</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x 文件名 // 增加文件可执行权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod -r 目录 // 删除目录可读权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录的可读权限：读取目录内容（如果没有此权限，可<span class="built_in">cd</span>，不能ls）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录的可写权限：修改目录内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录的可执行权限：对目录执行终端命令（如果没有此权限，甚至无法 <span class="built_in">cd</span> 到目录）</span></span><br></pre></td></tr></table></figure><p>chmod 高级用法</p><h4 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h4><ul><li><p><code>root</code> 账户用于系统的维护和管理，对操作系统的所有资源具有所有访问权限</p></li><li><p>不推荐直接使用 root 账户登录系统</p></li><li><p>在 linux 安装过程中，系统会自动创建一个标准用户账号</p></li></ul><p><strong>sudo</strong></p><ul><li><p><code>su</code> 是 <code>substitute user</code> 缩写，表示使用另一个用户身份</p></li><li><p><code>sudo</code> 命令用来以其他身份来执行命令，预设身份为 root</p></li><li><p>用户使用 sudo 时，需先输入密码，之后有五分钟的有效期，超过期限去重新输入密码</p></li></ul><h4 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h4><p><code>groupadd 组名</code> ：添加组</p><p><code>groupdel 组名</code> ：删除组</p><p><code>cat /etc/group</code> ：确认组信息</p><p><code>chgrp 组名 文件/目录名</code> ：修改文件/目录的所属组  -R 递归修改</p><blockquote><p>创建组/删除组的终端命令都需要通过 sudo 来执行</p><p>组信息保存在 /etc/group 文件中</p><p>/etc 目录是专门用来保存 系统配置信息的目录</p></blockquote><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p><strong>创建用户/设置密码/删除用户</strong></p><p><code>useradd -m -g 组 新建用户名</code> ：添加新用户</p><p>​    -m 自动建立用户家目录</p><p>​    -g 指定用户所在的组，否则会建立一个和用户名同名的组</p><p><code>passwd 用户名</code>：设置用户密码</p><p>​    如果是普通用户，直接用 passwd 可以修改自己的账户密码</p><p><code>userdel -r 用户名</code>：删除用户</p><p>​    -r 选项自动删除用户家目录</p><p><code>cat /etc/passwd | grep 用户名</code>：确认用户信息</p><p>​    新建用户后，用户信息保存在 <code>/etc/passwd</code> 文件中</p><blockquote><p>创建用户/删除用户/修改其他用户密码 的命令都需要通过 <code>sudo</code> 执行</p><p>用户信息保存在 <code>/etc/passwd</code> 文件中</p></blockquote><p><strong>查看用户信息</strong></p><p><code>id [用户名]</code>：查看用户UID 和 GID 信息</p><p><code>who</code> ：查看当前所有登陆的用户列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> who</span></span><br><span class="line">用户名  时间 (:0) # :0 表示当前电脑</span><br><span class="line">用户名  时间 (172.16.xx.xx)</span><br></pre></td></tr></table></figure><p><code>whoami</code> ：查看当前登录用户的账户名</p><p><strong>passwd 文件</strong> 由六个分号组成七个信息</p><ol><li>用户名</li><li>密码（x，表示加密的密码）</li><li>UID（用户标识）</li><li>GID（组标识）</li><li>用户全名</li><li>家目录</li><li>登录使用的shell，就是登陆之后使用的终端，ubuntu 默认使用 <code>dash</code></li></ol><p><strong>usermod</strong></p><p>用来设置用户的主组/附加组 和登录shell</p><p>主组：在用户新建时指定，在 <code>etc/passwd</code> 的第四列GID对应的组</p><p>附加组：在 <code>etc/group</code> 中最后一列表示该组的用户列表，用于指定用户的附加权限</p><blockquote><p>设置用户的附加组之后，需要重新登录才能生效</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 修改用户的主组</span><br><span class="line">$ usermod -g 组 用户名</span><br><span class="line"># 修改用户的附加组</span><br><span class="line">$ usermod -G 组 用户名</span><br><span class="line"># 修改用户登录shell</span><br><span class="line">$ usermod -s /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>默认使用 <code>useradd</code> 添加的用户是没有权限使用 <code>sudo</code> 以 <code>root</code> 身份执行命令的，使用以下命令将用户添加到 <code>sudo</code> 附加组中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -G sudo 用户名</span><br></pre></td></tr></table></figure><p><strong>which</strong></p><blockquote><p><code>/etc/passwd</code> 是用于保存用户信息的文件</p><p><code>/usr/bin/passwd</code> 是用于修改用户密码的程序</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">which</span> 可用于查看执行命令所在的位置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> ls</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /bin/ls</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> useradd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /usr/sbin/useradd</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cd</code> 这个命令是内置在系统内核中的，没有独立文件，因此用 <code>which</code> 无法找到</p></blockquote><p><strong>bin 和 sbin</strong></p><p><code>/bin</code> (binary) 是二进制执行文件目录，主要用于具体应用</p><p><code>/sbin</code> (system binary) 是系统管理员专用的二进制文件目录，主要用于系统管理</p><p><code>/usr/bin</code> (user commands for applications) 后期安装的一些软件</p><p><code>/usr/sbin</code> (super user commands for applications) 超级用户的一些管理程序</p><blockquote><p> bin 存储普通可执行文件，sbin存储跟系统管理相关的可执行文件</p></blockquote><h4 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h4><p><code>su - 用户名</code>：切换用户，并且切换目录</p><p>​    <code>-</code>  可以切换到用户家目录，否则保持位置不变</p><p><code>exit</code>： 退出当前登录用户</p><blockquote><p><code>su</code> 不接用户名，可以切换到 <code>roo</code>，不推荐，不安全</p></blockquote><p>exit示意图：</p><p><img src="exit%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>chowm 修改拥有者</p><p>chgrp 修改组</p><p>chmod 修改权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改文件/目录的拥有者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chown 用户名 文件名/目录名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归修改文件/目录的组</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chgrp -R 组名 文件名/目录名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归修改文件权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 755 三个数字分别代表 用户 u /组 g /其他用户 o 的权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod -R 755 文件名/目录名</span></span><br></pre></td></tr></table></figure><blockquote><p>r –&gt; 4   w –&gt; 2    x –&gt; 1  无权限 –&gt; 0 ，想要什么权限直接将数字相加</p></blockquote><h3 id="系统信息相关命令"><a href="#系统信息相关命令" class="headerlink" title="系统信息相关命令"></a>系统信息相关命令</h3><blockquote><p> 查询服务器上当前系统日期和时间 / 磁盘空间占用情况 / 程序执行情况</p></blockquote><h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><p><code>date</code> ：查看系统时间</p><p><code>cal</code> ：<code>calendar</code> 查看日历， <code>-y</code> 选项可以查看一年的日历</p><h4 id="磁盘和空间目录"><a href="#磁盘和空间目录" class="headerlink" title="磁盘和空间目录"></a>磁盘和空间目录</h4><p><code>df -h</code> ：<code>disk free</code> 显示磁盘剩余空间  -h 以人性化的方式显示文件大小</p><p><code>du -h [目录名]</code> ：<code>disk usage</code> 显示目录占用空间情况，不指定目录默认表示当前目录</p><blockquote><p>-h 以人性化的方式显示文件大小</p></blockquote><h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><p>PID 进程代号</p><p><code>ps au</code> : <code>process status</code> 查看进程的详细状况，默认只显示当前用户通过终端启动的程序</p><p>​    ps 选项(没有减号)</p><p>​    <code>a</code> 显示终端上的所有进程，包括其他用户的进程</p><p>​    <code>u</code> 显示进程的详细状态</p><p>​    <code>x</code> 显示不是通过终端启动的进程</p><p><code>top</code> : 动态显示运行中的进程并且排序 ，输入 q 退出</p><p><code>kill [-9] 进程代号</code> : 终止指定代号的进程，<code>-9</code> 表示强行终止</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><p><code>find [路径] -name “*.txt”</code>  : 查找指定路径下扩展名为.txt 的文件，包括子目录</p><p>​    如果省略路径，表示在当前文件夹下查找</p><h4 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h4><p><code>ln -s 被链接的源文件 链接文件</code> ：建立文件的软链接，类似于 Windows 下的快捷方式</p><p>注意：</p><ul><li><p>如果没有 <code>-s</code> 选项建立的是一个硬链接文件（两个文件占用相同大小的磁盘空间，几乎不用）</p></li><li><p>源文件要使用绝对路径，可以方便移动链接文件后，仍然能够正常使用</p></li></ul><h5 id="文件软硬链接示意图"><a href="#文件软硬链接示意图" class="headerlink" title="文件软硬链接示意图"></a>文件软硬链接示意图</h5><p><img src="%E6%96%87%E4%BB%B6%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p><ul><li><p>在 linux 中<strong>文件名</strong>和<strong>文件的数据</strong>是分开存储的</p></li><li><p>在 linux 中，只有文件的硬链接数为 0 文件才会被删除</p></li><li><p>在日常工作中几乎不会建立文件的硬链接</p></li></ul><h4 id="打包和解包"><a href="#打包和解包" class="headerlink" title="打包和解包"></a>打包和解包</h4><p>tar 是Linux中常用的备份工具，此命令可以把一系列文件打包到一个大文件中，也可以把一个打包的大文件恢复成一系列文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打包文件</span></span><br><span class="line">tar -cvf 打包文件.tar 被打包的文件/路径 (多个文件一次写在后面，用空格隔开)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解包文件</span></span><br><span class="line">tar -xvf 打包文件.tar</span><br></pre></td></tr></table></figure><ul><li><p><code>c</code> 生成档案文件，创建打包文件</p></li><li><p><code>x</code> 解开档案文件</p></li><li><p><code>v</code> 列出归档接档的详细过程</p></li><li><p><code>f</code> 指定档案文件名称， f选项必须放在最后</p></li></ul><h4 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h4><p><strong>gzip</strong></p><ul><li><p><code>tar</code> 和 <code>gzip</code> 命令结合使用实现文件打包和压缩</p><ul><li><p><code>tar</code> 只负责打包，但不压缩</p></li><li><p>用 <code>gzip</code> 压缩 <code>ta</code>r 打包后的文件，扩展名为 <code>xxx.tar.gz</code></p></li></ul></li><li><p><code>tar</code> 命令中 <code>-z</code> 选项可以调用 <code>gzip</code></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 压缩文件</span></span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩文件/路径</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩文件</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩到指定路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C 解压到指定路径，（路径必须存在）</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 目标路径</span><br></pre></td></tr></table></figure><p><strong>bzip2</strong></p><ul><li><p><code>tar</code> 和 <code>bzip2</code> 命令结合使用实现文件打包和压缩（用法同 <code>gzip</code>）</p><ul><li><p><code>tar</code> 只负责打包，但不压缩</p></li><li><p>用 <code>bzip2</code> 压缩 <code>ta</code>r 打包后的文件，扩展名为 <code>xxx.tar.bz2</code></p></li></ul></li><li><p><code>tar</code> 命令中 <code>-j</code> 选项可以调用 <code>bzip2</code></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 压缩文件</span></span><br><span class="line">tar -jcvf 打包文件.tar.bz2 被压缩文件/路径</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩文件</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩到指定路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C 解压到指定路径，（路径必须存在）</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2 -C 目标路径</span><br></pre></td></tr></table></figure><h4 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h4><p><code>apt</code> : <code>Advanced Packaging Tool</code> ，linux下安装包管理工具，可以方便的安装/卸载/更新软件包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装软件</span><br><span class="line">sudo apt install 软件包</span><br><span class="line"># 卸载软件</span><br><span class="line">sudo apt remove 如软件名</span><br><span class="line"># 更新已安装的包</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>neofetch</p><p>screenfetch</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 基础</title>
      <link href="/2018/javascript/javascript%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/javascript/javascript%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h1><h1 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h1><ul><li>第一种 : 写在<code>script</code>标签中</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  alert(<span class="string">'Hello World!'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>第二种 : 引入一个js文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">’main.js’</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>script 可以放在很多地方,但是我们一般规范写在body的最后面；</li><li>使用 src 引入的标签不能再在标签内写js代码 (写了不会执行)</li></ol><p>!&gt; 通过 <code>src</code> 请求到的 <code>js</code> 文件，会被解析到 <code>script</code> 标签内，并且覆盖原 <code>script</code> 标签内的 <code>js</code> 代码</p><p>!&gt; script 标签的 src 属性可以写任何路径或文件，并不仅仅只能写 js 文件</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><blockquote><p>注释代码不会被执行，仅仅起到一个提示的作用。注释可以对复杂的代码进行解释，方便后期的维护和开发。</p></blockquote><ul><li><p>单行注释 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释， 单行注释只能写一行代码</span></span><br><span class="line"><span class="comment">// 快捷键： ctrl + /</span></span><br></pre></td></tr></table></figure></li><li><p>多行注释 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是多行注释，在多行注释中可以</span></span><br><span class="line"><span class="comment">换行</span></span><br><span class="line"><span class="comment">快捷键  ctrl + shift + /</span></span><br><span class="line"><span class="comment">不可嵌套</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="输出语句-5种"><a href="#输出语句-5种" class="headerlink" title="输出语句 (5种)"></a>输出语句 (5种)</h1><ul><li><p><strong>alert : 警告框</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alert会弹出一个警告框</span></span><br><span class="line">alert(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>confirm : 确认框</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// confirm弹出一个确定框</span></span><br><span class="line">confirm(<span class="string">"我帅吗？"</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>prompt : 输入框</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prompt:弹出一个输入框，可以输入值</span></span><br><span class="line">prompt(<span class="string">"请输入你的真是年龄"</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>document.write : 网页中写入内容</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以识别标签</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;hello world&lt;/h1&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">Date</span>()); <span class="comment">// 输出当前时间</span></span><br></pre></td></tr></table></figure></li><li><p><strong>console.log：控制台输出</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F12打开控制台，在console中可以看到打印的信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"hello word"</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 声明变量</span></span><br><span class="line"><span class="keyword">var</span> age</span><br><span class="line">age = <span class="number">12</span> <span class="comment">// 先声明,后赋值</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">12</span> <span class="comment">// 同时声明+赋值</span></span><br><span class="line"><span class="keyword">var</span> age,name,sex <span class="comment">// 直接声明变量,可一次声明多个，用逗号隔开</span></span><br><span class="line">height=<span class="number">100</span> <span class="comment">// 不声明变量，直接赋值(不会报错，但是不推荐)</span></span><br><span class="line"><span class="built_in">console</span>.log(height) <span class="comment">// 不声明变量，也不赋值变量，直接使用（会报错）v</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2 <span class="comment">// 把两个数字加起来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">var student = &#123;</span></span><br><span class="line"><span class="comment">name:'小明'</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>变量<strong>命名要求</strong>（变量是[标识符][1]的一种）</p><ol><li>以字母、下划线或美元符号（$）开头</li><li>由字母、下划线、美元符号（$）和数字组成</li><li>标识符<strong>区分大小写</strong></li><li>标识符不能使用关键字和保留字</li><li>如果重新声明 JavaScript 变量，该变量的值不会丢失 <code>var car=&#39;yellow&#39;; var car</code>  car 的值依然是 ‘yellow’</li></ol></li></ul><blockquote><p>关键字 (有特殊意义的一些单词)<br><code>break</code> <code>do</code> <code>instanceof</code> <code>typeof</code> <code>case</code> <code>else</code> <code>new</code> <code>var</code> <code>in</code> <code>catch</code> <code>finally</code> <code>return</code> <code>void</code> <code>continue</code> <code>for</code> <code>switch</code> <code>while</code> <code>try</code> <code>debugger</code> <code>function</code> <code>this</code> <code>with</code> <code>default</code> <code>if</code> <code>throw</code> <code>delete</code></p><p>保留字<br><code>abstract</code> <code>enum</code> <code>int</code> <code>short</code> <code>boolean</code> <code>export</code> <code>interface</code> <code>static</code> <code>extends</code> <code>long</code> <code>super</code> <code>Char</code> <code>final</code> <code>native</code> <code>Class</code> <code>synchronized</code> <code>package</code> <code>throws</code> <code>Const</code> <code>goto</code> <code>private</code> <code>transient</code> <code>degubber</code> <code>implements</code> <code>volatile</code> <code>double</code> <code>import</code> <code>public</code> <code>byte</code> <code>float</code> <code>protected</code></p></blockquote><p>交换两个变量的值</p><ol><li><p>使用临时变量  <strong>(必须掌握)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br></pre></td></tr></table></figure></li><li><p>不使用临时变量  <strong>(了解)</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a+b</span><br><span class="line">b = a-b</span><br><span class="line">a = a-b</span><br></pre></td></tr></table></figure></li></ol><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ul><li>浮点数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">3.1416</span>; <span class="comment">// 3.1416</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">3.12e2</span>; <span class="comment">// 312</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">3.12e-1</span>; <span class="comment">// 0.312</span></span><br></pre></td></tr></table></figure><ul><li>整数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">070</span>; <span class="comment">// 56 (八进制)</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0xA</span>; <span class="comment">// 10 (十六进制)</span></span><br></pre></td></tr></table></figure><ul><li>特殊值<blockquote><p><code>NaN</code> <code>Infinity</code></p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>/<span class="number">0</span> <span class="comment">// Infinity (无穷大)</span></span><br></pre></td></tr></table></figure><blockquote><p>通过 <code>isNaN(num)</code> 可以判断是否是一个数字，返回 false 的时候，表示是一个数字</p></blockquote><ul><li>浮点数精度丢失问题</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在进行浮点数运算的时候，可能会出现精度丢失的问题</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> = <span class="number">0.30000000000000004</span></span><br><span class="line"><span class="number">0.2</span> + <span class="number">0.2</span> = <span class="number">0.4</span></span><br><span class="line"><span class="comment">// 尽量少用浮点数进行运算，不要让浮点数进行比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法 : 根据小数点后面的位数量 乘以对应的整数</span></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span>  ==&gt; (<span class="number">0.1</span>*<span class="number">10</span>+<span class="number">0.2</span>*<span class="number">10</span>) / <span class="number">10</span> = <span class="number">0.3</span></span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>只要是在<strong>单引号或双引号</strong>内的就是 <code>String</code> 类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name1 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">'july'</span></span><br><span class="line"><span class="keyword">var</span> name3 = <span class="string">'3.1416'</span></span><br><span class="line"><span class="comment">// 使用索引位置来访问字符串中的每个字符,字符串的索引从 0 开始</span></span><br><span class="line"><span class="keyword">var</span> character = name1[<span class="number">3</span>]; <span class="comment">// l</span></span><br><span class="line"><span class="comment">// 内置属性 length 来计算字符串的长度</span></span><br><span class="line"><span class="built_in">console</span>.log(name1.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><blockquote><p>若在字符串中使用引号，字符串中的引号不要与字符串的引号相同，或在字符串添加转义字符 <code>\</code></p></blockquote><p>字符串可以是对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">"john"</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"john"</span>);</span><br><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// String</span></span><br><span class="line"><span class="keyword">typeof</span> y; <span class="comment">// Object</span></span><br></pre></td></tr></table></figure><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>布尔型，只有 <code>true</code> 和 <code>false</code> 两个值，且是小写</p><ul><li>true :  <code>1</code>、<code>2</code>、<code>1.1</code>、<code>-1</code>、<code>&#39;0&#39;</code>、<code>&#39;1&#39;</code>、<code>[]</code>、<code>Infinity</code></li><li>false :  <code>0</code>、<code>&#39;&#39;</code>、<code>null</code>、<code>NaN</code>、<code>undefined</code></li></ul><blockquote><p>所有非 0 数都是 true，0 是 false</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sex = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> (sex) &#123;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'男'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">'女'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">cat[<span class="number">0</span>] = <span class="string">"yellow"</span></span><br><span class="line">cat[<span class="number">1</span>] = <span class="string">"red"</span></span><br><span class="line">cat[<span class="number">2</span>] = <span class="string">"blue"</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">var</span> cat = [<span class="string">"yellow"</span>,<span class="string">"red"</span>,<span class="string">"blue"</span>]</span><br></pre></td></tr></table></figure><blockquote><p>关键词 <code>new</code> 用于声明新变量的类型</p></blockquote><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>由花括号分隔，属性和方法的容器；对象的属性以名称和值对的形式 (name :  value) 来定义；多个属性由逗号分隔。对象的方法定义了一个函数，并作为对象的属性存储。对象方法通过添加 <code>()</code> 调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">cat.name = <span class="string">"kitty"</span></span><br><span class="line">cat.age = <span class="string">"2"</span></span><br><span class="line">cat.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">name: <span class="string">'kitty'</span>,</span><br><span class="line">age: <span class="number">2</span>,</span><br><span class="line">eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象属性有两种访问方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = cat.name</span><br><span class="line">name = cat[<span class="string">"name"</span>]</span><br></pre></td></tr></table></figure><p>对象方法的访问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eat = cat.eat() <span class="comment">// 输出函数执行结果</span></span><br><span class="line">eat = cat.eat <span class="comment">// 输出函数表达式</span></span><br></pre></td></tr></table></figure><h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>只有一个值：<code>null</code>，表示对象不存在</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="literal">null</span> <span class="comment">// 将cat的值清空</span></span><br></pre></td></tr></table></figure><ul><li>str.match()方法匹配不到返回 null</li><li>通过 document.querySelector、getElementById() 获取不到元素返回 null</li></ul><h2 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h2><p>只有一个值：<code>undefined</code></p><ul><li>已声明未赋值的变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>没有明确返回值的变量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象不存在的属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.c) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组下标不存在</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"zs"</span>, <span class="string">"ls"</span>, <span class="string">"ww"</span>]</span><br><span class="line"><span class="comment">//           0    1     2      下标从零开始，长度为3</span></span><br><span class="line">arr[<span class="number">5</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a + b)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// getSum(20, 30) // 50</span></span><br><span class="line"><span class="keyword">var</span> result = getSum(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数没有传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line">f() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><blockquote><p>是一个操作符而不是函数，圆括号可以使用，但不是必需的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num</span><br><span class="line"><span class="keyword">typeof</span> (num) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> (num1) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 对未初始化和未声明的变量执行 typeof 操作符都返回 undefined 值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">typeof</span> num <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">typeof</span> num <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">typeof</span> flag <span class="comment">// bollean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object ==&gt; null 被认为是一个空的对象引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = &#123;<span class="attr">name</span>: <span class="string">'kitty'</span>&#125;</span><br><span class="line"><span class="keyword">typeof</span> cat <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><h2 id="转换成字符串"><a href="#转换成字符串" class="headerlink" title="转换成字符串"></a>转换成字符串</h2><ol><li><p>调用 <code>toString()</code> 方法 （显式转换）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> result = a.toString()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> result) <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// number</span></span><br></pre></td></tr></table></figure><p>null 、undefined 没有 toString() 方法</p></li><li><p>调用 <code>String()</code> 构造函数（显式转换）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="built_in">String</span>(a)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str1) <span class="comment">// string</span></span><br></pre></td></tr></table></figure></li><li><p>直接和字符串做加法运算(推荐方法) （隐式因式转换）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任意数据类型的变量和字符串做加法运算结果都是字符串</span></span><br><span class="line"><span class="keyword">var</span> str2 = a + <span class="string">''</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str2) <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (b + <span class="string">''</span>)) <span class="comment">// string</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="转换成数值"><a href="#转换成数值" class="headerlink" title="转换成数值"></a>转换成数值</h2><ol><li><code>Number(a)</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1= <span class="built_in">Number</span>(<span class="string">"123"</span>)</span><br><span class="line"><span class="keyword">var</span> num2= <span class="built_in">Number</span>(<span class="string">"123c"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num1) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num2) <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 如果字符串不能转换成合法数字，转换结果为 NaN</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>parseInt()</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(’<span class="number">12.3</span>’)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num2) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 12 只保留整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(’<span class="number">15</span>xyz’)</span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(’<span class="number">15</span>x6yz’)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num3) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(num3) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(num4) <span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 如果字符串里有非法的数字，会逐个转换，直到遇到无法转化的字符串为止</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用 <code>parseFloat()</code> 完成</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(’<span class="number">12.34</span>’)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num3) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(num3) <span class="comment">// 12.34 可以保留小数位</span></span><br></pre></td></tr></table></figure><ol start="4"><li>让字符串和数字做除了加法以外的运算（隐式转换）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="string">"345"</span></span><br><span class="line"><span class="keyword">var</span> num4 = +d <span class="comment">// 前面加 + （正）号也可以转换</span></span><br><span class="line"><span class="comment">// num4 = d - 0</span></span><br><span class="line"><span class="comment">// numb4 = d * 1</span></span><br><span class="line"><span class="comment">// num4 = d / 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num4) <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(num4) <span class="comment">// 345</span></span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><blockquote><p><code>parseInt()</code> 函数解析一个字符串参数，指定该字符串为指定基数的进制值，并返回一个10进制的整数，如果被解析参数的第一个字符无法被转化成数值类型，则返回 <code>NaN</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="built_in">parseInt</span>(string, radix)</span><br><span class="line"><span class="comment">// string 要被解析的值，如果参数不是一个字符串，则将其转换为字符串</span></span><br><span class="line"><span class="comment">// radix 基数,表示进制，介于2和36之间的整数，默认为10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>, <span class="number">5</span>) <span class="comment">// 将'123'看作5进制数，返回十进制数38</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="built_in">parseInt</span>) <span class="comment">// [1, NaN, NaN]</span></span><br><span class="line"><span class="comment">// [1, 2, 3].map(parseInt(item, index))</span></span><br></pre></td></tr></table></figure><blockquote><p><code>parseFloat()</code> 函数解析一个字符串参数并返回一个浮点数，如果给定值不能被转换成数值，则会返回 NaN。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="built_in">parseFloat</span>(value)</span><br><span class="line"><span class="comment">// value 需要被解析成为浮点数的值</span></span><br><span class="line"><span class="built_in">parseFloat</span>(’<span class="number">3.14</span>‘) <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure><h2 id="转换成布尔值"><a href="#转换成布尔值" class="headerlink" title="转换成布尔值"></a>转换成布尔值</h2><ol><li>使用 <code>Boolean()</code> 完成</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">45</span></span><br><span class="line"><span class="keyword">var</span> result1 = <span class="built_in">Boolean</span>(a)</span><br><span class="line"><span class="built_in">console</span>.log(result1) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 对于数字类型来说：一般的数字都转换成为true，0、NaN 会被转换成为false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"hello"</span></span><br><span class="line"><span class="comment">// var str = ""</span></span><br><span class="line"><span class="comment">// var str = " "</span></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="built_in">Boolean</span>(str)</span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 字符串中只有空的字符串会被转换成为 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result3 = <span class="built_in">Boolean</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result3) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result4 = <span class="built_in">Boolean</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result4) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> result5 = <span class="built_in">Boolean</span>(b)</span><br><span class="line"><span class="built_in">console</span>.log(result5) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>0, NaN, 空字符串，undefined, null, false 会被转换成为 false</strong></p><ol start="2"><li>使用 <code>!!</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> !!a) <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(!!a) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>自动转换</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">""</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"哈哈"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量转换表"><a href="#变量转换表" class="headerlink" title="变量转换表"></a>变量转换表</h2><table><thead><tr><th>Value</th><th>Boolean</th><th>Number</th><th>String</th></tr></thead><tbody><tr><td>undefined</td><td>false</td><td>NaN</td><td>“undefined”</td></tr><tr><td>null</td><td>false</td><td><strong>0</strong></td><td>“null”</td></tr><tr><td>true</td><td>true</td><td>1</td><td>“true”</td></tr><tr><td>false</td><td>false</td><td>0</td><td>“false”</td></tr><tr><td>“”</td><td>false</td><td>0</td><td>“”</td></tr><tr><td>“123”</td><td>true</td><td>123</td><td>“123”</td></tr><tr><td>“1a”</td><td>true</td><td>NaN</td><td>“1a”</td></tr><tr><td>0</td><td>false</td><td>0</td><td>“0”</td></tr><tr><td>1</td><td>true</td><td>1</td><td>“1”</td></tr><tr><td>Infinity</td><td>true</td><td>Infinity</td><td>“Infinity”</td></tr><tr><td>NaN</td><td>false</td><td>NaN</td><td>“NaN”</td></tr><tr><td>{}</td><td><strong>true</strong></td><td>NaN</td><td>“[object Object]”</td></tr></tbody></table><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="算数操作符"><a href="#算数操作符" class="headerlink" title="算数操作符"></a>算数操作符</h2><blockquote><p><code>+</code> 、<code>-</code> 、<code>*</code> 、<code>/</code> 、<code>%</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">5</span> + <span class="number">6</span> <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">5</span> % <span class="number">2</span> <span class="comment">// 1 取余数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">5</span> % (<span class="number">-2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> num = (<span class="number">-5</span>) % <span class="number">2</span> <span class="comment">// -1 只与左边值的符号有关</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="string">"5"</span> + <span class="number">6</span> + <span class="number">7</span> <span class="comment">// "567" 数字与字符串相加，返回字符串</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">5</span> + <span class="number">6</span> + <span class="string">"7"</span> <span class="comment">// "117"</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="string">""</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="string">"7"</span> <span class="comment">// "567" 字符串 + 数字得到字符串</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="string">""</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> <span class="comment">// "567"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">5</span> + <span class="literal">true</span> <span class="comment">// 6  返回数值，false 转成 0，true 转成 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="string">"1"</span> + <span class="literal">true</span> <span class="comment">// "1true" 字符串与布尔值相加,布尔值转化成字符串</span></span><br></pre></td></tr></table></figure><h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><blockquote><p><code>a =  a  +  1</code> 即 <code>a++</code>, <code>a =  a - 1</code> 即 <code>a--</code><br><code>a = a + 5</code> 可简写成 <code>a += 5</code>，类似的还有 <code>a -= 5</code>、<code>a *= 5</code>、<code>a /= 5</code>、<code>x %= y</code></p><p>赋值运算符左边不能是常量或表达式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num = age++ <span class="comment">// num = 10 age = 11 (先将变量中的值取出做赋值操作,再自身+1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num = ++age <span class="comment">// num = 11 age = 11 (先自身+1,然后再将+1后的结果赋值)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(num++) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(++num) <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> y = x++ + ++x + x * <span class="number">10</span> <span class="comment">// x = 3</span></span><br><span class="line"><span class="comment">// y = 3 + ++x + x * 10  // x = 4</span></span><br><span class="line"><span class="comment">// y = 3 + 5 + x * 10 // x = 5</span></span><br><span class="line"><span class="comment">// y = 58</span></span><br></pre></td></tr></table></figure><h2 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h2><blockquote><p><code>&gt;</code> 、<code>&lt;</code> 、<code>&gt;=</code> 、<code>&lt;=</code></p><p><code>==</code> 相等 、<code>！=</code> 不相等 、<code>===</code> 全等 、<code>！===</code> 不全等</p><p><code>in</code> <code>instanceof</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">6</span> &gt; <span class="number">4</span></span><br><span class="line">alert(result) <span class="comment">// true 输出Boolean类型</span></span><br></pre></td></tr></table></figure><p>运算符的结果类型为 <code>Boolean</code></p><ul><li><p><code>&gt;</code> 、<code>&lt;</code> 、<code>&gt;=</code> 、<code>&lt;=</code> 、<code>==</code> 相等、<code>!=</code> 不相等  （字面量比较）</p><p>在比较前先执行类型转换</p><ul><li>如果有一个操作数是<strong>布尔值</strong>，则在比较相等性前先将其转换为<strong>数值</strong>—false转换为0，true转换为1</li><li>如果一个操作数是<strong>字符串</strong>，另一个操作数是<strong>数值</strong>，则在比较相等性前将字符串转换为<strong>数值</strong></li><li>如果两个值都是字符串，则按照字符串的字符编码进行逐位比较</li><li>如果一个操作数是对象，另一个不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则比较</li><li>如果两个操作数都是对象，则比较它们是否指向同一个对象</li><li><strong>null 和 undefined 是相等的</strong></li><li>在比较相等性之前，不能将 null 和 undefined 转换为其他任何值</li><li>如果有一个操作符是NaN，则相等操作符返回false，不相等操作符返回true；即使两个操作数都是NaN，也一样</li></ul></li></ul><ul><li><code>===</code> 全等、<code>！===</code> 不全等<br>两个操作数在未经转换的情况下相等返回true，不相等返回false</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">2</span> == <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="string">"0"</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">''</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">'4'</span> == <span class="number">4</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">"NaN"</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> != <span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">[] != [] <span class="comment">// true</span></span><br><span class="line">[] == [] <span class="comment">// false</span></span><br><span class="line">[] == ![] <span class="comment">// true</span></span><br><span class="line">&#123;&#125; == &#123;&#125; <span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> == [] <span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> == [<span class="number">1</span>] <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">-0</span> === <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">"4"</span> === <span class="number">4</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">null</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><p><code>in</code></p><p>判断对象是否能够访问到该属性</p></li><li><p><code>instanceof</code></p><p>判断一个对象是否是另一个对象的实例</p></li></ul><h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><blockquote><p><code>！</code> 非、<code>&amp;&amp;</code> 与、<code>||</code> 或</p></blockquote><ul><li><code>!</code> 对 Boolean 值取反</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line">alert(!flag) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">alert(!<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">alert(![]) <span class="comment">// false</span></span><br><span class="line">alert(!“”) <span class="comment">// true</span></span><br><span class="line">alert(!![]) <span class="comment">// true</span></span><br><span class="line">alert(!!<span class="number">1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><code>&amp;&amp;</code> 如果第一个值转换成boolean值之后为true， 则输出第二个值；如果第一个值转换成boolean值之后为false，则输出第一个值，且第二个值不在执行。（取第一个为false的值，如果都为true ，则输出最后一个值。）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="literal">true</span> &amp;&amp; <span class="number">3</span> <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">1</span> &amp;&amp; <span class="number">3</span> <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> result = [] &amp;&amp; <span class="string">""</span> <span class="comment">// ""</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="literal">false</span> &amp;&amp; <span class="number">3</span> <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">""</span> &amp;&amp; <span class="number">3</span> <span class="comment">// ""</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="literal">null</span> &amp;&amp; <span class="literal">true</span> <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">""</span> &amp;&amp; num++ <span class="comment">// ""   num = 0</span></span><br></pre></td></tr></table></figure><p><code>&amp;&amp;</code> 使用場景</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn &amp;&amp; fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不传参数不会报错</span></span><br><span class="line">animate()</span><br></pre></td></tr></table></figure><ul><li><code>||</code> 如果第一个值转换成boolean值之后为true， 则输出第一个值，且第二个值不在执行；如果第一个值转换成boolean值之后为false，则输出第二个值，以此类推，（取第一个为true的值，如果都为false ，则输出最后一个值。）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="literal">true</span> || <span class="number">3</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">1</span> || <span class="number">3</span> <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> result = [] || <span class="string">""</span> <span class="comment">// []</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="literal">false</span> || <span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">""</span> || <span class="number">3</span> <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> result = numm || <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="number">3</span> || num++ <span class="comment">// 3  num=0</span></span><br></pre></td></tr></table></figure><p><code>||</code> 使用场景</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.兼容性问题：</span></span><br><span class="line"><span class="keyword">var</span> scrollTop = <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 函数的参数默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    n = n || <span class="number">10</span> <span class="comment">// 给形参 n 设置默认值</span></span><br><span class="line">    <span class="built_in">console</span>.log(n + <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line">sum()</span><br></pre></td></tr></table></figure><h2 id="操作符的优先级"><a href="#操作符的优先级" class="headerlink" title="操作符的优先级"></a>操作符的优先级</h2><p>从高到低如下：</p><ul><li><p>() 优先级最高</p></li><li><p>一元运算符 ++  –   !</p></li><li><p>算数运算符 先 * / % 后 + -</p></li><li><p>关系运算符 &gt;  &gt;=  &lt;  &lt;=</p></li><li><p>相等运算符 ==  !=  ===  !==</p></li><li><p>逻辑运算符  先 &amp;&amp;  后 ||</p></li><li><p>赋值运算符 =</p></li></ul><h1 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h1><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><ul><li>单独的if语句</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">if</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 只有当条件为 true 时,执行代码</span></span><br><span class="line">&#125; <span class="comment">// else部分没有执行语句则 省略</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'可以访问该网站'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>if..else</code> 语句</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">if</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 当条件为 true 时执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当条件不为 true 时执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'可以玩吃鸡'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'不可以玩吃鸡'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>if..else if ..else</code> 语句</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 当条件1为  true 时执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// 当条件2 为true 时执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 当条件1和 条件2 都不为true 时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">条件 ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span></span><br><span class="line"><span class="number">1.</span> 如果 <span class="string">`条件`</span> 的值为<span class="literal">true</span>，会返回表达式<span class="number">1</span>的值</span><br><span class="line"><span class="number">2.</span> 如果<span class="string">`条件`</span>的值为<span class="literal">false</span>，会返回表达式<span class="number">2</span>的值</span><br><span class="line"><span class="comment">// 求两个数的最大值</span></span><br><span class="line"><span class="keyword">var</span> max = n1 &gt; n2 ? n1 : n2</span><br></pre></td></tr></table></figure><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><blockquote><p>if..else适用于范围的判断，switch..case适用于具体的值的判断</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">switch</span> (变量) &#123;</span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  …</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    默认语句</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意 :<br>break可以省略，如果省略，代码会继续执行下一个case<br>switch 语句在比较值时使用的是 <strong>全等</strong> 操作符, 因此不会发生类型转换（例如，字符串’10’ 不等于数值 10）</p></blockquote><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p><img src="while.png" alt></p><p>基本语法 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当循环条件为true时，执行循环体，</span></span><br><span class="line"><span class="comment">// 当循环条件为false时，结束循环。</span></span><br><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">  <span class="comment">// 循环体：需要循环执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算1-100之间所有数的和  (讲)</span></span><br><span class="line"><span class="comment">// 初始化变量</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">100</span>)&#123; <span class="comment">// 判断条件</span></span><br><span class="line">  sum += i <span class="comment">// 循环体</span></span><br><span class="line">  i++ <span class="comment">// 自增，修改循环条件（不能省略）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure><h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do..while循环"></a>do..while循环</h2><blockquote><p>do..while循环和while循环非常像，二者经常可以相互替代，但是do..while的特点是不管条件成不成立，都会执行一次。</p></blockquote><p><img src="dowhile.png" alt></p><p>基础语法 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span>(条件)</span><br></pre></td></tr></table></figure><p>代码示例 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化变量</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  sum += i <span class="comment">// 循环体</span></span><br><span class="line">  i++ <span class="comment">// 自增</span></span><br><span class="line">&#125;<span class="keyword">while</span>(i &lt;= <span class="number">100</span>) <span class="comment">// 循环条件</span></span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p><img src="for.png" alt></p><p>for 循环语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. for循环使用分号分隔</span></span><br><span class="line"><span class="comment">// 2. for循环有2个分号，两个分号不能少</span></span><br><span class="line"><span class="keyword">for</span> (初始化语句;判断语句;自增语句) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行顺序：1243  —-  243   —–243(直到循环条件变成false)</p><ol><li>初始化语句</li><li>判断语句</li><li>自增或者自减</li><li>循环体</li></ol><p>for 循环代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印1-5之间所有数</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">1</span>; i&lt;=<span class="number">5</span>; i++ ) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 6 即便循环已经结束了，我们依然可以访问 i 的值</span></span><br></pre></td></tr></table></figure><p>思考1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 求1-100之间所有数的和、平均值</span></span><br><span class="line"><span class="comment">// 2 求1-100之间所有数的乘积</span></span><br><span class="line"><span class="comment">// 3 计算1-100之间能3整除的数的和</span></span><br></pre></td></tr></table></figure><p>思考2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 计算1-100之间不能被7整除的数的和</span></span><br><span class="line"><span class="comment">// 2 求1-100之间所有偶数的和</span></span><br><span class="line"><span class="comment">// 3 同时求1-100之间所有偶数和奇数的和</span></span><br></pre></td></tr></table></figure><p>思考3（双重for循环）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1  网页打印5*5方形★阵  document.write()</span></span><br><span class="line"><span class="comment">// 2  网页打印直角三角形</span></span><br><span class="line"><span class="comment">// 3  网页打印9*9乘法表</span></span><br></pre></td></tr></table></figure><h2 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for ..in 循环"></a>for ..in 循环</h2><p>详见遍历对象</p><h2 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h2><blockquote><p><strong>break</strong>:    结束/中止循环（可以用在switch语句和循环语句中）</p><p>立即跳出当前整个循环，即循环结束，开始执行循环后面的内容（直接跳传出大括号）</p><p><strong>continue</strong>:   结束本次循环，进行下一次循环 （只能用在循环语句中）</p><p>立即跳出当前循环，继续下一次循环（跳到i++的地方）</p><p>在一个循环里，continue 和 break 后面不能在写任何语句，因为永远无法执行到</p></blockquote><p>思考1 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果是什么？ 1 2 3 4 6</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结 :"></a>总结 :</h2><ol><li>循环有很多种，但是以后用得最多的是for循环</li><li>当不明确循环次数的时候，可以使用while循环</li><li>当无论如何都要执行一次代码的时候，可以使用do..while循环</li><li>循环可以相互替代</li></ol><h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h1><ul><li>将多个元素，按一定顺序排列放到一个集合中 ， 那么这个集合我们就称之为数组</li><li>可以存放任意类型的数据（一般一个数组只存放一种类型）</li><li>特点 :  用逗号隔开，有顺序，有长度，数组长度可以动态调整</li><li>用途 : 存储大量的数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为什么要有数组?</span></span><br><span class="line"><span class="comment">// 1. 我们知道,一个变量能够存储一个值, 当我们想要存储多个值的时候, 就可以使用数组。比如存储一个班级里面所有学生的名;</span></span><br><span class="line"><span class="comment">// 2. 使用数组可以对多个相同类型的值统一的管理,存储起来方便,操作的时候,也会很方便</span></span><br></pre></td></tr></table></figure><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><ol><li><p>通过 <strong>构造函数</strong> 创建数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>() <span class="comment">// 创建了一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>) <span class="comment">// 创建了一个数组，长度为4,里面全是空值</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"4"</span>) <span class="comment">// 创建了一个数组，长度为1,内容为字符串 "4"</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// 创建了一个数组，里面存放了2个数字</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <strong>数组字面量</strong> 创建数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [] <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>] <span class="comment">// 创建了一个数组，长度为1,内容为数字 4</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// 创建一个包含2个数值的数组，多个数组项以逗号隔开</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="string">"2"</span>,<span class="string">"b"</span>] <span class="comment">// 创建一个包含两个字符串的数组</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="数组的长度与下标"><a href="#数组的长度与下标" class="headerlink" title="数组的长度与下标"></a>数组的长度与下标</h2><ul><li><p>数组的长度 : 跟字符串一样,数组有一个length 属性,, 指数组中存放的元素的个数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [] <span class="comment">// 空数组 长度为 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">arr.length <span class="comment">// 长度就是3</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span> <span class="comment">// 设置length属性改变数组中元素的个数</span></span><br></pre></td></tr></table></figure></li><li><p>数组的下标（又称索引） : 因为数组有序的，有序的就应该有自己的序号，而这个序号就是每个元素对应的下标，<strong>下标从0 开始 , 到 arr.length-1 结束</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组取值，如果下标不存在，则返回 undefined</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"zs"</span>, <span class="string">"ls"</span>, <span class="string">"ww"</span>]</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// zs</span></span><br><span class="line">arr[<span class="number">2</span>] <span class="comment">// ww</span></span><br><span class="line">arr[<span class="number">5</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的赋值</span></span><br><span class="line"><span class="comment">// 格式：数组名[下标] = 值</span></span><br><span class="line"><span class="comment">// 如果下标有对应的值，会把原来的值覆盖，如果下标不存在，会给数组新增一个元素。</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">"yellow"</span> <span class="comment">// 把red替换成了yellow</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">"pink"</span>   <span class="comment">// 给数组新增加了一个pink的值</span></span><br><span class="line"><span class="comment">// 如果下标有跨度,中间全是empty 不合法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组末尾添加新的元素</span></span><br><span class="line">arr[arr.length] = 值</span><br><span class="line">arr.push(值)</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><blockquote><p>遍历 : 对数组的每一个元素都访问一次就叫遍历</p></blockquote><p>数组遍历的基本语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="comment">// 数组遍历的固定结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组中的数从小到大排列</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>]</span><br><span class="line"><span class="comment">// var arr = [1,2,3,4,5,6,7,8]</span></span><br><span class="line"><span class="keyword">var</span> numi = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> numj = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length <span class="number">-1</span>; j++) &#123;</span><br><span class="line">    numj += <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span> -j; i++) &#123;</span><br><span class="line">        <span class="comment">// document.write("(" + arr[i] + "," + arr[i + 1] + ")")</span></span><br><span class="line">        numi += <span class="number">1</span></span><br><span class="line">        <span class="comment">// 两两比较，如果前面的大于后面的，交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">var</span> temp</span><br><span class="line">            temp = arr[i]</span><br><span class="line">            arr[i] = arr[i + <span class="number">1</span>]</span><br><span class="line">            arr[i + <span class="number">1</span>] = temp</span><br><span class="line">            <span class="comment">// document.write("交换了")</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// document.write("，arr=（" + arr + "）")</span></span><br><span class="line">    <span class="comment">// document.write("&lt;br&gt;")</span></span><br><span class="line">    <span class="comment">// 如果一趟下来，一次交换都没有做，说明就已经排好序，就不需要继续比</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(arr)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(numi)</span><br><span class="line"><span class="built_in">console</span>.log(numj)</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote><p>把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数</p><p>函数的作用就是封装一段代码，只需要声明一次，就可以被多次调用</p><p>提高代码的复用率，提高可维护性</p></blockquote><p>函数三要素包括：<strong>函数名、参数、返回值</strong></p><h2 id="函数的声明与调用"><a href="#函数的声明与调用" class="headerlink" title="函数的声明与调用"></a>函数的声明与调用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名 (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">函数名()</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>函数声明的时候，函数体并不会执行，函数体只有在调用的时候才会执行</li><li>可多次调用</li></ol><p>练习：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 封装一个打招呼的函数</span></span><br><span class="line"><span class="comment">// 2. 封装一个函数，计算两个数的和</span></span><br><span class="line"><span class="comment">// 3. 封装一个函数，计算1-100之间所有数的和</span></span><br></pre></td></tr></table></figure><h2 id="函数的参数-arguments"><a href="#函数的参数-arguments" class="headerlink" title="函数的参数(arguments)"></a>函数的参数(arguments)</h2><ul><li><strong>形参 ( 形式参数 )</strong> : 在函数声明时, 设置的参数。作用是占位置 。</li><li><strong>实参 ( 实际参数 )</strong> : 在函数调用时传入的参数。 作用 : 函数调用时，会把实参的值赋值给形参，这样形参就有了值，在函数体里，可以直接使用形参!</li></ul><p><strong>语法 :</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数的函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>, 形参<span class="number">2</span>, 形参...</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参数的函数调用</span></span><br><span class="line">函数名(实参<span class="number">1</span>, 实参<span class="number">2</span>, 实参<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在声明函数的时候，碰到不确定的值的时候，就可以定义成形参</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>如果实参的个数大于形参的个数，多余的实参会被 保存到函数的arguments对象里，arguments对象里保存了所有的实参，arguments是一个伪数组（可以像数组一样使用）</li><li>如果实参的个数小于形参的个数，不够的参数会用 undefined 来补充</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实参个数大于形参个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// return a + b // 3</span></span><br><span class="line">    <span class="comment">// 任意多个数相加, 并没有调用形参，即可以省略不写</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">arguments</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = getSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实参个数小于形参个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum1</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(d) <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c + d</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result1 = getSum1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result1) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><blockquote><p>当函数执行完的时候，我们期望函数给我一些反馈（比如计算的结果），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值</p></blockquote><p>返回值语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个带返回值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名 (<span class="params">形参<span class="number">1</span>, 形参<span class="number">2</span>, 形参...</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">  <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过变量来接收这个返回值</span></span><br><span class="line"><span class="keyword">var</span> 变量 = 函数名(实参<span class="number">1</span>, 实参<span class="number">2</span>, 实参<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>函数返回值注意事项：</p><ul><li><strong>return 语句代表一个函数的结束，后面不能再有语句（语句不会执行）</strong></li><li>函数可以没有返回值，函数如果没有return，那么返回结果是 <strong>undefined</strong></li><li>函数的参数可以有多个，但是返回值只能有 <strong>1</strong> 个</li><li><code>return</code>  在函数包含判断语句时，可以用来直接停掉一个函数的执行</li></ul><p><strong>练习：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 求两个数的最大值,并且返回。</span></span><br><span class="line"><span class="comment">// 2. 求三个数的最大值,并且返回。</span></span><br><span class="line"><span class="comment">// 3. 求一个数组的最大值和最小值，并且返回。</span></span><br></pre></td></tr></table></figure><h2 id="函数内部调用函数"><a href="#函数内部调用函数" class="headerlink" title="函数内部调用函数"></a>函数内部调用函数</h2><blockquote><p>在函数内部是可以继续调用别的函数的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJc</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum *= i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = getJc(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求阶乘和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJcSum</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        sum1 += getJc(j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result1 = getJcSum(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result1)</span><br></pre></td></tr></table></figure><h2 id="函数是一种数据类型-function"><a href="#函数是一种数据类型-function" class="headerlink" title="函数是一种数据类型(function)"></a>函数是一种数据类型(function)</h2><h3 id="函数可以作为参数"><a href="#函数可以作为参数" class="headerlink" title="函数可以作为参数"></a>函数可以作为参数</h3><blockquote><p>通常，我们把作为参数传递的函数叫做回调函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">fn1(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"哈哈"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="函数可以作为返回值"><a href="#函数可以作为返回值" class="headerlink" title="函数可以作为返回值"></a>函数可以作为返回值</h3><blockquote><p>在js高级中，闭包会使用到</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"呵呵"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1()() <span class="comment">// 呵呵</span></span><br></pre></td></tr></table></figure><h2 id="匿名函数与自执行函数"><a href="#匿名函数与自执行函数" class="headerlink" title="匿名函数与自执行函数"></a>匿名函数与自执行函数</h2><h3 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h3><p>函数可以自执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我可以自己执行哦"</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><blockquote><p>匿名函数：没有名字的函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名自调用函数 ,用完一次就没了</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"哈哈"</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>匿名函数如何使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 将匿名函数赋值给一个变量，这样就可以通过变量进行调用</span><br><span class="line">2. 自执行（匿名函数自执行）</span><br></pre></td></tr></table></figure><p>匿名函数自执行的作用：防止全局变量污染。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote><p>作用域：变量起作用的区域</p></blockquote><p><strong>全局作用域</strong> ：在script标签内，<strong>函数外</strong>的区域就是全局作用域，在全局作用内声明的变量叫做<strong>全局变量</strong> 。全局变量可以在任意地方访问。（if/while/for 语句中声明的变量也是全局变量）</p><p><strong>函数作用域</strong> ：在函数内的区域叫做函数作用域，在函数作用域内声明的变量叫做<strong>局部变量</strong> ，局部变量只有在当前函数内才能访问到。</p><blockquote><p>隐式全局变量：没有使用var定义的变量也是全局变量，叫做隐式全局变量。(不要使用)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">11</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">22</span></span><br><span class="line">  num2 = <span class="number">33</span></span><br><span class="line">  num = <span class="number">33</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(num)</span><br><span class="line"><span class="comment">// console.log(num1)</span></span><br><span class="line"><span class="built_in">console</span>.log(num2)</span><br></pre></td></tr></table></figure><p>变量的查找规则：</p><ul><li><p>函数内部可以使用函数外部的变量</p></li><li><p>有局部变量就用局部变量，没有局部变量就用全局变量。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">20</span></span><br><span class="line">    num = <span class="number">30</span>  <span class="comment">// num 在局部声明过，只能修改局部的num值</span></span><br><span class="line">    num1 = <span class="number">20</span> <span class="comment">// 修改全局的 num1 值</span></span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">40</span></span><br><span class="line">    num3 = <span class="number">50</span> <span class="comment">// 隐式全局</span></span><br><span class="line">    <span class="built_in">console</span>.log(num)  <span class="comment">// 30</span></span><br><span class="line">    <span class="built_in">console</span>.log(num1)  <span class="comment">// 20</span></span><br><span class="line">    <span class="built_in">console</span>.log(num2)  <span class="comment">// 40</span></span><br><span class="line">    <span class="built_in">console</span>.log(num3)  <span class="comment">// 50</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num1) <span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 如果 text 函数没执行过，则num1值为 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num3) <span class="comment">// 50</span></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>js执行代码分为两个过程：</p><ul><li>预解析过程（var 声明与函数声明提升）（提升到当前作用域的最顶端）</li><li>代码一行一行执行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预解析过程</span></span><br><span class="line"><span class="comment">// 1. var声明的变量：只提升声明,不会提升赋值</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>; <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;..&#125;</span><br><span class="line"><span class="comment">// 2. 函数声明：整体提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;..&#125;</span><br><span class="line"><span class="comment">// 先提升var声明的变量，后提升函数声明</span></span><br><span class="line"><span class="comment">// 3. 如果函数声明同名，后者会覆盖前者</span></span><br><span class="line"><span class="comment">// 4. 如果 var声明 和 函数声明 同名,函数声明会把var声明覆盖</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数预解析</span></span><br><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">45</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n) <span class="comment">// undefined</span></span><br><span class="line">    n = <span class="number">20</span></span><br><span class="line">    <span class="built_in">console</span>.log(n) <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">    <span class="built_in">console</span>.log(n) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line">fn5()</span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">// 45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 函数体</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">23</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 23</span></span><br><span class="line"><span class="comment">// b() // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 函数体</span></span><br><span class="line">c() <span class="comment">// 嘿嘿</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    comsole.log(<span class="string">"哈哈"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"嘿嘿"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.</span></span><br><span class="line"><span class="built_in">console</span>.log(fn1) <span class="comment">// 函数体</span></span><br><span class="line">fn1()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"哈哈"</span>) <span class="comment">// 哈哈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn2) <span class="comment">// undefined</span></span><br><span class="line">fn2() <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"嘿嘿"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于函数表达式，函数的调用必须在表达式声明之后</span></span><br><span class="line">fn2() <span class="comment">// 嘿嘿</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.</span></span><br><span class="line"><span class="comment">// 只有用 var 声明的变量才会预解析</span></span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">// 报错</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.</span></span><br><span class="line"><span class="built_in">console</span>.log(e)</span><br><span class="line"><span class="built_in">console</span>.log(f) <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> e = f = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(f) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h2 id="递归函数（了解）"><a href="#递归函数（了解）" class="headerlink" title="递归函数（了解）"></a>递归函数（了解）</h2><blockquote><p>递归函数：自己直接或者间接调用自己的函数</p><p>注意 : 递归函数一定要留有出口，不然就是死循环了</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1.</span> 求<span class="number">1</span><span class="number">-100</span>所有数的和</span><br><span class="line"> <span class="number">2.</span> 斐波那契数列，有个人想知道，一年之内一对兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关在里面。已知一对兔子每个月可以生一对小兔子，而一对兔子从出生后第<span class="number">3</span>个月起每月生一对小兔子。假如一年内没有发生死亡现象，那么，一对兔子一年内（<span class="number">12</span>个月）能繁殖成多少对？</span><br><span class="line"><span class="comment">//兔子的规律为数列，1，1，2，3，5，8，13，21 ,34 , 55, 89, 144</span></span><br><span class="line"><span class="comment">// 求斐波那契数列 Fibonacci 中第n个数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(n - <span class="number">1</span>) + fn(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p><img src="%E9%80%92%E5%BD%92%E5%85%94%E5%AD%90.png" alt></p><h2 id="函数的断点调试"><a href="#函数的断点调试" class="headerlink" title="函数的断点调试"></a>函数的断点调试</h2><ol><li>跳到下个断点, 如果后面没有断点了,那么代码直接执行完</li><li>单步调试 : 下一步  没有断点的话,函数就直接跳过</li><li>单步调试 : 进入函数</li><li>单步调试 : 跳出函数</li><li>单步调试 : 下一步  不管有没有断点,都会一步一步的走,纯碎的下一步</li><li>让所有的断点失效</li><li>自动根据错误断点</li></ol><p><img src="%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%E4%BB%8B%E7%BB%8D.png" alt></p><p><img src="watch%E7%9B%91%E5%90%AC.png" alt></p><p><img src="%E8%B0%83%E7%94%A8%E6%A0%88.png" alt></p><h2 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h2><p>如果多个函数的函数名相同，但是参数或返回值不同，这些函数是不同的函数</p><p>参数不同指 1. 参数的个数不同2. 参数的数据类型不同</p><p>js中不允许函数的重载，即在js中，只要函数名一样，就是同一个函数，如果两个函数名相同，后边的会覆盖前边的</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ul><li><p><strong>对象</strong> : 是一组无序的键（key）值（value）对的集合，有对应的属性和方法</p></li><li><p><strong>特点 :</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 声明的变量 = &#123;&#125;</span><br><span class="line"><span class="number">2.</span> 键值对出现</span><br><span class="line"><span class="number">3.</span> 逗号隔开</span><br><span class="line"><span class="number">4.</span> 属性可以是任意类型</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组多个元素之间使用,隔开</span></span><br><span class="line"><span class="comment">// 对象中多个键值对之间也用逗号隔开,键值对的格式： 键:值</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name:<span class="string">"张三"</span>,</span><br><span class="line">  age:<span class="number">18</span>,</span><br><span class="line">  sex:<span class="string">"男"</span>,</span><br><span class="line">  hobby:<span class="string">"上网"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this-的基本概念"><a href="#this-的基本概念" class="headerlink" title="this 的基本概念"></a>this 的基本概念</h2><h2 id="创建对象-1-2种方式-单创"><a href="#创建对象-1-2种方式-单创" class="headerlink" title="创建对象-1 (2种方式 单创)"></a>创建对象-1 (2种方式 单创)</h2><blockquote><p>单纯的创建一个对象</p></blockquote><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><blockquote><p>字面量 : 直接量，通过看数值，直接看出来类型的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">    name : <span class="string">'zs'</span>,</span><br><span class="line">    age:<span class="number">18</span>,</span><br><span class="line">    sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过Object构造函数创建"><a href="#通过Object构造函数创建" class="headerlink" title="通过Object构造函数创建"></a>通过Object构造函数创建</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p =  <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 创建一个空的对象</span></span><br><span class="line"><span class="keyword">var</span> p =  <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span> :<span class="string">'xx'</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>设置对象的属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置对象的属性 语法  对象名.属性 = 值</span></span><br><span class="line"><span class="comment">// 如果对象有这个属性，修改这个属性</span></span><br><span class="line"><span class="comment">// 如果对象没有这个属性，添加这个属性</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">obj.name = <span class="string">'zs'</span></span><br><span class="line">obj.age = <span class="number">18</span></span><br><span class="line">obj.gender = <span class="string">'男'</span></span><br><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line">obj.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'大家好,我是'</span> + obj.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建对象-2-2种方式-批量"><a href="#创建对象-2-2种方式-批量" class="headerlink" title="创建对象-2 (2种方式 批量)"></a>创建对象-2 (2种方式 批量)</h2><blockquote><p>批量创建对象</p><p>在实际开发中，经常需要创建多个相同类型的对象，比如游戏中的怪物，班级的学生等。</p></blockquote><h3 id="使用工厂函数创建对象"><a href="#使用工厂函数创建对象" class="headerlink" title="使用工厂函数创建对象"></a>使用工厂函数创建对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数，用于创建学生对象</span></span><br><span class="line"><span class="comment">// 工厂函数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建空对象</span></span><br><span class="line">    <span class="keyword">var</span> stu = &#123;&#125;</span><br><span class="line">    <span class="comment">// 设置对象属性</span></span><br><span class="line">    stu.name = name</span><br><span class="line">    stu.age = age</span><br><span class="line">    stu.sex = sex</span><br><span class="line">    stu.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"大家好,我是"</span> + <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> stu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu1 = createStudent(<span class="string">"zs"</span>, <span class="number">18</span>, <span class="string">"男"</span>)</span><br><span class="line">stu1.sayHi()</span><br></pre></td></tr></table></figure><p>优点：可以同时创建多个对象</p><p>缺点：创建出来的没有具体的类型，都是object类型的</p><h3 id="自定义构造函数-triangular-flag-on-post"><a href="#自定义构造函数-triangular-flag-on-post" class="headerlink" title="自定义构造函数:triangular_flag_on_post:"></a>自定义构造函数:triangular_flag_on_post:</h3><blockquote><p>工厂函数的缺点 就是无法确定对象的具体类型</p></blockquote><blockquote><p>构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数内部的this指向的是新创建的那个对象</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> Teacher(<span class="string">"zs"</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(tea)</span><br></pre></td></tr></table></figure><ol><li>构造函数首字母要大写（推荐做法）</li><li>构造函数要和 new 一起使用才有意义</li><li>构造函数的作用是用于实例化一个对象，即给对象添加属性和方法</li></ol><p><strong>new 在执行时会做四件事情</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">new</span> 会创建一个新的空对象，类型是Teacher</span><br><span class="line"><span class="number">2.</span> <span class="keyword">new</span> 会让 <span class="keyword">this</span> 指向这个新的对象</span><br><span class="line"><span class="number">3.</span> 执行构造函数  目的：给这个新对象加属性和方法</span><br><span class="line"><span class="number">4.</span> <span class="keyword">new</span> 会返回这个新对象</span><br><span class="line"></span><br><span class="line">构造函数的作用(实例化对象)：给创建出来的对象增加属性和方法</span><br></pre></td></tr></table></figure><h2 id="查看一个对象的类型"><a href="#查看一个对象的类型" class="headerlink" title="查看一个对象的类型"></a>查看一个对象的类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> 只能查看基本数据类型的类型</span><br><span class="line"><span class="keyword">instanceof</span> 判断对象的具体类型</span><br><span class="line"><span class="keyword">constructor</span>.name 获取对象的具体类型</span><br></pre></td></tr></table></figure><p>关于typeof</p><ul><li><p>用于查看基本的数据类型， number string boolean undefined</p></li><li><p>null 比较特殊，结果是 object</p></li><li><p>如果查看复杂数据类型，返回的都是 object 类型。</p></li><li><p>函数的结果是 function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// typeof 判断</span></span><br><span class="line"><span class="comment">// 简单类型</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">12</span> <span class="comment">// number</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="string">'abc'</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="literal">undefined</span> <span class="comment">// underfined</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="comment">// 复杂类型 (引用类型)</span></span><br><span class="line">va fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">var</span> arr = [] <span class="comment">// object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125; <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2 : instanceof 判断</span></span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log( arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( fn <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3 : constructor.name</span></span><br><span class="line"><span class="comment">// 原型的构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor.name) <span class="comment">// Array</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor.name) <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.constructor.name) <span class="comment">// Function</span></span><br><span class="line"><span class="comment">// 自定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> Teacher(<span class="string">"zs"</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(tea.constructor.name) <span class="comment">// Teacher</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="操作对象的属性"><a href="#操作对象的属性" class="headerlink" title="操作对象的属性"></a>操作对象的属性</h2><p><code>.</code> 语法    —– 对象名.属性名 ( 看似变量，不是字符串 )</p><p><code>[]</code> 语法   —-  对象名 [ 属性字符串 ]  (字符串) ，也叫关联数组的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象属性的语法：</span></span><br><span class="line"><span class="comment">// 对象.属性：对象的属性</span></span><br><span class="line">    <span class="comment">// 1. 如果有这个属性，直接返回属性值</span></span><br><span class="line">    <span class="comment">// 2. 如果没有这个属性，返回undefined</span></span><br><span class="line"><span class="comment">// 3. 如果是方法，可以调用</span></span><br><span class="line"><span class="comment">// 设置对象的属性的语法</span></span><br><span class="line">    <span class="comment">// 对象.属性 = 值</span></span><br><span class="line">    <span class="comment">// 1. 如果对象有这个属性，修改这个属性</span></span><br><span class="line">    <span class="comment">// 2. 如果对象没有这个属性，添加这个属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'zs'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log (obj.name) <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">console</span>.log (obj[name]) <span class="comment">// X</span></span><br><span class="line"><span class="built_in">console</span>.log (obj.<span class="string">'name'</span>) <span class="comment">// X</span></span><br><span class="line"></span><br><span class="line">obj.age = <span class="number">18</span> <span class="comment">// 增加 age 属性为 18</span></span><br><span class="line">obj.name = <span class="string">'ls'</span> <span class="comment">// 修改name属性为 ls</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> key = <span class="string">'name'</span></span><br><span class="line"><span class="built_in">console</span>.log (obj.key) <span class="comment">// X</span></span><br><span class="line"><span class="built_in">console</span>.log (obj[key]) <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">console</span>.log (obj[<span class="string">'name'</span>]) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>二者的区别：当属性名是一个字符串存储在变量中的时候，只能使用关联数组的方式。</p><p>应用场景 : 遍历对象</p><p><strong>删除对象属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除对象属性</span></span><br><span class="line"><span class="keyword">delete</span> obj.name <span class="comment">// 删除obj的name属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> obj.name) <span class="comment">// 如果删除成功，返回true，删除失败，返回false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var 声明的全局变量不能被删除</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">12</span></span><br><span class="line">str = <span class="string">"hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> <span class="built_in">window</span>.num) <span class="comment">// false 删除失败</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> <span class="built_in">window</span>.str) <span class="comment">// true 删除成功</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// 报错 str is not undefined</span></span><br></pre></td></tr></table></figure><h2 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h2><p> 通过 <code>for..in</code> 循环语法可以遍历一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[key])</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">"=="</span> + obj[key])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个属性是否是对象的一个属性</span></span><br><span class="line"><span class="comment">// console.log("name" in obj) 返回布尔值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"name"</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'是'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象里的所有属性</span></span><br><span class="line"><span class="comment">// 结构: Object.keys(对象)  返回一个包含所有属性的数组</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br></pre></td></tr></table></figure><h2 id="原始类型与引用类型"><a href="#原始类型与引用类型" class="headerlink" title="原始类型与引用类型"></a>原始类型与引用类型</h2><ul><li>原始类型（简单数据类型/值类型）</li></ul><blockquote><p><code>Number</code> <code>String</code> <code>Boolean</code> <code>Undefined</code> <code>Null</code></p></blockquote><ul><li>引用类型（复杂数据类型）</li></ul><blockquote><p><code>Object</code> <code>Array</code> <code>function</code> <code>自定义的对象</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> num2 = num1</span><br><span class="line">num2 = <span class="number">456</span></span><br><span class="line"><span class="built_in">console</span>.log(num1) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1 <span class="comment">// obj1和obj2，均指向了同一个对象</span></span><br><span class="line">obj2.a = <span class="number">3</span> <span class="comment">// 对obj2的任何操作</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">// 3  同时也会影响到 obj1</span></span><br></pre></td></tr></table></figure><p>原始数据类型和引用数据类型，主要是根据内存存储方式来区分的</p><ul><li>原始类型储存在栈（Stack）中，存的是<strong>值本身</strong>（值类型），进行赋值的时候，赋值的是值本身</li><li>引用类型储存在堆（Heap）中，并非储存变量真实数值而是<strong>引用</strong>（也叫<strong>地址</strong>），进行赋值的时候，赋值的是地址，而不是数据本身</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="comment">// a -&gt; x</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 相当于</span></span><br><span class="line">  <span class="comment">// var a = 10</span></span><br><span class="line">  <span class="comment">// var b = 20</span></span><br><span class="line">  <span class="comment">// 函数的参数 其实就是函数内部的局部变量</span></span><br><span class="line">  a = a + <span class="number">1</span></span><br><span class="line">  b = b + <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 11</span></span><br><span class="line">  <span class="built_in">console</span>.log(b) <span class="comment">// 21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">20</span></span><br><span class="line">fn(x, y)</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(y) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  name:<span class="string">"zs"</span>,</span><br><span class="line">  age:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">person</span>) </span>&#123;</span><br><span class="line">  person.name = <span class="string">'ls'</span></span><br><span class="line">  <span class="built_in">console</span>.log(person.name) <span class="comment">// ls</span></span><br><span class="line">&#125;</span><br><span class="line">fn(p)</span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, salary</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name</span><br><span class="line">   <span class="keyword">this</span>.age = age</span><br><span class="line">   <span class="keyword">this</span>.salary = salary</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params">person</span>) </span>&#123;</span><br><span class="line">   person.name = <span class="string">"ls"</span></span><br><span class="line">   <span class="built_in">console</span>.log(person.name) <span class="comment">// ls</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"zs"</span>, <span class="number">18</span>, <span class="number">1000</span>) <span class="comment">// 创建一个新对象</span></span><br><span class="line"> <span class="built_in">console</span>.log(p.name) <span class="comment">// zs</span></span><br><span class="line"> f1(p)</span><br><span class="line"> <span class="built_in">console</span>.log(p.name) <span class="comment">// ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, salary</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name</span><br><span class="line">   <span class="keyword">this</span>.age = age</span><br><span class="line">   <span class="keyword">this</span>.salary = salary</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">   person.name = <span class="string">"ls"</span></span><br><span class="line">   <span class="comment">// person 指向新的对象</span></span><br><span class="line">   person = &#123;</span><br><span class="line">     name : <span class="string">'ww'</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(person.name) <span class="comment">// ww</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"zs"</span>, <span class="number">18</span>, <span class="number">1000</span>) <span class="comment">// 创建一个新对象</span></span><br><span class="line"> <span class="built_in">console</span>.log(p.name) <span class="comment">// zs</span></span><br><span class="line"> f1(p)</span><br><span class="line"> <span class="built_in">console</span>.log(p.name) <span class="comment">// ls</span></span><br></pre></td></tr></table></figure><h2 id="object-valueOf"><a href="#object-valueOf" class="headerlink" title="object.valueOf()"></a>object.valueOf()</h2><p>返回值为该对象的原始值，如果对象没有原始值，则  <code>valueOf</code> 将返回对象本身</p><table><thead><tr><th><strong>对象</strong></th><th><strong>返回值</strong></th></tr></thead><tbody><tr><td>Array</td><td>返回数组对象本身</td></tr><tr><td>Boolean</td><td>布尔值</td></tr><tr><td>Date</td><td>存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC</td></tr><tr><td>Function</td><td>函数本身</td></tr><tr><td>Number</td><td>数字值</td></tr><tr><td>Object</td><td>对象本身 （这是默认情况）</td></tr><tr><td>String</td><td>字符串值</td></tr><tr><td></td><td>Math 和 Error 对象没有 valueOf 方法</td></tr></tbody></table><h1 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h1><blockquote><p>JS内置对象就是指Javascript自带的一些对象，供开发者使用，这些对象提供了一些常用的的功能。</p><p>常见的内置对象有 Math、String、Array、Date 等</p></blockquote><ul><li>跳转到定义<code>ctrl+左键</code></li><li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">火狐开发者网站MDN</a></li><li><a href="http://www.w3school.com.cn/jsref/" target="_blank" rel="noopener">W3School网站</a></li></ul><h2 id="如何学习一个方法？"><a href="#如何学习一个方法？" class="headerlink" title="如何学习一个方法？"></a>如何学习一个方法？</h2><ol><li>方法的功能</li><li>参数的意义和<strong>类型</strong></li><li>返回值意义和<strong>类型</strong></li><li>demo进行测试</li></ol><h2 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h2><blockquote></blockquote><ul><li><p>属性PI</p><p><code>Math.PI</code></p></li><li><p>最大值/最小值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max()</span><br><span class="line">Math.min()</span><br></pre></td></tr></table></figure></li><li><p>取整</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil() <span class="comment">// 向上取整</span></span><br><span class="line"><span class="built_in">Math</span>.floor() <span class="comment">// 向下取整</span></span><br><span class="line"><span class="built_in">Math</span>.round() <span class="comment">// 四舍五入，如果是.5，则取更大的那个数</span></span><br></pre></td></tr></table></figure></li><li><p>随机数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.random() <span class="comment">// 返回一个[0,1)之间的数，能取到0，取不到1</span></span><br><span class="line"><span class="comment">// [0~N]随机数 parseInt(Math.random * (N+1))</span></span><br><span class="line"><span class="comment">// [4~9] ==&gt; [0~5]+4</span></span><br></pre></td></tr></table></figure></li><li><p>绝对值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs() <span class="comment">// 求绝对值</span></span><br></pre></td></tr></table></figure></li><li><p>次幂和平方</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(num, power) <span class="comment">// 求num的power次方</span></span><br><span class="line"><span class="built_in">Math</span>.sqrt(num) <span class="comment">// 对num开平方</span></span><br></pre></td></tr></table></figure></li><li><p>练习</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">随机生成一个rgb颜色？</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomRGB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> colorA = <span class="built_in">parseInt</span>( <span class="built_in">Math</span>.random() * <span class="number">256</span> )</span><br><span class="line">  <span class="keyword">var</span> colorB = <span class="built_in">parseInt</span>( <span class="built_in">Math</span>.random() * <span class="number">256</span> )</span><br><span class="line">  <span class="keyword">var</span> colorC = <span class="built_in">parseInt</span>( <span class="built_in">Math</span>.random() * <span class="number">256</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'rgb('</span>+ colorA + <span class="string">","</span> + colorB + <span class="string">','</span> + colorC +<span class="string">')'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h2><blockquote><p>Date 对象用来处理日期和时间</p></blockquote><ul><li><p>创建一个日期对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不传参数：创建一个当前时间的对象</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期格式字符串：创建一个指定时间的日期对象</span></span><br><span class="line"><span class="comment">// '-' 在 safari 下不识别，推荐用 /</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2018/12/02'</span>)</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2018/12/02 00:02:05'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日期以逗号分隔：注意月份从0开始</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>) <span class="comment">// 2018/12/02</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">1543680125000</span>)</span><br></pre></td></tr></table></figure></li><li><p>日期格式化(了解)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date.toString() <span class="comment">// 默认的日期格式 ，包括日期和时间</span></span><br><span class="line">date.toLocalString() <span class="comment">// 本地风格的日期格式（兼容性）</span></span><br><span class="line">date.toDateString() <span class="comment">// 只显示日期</span></span><br><span class="line">date.toLocalDateString()</span><br><span class="line">date.toTimeString() <span class="comment">// 只显示时间</span></span><br><span class="line">date.toLocalTimeString()</span><br></pre></td></tr></table></figure></li><li><p>获取日期的指定部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getMilliseconds() <span class="comment">// 获取毫秒值</span></span><br><span class="line">getSeconds() <span class="comment">// 获取秒</span></span><br><span class="line">getMinutes() <span class="comment">// 获取分钟</span></span><br><span class="line">getHours() <span class="comment">// 获取小时</span></span><br><span class="line">getDay() <span class="comment">// 获取星期，0-6    0：星期天</span></span><br><span class="line">getDate() <span class="comment">// 获取日，即当月的第几天</span></span><br><span class="line">getMonth() <span class="comment">// 返回月份，注意月份从0开始</span></span><br><span class="line">getFullYear() <span class="comment">// 返回4位的年份  如 2018</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 思考：</span></span><br><span class="line"><span class="comment">// 封装一个函数，返回当前的时间，格式是：yyyy-MM-dd HH:mm:ss</span></span><br></pre></td></tr></table></figure></li><li><p>时间戳</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = +<span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// 1970年01月01日00时00分00秒起至现在的总毫秒数</span></span><br><span class="line"><span class="comment">// 思考</span></span><br><span class="line"><span class="comment">// 如何统计一段代码的执行时间？</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h2><blockquote><p>数组对象在 javascript 中非常的常用</p></blockquote><ul><li><p>数组转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法：arr.join(separator)</span></span><br><span class="line"><span class="comment">// 作用：将数组的值拼接成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr.join() <span class="comment">// 不传参数，默认用逗号进行拼接，返回拼接好的字符串</span></span><br><span class="line">arr.join(<span class="string">''</span>)</span><br><span class="line">arr.join(<span class="string">'-'</span>) <span class="comment">// 用 - 进行拼接</span></span><br></pre></td></tr></table></figure></li><li><p>数组的增删操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr.push() <span class="comment">// 从后面添加一个或多个元素，逗号隔开，返回新数组的 length</span></span><br><span class="line">arr.pop() <span class="comment">// 从数组的后面删除元素，返回删除的那个元素</span></span><br><span class="line">arr.unshift() <span class="comment">// 从数组的前面的添加元素，返回新数组的 length</span></span><br><span class="line">arr.shift() <span class="comment">// 从数组的最前面删除元素，返回删除的那个元素</span></span><br><span class="line">arr.push(arr1) <span class="comment">// 把 arr1 当成一个整体放到 arr 里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 练习1</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'刘备'</span>]</span><br><span class="line"><span class="comment">// 添加数据后变成：['赵云','马超','刘备','关羽','张飞']</span></span><br><span class="line"><span class="comment">// 删除数据后变成：['关羽','张飞']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 练习2</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'赵云'</span>,<span class="string">'马超'</span>,<span class="string">'刘备'</span>,<span class="string">'关羽'</span>,<span class="string">'张飞'</span>]</span><br><span class="line"><span class="comment">// 把数组的最后一个元素变成数组的第一个元素</span></span><br><span class="line"><span class="comment">// 把数组的第一个元素变成数组的最后一个元素</span></span><br></pre></td></tr></table></figure></li><li><p>数组的翻转与排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr.reverse() <span class="comment">// 翻转数组</span></span><br><span class="line">arr.sort() <span class="comment">// 数组的排序，按照首字符依次比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort 方法可以传递一个函数作为参数，这个参数用来控制数组如何进行排序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数为 true 时，即返回值 &gt; 0 时，交换位置</span></span><br><span class="line">  <span class="comment">// return a - b // 从小到大排序</span></span><br><span class="line">  <span class="keyword">return</span> b - a  <span class="comment">// 从大到小排序</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思考：</span></span><br><span class="line"><span class="comment">// 将[3, 6, 1, 5, 10, 2,11]从小到大排列</span></span><br><span class="line"><span class="comment">// 将字符串数组按照字符长度从小到大排列 a.sort(function (a, b) &#123;return a.length - b.length&#125;)</span></span><br><span class="line"><span class="comment">// 将学生数组按照年龄从小到大排列</span></span><br></pre></td></tr></table></figure></li><li><p>数组的拼接与截取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concat：数组合并，返回一个新数组，原数组不受影响</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.concat(arr2) <span class="comment">// 把 arr 和 arr2 中的所有元素放到 newArr 里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice: 数组切分，复制数组的一部分到一个新数组，并返回这个新数组，原数组不受影响</span></span><br><span class="line"><span class="comment">// slice(begin, end) 包含 begin，不包含 end， begin 和 end 为下标</span></span><br><span class="line"><span class="comment">// slice(begin) 只有一个参数时，为开始参数，截取到末尾</span></span><br><span class="line"><span class="comment">// slice() 没有参数，全部截取</span></span><br><span class="line"><span class="comment">// 可以为负数，会将字符串的长度与对应的负数相加，结果作为参数，-1 表示从后数第一个</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.slice(begin, end)</span><br><span class="line"></span><br><span class="line"><span class="comment">// splice: 删除或者增加数组元素，修改原数组，返回删除的内容（数组形式）</span></span><br><span class="line"><span class="comment">// start: 开始位置  deletedCount: 删除的个数（如果不删除为 0）items: 替换的内容, 可为多个</span></span><br><span class="line">arr.splice(start, deletedCount, [items]) <span class="comment">// items 将作为 arr 的一项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 练习：</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'赵云'</span>,<span class="string">'马超'</span>,<span class="string">'刘备'</span>,<span class="string">'关羽'</span>,<span class="string">'张飞'</span>]</span><br><span class="line"><span class="comment">// 截取['刘备','关羽']</span></span><br><span class="line"><span class="comment">// 在马超后面增加马腾</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'马腾'</span>)</span><br><span class="line"><span class="comment">// 删除关羽</span></span><br></pre></td></tr></table></figure></li><li><p>数组查找元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// indexOf 方法返回数组中某个元素第一次出现的位置，如果找不到，返回 -1</span></span><br><span class="line"><span class="comment">// 可以用来判断元素是否在数组中</span></span><br><span class="line"><span class="comment">// fromIndex 表示从 fromIndex 下标开始查找</span></span><br><span class="line">arr.indexOf(<span class="string">'zs'</span>, [fromIndex])</span><br><span class="line"></span><br><span class="line"><span class="comment">// lastIndexOf() 从后面开始查找数组中元素出现位置,即查找某元素最后一次出现的位置</span></span><br><span class="line"><span class="comment">// 如果找不到，返回 -1</span></span><br><span class="line">arr.lastIndexOf(<span class="string">'zs'</span>, [fromIndex])</span><br></pre></td></tr></table></figure></li><li><p>清空数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. arr.splice(0,arr.length) // 删除数组中所有的元素</span></span><br><span class="line"><span class="comment">// 2．arr.length = 0 // 直接修改数组的长度</span></span><br><span class="line"><span class="comment">// 3．arr = [] // 将数组赋值为一个空数组，推荐</span></span><br></pre></td></tr></table></figure></li><li><p>数组综合练习</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'a'</span>, <span class="string">'x'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'z'</span>, <span class="string">'c'</span>, <span class="string">'x'</span>, <span class="string">'a'</span>, <span class="string">'x'</span>]</span><br><span class="line"><span class="comment">// 1. 找到数组中第一个a出现的位置</span></span><br><span class="line"><span class="comment">// 2. 找到数组中最后一个a出现的位置</span></span><br><span class="line"><span class="comment">// 3. 找到数组中每一个a出现的位置</span></span><br><span class="line"><span class="comment">// 4. 数组去重，返回一个新数组</span></span><br><span class="line"><span class="comment">// 5. 获取数组中每个元素出现的次数</span></span><br></pre></td></tr></table></figure></li></ul><p>!&gt; 补充数组对象方法</p><blockquote><p><strong>forEach()</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;&#125;, thisArg)</span><br><span class="line"><span class="comment">// item 必需。数组中正在处理的当前元素</span></span><br><span class="line"><span class="comment">// index 可选。数组中正在处理的当前元素的索引</span></span><br><span class="line"><span class="comment">// arr 可选。当前数组</span></span><br><span class="line"><span class="comment">// thisArg 可选。当执行回调函数时用作this的值</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'zs'</span>, <span class="string">'ls'</span>, <span class="string">'ww'</span>]</span><br><span class="line">arr.forEach (<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 返回值: undefined</span></span><br><span class="line"><span class="comment">// 不支持 return 操作输出，return 只用于控制循环是否跳出当前循环</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>arr.map()</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// item 必需。数组中正在处理的当前元素</span></span><br><span class="line">  <span class="comment">// index 可选。数组中正在处理的当前元素的索引</span></span><br><span class="line">  <span class="comment">// arr 可选。当前数组</span></span><br><span class="line">  <span class="comment">// 使用 return 操作输出，会循环数组每一项，并返回新的每一项组成的数组</span></span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不修改原数组</span></span><br><span class="line"><span class="comment">// 返回一个新数组，新数组的每一项乘以 2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>arr.filter()</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数同 map</span></span><br><span class="line">  <span class="comment">// 使用 return 操作输出，会循环数组每一项，并返回判断为 true 的每一项组成的数组</span></span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span> &amp;&amp; item &lt; <span class="number">5</span> <span class="comment">// return 后是判断条件</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不修改原数组</span></span><br><span class="line"><span class="comment">// 返回一个新数组，新数组每一项满足 2 &lt; item &lt; 5</span></span><br></pre></td></tr></table></figure><blockquote><p>arr.some()</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数同 map</span></span><br><span class="line">  <span class="comment">// 返回布尔值，只要有一项满足条件就返回 true，否则返回 false</span></span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span> <span class="comment">// return 后是判断条件</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不修改原数组</span></span><br></pre></td></tr></table></figure><blockquote><p>arr.every()</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数同 map</span></span><br><span class="line">  <span class="comment">// 返回布尔值，只有所有项都满足条件才返回 true，否则返回f alse</span></span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span> <span class="comment">// return 后是判断条件</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不修改原数组</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>arr.includes()</strong></p></blockquote><p>判断数组是否含有某值，输出 true 或 false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> new1 = arr.includes(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(new1)</span><br></pre></td></tr></table></figure><p>必须完全匹配才会返回 flase（实用性不如正则）</p><blockquote><p><strong>arr.find()</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.find(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数同 map</span></span><br><span class="line">  <span class="comment">// 使用 return 操作输出，会循环数组每一项，当遍历循环到判断到一个为 true 则跳出循环，输出当前数组元素</span></span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span> <span class="comment">// return 后是判断条件</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不修改原数组</span></span><br><span class="line"><span class="comment">// 返回一个数组元素，如果全不满足返回 undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>arr.findIndex()</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">var</span> newArr = arr.find(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数同 map</span></span><br><span class="line">  <span class="comment">// 使用 return 操作输出，会循环数组每一项，当遍历循环到判断到一个为 true 则跳出循环，输出当前数组元素的下标</span></span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">2</span> <span class="comment">// return 后是判断条件</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不修改原数组</span></span><br><span class="line"><span class="comment">// 返回一个数组元素的下标，如果全不满足返回 -1</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>arr.reduce()</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">var</span> new1 = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, next, index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// pre 第一次为数组第一项，之后为上一操作的结果</span></span><br><span class="line">  <span class="comment">// next 数组的下一项</span></span><br><span class="line">  <span class="comment">// index next项的序列</span></span><br><span class="line">  <span class="comment">// arr 可选。当前数组</span></span><br><span class="line">  <span class="comment">// 使用 return 操作输出</span></span><br><span class="line">  <span class="keyword">return</span> pre + next <span class="comment">// 返回数组每一项的和</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不修改原数组</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扁平化数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]]</span><br><span class="line"><span class="keyword">var</span> new2 = arr2.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, next, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pre.concat(next) <span class="comment">// 前数组拼接后数组 .concat()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象数组叠加计算</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [&#123; <span class="attr">price</span>: <span class="number">1</span>, <span class="attr">count</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">price</span>: <span class="number">2</span>, <span class="attr">count</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">price</span>: <span class="number">3</span>, <span class="attr">count</span>: <span class="number">3</span> &#125;]</span><br><span class="line"><span class="keyword">var</span> new3 = arr3.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pre, next, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pre + next.price * next.count</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当需要操作第一项的时候，利用 reduce(callbreak()&#123;&#125;,往数组第一项前添加一项，如:0)</span></span><br><span class="line">&#125;, <span class="number">0</span>) <span class="comment">// 在原数组第一项添加为 0，不改变原数组</span></span><br></pre></td></tr></table></figure><h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><blockquote><p><strong>简单数据类型是没有方法的</strong>。为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String/Number/Boolean</p></blockquote><p>基本包装类型：把基本类型包装成复杂类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> result = str.indexOf(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发生了三件事情</span></span><br><span class="line"><span class="comment">// 1. 把简单类型转换成复杂类型：var s = new String(str)</span></span><br><span class="line"><span class="comment">// 2. 调用包装类型的 indexOf 方法：var result = s.indexOf('a')</span></span><br><span class="line"><span class="comment">// 3. 销毁刚刚创建的复杂类型</span></span><br></pre></td></tr></table></figure><h3 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h3><blockquote><p>Number 对象是数字的包装类型，数字可以直接使用这些方法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num.toFixed(<span class="number">2</span>) <span class="comment">// 返回保留2位小数的新数的字符串格式</span></span><br><span class="line">num.toString() <span class="comment">// 转换成字符串并返回</span></span><br></pre></td></tr></table></figure><h3 id="Boolean-对象"><a href="#Boolean-对象" class="headerlink" title="Boolean 对象"></a>Boolean 对象</h3><blockquote><p>Boolean 对象是布尔类型的包装类型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toString() <span class="comment">// 转换成字符串并返回</span></span><br></pre></td></tr></table></figure><p><strong>undefined 和 null 没有包装类型，所以调用toString方法会报错</strong></p><h3 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h3><blockquote><p>字符串可以看成是一个字符数组（伪数组）。因此字符串也有长度，也可以进行遍历。String对象很多方法的名字和 Array 的一样。</p><p>操作字符串的方法<strong>不会改变原来的字符串</strong>，需要新字符串去接收</p></blockquote><ul><li><p>查找指定字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str.indexOf(‘‘) <span class="comment">// 获取某个字符串第一次出现的位置，如果没有，返回-1</span></span><br><span class="line">str.lastIndexOf(’’) <span class="comment">// 从后面开始查找第一次出现的位置。如果没有，返回-1</span></span><br><span class="line"></span><br><span class="line">str.search(regexp) <span class="comment">// 查找并输出索引位置,找不到输出-1</span></span><br><span class="line">str.match(regexp) <span class="comment">// 输出匹配到的第一个字符，匹配不到返回 null</span></span><br><span class="line">str.match(regexp/g) <span class="comment">// 全部输出</span></span><br><span class="line"></span><br><span class="line">str.startsWith(str1) <span class="comment">// 判断 str 字符串是否以 str1 字符串开头，若符合返回 true</span></span><br><span class="line"><span class="comment">// 等价于判断 str.indexOf(str1) === 0</span></span><br><span class="line">str.endsWith(str1) <span class="comment">// 判断 str 字符串是否以 str1 字符串结尾，若符合返回 true</span></span><br><span class="line">str.indexOf(str1) === str.length - str1.length</span><br></pre></td></tr></table></figure></li><li><p>去除空白</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.trim() <span class="comment">// 去除字符串两边的空格，内部空格不会去除</span></span><br></pre></td></tr></table></figure></li><li><p>大小写转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.toUpperCase() <span class="comment">// 全部转换成大写字母</span></span><br><span class="line">str.toLowerCase() <span class="comment">// 全部转换成小写字母</span></span><br></pre></td></tr></table></figure></li><li><p>字符串拼接与截取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串拼接 可以用 concat，用法与数组一样，但是字符串拼串我们一般都用 +</span></span><br><span class="line"></span><br><span class="line">str.slice(start, end) <span class="comment">// 从 start 开始，end 结束，并且取不到 end，没有 end 则截取到末尾</span></span><br><span class="line"><span class="comment">// 可以为负数，会将字符串的长度与对应的负数相加，结果作为参数，-1 表示从后数第一个，一次为 -2、-3...</span></span><br><span class="line">str.slice(<span class="number">-3</span>) <span class="comment">// 截取字符串后三位</span></span><br><span class="line"><span class="comment">// str.slice() 与 str.slice(0) 等价 截取全部</span></span><br><span class="line"></span><br><span class="line">str.substring(start, end) <span class="comment">// 以两个参数中较小一个作为起始位置，较大的参数作为结束位置</span></span><br><span class="line"><span class="comment">// 负参数会被直接转换为 0</span></span><br><span class="line"><span class="comment">// str.substring() 与 str.substring(0) 等价 截取全部</span></span><br><span class="line"></span><br><span class="line">str.substr(start, length) <span class="comment">// 从 start 开始，截取 length 个字符，没有 length 则截取到末尾</span></span><br><span class="line"><span class="comment">// 第一个参数为负参数时，会将第一个参数与字符串长度相加后的结果作为第一个参数，</span></span><br><span class="line"><span class="comment">// 第二个参数为负数时，会被转化为 0 ，即截取长度为 0</span></span><br></pre></td></tr></table></figure></li><li><p>字符串切割</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串分割成数组（很常用）</span></span><br><span class="line">str.split()</span><br><span class="line"><span class="comment">// 功能和数组的 join 正好相反</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'zs,ls,ww'</span></span><br><span class="line"><span class="keyword">var</span> arr = str.split(<span class="string">','</span>)</span><br></pre></td></tr></table></figure></li><li><p>字符串替换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.replace(searchValue, replaceValue)</span><br><span class="line"><span class="comment">// 参数：searchValue: 需要替换的值    replaceValue: 用来替换的值  默认只替换第一个</span></span><br><span class="line">str.replace(<span class="regexp">/searchValue/g</span>, replaceValue) <span class="comment">// 全部替换</span></span><br><span class="line">str.replace(<span class="regexp">/ /g</span>, <span class="string">''</span>) <span class="comment">// 将全部空格去掉</span></span><br></pre></td></tr></table></figure></li><li><p>访问</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str[i]</span><br><span class="line">str.charAt(i)</span><br><span class="line"><span class="comment">// i 均为下标</span></span><br></pre></td></tr></table></figure></li><li><p>练习</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 截取字符串’我爱中华人民共和国’，中的’中华’</span><br><span class="line"><span class="number">2.</span> ’abcoefoxyozzopp’查找字符串中所有o出现的位置</span><br><span class="line"><span class="number">3.</span> 把字符串中所有的o替换成!</span><br><span class="line"><span class="number">4.</span> 把一个字符串中所有的空格全部去掉</span><br><span class="line"><span class="number">5.</span> 统计一个字符串中每个字符出现的次数</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 模块化编程</title>
      <link href="/2018/javascript/js%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2018/javascript/js%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Javascript模块化编程"><a href="#Javascript模块化编程" class="headerlink" title="Javascript模块化编程"></a>Javascript模块化编程</h1><blockquote><p>最初Javascript不是一种模块化编程语言(es6开始支持)。为了能够尽可能的实现js的模块化，我们会把代码写成这样:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 最原始:封装函数写法</span></span><br><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// code</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// code</span></span><br><span class="line">　　&#125;</span><br><span class="line"><span class="comment">// 上面的函数fn1()和fn2()，组成一个模块。使用的时候，直接调用就行了。</span></span><br><span class="line"><span class="comment">// 这种做法的缺点很明显："污染"了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 对象写法</span></span><br><span class="line"><span class="comment">// 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。</span></span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> module1 = &#123;</span><br><span class="line">　　　　_count : <span class="number">0</span>,</span><br><span class="line">　　　　fn1 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　<span class="comment">//code</span></span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　fn2 : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　<span class="comment">//code</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;;</span><br><span class="line"><span class="comment">// 上面的函数fn1()和fn2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。</span></span><br><span class="line"><span class="comment">//　module1.fn1();</span></span><br><span class="line"><span class="comment">// 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</span></span><br><span class="line"><span class="comment">// module1._count = 666;</span></span><br></pre></td></tr></table></figure><blockquote><p>Javascript 模块的基本写法</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.立即执行函数(自调用函数)写法  (沙箱模式)</span></span><br><span class="line"><span class="comment">// 使用"立即执行函数"，可以达到不暴露私有成员的目的。</span></span><br><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _count = <span class="number">0</span>; <span class="comment">//一般私有的变量:申明变量名时,以_开头</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        fn1 : fn1,</span><br><span class="line">        fn2 : fn2</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面的写法，外部代码无法读取内部的_count变量。</span></span><br><span class="line"><span class="comment">// console.info(module1._count); //undefined</span></span><br></pre></td></tr></table></figure><p>##模块化的标准</p><p>让模块拥有更好的通用性！</p><ul><li>AMD : Async Module Definition  异步模块定义</li></ul><blockquote><p>依赖前置： 在一开始就将所有的依赖项全部加载</p></blockquote><ul><li>CMD : Common Module Definition  通用模块定义</li></ul><blockquote><p>依赖延迟： 在需要的时候才去加载依赖项</p></blockquote><p><strong>区别: AMD是异步的, CMD是同步的</strong></p><p>###CMD (Common Module Definition)</p><blockquote><p>同步加载模块</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module add.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> &#123;add&#125; = <span class="built_in">require</span>(<span class="string">'./add'</span>); <span class="comment">// 此处是同步加载</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1 + 2 = '</span> + add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步加载这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"状态。</span></span><br></pre></td></tr></table></figure><h3 id="AMD-Asynchronous-Module-Definition"><a href="#AMD-Asynchronous-Module-Definition" class="headerlink" title="AMD (Asynchronous Module Definition)"></a>AMD (Asynchronous Module Definition)</h3><blockquote><p>异步加载模块 <a href="http://requirejs.org/" target="_blank" rel="noopener">require.js</a> 库实现了AMD规范</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module add.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// 第一个参数是要请求的模块,第二个参数是依赖模块请求完成的回调函数</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'add'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">add</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1 + 2 = '</span> + add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="学习使用-require-js"><a href="#学习使用-require-js" class="headerlink" title="学习使用 require.js"></a>学习使用 require.js</h2><p>js 文件加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；由于js文件之间存在依赖关系，因此必须严格保证加载顺序，依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p><p>require.js 的诞生，就是为了解决这两个问题：</p><blockquote><p>（1）实现js文件的异步加载，避免网页失去响应；</p><p>（2）管理模块之间的依赖性，便于代码的编写和维护。</p></blockquote><p>###require.js 的下载和引入</p><p>使用 require.js 的第一步，是先去官方网站<a href="http://requirejs.org/docs/download.html" target="_blank" rel="noopener">下载</a>最新版本。</p><p>中文网 <a href="http://www.requirejs.cn" target="_blank" rel="noopener">http://www.requirejs.cn</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入方式: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- async 属性表明这个文件需要异步加载，避免网页失去响应 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- IE不支持这个属性，只支持 defer，所以把 defer 也写上 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span> <span class="attr">defer</span> <span class="attr">async</span>=<span class="string">"true"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- data-main 属性的作用是，指定网页程序的主模块。在上例中，就是 js 目录下面的 main.js，这个文件会第一个被 require.js 加载。由于 require.js 默认的文件后缀名是 js ，所以可以把 main.js 简写成 main。--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span> <span class="attr">data-main</span>=<span class="string">"js/main"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>###主模块的写法</p><p>main.js，我把它称为”主模块”，意思是整个网页的入口代码。所有代码都从这儿开始运行。</p><p>下面就来看，怎么写main.js。</p><p>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">alert(<span class="string">"加载成功！"</span>);</span><br></pre></td></tr></table></figure><p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">　　<span class="built_in">require</span>([<span class="string">'moduleA'</span>, <span class="string">'moduleB'</span>, <span class="string">'moduleC'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">moduleA, moduleB, moduleC</span>)</span>&#123;</span><br><span class="line">　　　　<span class="comment">// some code here</span></span><br><span class="line">　　&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// require.js 要求，每个模块是一个单独的js文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// require() 函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是['moduleA', 'moduleB', 'moduleC']，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// require() 异步加载 moduleA，moduleB 和 moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</span></span><br></pre></td></tr></table></figure><h3 id="每个-AMD-模块的写法"><a href="#每个-AMD-模块的写法" class="headerlink" title="每个 AMD 模块的写法"></a>每个 AMD 模块的写法</h3><blockquote><p>require.js 加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</p><p>具体来说，就是模块必须采用特定的 define() 函数来定义。</p></blockquote><blockquote><p>如果一个模块不依赖其他模块，那么可以直接定义在 define() 函数之中。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定现在有一个math.js文件，它定义了一个 math 模块。那么，math.js 就要这样写：</span></span><br><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add: add</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>加载方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</span><br><span class="line">    alert(math.add(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>如果这个模块还依赖其他模块，那么 define() 函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当require() 函数加载上面这个模块的时候，就会先加载 myLib.js 文件。</span></span><br><span class="line">define([<span class="string">'myLib'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">myLib</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        myLib.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo : foo</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="模块加载的配置"><a href="#模块加载的配置" class="headerlink" title="模块加载的配置"></a>模块加载的配置</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面代码中主模块的依赖模块是['moduleA', 'moduleB', 'moduleC']。默认情况下，require.js 假定这三个模块与main.js 在同一个目录，文件名分别为 moduleA.js，moduleB.js 和 moduleC.js，然后自动加载。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 require.config() 方法，我们可以对模块的加载行为进行自定义。require.config() 写在主模块（main.js）的头部。参数就是一个对象，这个对象的 paths 属性指定各个模块的加载路径。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">"moduleA"</span>: <span class="string">"moduleA.min"</span>,</span><br><span class="line">        <span class="string">"moduleB"</span>: <span class="string">"moduleB.min"</span>,</span><br><span class="line">        <span class="string">"moduleC"</span>: <span class="string">"moduleC.min"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面的代码给出了三个模块的文件名，路径默认与 main.js 在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="comment">// 注意:路径相对的是 main 的路径, 不需要写后缀名,require 会自动加</span></span><br><span class="line">        <span class="string">"moduleA"</span>: <span class="string">"lib/moduleA.min"</span>,</span><br><span class="line">        <span class="string">"moduleB"</span>: <span class="string">"lib/moduleB.min"</span>,</span><br><span class="line">        <span class="string">"moduleC"</span>: <span class="string">"lib/moduleC.min"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种则是直接改变基目录（baseUrl）。</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">"js/lib"</span>,</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">"moduleA"</span>: <span class="string">"moduleA.min"</span>,</span><br><span class="line">        <span class="string">"moduleB"</span>: <span class="string">"moduleB.min"</span>,</span><br><span class="line">        <span class="string">"moduleC"</span>: <span class="string">"moduleC.min"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某个模块在另一台主机上，也可以直接指定它的网址，比如：</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">"jquery"</span>: <span class="string">"https://code.jquery.com/jquery-3.3.1.min"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>###加载非规范的模块</p><blockquote><p>理论上，require.js 加载的模块，必须是按照AMD规范、用 define() 函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？</p><p>回答是可以的</p><p>这样的模块在用require()加载之前，要先用 require.config() 方法，定义它们的一些特征</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// require.config() 接受一个配置对象，这个对象除了有前面说过的 paths 属性之外，还有一个 shim 属性，专门用来配置不兼容的模块。具体来说，每个模块要定义：（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入有一个demo.js文件,没有按照AMD规范定义, 那么应该如果使用呢?</span></span><br><span class="line"><span class="comment">// 1. 在 paths 中先配置一下这个 demo.js 的路径</span></span><br><span class="line"><span class="comment">// 2. 在 shim 中配置这个文件的依赖项和导出项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'.box'</span>).stop(<span class="literal">true</span>).fadeIn(<span class="number">1000</span>).fadeOut(<span class="number">1000</span>).slideDown(<span class="number">1000</span>).hide(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'动画执行了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">'jquery'</span>: <span class="string">'https://code.jquery.com/jquery-3.3.1.min'</span>,</span><br><span class="line">        <span class="string">'demo'</span>: <span class="string">'demo.js 相对 main.js 的路径'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    shim: &#123;</span><br><span class="line">        <span class="string">'demo'</span>: &#123;</span><br><span class="line">            deps: [<span class="string">'jquery'</span>],</span><br><span class="line">            <span class="comment">// 注意: 这里导出项要写的是demo.js中的那些内容</span></span><br><span class="line">            <span class="comment">// 这里要导出 animate 函数</span></span><br><span class="line">            exports: <span class="string">'animate'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'demo'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">demo</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(demo);</span><br><span class="line">  demo(); <span class="comment">// 会执行demo.js 文件中 animate 函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fixed定位脱离Viewport的bug</title>
      <link href="/2018/html&amp;css/Fixed%E5%AE%9A%E4%BD%8D%E8%84%B1%E7%A6%BBViewport%E7%9A%84bug/"/>
      <url>/2018/html&amp;css/Fixed%E5%AE%9A%E4%BD%8D%E8%84%B1%E7%A6%BBViewport%E7%9A%84bug/</url>
      
        <content type="html"><![CDATA[<h3 id="Fixed定位脱离Viewport的bug"><a href="#Fixed定位脱离Viewport的bug" class="headerlink" title="Fixed定位脱离Viewport的bug"></a>Fixed定位脱离Viewport的bug</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  .outer &#123;</span></span><br><span class="line"><span class="undefined">    overflow: hidden;</span></span><br><span class="line"><span class="undefined">    width: 300px;</span></span><br><span class="line"><span class="undefined">    height: 300px;</span></span><br><span class="line"><span class="undefined">    background: yellow;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  .mid &#123;</span></span><br><span class="line"><span class="undefined">    margin: 20px;</span></span><br><span class="line"><span class="undefined">    width: 200px;</span></span><br><span class="line"><span class="undefined">    height: 200px;</span></span><br><span class="line"><span class="undefined">    transform: translate(0, 0);</span></span><br><span class="line"><span class="undefined">    background: greenyellow;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  .inner &#123;</span></span><br><span class="line"><span class="undefined">    position: fixed;</span></span><br><span class="line"><span class="undefined">    top: 0;</span></span><br><span class="line"><span class="undefined">    left: 0;</span></span><br><span class="line"><span class="undefined">    width: 100px;</span></span><br><span class="line"><span class="undefined">    height: 100px;</span></span><br><span class="line"><span class="undefined">    background: pink;</span></span><br><span class="line"><span class="undefined">    z-index: 1</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"mid"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于声明transfrom值非none元素，其子元素中若存在position: fixed将以声明transform的最近祖先作为基准而定位，这是因为transfrom值非none的元素<a href="http://www.w3.org/TR/css3-2d-transforms/#transform-rendering" target="_blank" rel="noopener">定义了一个局部坐标系统</a>，导致postion: fixed以此坐标系统计算布局。</p>]]></content>
      
      
      <categories>
          
          <category> html&amp;css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html&amp;css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-z-index 堆叠顺序</title>
      <link href="/2018/html&amp;css/css-z-index/"/>
      <url>/2018/html&amp;css/css-z-index/</url>
      
        <content type="html"><![CDATA[<h3 id="9-3-2-堆叠顺序（z-index）"><a href="#9-3-2-堆叠顺序（z-index）" class="headerlink" title="9.3.2 堆叠顺序（z-index）"></a>9.3.2 堆叠顺序（z-index）</h3><p>在使用<strong>定位</strong>布局时，可能会<strong>出现盒子重叠的情况</strong>。加了定位的盒子，默认<strong>后来者居上</strong>， 后面的盒子会压住前面的盒子。</p><p>应用 <code>z-index</code> 层叠等级属性可以<strong>调整盒子的堆叠顺序</strong>。</p><p><code>z-index</code> 的特性如下：</p><ol><li><strong>属性值</strong>：<strong>正整数</strong>、<strong>负整数</strong>或 <strong>0</strong>，默认值是 0，数值越大，盒子越靠上；</li><li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li><li><strong>数字后面无单位</strong>。</li><li>只应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</li><li><strong>层叠水平仅在直接父级层叠上下文中进行比较，即层叠上下文A中的子元素的层叠水平不会和另一个层叠上下文中的子元素进行比较</strong></li></ol><p><strong>层叠上下文（stacking context）</strong>：创建层叠上下文的元素自己会成为一个<code>参考对象</code>。</p><p><strong>层叠水平（stacking level）</strong></p><p><strong>层叠顺序（stacking order）</strong></p><p><img src="z-index.png" alt="层叠顺序"></p><p><strong>满足下面规则的元素将会构造出一个 Stacking Context 结构：</strong></p><ul><li><code>html</code> 根元素默认会创建层叠上下文</li><li><code>position</code>不为<code>static</code>且<code>z-index</code>不是auto的元素</li><li><code>display</code>为<code>flex</code>且<code>z-index</code>不是auto的元素</li><li><code>opacity</code>不等于1</li><li><code>transform</code>不等于none</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"me"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"you"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    .me &#123;</span></span><br><span class="line"><span class="undefined">       width: 100px;</span></span><br><span class="line"><span class="undefined">       height: 100px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">    .you &#123;</span></span><br><span class="line"><span class="undefined">        width: 100px;</span></span><br><span class="line"><span class="undefined">        height: 100px;</span></span><br><span class="line"><span class="undefined">        left: 50px;</span></span><br><span class="line"><span class="undefined">        position: relative;</span></span><br><span class="line"><span class="undefined">        z-index: -1;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>you在这里和me做比较，比较开始，首先you寻找参考对象，上一层me是吗？显然不是，因为me没有触发上面任一条件创建层叠上下文，所以继续往上寻找，找到html。对于me，也直接往上找到html，所以这个例子里me和you是在以html为参考对象进行比较，<strong>换句话说就是在html创建的层叠上下文环境中进行比较</strong>！然后按照七阶图，负值index在block元素之下！所以me在you之上。</p><p>然后我们修改下me，加个<code>z-index:0;</code> 按照之前的思路演算一遍，you的参考对象变成me了！而me仍然是html，然后me和html再做比较，me参考对象是html，html的参考对象是html，OK，在同一上下文了，me明显高于html，所以you高于me。</p><p>参考链接</p><p><a href="http://www.cnblogs.com/bfgis/p/5440956.html" target="_blank" rel="noopener"> 北风吹雪：不起眼的 z-index 却能牵扯出这么大的学问</a></p><p><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">张鑫旭:深入理解CSS中的层叠上下文和层叠顺序</a></p>]]></content>
      
      
      <categories>
          
          <category> html&amp;css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html&amp;css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 基础</title>
      <link href="/2018/html&amp;css/css/"/>
      <url>/2018/html&amp;css/css/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS层叠样式表"><a href="#CSS层叠样式表" class="headerlink" title="CSS层叠样式表"></a>CSS层叠样式表</h1><h2 id="1-CSS初识"><a href="#1-CSS初识" class="headerlink" title="1.CSS初识"></a>1.CSS初识</h2><ul><li><p>概念：</p><ul><li>CSS(Cascading Style Sheets)  ，通常称为CSS样式表或层叠样式表（级联样式表）</li></ul></li><li><p>作用：</p><ul><li>主要用于<strong>设置</strong> HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及<strong>版面的布局和外观显示样式。</strong></li><li>CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。</li></ul></li></ul><h2 id="2-引入CSS样式表（书写位置）"><a href="#2-引入CSS样式表（书写位置）" class="headerlink" title="2. 引入CSS样式表（书写位置）"></a>2. 引入CSS样式表（书写位置）</h2><h3 id="2-1-行内式（内联样式）"><a href="#2-1-行内式（内联样式）" class="headerlink" title="2.1 行内式（内联样式）"></a>2.1 行内式（内联样式）</h3><ul><li><p>概念：</p><pre><code>称行内样式、行间样式.  是通过标签的style属性来设置元素的样式</code></pre></li></ul><ul><li>其基本语法格式如下：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名</span> <span class="attr">style</span>=<span class="string">"属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"</span>&gt;</span> 内容 <span class="tag">&lt;/<span class="name">标签名</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际上任何HTML标签都拥有style属性，用来设置行内式。</p><ul><li>案例：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style="color: red; font-size: 12px;"&gt;青春不常在，抓紧谈恋爱&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>style其实就是标签的属性</li><li>样式属性和值中间是 <code>:</code></li><li>多组属性值之间用 <code>;</code> 隔开。</li><li>只能控制当前的标签和以及嵌套在其中的子标签，造成代码冗余</li></ul></li><li>缺点：<ul><li>没有实现样式和结构相分离</li></ul></li></ul><h3 id="2-2-内部样式表（内嵌样式表）"><a href="#2-2-内部样式表（内嵌样式表）" class="headerlink" title="2.2 内部样式表（内嵌样式表）"></a>2.2 内部样式表（内嵌样式表）</h3><ul><li><p>概念：</p><pre><code>称内嵌式  是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义</code></pre></li><li><p>其基本语法格式如下：</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"> <span class="selector-tag">div</span> &#123;</span><br><span class="line"> <span class="attribute">color</span>: red;</span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><ul><li>style标签一般位于head标签中</li><li>type=”text/css”  在html5中可以省略</li><li>只能控制当前的页面</li></ul></li><li><p>缺点：</p><p>  没有彻底分离</p></li></ul><h3 id="2-3-外部样式表（外链式）"><a href="#2-3-外部样式表（外链式）" class="headerlink" title="2.3 外部样式表（外链式）"></a>2.3 外部样式表（外链式）</h3><ul><li><p>概念：</p><p> 称链入式</p><pre><code>是将所有的样式放在一个或多个以 .CSS 为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中</code></pre></li><li><p>其基本语法格式如下：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"css文件路径"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>link 是个单标签</li><li>link标签需要放在head头部标签中，并且指定link标签的三个属性</li></ul></li></ul><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>rel</td><td align="left">定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</td></tr><tr><td>type</td><td align="left">定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。我们都可以省略</td></tr><tr><td>href</td><td align="left">定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</td></tr></tbody></table><h3 id="2-4-三种样式表总结（位置）"><a href="#2-4-三种样式表总结（位置）" class="headerlink" title="2.4 三种样式表总结（位置）"></a>2.4 三种样式表总结（位置）</h3><table><thead><tr><th>样式表</th><th>优点</th><th>缺点</th><th>使用情况</th><th>控制范围</th></tr></thead><tbody><tr><td>行内样式表</td><td>书写方便，权重高</td><td>没有实现样式和结构相分离</td><td>较少</td><td>控制一个标签（少）</td></tr><tr><td>内部样式表</td><td>部分结构和样式相分离</td><td>没有彻底分离</td><td>较多</td><td>控制一个页面（中）</td></tr><tr><td>外部样式表</td><td>完全实现结构和样式相分离</td><td>需要引入</td><td>最多，强烈推荐</td><td>控制整个站点（多）</td></tr></tbody></table><h2 id="3-CSS样式规则"><a href="#3-CSS样式规则" class="headerlink" title="3. CSS样式规则"></a>3. CSS样式规则</h2><ol><li>选择器用于指定CSS样式作用的HTML标签，花括号内是对该对象设置的具体样式。</li><li>属性和属性值以“键值对”的形式出现。</li><li>属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。</li><li>属性和属性值之间用英文 <code>:</code> 连接。</li><li>多个“键值对”之间用英文 <code>;</code> 进行区分。</li></ol><h2 id="4-CSS-选择器（重点）"><a href="#4-CSS-选择器（重点）" class="headerlink" title="4. CSS 选择器（重点）"></a>4. CSS 选择器（重点）</h2><h3 id="4-1-CSS-基础选择器"><a href="#4-1-CSS-基础选择器" class="headerlink" title="4.1 CSS 基础选择器"></a>4.1 CSS 基础选择器</h3><h4 id="4-1-1-标签选择器"><a href="#4-1-1-标签选择器" class="headerlink" title="4.1.1 标签选择器"></a>4.1.1 标签选择器</h4><ul><li><p>概念：</p><p>标签选择器（元素选择器）是指用<strong>HTML标签名</strong>称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。</p></li><li><p>语法：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-类选择器"><a href="#4-1-2-类选择器" class="headerlink" title="4.1.2 类选择器"></a>4.1.2 类选择器</h4><p>类选择器使用 <code>.</code>（英文点号）进行标识，后面紧跟类名.</p><ul><li><p>语法：</p><ul><li>类名选择器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.类名  &#123;</span><br><span class="line">    属性1:属性值1;</span><br><span class="line">    属性2:属性值2;</span><br><span class="line">    属性3:属性值3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>标签</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&apos;类名&apos;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li>可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签</li></ul></li><li><p>注意</p><ul><li>可以使用字母，数字，<code>-</code> ，<code>_</code></li><li>必须以字母开头，区分大小写，不要纯数字、中文等命名</li><li>一个class可以出现多次，一个元素可以有多个class，<strong>各个类名中间用空格隔开</strong></li></ul></li></ul><h4 id="4-1-3-id-选择器"><a href="#4-1-3-id-选择器" class="headerlink" title="4.1.3 id 选择器"></a>4.1.3 id 选择器</h4><p>id 选择器使用 <code>#</code> 进行标识，后面紧跟id名</p><ul><li><p>其基本语法格式如下：</p></li><li><p>id选择器</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#id名 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意</p><ul><li>必须以字母开头</li><li>区分大小写</li><li>只可出现一次</li></ul></li></ul><h4 id="4-1-4-通配符选择器"><a href="#4-1-4-通配符选择器" class="headerlink" title="4.1.4 通配符选择器"></a>4.1.4 通配符选择器</h4><p>通配符选择器用 <code>*</code> 号表示，选择所有的标签。</p><ul><li>其基本语法格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;</span><br></pre></td></tr></table></figure><p>例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;   <span class="comment">/* 定义外边距*/</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;  <span class="comment">/* 定义内边距*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><p>会匹配页面所有的元素，降低页面响应速度，不建议随便使用</p></li></ul><h3 id="4-2-CSS-复合选择器"><a href="#4-2-CSS-复合选择器" class="headerlink" title="4.2 CSS 复合选择器"></a>4.2 CSS 复合选择器</h3><h4 id="4-2-1-后代选择器（重点）"><a href="#4-2-1-后代选择器（重点）" class="headerlink" title="4.2.1 后代选择器（重点）"></a>4.2.1 后代选择器（重点）</h4><ul><li>后代选择器又称为包含选择器（标签有<strong>直接或间接嵌套</strong>关系，可隔代选择）</li><li>中间用 <code>空格</code> 连接</li><li>语法：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父级 子级&#123;属性:属性值;属性:属性值;&#125;</span><br><span class="line"><span class="selector-class">.class</span> <span class="selector-tag">h3</span>&#123;<span class="attribute">color</span>:red;<span class="attribute">font-size</span>:<span class="number">16px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-子元素-子代-选择器"><a href="#4-2-2-子元素-子代-选择器" class="headerlink" title="4.2.2 子元素(子代)选择器"></a>4.2.2 子元素(子代)选择器</h4><ul><li>子元素选择器只能选择作为某元素<strong>子元素(亲儿子)</strong>的元素（直接嵌套，不能隔代）。</li><li>其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 <code>&gt;</code> 进行连接</li><li>语法：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &gt; <span class="selector-tag">h3</span>&#123;<span class="attribute">color</span>:red;<span class="attribute">font-size</span>:<span class="number">14px</span>;&#125;</span><br></pre></td></tr></table></figure><p>白话：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如:  <span class="selector-class">.demo</span> &gt; <span class="selector-tag">h3</span> &#123;<span class="attribute">color</span>: red;&#125;   说明 <span class="selector-tag">h3</span> 一定是 <span class="selector-tag">demo</span> 亲儿子  <span class="selector-tag">demo</span> 元素包含着<span class="selector-tag">h3</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-交集选择器"><a href="#4-2-3-交集选择器" class="headerlink" title="4.2.3 交集选择器"></a>4.2.3 交集选择器</h4><ul><li><p>由两个选择器构成，找到的标签必须满足：既有标签一的特点，也有标签二的特点。</p></li><li><p>两个选择器之间 <strong>不能有空格</strong>，如h3.special。</p></li></ul><p><strong>记忆技巧：</strong></p><p>交集选择器 是 并且的意思。  即…又…的意思</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如: <span class="selector-tag">p</span><span class="selector-class">.one</span>   选择的是类名为 <span class="selector-class">.one</span>  的 <span class="selector-tag">p</span> 标签</span><br></pre></td></tr></table></figure><p>用的相对来说比较少，不太建议使用。</p><h4 id="4-2-4-并集选择器（重点）"><a href="#4-2-4-并集选择器（重点）" class="headerlink" title="4.2.4 并集选择器（重点）"></a>4.2.4 并集选择器（重点）</h4><ul><li><p>并集选择器（CSS选择器分组）是各个选择器通过<code>,</code>连接而成的，通常用于集体声明。</p></li><li><p>任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如  <span class="selector-class">.one</span>, <span class="selector-tag">p</span> , <span class="selector-id">#test</span> &#123;<span class="attribute">color</span>: <span class="number">#F00</span>;&#125;</span><br><span class="line">表示   <span class="selector-class">.one</span> 和 <span class="selector-tag">p</span> 和 <span class="selector-id">#test</span> 这三个选择器都会执行颜色为红色</span><br><span class="line">通常用于集体声明</span><br></pre></td></tr></table></figure><h4 id="4-2-5-伪类选择器"><a href="#4-2-5-伪类选择器" class="headerlink" title="4.2.5 伪类选择器"></a>4.2.5 伪类选择器</h4><p>伪类选择器实质上是让设计师可以根据元素特定的状态，设置不同的视觉效果。具体有<code>:link</code>、<code>:visited</code>、<code>:hover</code>、<code>:active</code>、<code>:focus</code>、<code>:focus-within</code>、<code>:target</code>、<code>:root</code>和<code>:checked</code>。</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>a:link</td><td></td><td>用于设置链接初始状态时的样式</td></tr><tr><td>a:visited</td><td></td><td>用于设置链接被点击过后的样式    设置font-size不起作用</td></tr><tr><td>a:hover</td><td></td><td>用于设置鼠标悬停在链接上方时，链接的样式</td></tr><tr><td>a:active</td><td></td><td>用于设置鼠标按键按下，但未释放时，链接的样式</td></tr><tr><td></td><td></td><td></td></tr><tr><td>:first-child</td><td>li:first-child</td><td>选择属于其父元素的第一个子元素(不一定是li元素)</td></tr><tr><td>:last-child</td><td>li:last-child</td><td>选择属于其父元素的最后一个子元素</td></tr><tr><td>:nth-child(2)</td><td>li:nth-child(2)</td><td>选择属于其父元素的第二个子元素</td></tr><tr><td>:nth-child(even)</td><td>li:nth-child(even)</td><td>选择属于其父元素的偶数项的子元素</td></tr><tr><td>:nth-child(3n+1)</td><td>li:nth-child(3n+1)</td><td>选择属于其父元素的正向3n+1项(n从0开始)的子元素</td></tr><tr><td>nth-last-child(3n+1)</td><td>li:nth-last-child(-n+5)</td><td>选择属于其父元素的反向-n+5项(n从0开始)的子元素<br>(即选择最后五个li元素)</td></tr><tr><td>:only-child</td><td>li:only-child</td><td>选择属于其父元素的唯一子元素的每个 <code>&lt;li&gt;</code> 元素</td></tr><tr><td>:only-of-type</td><td>li:only-of-type</td><td>选择属于其父元素唯一 <code>&lt;li&gt;</code> 元素的每个 <code>&lt;li&gt;</code> 元素</td></tr><tr><td>:first-of-type</td><td>li:first-of-type</td><td>选择属于其父元素的第一个<code>&lt;li&gt;</code> 元素</td></tr><tr><td>:last-of-type</td><td>li:last-of-type</td><td>选择属于其父元素的最后一个 <code>&lt;li&gt;</code> 元素</td></tr><tr><td>:nth-of-type(2)</td><td>li:nth-of-type(2)</td><td>选择属于其父元素的第二个 <code>&lt;li&gt;</code> 元素</td></tr><tr><td></td><td></td><td></td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择每个启用的 <code>&lt;input&gt;</code> 元素</td></tr><tr><td>:disabled</td><td>input:disabled</td><td>选择每个禁用的 <code>input&gt;</code> 元素</td></tr><tr><td>:checked</td><td>input:checked</td><td>选择每个被选中的 <code>&lt;input&gt;</code> 元素</td></tr><tr><td></td><td></td><td></td></tr><tr><td>:focus</td><td></td><td>用于设置元素处于focus状态下的样式。</td></tr><tr><td>:focus-within</td><td></td><td>用于设置当子元素处于focus状态时，该元素的样式。</td></tr><tr><td>:empty</td><td>p:empty</td><td>选择没有子元素的每个 <code>&lt;p&gt;</code> 元素（包括文本节点）</td></tr><tr><td>:target</td><td><code>#news:target</code></td><td>选择当前活动的 <code>#news</code> 元素</td></tr><tr><td>:root</td><td></td><td>选择文档的根元素</td></tr><tr><td>:not(p)</td><td>li:not(:last-of-type)</td><td>选择最后一个li之外其他所有li</td></tr><tr><td>:placeholder-shown</td><td></td><td>用于设置元素placeholder显示时的样式</td></tr><tr><td></td><td></td><td></td></tr><tr><td>伪元素</td><td></td><td></td></tr><tr><td>::selection</td><td>::selection</td><td>选择被用户选取的元素部分</td></tr><tr><td>::first-letter</td><td>p::first-letter</td><td>选择每个 <code>&lt;p&gt;</code> 元素的首字母。</td></tr><tr><td>::first-line</td><td>p::first-line</td><td>选择每个 <code>&lt;p&gt;</code> 元素的首行</td></tr><tr><td>::placeholder</td><td>input::placeholder</td><td>选择input内部的占位符，给其设置样式</td></tr><tr><td>::before</td><td>div::before</td><td>在每个 <code>&lt;div&gt;</code> 元素的内容之前插入内容</td></tr><tr><td>::after</td><td>div::after</td><td>在每个 <code>&lt;div&gt;</code> 元素的内容之后插入内容</td></tr><tr><td></td><td></td><td></td></tr><tr><td>属性选择器</td><td></td><td></td></tr><tr><td>[attribute]</td><td>[disabled]</td><td>选择带有disabled 属性所有元素。</td></tr><tr><td>[attribute=value]</td><td>[target=_blank]</td><td>选择 target=”_blank” 的所有元素。</td></tr><tr><td>[attribute~=value]</td><td>[title~=flower]</td><td>选择 title 属性包含单词 “flower” 的所有元素。</td></tr><tr><td>[attribute|=value]</td><td>[lang|=en]</td><td>选择 lang 属性值以 “en” 开头后续以-分隔的所有元素。</td></tr><tr><td>:lang(language)</td><td>p:lang(it)</td><td>选择带有以 “it” 开头的 lang 属性值的每个 <code>&lt;p&gt;</code> 元素</td></tr><tr><td>[attribute^=value]</td><td>a[src^=”https”]</td><td>选择其 src 属性值以 “https” 开头的每个 <code>&lt;a&gt;</code> 元素</td></tr><tr><td>[attribute$=value]</td><td>a[src$=”.pdf”]</td><td>选择其 src 属性以 “.pdf” 结尾的所有 <code>&lt;a&gt;</code> 元素</td></tr><tr><td>[attribute*=value]</td><td>a[src*=”abc”]</td><td>选择其 src 属性中包含 “abc” 子串的每个 <code>&lt;a&gt;</code> 元素</td></tr></tbody></table><p><code>#nav == [id=nav]</code> 选择 id=nav 的所有元素</p><blockquote><p><code>li:last-child</code> 是选择li元素的父元素下的最后一个子元素，不一定是 li</p><p><code>li:last-of-type</code>  是选择li元素的父元素的最后一个 li 元素</p><p><code>li:not(:last-of-type)</code>  选择最后一个li之外其他所有li</p><p><code>::before</code> <code>::after</code> 必须指定 content 属性，否则无效；生成的伪元素默认是行内样式；生成的伪元素无法被找到，更不能被 hover 等；一般用来清除浮动(只有::after可以)或添加小图标</p></blockquote><p>关于单冒号和双冒号问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">关于:before与::before的区别</span><br><span class="line">:before是css2中伪元素的写法，但是呢，在css3中严格规定，伪类采用单冒号，伪元素需要使用双冒号。为了兼容旧的代码，当浏览器碰到了:before之后，会自动的转换成::before。</span><br><span class="line">如果需要兼容老的浏览器，比如IE678，推荐使用:before</span><br><span class="line">如果不需要兼容老的浏览器，比如移动端，推荐使用::before</span><br></pre></td></tr></table></figure><h4 id="链接伪类注意"><a href="#链接伪类注意" class="headerlink" title="链接伪类注意"></a>链接伪类注意</h4><ul><li>写的时候，他们的顺序尽量不要颠倒  按照  lvha 的顺序。否则可能引起错误。</li><li>记忆法<ul><li><strong>l</strong>o<strong>v</strong>e   <strong>ha</strong>te     爱上了讨厌</li><li><strong>lv *<em>包包   非常 *</em>ha</strong>o</li></ul></li><li>因为叫链接伪类，所以都是 利用交集选择器  a:link    a:hover</li><li>因为a链接浏览器具有默认样式，所以我们实际工作中都需要给链接单独指定样式。</li><li>实际工作开发中，我们很少写全四个状态，一般我们写法如下：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;   <span class="comment">/* a是标签选择器  所有的链接 */</span></span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"><span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;   <span class="comment">/* :hover 是链接伪类选择器 鼠标经过 */</span></span><br><span class="line"><span class="attribute">color</span>: red; <span class="comment">/*  鼠标经过的时候，由原来的 灰色 变成了红色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-CSS属性"><a href="#5-CSS属性" class="headerlink" title="5. CSS属性"></a>5. CSS属性</h2><h3 id="5-1-font-字体"><a href="#5-1-font-字体" class="headerlink" title="5.1 font:字体"></a>5.1 font:字体</h3><h4 id="5-1-1-font-size-大小"><a href="#5-1-1-font-size-大小" class="headerlink" title="5.1.1 font-size:大小"></a>5.1.1 font-size:大小</h4><ul><li><p>作用：</p><p>font-size属性用于设置字号</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>谷歌浏览器默认的文字大小为16px，最小为12px。</li><li>em、百分比 相对父元素大小</li><li>设置body默认字体大小为100%，其他文字大小以此为基础设置百分比值</li></ul></blockquote><h4 id="5-1-2-font-family-字体"><a href="#5-1-2-font-family-字体" class="headerlink" title="5.1.2 font-family:字体"></a>5.1.2 font-family:字体</h4><ul><li><p>作用：</p><p>font-family属性用于设置哪一种字体。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123; font-family:&quot;微软雅黑&quot;;&#125;</span><br></pre></td></tr></table></figure><ul><li>可以同时指定多个字体，<strong>中间以逗号隔开</strong>，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。</li><li>中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。</li><li>如果字体名中包含空格、#、$ 等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: “Times New Roman”;。</li><li>尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p&#123;font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CSS Unicode字体</p><ul><li><p>为什么使用 Unicode字体</p></li><li><p>在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。</p></li><li><p>xp 系统不支持 类似微软雅黑的中文。</p></li></ul><p>解决：</p><ul><li><p>方案一： 你可以使用英文来替代。 比如<code>font-family:&quot;Microsoft Yahei&quot;</code>。</p></li><li><p>方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;   font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;;   表示设置字体为“微软雅黑”。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><table><thead><tr><th>字体名称</th><th>英文名称</th><th>Unicode 编码</th></tr></thead><tbody><tr><td>宋体</td><td>SimSun</td><td>\5B8B\4F53</td></tr><tr><td>新宋体</td><td>NSimSun</td><td>\65B0\5B8B\4F53</td></tr><tr><td>黑体</td><td>SimHei</td><td>\9ED1\4F53</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td><td>\5FAE\8F6F\96C5\9ED1</td></tr><tr><td>楷体_GB2312</td><td>KaiTi_GB2312</td><td>\6977\4F53_GB2312</td></tr><tr><td>隶书</td><td>LiSu</td><td>\96B6\4E66</td></tr><tr><td>幼园</td><td>YouYuan</td><td>\5E7C\5706</td></tr><tr><td>华文细黑</td><td>STXihei</td><td>\534E\6587\7EC6\9ED1</td></tr><tr><td>细明体</td><td>MingLiU</td><td>\7EC6\660E\4F53</td></tr><tr><td>新细明体</td><td>PMingLiU</td><td>\65B0\7EC6\660E\4F53</td></tr></tbody></table></blockquote><h4 id="5-1-3-font-weight-字体粗细"><a href="#5-1-3-font-weight-字体粗细" class="headerlink" title="5.1.3 font-weight:字体粗细"></a>5.1.3 font-weight:字体粗细</h4><ul><li>在html中如何将字体加粗我们可以用标签来实现<ul><li>使用 b  和 strong 标签是文本加粗。</li></ul></li><li>可以使用CSS 来实现，但是CSS 是没有语义的。</li></ul><table><thead><tr><th>属性值</th><th align="left">描述</th></tr></thead><tbody><tr><td>normal</td><td align="left">默认值（不加粗的）</td></tr><tr><td>bold</td><td align="left">定义粗体（加粗的）</td></tr><tr><td>100~900</td><td align="left">400 等同于 normal，而 700 等同于 bold  我们重点记住这句话</td></tr></tbody></table><h4 id="5-1-4-font-style-字体风格"><a href="#5-1-4-font-style-字体风格" class="headerlink" title="5.1.4 font-style:字体风格"></a>5.1.4 font-style:字体风格</h4><ul><li>在html中如何将字体倾斜我们可以用标签来实现<ul><li>字体倾斜除了用 i  和 em 标签，</li></ul></li><li>可以使用CSS 来实现，但是CSS 是没有语义的</li></ul><p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>normal</td><td align="left">默认值，浏览器会显示标准的字体样式  font-style: normal;</td></tr><tr><td>italic</td><td align="left">浏览器会显示斜体的字体样式。</td></tr></tbody></table><h4 id="5-1-5-line-height-文字行高"><a href="#5-1-5-line-height-文字行高" class="headerlink" title="5.1.5 line-height:文字行高"></a>5.1.5 line-height:文字行高</h4><ul><li><p>作用：</p><p>设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</p><p>使用行高实现<strong>单行文字垂直居中</strong></p></li><li><p>单位：</p><ul><li>line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px</li></ul></li></ul><blockquote><p>技巧：</p><ul><li>一般情况下，行距比字号大7.8像素左右就可以了。line-height: 24px;</li><li>文字垂直居中就设置行高等于他外部元素的高度</li><li>line-height 不要代替 height ，height 不写 line-height 会把盒子撑起来，不建议这样， height该写也得写</li></ul></blockquote><p><strong>行高测量</strong></p><p><img src="line2.png" alt></p><p><strong>行高和高度的三种关系</strong></p><ul><li>如果 行高 等 高度  文字会 垂直居中</li><li>如果行高 大于 高度   文字会 偏下</li><li>如果行高小于高度   文字会  偏上</li></ul><p><strong>300%、3em、3 之间区别</strong></p><ul><li>300%  先计算后继承</li><li>3 先继承后计算</li><li>3em</li></ul><h4 id="5-1-6-font-综合设置字体样式-重点"><a href="#5-1-6-font-综合设置字体样式-重点" class="headerlink" title="5.1.6 font: 综合设置字体样式 (重点)"></a>5.1.6 font: 综合设置字体样式 (重点)</h4><p>font属性用于对字体样式进行综合设置</p><ul><li>基本语法格式如下：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">font</span>: <span class="selector-attr">[&lt;font-style&gt;||&lt;font-weight&gt;]</span>?&lt;<span class="selector-tag">font-size</span>&gt;<span class="selector-attr">[/&lt;line-height&gt;]</span>?&lt;<span class="selector-tag">font-family</span>&gt;(必不可少，否则无效)</span><br><span class="line"></span><br><span class="line">font:italic bold 20px/2 arial,serif;</span><br><span class="line">//表示font-style:italic  font-weight:bold    font-size:20px  line-height:2   font-family:arial,serif</span><br></pre></td></tr></table></figure><ul><li>注意：<ul><li>使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以<strong>空格</strong>隔开。</li><li>其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。</li><li>line-height 值如果不写，浏览器会默认添加 <code>normal</code></li></ul></li></ul><h3 id="5-2-text-属性"><a href="#5-2-text-属性" class="headerlink" title="5.2 text 属性"></a>5.2 text 属性</h3><h4 id="5-2-1-color-文本颜色"><a href="#5-2-1-color-文本颜色" class="headerlink" title="5.2.1 color:文本颜色"></a>5.2.1 color:文本颜色</h4><ul><li><p>作用：</p><p>color属性用于定义文本的颜色，</p></li><li><p>其取值方式有如下3种：</p></li></ul><table><thead><tr><th align="left">表示表示</th><th align="left">属性值</th></tr></thead><tbody><tr><td align="left">预定义的颜色值</td><td align="left">red，green，blue等等</td></tr><tr><td align="left">十六进制</td><td align="left">#FF0000，#FF6600，#29D794</td></tr><tr><td align="left">RGB代码</td><td align="left">rgb(255,0,0)或rgb(100%,0%,0%)<br>rgba(255,0,0,1)1表示不透明，0表示全透明<br>全透明也可以用color：transparent</td></tr></tbody></table><ul><li><p>注意</p><p>我们实际工作中， 用 16进制的写法是最多的，而且我们更喜欢简写方式比如  #f00 代表红色</p></li></ul><h4 id="5-2-2-text-align-文本水平对齐方式"><a href="#5-2-2-text-align-文本水平对齐方式" class="headerlink" title="5.2.2 text-align:文本水平对齐方式"></a>5.2.2 text-align:文本水平对齐方式</h4><ul><li><p>作用：</p><p>text-align 属性用于设置当前这个标签内部的 <strong>内容</strong>（可以是文字 、行内标签、行内块标签）的水平对齐方式</p></li><li><p>其可用属性值如下：</p></li></ul><table><thead><tr><th>属性</th><th align="center">解释</th></tr></thead><tbody><tr><td>left</td><td align="center">左对齐（默认值）</td></tr><tr><td>right</td><td align="center">右对齐</td></tr><tr><td>center</td><td align="center">居中对齐</td></tr><tr><td>justify</td><td align="center">两端对齐</td></tr></tbody></table><ul><li><p>注意：</p><p>是让盒子里面的 <strong>内容水平居中</strong> ， 而不是让盒子居中对齐</p></li></ul><h4 id="5-2-3-text-indent-首行缩进"><a href="#5-2-3-text-indent-首行缩进" class="headerlink" title="5.2.3 text-indent:首行缩进"></a>5.2.3 text-indent:首行缩进</h4><ul><li><p>作用：</p><p>text-indent 属性用于设置首行文本的缩进，</p></li><li><p>属性值</p><ul><li>其属性值可为不同单位的数值、em字符宽度的倍数、或相对于父元素宽度的百分比%，允许使用负值（设置成很大的负值可以用来隐藏文字）</li><li>建议使用em作为设置单位。</li><li>可以继承</li></ul></li></ul><p><strong>1em 就是一个字的宽度   如果是汉字的段落， 1em 就是一个汉字的宽度</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">      <span class="comment">/*行间距*/</span></span><br><span class="line">      <span class="attribute">line-height</span>: <span class="number">25px</span>;</span><br><span class="line">      <span class="comment">/*首行缩进2个字  em  1个em 就是1个字的大小*/</span></span><br><span class="line">      <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-4-text-decoration-文本的装饰"><a href="#5-2-4-text-decoration-文本的装饰" class="headerlink" title="5.2.4 text-decoration 文本的装饰"></a>5.2.4 text-decoration 文本的装饰</h4><p>text-decoration   通常我们用于给链接修改装饰效果</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认。定义标准的文本。 取消下划线（最常用）</td></tr><tr><td>underline</td><td>定义文本下的一条线。下划线 也是我们链接自带的（常用）</td></tr><tr><td>overline</td><td>定义文本上的一条线。（不用）</td></tr><tr><td>line-through</td><td>定义穿过文本的一条线。（不常用）</td></tr></tbody></table><blockquote><p> 多个属性值写在同一个text-decoration里会叠加<br> 多个属性值写在不同的text-decoration里，<strong>属性不会累加</strong>，优先级高的会完全取代优先级低的</p></blockquote><h4 id="5-2-5-CSS外观属性总结"><a href="#5-2-5-CSS外观属性总结" class="headerlink" title="5.2.5 CSS外观属性总结"></a>5.2.5 CSS外观属性总结</h4><table><thead><tr><th align="left">属性</th><th align="left">表示</th><th align="left">注意点</th></tr></thead><tbody><tr><td align="left">color</td><td align="left">颜色</td><td align="left">我们通常用  十六进制   比如 而且是简写形式 #fff</td></tr><tr><td align="left">line-height</td><td align="left">行高</td><td align="left">控制行与行之间的距离</td></tr><tr><td align="left">text-align</td><td align="left">水平对齐</td><td align="left">可以设定文字水平的对齐方式</td></tr><tr><td align="left">text-indent</td><td align="left">首行缩进</td><td align="left">通常我们用于段落首行缩进2个字的距离   text-indent: 2em;</td></tr><tr><td align="left">text-decoration</td><td align="left">文本修饰</td><td align="left">记住 添加 下划线  underline  取消下划线  none</td></tr></tbody></table><h3 id="5-3-背景-background-属性"><a href="#5-3-背景-background-属性" class="headerlink" title="5.3 背景(background)属性"></a>5.3 背景(background)属性</h3><h4 id="color"><a href="#color" class="headerlink" title="color"></a>color</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 背景颜色 */</span></span><br><span class="line"><span class="selector-tag">background-color</span>: 颜色值;   默认的值是 <span class="selector-tag">transparent</span> 透明的  <span class="selector-tag">inherit</span> 继承</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 半透明背景 */</span></span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.3</span>);</span><br><span class="line">  <span class="comment">/* 只作用于盒子背景颜色，不会影响文本和背景图片 */</span></span><br><span class="line">  <span class="comment">/* 最后一个参数是 alpha 透明度 取值范围 0~1 之间 */</span></span><br><span class="line">  <span class="comment">/* 0.3 的 0 可以省略 */</span></span><br><span class="line">  <span class="comment">/* C3 属性，低于 ie9 的版本不支持 */</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>opacity</strong> 属性 设置整个标签的透明度，取值范围 <code>0~1</code>之间</p></blockquote><h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 背景图片 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>:</span><br><span class="line">  <span class="selector-tag">none</span>(默认)</span><br><span class="line">  <span class="selector-tag">url</span>(图片地址)</span><br><span class="line">  <span class="selector-tag">url</span>("<span class="selector-tag">demo1</span><span class="selector-class">.png</span>"), <span class="selector-tag">url</span>("<span class="selector-tag">demo2</span><span class="selector-class">.png</span>"); <span class="comment">/* demo1 在 demo2 上层 */</span></span><br></pre></td></tr></table></figure><ul><li><p>在background-color上层</p></li><li><p>推荐背景图片 url 加引号</p></li><li><p>多个背景图片，使用逗号隔开</p></li></ul><p><strong>img 和背景图片的区别：</strong></p><ul><li>img 直接可以显示在页面，不需要设置宽高，但是背景图片必须要给盒子设置宽高才能显示，背景图片撑不开容器</li><li>img 上面写不了内容（除非后期使用定位），而背景图片完全可以</li><li>在实际工作中：img 一般用来做产品图片展示（经常更新），而背景图片一般用来做背景或者一些很少更新的小 icon</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 插入图片更改大小 width 和 height */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">30px</span>; <span class="comment">/* 插入图片更改位置 可以用 margin 或 padding  盒模型 */</span></span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">50px</span>; <span class="comment">/* 插入的图片也是一个盒子 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid purple;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span> <span class="built_in">url</span>(<span class="string">'images/sun.jpg'</span>) no-repeat;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">30px</span> <span class="number">50px</span>; <span class="comment">/* 背景图片更改位置用 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 背景平铺 */</span></span><br><span class="line"><span class="selector-tag">background-repeat</span>:</span><br><span class="line"><span class="selector-tag">repeat</span>：背景图像在纵向和横向上平铺（默认的）</span><br><span class="line"><span class="selector-tag">no-repeat</span>：背景图像不平铺（常用）</span><br><span class="line"><span class="selector-tag">repeat-x</span>：背景图像在横向上平铺</span><br><span class="line"><span class="selector-tag">repeat-y</span>：背景图像在纵向平铺</span><br><span class="line"><span class="selector-tag">space</span>：中间有空白，保证显示每个图片完整</span><br><span class="line"><span class="selector-tag">round</span>：通过缩放保证每个图片显示完整，有可能图片会被拉伸</span><br></pre></td></tr></table></figure><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 背景位置 */</span></span><br><span class="line"><span class="selector-tag">background-position</span>:</span><br><span class="line">  length：百分数 | 由浮点数字和单位标识符组成的长度值</span><br><span class="line">  position：top | center | bottom | left | center | right   方位名词</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>必须先指定 background-image 属性</li><li>x 轴向右为正方向，y 轴向下为正方向，z 轴向屏幕外是正方向</li><li>如果 position 后面是精确坐标， 那么第一个是 x ，第二的一定是 y</li><li>如果指定的两个值是精确单位和方位名字混合使用，则第一个值是 x 坐标，第二个值是 y 坐标</li><li>如果指定两个值都是方位名字，则两个值前后顺序无关，比如 left  top 和 top  left 效果一致</li><li>如果只指定了一个方位名词，另一个值默认<strong>居中对齐</strong>。如果只指定一个数值，那该数值一定是 x 坐标，另一个默认<strong>垂直居中</strong></li><li>可设置像素值或百分比（百分比对应容器百分比位置，50% 50% 等价于 center center 即居中）</li><li>right 10px top 20px  表示距离右边10px 距离上边 20px</li></ul><h4 id="attachment"><a href="#attachment" class="headerlink" title="attachment"></a>attachment</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 背景附着就是解释背景是滚动的还是固定的 */</span></span><br><span class="line"><span class="selector-tag">background-attachment</span>:</span><br><span class="line">  <span class="selector-tag">scroll</span>：背景图像是随对象内容滚动</span><br><span class="line">  <span class="selector-tag">fixed</span>：背景图像固定</span><br><span class="line">  <span class="selector-tag">inherit</span></span><br></pre></td></tr></table></figure><h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><ul><li>跟 width 或者 height 属性是一致的，其实就是设置背景图片的宽高</li><li>设置百分比则是相对于容器的百分比，而不是图片，50% 不是将图片缩小一半</li><li>特殊值：cover 和 contain 图片等比缩放恰好覆盖整个元素<ul><li>cover 某一边正好100%，另一边等于或者大于元素对应方向的长度</li><li>contain 某一边正好100%，另一边等于或者小于元素对应方向的长度</li></ul></li></ul><h4 id="origin"><a href="#origin" class="headerlink" title="origin"></a>origin</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置背景零点参考的盒模型即设置（0.0）坐标位置 */</span></span><br><span class="line">background-origin: padding-box（默认值） | border-box | content-box</span><br></pre></td></tr></table></figure><h4 id="clip"><a href="#clip" class="headerlink" title="clip"></a>clip</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置背景裁剪参考的盒模型 */</span></span><br><span class="line"><span class="selector-tag">background-clip</span>:</span><br><span class="line">  <span class="selector-tag">border-box</span>  （默认值）背景区域：<span class="selector-tag">border</span> + <span class="selector-tag">padding</span> + <span class="selector-tag">content</span></span><br><span class="line">  <span class="selector-tag">padding-box</span>   背景区域：<span class="selector-tag">padding</span> + <span class="selector-tag">content</span></span><br><span class="line">  <span class="selector-tag">content-box</span>   背景区域：<span class="selector-tag">content</span></span><br><span class="line">  <span class="selector-tag">text</span>   (需要加 <span class="selector-tag">-webkit-</span> 前缀) 背景区域 ：文字</span><br></pre></td></tr></table></figure><h4 id="背景属性简写"><a href="#背景属性简写" class="headerlink" title="背景属性简写"></a>背景属性简写</h4><p>!&gt; background: bg-image || bg-position/bg-size || repeat-style || bg-attachment || bg-origin||  bg-clip(origin 和 clip 只设置一个值时则他俩为同一个值)  || bg-color</p><p>多重背景：background 设置背景的时候，可以设置多个背景图片，使用逗号隔开。注意颜色只能设置一次，并且颜色通常都是在最后面进行设置。</p><p>background 是一个合写的属性，如果在 background 之前设置了background相关的样式，会被覆盖掉</p><h3 id="5-4-display-属性（重点）"><a href="#5-4-display-属性（重点）" class="headerlink" title="5.4 display 属性（重点）"></a>5.4 display 属性（重点）</h3><p>属性值：<br>​    none 此元素不会被显示，不占空间，后续元素会补充上去（visibility：hidden   不显示，但空间保留）<br>​    block 显示为块级元素<br>​    inline 显示为内联元素<br>​    inline-block  显示为行内块</p><h4 id="5-4-1-块级元素-block"><a href="#5-4-1-块级元素-block" class="headerlink" title="5.4.1 块级元素(block)"></a>5.4.1 块级元素(block)</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:block</span>;</span><br></pre></td></tr></table></figure><blockquote><p>常见的块元素有 <code>&lt;h1&gt;~&lt;h6&gt;</code> 、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code> 、<code>dl</code>、 <code>dt</code>  、<code>dd</code>、  <code>header</code> 、 <code>footer</code>  、<code>aside</code>、  <code>nav</code> 、 <code>article</code> 、 <code>section</code> …等，其中<code>&lt;div&gt;</code>标签是最典型的块元素。</p></blockquote><ul><li>块级元素的特点</li></ul><p>（1）独占一行</p><p>（2）高度，宽度、外边距以及内边距都可以控制。</p><p>（3）继承父元素的宽度，高度不继承</p><p>（4）是一个容器及盒子，里面可以放行内或者块级元素。</p><ul><li>注意：<ul><li>只有文字才能组成段落  因此 p  里面不能放块级元素，特别是 p 不能放div</li><li>同理还有这些标签 h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</li></ul></li></ul><h4 id="5-4-2-行内元素-inline"><a href="#5-4-2-行内元素-inline" class="headerlink" title="5.4.2 行内元素(inline)"></a>5.4.2 行内元素(inline)</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:inline</span>;</span><br></pre></td></tr></table></figure><blockquote><p>常见的行内元素有<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;del&gt;</code>、<code>&lt;s&gt;</code>、<code>&lt;ins&gt;</code>、<code>&lt;u&gt;</code>、<code>lable</code> 、<code>&lt;span&gt;</code> 等，其中 <code>&lt;span&gt;</code> 标签最典型的行内元素。有的地方也成内联元素</p></blockquote><p><strong>行内元素的特点：</strong></p><p>（1）相邻行内元素在一行上，一行可以显示多个。</p><p>（2）高、宽直接设置是无效的。</p><p>（3）默认宽度就是它本身内容的宽度。</p><p>（4）<strong>不可设置竖直方向的marging和padding</strong>,但是可以设置水平方向的margin和padding</p><p>（5）<strong>行内元素只能容纳文本或则其他行内元素。</strong></p><p>  注意：</p><ul><li><code>&lt;a&gt;</code> 不能直接嵌套 <code>&lt;a&gt;</code></li><li>特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。</li></ul><h4 id="5-4-3-行内块元素（inline-block）"><a href="#5-4-3-行内块元素（inline-block）" class="headerlink" title="5.4.3 行内块元素（inline-block）"></a>5.4.3 行内块元素（inline-block）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在行内元素中有几个特殊的标签——<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;td&gt;</code>、<code>textarea</code> ，<code>select</code> ，<code>button</code>，可以对它们设置宽高和对齐属性，这些元素把它们称为行内块元素。</p></blockquote><ul><li><p>行内块元素的特点：</p><p>（1）和相邻行内元素（行内块）在一行上。一行可以显示多个，超出范围会整块换行<br>（2）默认宽度就是它本身内容的宽度。<br>（3）高度，行高、外边距以及内边距都可以控制。<br>（4）可以设置垂直居中 {vertical-align：middle；}</p></li></ul><h3 id="5-5-盒子阴影-box-shadow-CSS3"><a href="#5-5-盒子阴影-box-shadow-CSS3" class="headerlink" title="5.5 盒子阴影 box-shadow (CSS3)"></a>5.5 盒子阴影 box-shadow (CSS3)</h3><ul><li>语法:</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow:水平阴影 垂直阴影 模糊距离（虚实）  阴影尺寸（影子大小）  阴影颜色  内/外阴影；</span><br></pre></td></tr></table></figure><ul><li>前两个属性是必须写的，其余的可以省略。</li><li>水平阴影、垂直阴影、阴影尺寸可为负值，模糊距离不能为负</li><li>外阴影 (outset) 是默认的 但是不能写  想要内阴影可以写  inset</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">    <span class="comment">/* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  */</span></span><br><span class="line">    <span class="comment">/* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内/外阴影； */</span></span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">15px</span> <span class="number">30px</span>  <span class="built_in">rgba</span>(0, 0, 0, .4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>颜色如果没设置则为border或文字颜色，阴影不占空间，内外阴影可以叠加，中间用逗号隔开</p><h2 id="6-CSS-三大特性"><a href="#6-CSS-三大特性" class="headerlink" title="6. CSS 三大特性"></a>6. CSS 三大特性</h2><p>目标：</p><ul><li>理解<ul><li>能说出css样式冲突采取的原则</li><li>能说出哪些常见的样式会有继承</li></ul></li><li>应用<ul><li>能写出CSS优先级的算法</li><li>能会计算常见选择器的叠加值</li></ul></li></ul><h3 id="6-1-CSS层叠性"><a href="#6-1-CSS层叠性" class="headerlink" title="6.1 CSS层叠性"></a>6.1 CSS层叠性</h3><ul><li><p>概念：</p><p>所谓层叠性是指多种CSS样式的叠加。</p><p>是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</p></li><li><p>原则：</p><ul><li>样式冲突，遵循的原则是<strong>就近原则。</strong></li><li>同一标签同一属性，后面的会覆盖前面的</li><li>样式不冲突，不会层叠</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS层叠性最后的执行口诀：  长江后浪推前浪，前浪死在沙滩上。</span><br></pre></td></tr></table></figure><h3 id="6-2-CSS继承性"><a href="#6-2-CSS继承性" class="headerlink" title="6.2 CSS继承性"></a>6.2 CSS继承性</h3><p><img src="21%E7%BB%A7%E6%89%BF%E6%80%A7.png" alt></p><ul><li><p>概念：</p><p>子标签会继承父标签的某些样式，如文本颜色和字号。</p><p> 想要设置一个可继承的属性，只需将它应用于父元素即可。</p></li></ul><p>简单的理解就是：  子承父业。</p><ul><li><strong>注意</strong>：<ul><li>恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。</li><li>子元素可以继承父元素的样式（<strong>text-，font-，line- 这些元素开头的可以继承，以及color属性</strong>）</li><li>a标签不会继承color， text-decoration <code>none</code> 属性值不会继承，其他属性值会继承</li><li>h标签会继承的父元素的font-size，但是具体的值是继承下来的font-size的值* 2</li></ul></li></ul><h3 id="6-3-CSS优先级（重点）"><a href="#6-3-CSS优先级（重点）" class="headerlink" title="6.3 CSS优先级（重点）"></a>6.3 CSS优先级（重点）</h3><p><img src="22%E4%BC%98%E5%85%88%E7%BA%A7.png" alt></p><ul><li><p>概念：</p><p>定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，</p><ul><li>选择器相同，则执行层叠性</li><li>选择器不同，就会出现优先级的问题。</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!important &gt; style &gt; id &gt; 类/伪类 &gt; 标签 &gt; * &gt; 继承</span><br></pre></td></tr></table></figure><h4 id="1-权重计算公式"><a href="#1-权重计算公式" class="headerlink" title="1). 权重计算公式"></a>1). 权重计算公式</h4><p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</p><table><thead><tr><th>标签选择器</th><th>计算权重公式</th></tr></thead><tbody><tr><td>继承或者 *</td><td>0,0,0,0</td></tr><tr><td>每个元素（标签选择器），伪元素选择器</td><td>0,0,0,1</td></tr><tr><td>每个类，伪类，属性选择器</td><td>0,0,1,0</td></tr><tr><td>每个ID</td><td>0,1,0,0</td></tr><tr><td>每个行内样式 style=””</td><td>1,0,0,0</td></tr><tr><td>每个!important  重要的</td><td>∞ 无穷大</td></tr></tbody></table><ul><li><p>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</p></li><li><p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</p></li><li><p>div { color: pink!important;  }</p></li></ul><h4 id="2-权重叠加"><a href="#2-权重叠加" class="headerlink" title="2). 权重叠加"></a>2). 权重叠加</h4><p>我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。</p><p>就是一个简单的加法计算</p><ul><li>div ul  li   ——&gt;      0,0,0,3</li><li>.nav ul li   ——&gt;      0,0,1,2</li><li>a:hover      —–—&gt;   0,0,1,1</li><li>.nav a       ——&gt;      0,0,1,1</li></ul><p>注意：</p><ol><li>数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</li></ol><h4 id="3-继承的权重是0"><a href="#3-继承的权重是0" class="headerlink" title="3). 继承的权重是0"></a>3). 继承的权重是0</h4><p>这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。</p><p>1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。<br>2） 如果没有选中，那么权重是0，因为继承的权重为0.（<strong>!important也无效</strong>）</p><h2 id="7-盒子模型（CSS重点）"><a href="#7-盒子模型（CSS重点）" class="headerlink" title="7. 盒子模型（CSS重点）"></a>7. 盒子模型（CSS重点）</h2><p>css学习三大重点： css 盒子模型   、  浮动  、  定位</p><p>主题思路：</p><p><img src="css%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt></p><p>目标：</p><ul><li>理解：<ul><li>能说出盒子模型有哪四部分组成</li><li>能说出内边距的作用以及对盒子的影响</li><li>能说出padding设置不同数值个数分别代表的意思</li><li>能说出块级盒子居中对齐需要的2个条件</li><li>能说出外边距合并的解决方法</li></ul></li><li>应用：<ul><li>能利用边框复合写法给元素添加边框</li><li>能计算盒子的实际大小</li><li>能利用盒子模型布局模块案例</li></ul></li></ul><h3 id="7-1-盒子模型（Box-Model）"><a href="#7-1-盒子模型（Box-Model）" class="headerlink" title="7.1 盒子模型（Box Model）"></a>7.1 盒子模型（Box Model）</h3><ul><li><p>所谓盒子模型：</p><ul><li>就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</li></ul></li></ul><p>  <strong>总结:</strong></p><ul><li>盒子模型有元素的内容（）、边框（border）、内边距（padding）、和外边距（margin）组成。</li><li>盒子里面的文字和图片等元素是 内容区域</li><li>盒子的厚度 我们成为 盒子的边框</li><li>盒子内容与边框的距离是内边距（类似单元格的 cellpadding)</li><li>盒子与盒子之间的距离是外边距（类似单元格的 cellspacing）</li><li>css中设置的宽高默认是内容部分</li></ul><h3 id="7-2-盒子边框（border）​"><a href="#7-2-盒子边框（border）​" class="headerlink" title="7.2 盒子边框（border）​"></a>7.2 盒子边框（border）​</h3><ul><li>语法：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">border : border-width || border-style || border-color || none</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th align="center">作用</th></tr></thead><tbody><tr><td>border-width</td><td align="center">定义边框粗细，单位是px</td></tr><tr><td>border-style</td><td align="center">边框的样式</td></tr><tr><td>border-color</td><td align="center">边框颜色</td></tr></tbody></table><ul><li>边框的样式：<ul><li>none：没有边框即忽略所有边框的宽度（默认值）</li><li>solid：边框为单实线(最为常用的)</li><li>dashed：边框为虚线</li><li>dotted：边框为点线</li></ul></li></ul><h4 id="7-2-1-盒子边框写法总结表"><a href="#7-2-1-盒子边框写法总结表" class="headerlink" title="7.2.1 盒子边框写法总结表"></a>7.2.1 盒子边框写法总结表</h4><p>很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。</p><table><thead><tr><th align="left">上边框</th><th align="left">下边框</th><th align="left">左边框</th><th align="left">右边框</th></tr></thead><tbody><tr><td align="left">border-top-style:样式;</td><td align="left">border-bottom-style:样式;</td><td align="left">border-left-style:样式;</td><td align="left">border-right-style:样式;</td></tr><tr><td align="left">border-top-width:宽度;</td><td align="left">border- bottom-width:宽度;</td><td align="left">border-left-width:宽度;</td><td align="left">border-right-width:宽度;</td></tr><tr><td align="left">border-top-color:颜色;</td><td align="left">border- bottom-color:颜色;</td><td align="left">border-left-color:颜色;</td><td align="left">border-right-color:颜色;</td></tr><tr><td align="left">border-top:宽度 样式 颜色;</td><td align="left">border-bottom:宽度 样式 颜色;</td><td align="left">border-left:宽度 样式 颜色;</td><td align="left">border-right:宽度 样式 颜色;</td></tr></tbody></table><h4 id="7-2-2-表格的细线边框"><a href="#7-2-2-表格的细线边框" class="headerlink" title="7.2.2 表格的细线边框"></a>7.2.2 表格的细线边框</h4><ul><li><p>通过表格的<code>cellspacing=&quot;0&quot;</code>,将单元格与单元格之间的距离设置为0，</p></li><li><p>但是两个单元格之间的边框会出现重叠，从而使边框变粗</p></li><li><p>通过css属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table&#123; border-collapse:collapse; &#125;</span><br></pre></td></tr></table></figure><ul><li>collapse 单词是合并的意思</li><li>border-collapse:collapse; 表示相邻边框合并在一起。</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">td</span> &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">td</span> &#123;</span><br><span class="line"><span class="attribute">border-collapse</span>: collapse;  <span class="comment">/*合并相邻边框*/</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="7-2-3-圆角边框-CSS3"><a href="#7-2-3-圆角边框-CSS3" class="headerlink" title="7.2.3 圆角边框(CSS3)"></a>7.2.3 圆角边框(CSS3)</h4><ul><li>语法：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-radius</span><span class="selector-pseudo">:length</span>;  <span class="comment">/*圆角的半径*/</span></span><br></pre></td></tr></table></figure><ul><li><p>其中每一个值可以为数值或百分比的形式。</p></li><li><p>四个值的顺序是：左上、右上、右下、左下，依旧是顺时针旋转。每个角又有水平半径垂直半径，前四个代表水平，后四个代表垂直，中间用/隔开</p></li><li><p>技巧：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-radius</span>: 50%; <span class="comment">/*让一个正方形  变成圆圈 */</span></span><br><span class="line"><span class="selector-tag">border-top-left-radius</span>：10<span class="selector-tag">px</span>; <span class="comment">/*单独设置一个角*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-3-内边距（padding）"><a href="#7-3-内边距（padding）" class="headerlink" title="7.3 内边距（padding）"></a>7.3 内边距（padding）</h3><h4 id="7-3-1-内边距"><a href="#7-3-1-内边距" class="headerlink" title="7.3.1 内边距"></a>7.3.1 内边距</h4><p>padding属性用于设置内边距。 <strong>是指 边框与内容之间的距离。</strong></p><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>padding-left</td><td align="left">左内边距</td></tr><tr><td>padding-right</td><td align="left">右内边距</td></tr><tr><td>padding-top</td><td align="left">上内边距</td></tr><tr><td>padding-bottom</td><td align="left">下内边距</td></tr></tbody></table><p>当我们给盒子指定padding值之后， 发生了2件事情：</p><ol><li>内容和边框 有了距离，添加了内边距。</li><li>盒子会变大。</li></ol><blockquote><p>如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。</p></blockquote><p><strong>注意：  后面跟几个数值表示的意思是不一样的。</strong></p><table><thead><tr><th>值的个数</th><th>表达意思</th></tr></thead><tbody><tr><td>1个值</td><td>padding：上下左右内边距;</td></tr><tr><td>2个值</td><td>padding: 上下内边距    左右内边距 ；</td></tr><tr><td>3个值</td><td>padding：上内边距   左右内边距   下内边距；</td></tr><tr><td>4个值</td><td>padding: 上内边距 右内边距 下内边距 左内边距 ；</td></tr></tbody></table><h4 id="7-3-2-内盒尺寸计算（元素实际大小）"><a href="#7-3-2-内盒尺寸计算（元素实际大小）" class="headerlink" title="7.3.2 内盒尺寸计算（元素实际大小）"></a>7.3.2 内盒尺寸计算（元素实际大小）</h4><ul><li><p>宽度</p><p>Element Height = content height + padding + border （Height为内容高度）</p></li><li><p>高度</p><p>Element Width = content width + padding + border （Width为内容宽度）</p></li><li><p>盒子的实际的大小 =   内容的宽度和高度 +  内边距   +  边框</p><blockquote><p>会撑大原来的盒子</p></blockquote></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">content-box</span>（为默认，宽高不包含<span class="selector-tag">padding</span>和<span class="selector-tag">border</span>）</span><br><span class="line"><span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>; 此时宽高包含<span class="selector-tag">border</span>在内</span><br></pre></td></tr></table></figure><h3 id="7-4-外边距（margin）"><a href="#7-4-外边距（margin）" class="headerlink" title="7.4 外边距（margin）"></a>7.4 外边距（margin）</h3><h4 id="7-4-1-外边距"><a href="#7-4-1-外边距" class="headerlink" title="7.4.1 外边距"></a>7.4.1 外边距</h4><p>margin 属性用于设置外边距。  margin 就是控制<strong>盒子和盒子之间的距离</strong>，可以为负值</p><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>margin-left</td><td align="left">左外边距</td></tr><tr><td>margin-right</td><td align="left">右外边距</td></tr><tr><td>margin-top</td><td align="left">上外边距</td></tr><tr><td>margin-bottom</td><td align="left">下外边距</td></tr></tbody></table><blockquote><p> margin值的简写 （复合写法）代表意思  跟 padding 完全相同。</p></blockquote><p><strong>行内元素设置 margin-top/bottom 无效</strong></p><h4 id="7-4-2-块级盒子水平居中"><a href="#7-4-2-块级盒子水平居中" class="headerlink" title="7.4.2 块级盒子水平居中"></a>7.4.2 块级盒子水平居中</h4><ul><li>可以让一个块级盒子实现水平居中必须：<ul><li>盒子必须指定了宽度（width）</li><li>然后就给<strong>左右的外边距都设置为auto</strong>，</li></ul></li></ul><p>实际工作中常用这种方式进行网页布局，示例代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span>&#123; <span class="attribute">width</span>:<span class="number">960px</span>; <span class="attribute">margin</span>:<span class="number">0</span> auto;&#125;</span><br></pre></td></tr></table></figure><p>常见的写法，以下下三种都可以。</p><ul><li>margin-left: auto;   margin-right: auto;</li><li>margin: auto;</li><li>margin: 0 auto;</li></ul><h4 id="7-4-3-文字居中和盒子居中区别"><a href="#7-4-3-文字居中和盒子居中区别" class="headerlink" title="7.4.3 文字居中和盒子居中区别"></a>7.4.3 文字居中和盒子居中区别</h4><ol><li>盒子内的文字水平居中是  text-align: center,  而且还可以让 行内元素和行内块居中对齐</li><li>块级盒子水平居中  左右margin 改为 auto</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>; <span class="comment">/*  文字 行内元素 行内块元素水平居中 */</span></span><br><span class="line"><span class="selector-tag">margin</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">auto</span>;  <span class="comment">/* 块级盒子水平居中  左右margin 改为 auto 就阔以了 上下margin都可以 */</span></span><br></pre></td></tr></table></figure><h4 id="7-4-4-外边距合并（塌陷）"><a href="#7-4-4-外边距合并（塌陷）" class="headerlink" title="7.4.4 外边距合并（塌陷）"></a>7.4.4 外边距合并（塌陷）</h4><p>使用margin定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p><p><strong>(1). 相邻块元素垂直外边距的合并</strong></p><ul><li><p>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和而是<strong>取两个值中的较大者</strong>，这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</p><p><img src="margin%E5%90%88%E5%B9%B6.png" alt></p></li></ul><p><strong>解决方案：尽量只给一个盒子添加margin值</strong>。</p><p><strong>(2). 嵌套块元素垂直外边距的合并（塌陷）</strong></p><ul><li><p>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，父元素的上外边距会与子元素的上外边距发生合并（父元素会跟着下来），合并后的外边距为两者中的较大者</p><p><img src="margin%E5%90%88%E5%B9%B61.png" alt></p></li></ul><p><strong>解决方案：</strong></p><ol><li>可以为父元素定义上边框。</li><li>可以为父元素定义上内边距</li><li>可以为父元素添加overflow:hidden。</li></ol><p>还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</p><h4 id="7-4-5-清除元素的默认内外边距-重要"><a href="#7-4-5-清除元素的默认内外边距-重要" class="headerlink" title="7.4.5 清除元素的默认内外边距(重要)"></a>7.4.5 清除元素的默认内外边距(重要)</h4><p>为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除</p><p>代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">   <span class="attribute">padding</span>:<span class="number">0</span>;         <span class="comment">/* 清除内边距 */</span></span><br><span class="line">   <span class="attribute">margin</span>:<span class="number">0</span>;          <span class="comment">/* 清除外边距 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。</li></ul><h2 id="8-CSS-浮动-float"><a href="#8-CSS-浮动-float" class="headerlink" title="8. CSS 浮动(float)"></a>8. CSS 浮动(float)</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li><strong>记忆</strong><ul><li>能够说出 CSS 的布局的三种机制</li></ul></li><li><strong>理解</strong><ul><li>能够说出普通流在布局中的特点</li><li>能够说出我们为什么用浮动</li><li>能够说出我们为什么要清除浮动</li></ul></li><li><strong>应用</strong><ul><li>能够利用浮动完成导航栏案例</li><li>能够清除浮动</li></ul></li></ul><h3 id="8-1-浮动"><a href="#8-1-浮动" class="headerlink" title="8.1 浮动"></a>8.1 浮动</h3><h4 id="8-1-1-CSS-布局的三种机制"><a href="#8-1-1-CSS-布局的三种机制" class="headerlink" title="8.1.1 CSS 布局的三种机制"></a>8.1.1 CSS 布局的三种机制</h4><p>CSS 提供了 <strong>3 种机制</strong>来设置盒子的摆放位置，分别是<strong>普通流</strong>（标准流）、<strong>浮动</strong>和<strong>定位</strong>，其中：</p><ol><li><strong>普通流</strong>（标准流）<ul><li><strong>块级元素</strong>会独占一行，<strong>从上向下</strong>顺序排列；<ul><li>常用元素：div、hr、p、h1~h6、ul、ol、dl</li></ul></li><li><strong>行内元素</strong>会按照顺序，<strong>从左到右</strong>顺序排列，碰到父元素边缘则自动换行；<ul><li>常用元素：span、a、i、em等</li></ul></li></ul></li><li><strong>浮动</strong><ul><li>让盒子从普通流中<strong>浮</strong>起来,主要作用让多个块级盒子一行显示。</li></ul></li><li><strong>定位</strong><ul><li>将盒子<strong>定</strong>在浏览器的某一个<strong>位</strong>置——CSS 离不开定位，特别是后面的 js 特效。</li></ul></li></ol><h4 id="8-1-2-为什么需要浮动？"><a href="#8-1-2-为什么需要浮动？" class="headerlink" title="8.1.2 为什么需要浮动？"></a>8.1.2 为什么需要浮动？</h4><p>思考题：</p><p> 我们首先要思考以下2个布局中最常见的问题？</p><ol><li>如何让多个盒子(div)水平排列成一行？</li><li>如何实现盒子的左右对齐？</li></ol><p>虽然我们前面学过行内块（inline-block） 但是他却有自己的缺陷：</p><ol><li>它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题。</li><li>它不能实现以上第二个问题，盒子左右对齐</li></ol><p><strong>pink老师一句话总结他们</strong></p><blockquote><p>因为一些网页布局要求，标准流不能满足我们的需要了，因此我们需要浮动来完成网页布局。</p></blockquote><h4 id="8-1-3-什么是浮动-float"><a href="#8-1-3-什么是浮动-float" class="headerlink" title="8.1.3  什么是浮动(float)"></a>8.1.3  什么是浮动(float)</h4><p><strong>概念</strong>：元素的浮动是指<strong>设置了浮动属性的元素</strong>会</p><ol><li>脱离标准普通流的控制</li><li>移动到指定位置。</li></ol><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li><strong>让多个盒子(div)水平排列成一行</strong>，使得浮动成为布局的重要手段。</li><li>可以实现盒子的左右对齐等等..</li><li>浮动最早是用来<strong>控制图片</strong>，实现<strong>文字环绕图片的效果</strong>。</li></ol><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>在 CSS 中，通过 <code>float</code>  属性定义浮动，语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; float: 属性值; &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>none</strong></td><td>元素不浮动（<strong>默认值</strong>）</td></tr><tr><td><strong>left</strong></td><td>元素向<strong>左</strong>浮动</td></tr><tr><td><strong>right</strong></td><td>元素向<strong>右</strong>浮动</td></tr></tbody></table><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li><code>float</code> 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下，遮挡起来了</li><li>原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。</li><li>元素不在受标准流显示模式的限制,<strong>块级元素不再继承父元素的宽度，行内元素可以直接设置宽高</strong></li><li><strong>浮动的元素互相贴靠一起的，中间没有空白，但是如果父级宽度装不下这些浮动的盒子， 多出的盒子会</strong>掉下来（掉下来的位置会根据上一个浮动盒子的高度决定, 会以<strong>上一个盒子的底边线为基准线</strong>水平移动，如果在移动的过程里面被挡住了，那么就会卡在这里地方）</li><li>左浮从左往右排，右浮从右往左排</li><li>文字和img标签不会和浮动元素重叠</li><li>margin的auto值对于脱标元素没有作用</li></ul><blockquote><p>实际重要的导航栏中，我们不会直接用链接a 而是用 li  包含链接(li+a)的做法。</p><ol><li>li+a 语义更清晰，一看这就是有条理的列表型内容。</li><li>如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名</li></ol></blockquote><h3 id="8-2-清除浮动"><a href="#8-2-清除浮动" class="headerlink" title="8.2 清除浮动"></a>8.2 清除浮动</h3><ul><li>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响</li><li>准确地说，所谓的清除浮动，是<strong>清除浮动后造成的影响</strong></li><li>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</li></ul><h4 id="8-2-1-清除浮动的方法"><a href="#8-2-1-清除浮动的方法" class="headerlink" title="8.2.1 清除浮动的方法"></a>8.2.1 清除浮动的方法</h4><p>在CSS中，clear属性用于清除浮动</p><ul><li>语法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;clear:属性值;&#125;   clear 清除</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td>right</td><td>不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td>both</td><td>同时清除左右两侧浮动的影响</td></tr></tbody></table><p>但是我们实际工作中， 几乎只用 clear: both;</p><h5 id="1-额外标签法-隔墙法"><a href="#1-额外标签法-隔墙法" class="headerlink" title="1).额外标签法(隔墙法)"></a>1).额外标签法(隔墙法)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">”clear:both”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>优点： 通俗易懂，书写方便</li><li>缺点： 添加许多无意义的标签，结构化较差。</li></ul><h5 id="2-父级添加overflow属性方法"><a href="#2-父级添加overflow属性方法" class="headerlink" title="2).父级添加overflow属性方法"></a>2).父级添加overflow属性方法</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以给父级添加: overflow为 hidden| auto| scroll  都可以实现。</span><br></pre></td></tr></table></figure><p>优点：  代码简洁</p><p>缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p><h5 id="3-使用after伪元素清除浮动"><a href="#3-使用after伪元素清除浮动" class="headerlink" title="3).使用after伪元素清除浮动"></a>3).使用after伪元素清除浮动</h5><p><strong>::after 方式为空元素额外标签法的升级版，好处是不用单独加标签了</strong></p><p>使用方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">     <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">     <span class="attribute">display</span>: block;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">clear</span>: both;</span><br><span class="line">     <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*content: ""; display: block; clear: both; 这三个必须写*/</span></span><br><span class="line"> <span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">     *zoom: 1;</span><br><span class="line">&#125;   <span class="comment">/* IE6、7 专有 */</span></span><br></pre></td></tr></table></figure><ul><li>优点： 符合闭合浮动思想  结构语义化正确</li><li>缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</li></ul><h4 id="8-2-2-清除浮动总结"><a href="#8-2-2-清除浮动总结" class="headerlink" title="8.2.2 清除浮动总结"></a>8.2.2 清除浮动总结</h4><ol><li>父级没高度</li><li>子盒子浮动了</li><li>影响下面布局了，我们就应该清除浮动了。</li></ol><table><thead><tr><th>清除浮动的方式</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td>额外标签法（隔墙法）</td><td align="left">通俗易懂，书写方便</td><td align="left">添加许多无意义的标签，结构化较差。</td></tr><tr><td>父级overflow:hidden;</td><td align="left">书写简单</td><td align="left">溢出隐藏</td></tr><tr><td>父级after伪元素</td><td align="left">结构语义化正确</td><td align="left">由于IE6-7不支持:after，兼容性问题</td></tr></tbody></table><h2 id="9-定位-position"><a href="#9-定位-position" class="headerlink" title="9. 定位(position)"></a>9. 定位(position)</h2><p>定位也是用来布局的，它有两部分组成：</p><blockquote><p><code>定位 = 定位模式 + 边偏移</code></p></blockquote><h3 id="9-1-边偏移"><a href="#9-1-边偏移" class="headerlink" title="9.1 边偏移"></a>9.1 边偏移</h3><p>通过 <code>top</code>、<code>bottom</code>、<code>left</code> 和 <code>right</code> 属性定义元素的<strong>边偏移</strong>：</p><table><thead><tr><th>边偏移属性</th><th align="left">示例</th><th>描述</th></tr></thead><tbody><tr><td><code>top</code></td><td align="left"><code>top: 80px</code></td><td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td></tr><tr><td><code>bottom</code></td><td align="left"><code>bottom: 80px</code></td><td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td></tr><tr><td><code>left</code></td><td align="left"><code>left: 80px</code></td><td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td></tr><tr><td><code>right</code></td><td align="left"><code>right: 80px</code></td><td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td></tr></tbody></table><p>定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。</p><h3 id="9-2-定位模式-position"><a href="#9-2-定位模式-position" class="headerlink" title="9.2  定位模式 (position)"></a>9.2  定位模式 (position)</h3><p>在 CSS 中，通过 <code>position</code> 属性定义元素的<strong>定位模式</strong>，语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">position</span>: 属性值; &#125;</span><br></pre></td></tr></table></figure><p>定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。</p><table><thead><tr><th>值</th><th align="center">语义</th></tr></thead><tbody><tr><td><code>static</code></td><td align="center"><strong>静态</strong>定位</td></tr><tr><td><code>relative</code></td><td align="center"><strong>相对</strong>定位</td></tr><tr><td><code>absolute</code></td><td align="center"><strong>绝对</strong>定位</td></tr><tr><td><code>fixed</code></td><td align="center"><strong>固定</strong>定位</td></tr></tbody></table><h4 id="9-2-1-静态定位-static-了解"><a href="#9-2-1-静态定位-static-了解" class="headerlink" title="9.2.1 静态定位(static) - 了解"></a>9.2.1 静态定位(static) - 了解</h4><ul><li><strong>静态定位</strong>是元素的默认定位方式，无定位的意思。它相当于 border 里面的none， 不要定位的时候用。</li><li>静态定位 按照标准流特性摆放位置，它没有边偏移。</li><li>静态定位在布局时我们几乎不用的</li></ul><h4 id="9-2-2-相对定位-relative-重要"><a href="#9-2-2-相对定位-relative-重要" class="headerlink" title="9.2.2 相对定位(relative) - 重要"></a>9.2.2 相对定位(relative) - 重要</h4><ul><li><strong>相对定位</strong>是元素<strong>相对</strong>于它原来在标准流中的位置来说的。（自恋型）</li><li>原来<strong>在标准流的区域继续占有</strong>，后面的盒子仍然以标准流的方式对待它。</li></ul><h4 id="9-2-3-绝对定位-absolute-重要"><a href="#9-2-3-绝对定位-absolute-重要" class="headerlink" title="9.2.3 绝对定位(absolute) - 重要"></a>9.2.3 绝对定位(absolute) - 重要</h4><ul><li>依据最近的已经定位的父级元素（<strong>默认父元素的padding部分</strong>）来进行定位（拼爹型）</li><li>不保留原来的位置，完全是脱标的。</li></ul><p>因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。</p><p><strong>定位口诀</strong> —— <strong>子绝父相</strong>—— <strong>子级</strong>是<strong>绝对</strong>定位，<strong>父级</strong>要用<strong>相对</strong>定位。</p><blockquote><p>子元素的 0 点为 margin-box 右上角，父元素的 0 点为 padding-box 右上角</p></blockquote><h4 id="9-2-4-固定定位-fixed-重要"><a href="#9-2-4-固定定位-fixed-重要" class="headerlink" title="9.2.4 固定定位(fixed) - 重要"></a>9.2.4 固定定位(fixed) - 重要</h4><ol><li><strong>完全脱标</strong> —— 完全不占位置；</li><li>只认<strong>浏览器的可视窗口</strong> —— <code>浏览器可视窗口 + 边偏移属性</code> 来设置元素的位置；<ul><li>跟父元素没有任何关系；单独使用的</li><li>不随滚动条滚动。</li></ul></li></ol><h3 id="9-3-定位-position-的扩展"><a href="#9-3-定位-position-的扩展" class="headerlink" title="9.3 定位(position)的扩展"></a>9.3 定位(position)的扩展</h3><h4 id="9-3-1-绝对定位的盒子居中"><a href="#9-3-1-绝对定位的盒子居中" class="headerlink" title="9.3.1 绝对定位的盒子居中"></a>9.3.1 绝对定位的盒子居中</h4><blockquote><p><strong>注意</strong>：<strong>绝对定位/固定定位的盒子</strong>不能通过设置 <code>margin: auto</code> 设置<strong>水平居中</strong>。</p></blockquote><p>在使用<strong>绝对定位</strong>时要想实现水平居中，可以按照如下方法（垂直居中同理）：</p><ol><li><code>left: 50%;</code>：让<strong>盒子的左侧</strong>移动到<strong>父级元素的水平中心位置</strong>；</li><li><code>margin-left: -100px;</code>：让盒子<strong>向左</strong>移动<strong>自身宽度的一半</strong>。</li></ol><p>居中还可以这样：{margin: auto; left: 0; right: 0; top: 0; bottom: 0;}</p><h4 id="9-3-2-堆叠顺序（z-index）"><a href="#9-3-2-堆叠顺序（z-index）" class="headerlink" title="9.3.2 堆叠顺序（z-index）"></a>9.3.2 堆叠顺序（z-index）</h4><p>在使用<strong>定位</strong>布局时，可能会<strong>出现盒子重叠的情况</strong>。加了定位的盒子，默认<strong>后来者居上</strong>， 后面的盒子会压住前面的盒子。</p><p>应用 <code>z-index</code> 层叠等级属性可以<strong>调整盒子的堆叠顺序</strong>。</p><p><code>z-index</code> 的特性如下：</p><ol><li><strong>属性值</strong>：<strong>正整数</strong>、<strong>负整数</strong>或 <strong>0</strong>，默认值是 0，数值越大，盒子越靠上；</li><li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li><li><strong>数字后面不能加单位</strong>。</li><li>兄弟元素间相互比较（若A在B上面，B的子元素不管怎么设置都不可能覆盖A）</li></ol><p><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</p><h4 id="9-3-3-定位改变display属性"><a href="#9-3-3-定位改变display属性" class="headerlink" title="9.3.3 定位改变display属性"></a>9.3.3 定位改变display属性</h4><p> 前面我们讲过，display 是显示模式， 可以改变显示模式有以下方式:</p><ul><li>可以用inline-block  转换为行内块</li><li>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</li><li>绝对定位和固定定位也和浮动类似， 默认转换的特性转换为<strong>行内块</strong>。</li></ul><p>所以说， 一个行内的盒子，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，不用转换，就可以给这个盒子直接设置宽度和高度等。</p><p><strong>同时注意：</strong></p><p>浮动元素、绝对定位(固定定位）元素不再有外边距合并（塌陷）的问题。</p><h3 id="9-4-定位小结"><a href="#9-4-定位小结" class="headerlink" title="9.4 定位小结"></a>9.4 定位小结</h3><table><thead><tr><th>定位模式</th><th>是否脱标占有位置</th><th align="left">移动位置基准</th><th>模式转换（行内块）</th><th>使用情况</th></tr></thead><tbody><tr><td>静态static</td><td>不脱标，正常模式</td><td align="left">正常模式</td><td>不能</td><td>几乎不用</td></tr><tr><td>相对定位relative</td><td>不脱标，占有位置</td><td align="left">相对自身位置移动</td><td>不能</td><td>基本单独使用</td></tr><tr><td>绝对定位absolute</td><td>完全脱标，不占有位置</td><td align="left">相对于定位父级移动位置</td><td>能</td><td>要和定位父级元素搭配使用</td></tr><tr><td>固定定位fixed</td><td>完全脱标，不占有位置</td><td align="left">相对于浏览器移动位置</td><td>能</td><td>单独使用，不需要父级</td></tr></tbody></table><h2 id="10-CSS书写规范"><a href="#10-CSS书写规范" class="headerlink" title="10. CSS书写规范"></a>10. CSS书写规范</h2><h3 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h3><p>【强制】 选择器 与 { 之间必须包含空格。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.selector</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【强制】 属性名与之后的 : 之间不允许包含空格， : 与 属性值之间必须包含空格。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span>: 12<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><h3 id="选择器规范"><a href="#选择器规范" class="headerlink" title="选择器规范"></a>选择器规范</h3><p>【强制】 并集选择器，每个选择器声明必须独占一行。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* good */</span><br><span class="line">.post,</span><br><span class="line">.page,</span><br><span class="line">.comment &#123;</span><br><span class="line">    line-height: 1.5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* bad */</span><br><span class="line">.post, .page, .comment &#123;</span><br><span class="line">    line-height: 1.5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【建议】 一般情况下，选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-id">#username</span> <span class="selector-tag">input</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.comment</span> <span class="selector-class">.avatar</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.header</span> <span class="selector-class">.login</span>  <span class="selector-tag">input</span> &#123;&#125;</span><br><span class="line"><span class="selector-class">.comment</span> <span class="selector-tag">div</span> * &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="属性规范"><a href="#属性规范" class="headerlink" title="属性规范"></a>属性规范</h3><p>【强制】 属性定义必须另起一行。以分号结尾</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.selector</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.selector</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="11-CSS补充知识"><a href="#11-CSS补充知识" class="headerlink" title="11. CSS补充知识"></a>11. CSS补充知识</h2><h3 id="11-1-元素的显示与隐藏"><a href="#11-1-元素的显示与隐藏" class="headerlink" title="11.1  元素的显示与隐藏"></a>11.1  元素的显示与隐藏</h3><ul><li><p>目的</p><p>让一个元素在页面中消失或者显示出来</p></li><li><p>场景</p><p>类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！</p></li></ul><h4 id="11-1-1-display-显示（重点）"><a href="#11-1-1-display-显示（重点）" class="headerlink" title="11.1.1 display 显示（重点）"></a>11.1.1 display 显示（重点）</h4><ul><li>display 设置或检索对象是否及如何显示。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">none</span>; <span class="comment">/*隐藏对象*/</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">block</span>; <span class="comment">/*除了转换为块级元素之外，同时还有显示元素的意思。*/</span></span><br></pre></td></tr></table></figure><ul><li>特点： 隐藏之后，不再保留位置。</li></ul><p>实际开发场景：</p><blockquote><p>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</p></blockquote><h4 id="11-1-2-visibility-可见性-了解"><a href="#11-1-2-visibility-可见性-了解" class="headerlink" title="11.1.2 visibility 可见性 (了解)"></a>11.1.2 visibility 可见性 (了解)</h4><ul><li>设置或检索是否显示对象。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">visibility</span>: <span class="selector-tag">visible</span>; 　<span class="comment">/*对象可视*/</span></span><br><span class="line"><span class="selector-tag">visibility</span>: <span class="selector-tag">hidden</span>; 　  <span class="comment">/*对象隐藏*/</span></span><br></pre></td></tr></table></figure><ul><li>特点： 隐藏之后，继续保留原有位置。（停职留薪）</li></ul><h4 id="11-1-3-overflow-溢出-重点"><a href="#11-1-3-overflow-溢出-重点" class="headerlink" title="11.1.3 overflow 溢出(重点)"></a>11.1.3 overflow 溢出(重点)</h4><ul><li>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</li></ul><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>visible</strong></td><td>不剪切内容也不添加滚动条（默认）</td></tr><tr><td><strong>hidden</strong></td><td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td></tr><tr><td><strong>scroll</strong></td><td>不管超出内容否，总是显示滚动条，包括上下和左右</td></tr><tr><td><strong>auto</strong></td><td>超出自动显示滚动条，不超出不显示滚动条</td></tr></tbody></table><p>实际开发场景：</p><ol><li>清除浮动</li><li>隐藏超出内容，隐藏掉,  不允许内容超过父盒子。</li></ol><h4 id="11-1-4-显示与隐藏总结"><a href="#11-1-4-显示与隐藏总结" class="headerlink" title="11.1.4 显示与隐藏总结"></a>11.1.4 显示与隐藏总结</h4><table><thead><tr><th>属性</th><th>区别</th><th>用途</th></tr></thead><tbody><tr><td><strong>display</strong></td><td>隐藏对象，不保留位置</td><td>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</td></tr><tr><td><strong>visibility</strong></td><td>隐藏对象，保留位置</td><td>使用较少</td></tr><tr><td><strong>overflow</strong></td><td>只是隐藏超出大小的部分</td><td>1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围</td></tr></tbody></table><h3 id="11-2-鼠标样式-cursor"><a href="#11-2-鼠标样式-cursor" class="headerlink" title="11.2  鼠标样式 cursor"></a>11.2  鼠标样式 cursor</h3><p> 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>default</strong></td><td>小白  默认</td></tr><tr><td><strong>pointer</strong></td><td>小手</td></tr><tr><td><strong>move</strong></td><td>移动</td></tr><tr><td><strong>text</strong></td><td>文本</td></tr><tr><td><strong>not-allowed</strong></td><td>禁止</td></tr><tr><td>url()</td><td>图片</td></tr><tr><td>none</td><td>鼠标消失</td></tr><tr><td>help</td><td>问号</td></tr><tr><td>zoom-in</td><td>放大镜</td></tr><tr><td>zoom-out</td><td>缩小镜</td></tr></tbody></table><h3 id="11-3-轮廓线-outline"><a href="#11-3-轮廓线-outline" class="headerlink" title="11.3 轮廓线 outline"></a>11.3 轮廓线 outline</h3><p> 是绘制于元素周围的一条线，位于border的外围，不占空间，不影响元素布局，可起到突出元素的作用。如input输入框</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outline: outline-color ||outline-style || outline-width;</span><br></pre></td></tr></table></figure><p> 四个边不能单独设置</p><p>但是我们都不关心可以设置多少，我们平时都是去掉的。</p><p>最直接的写法是 ：  outline: 0;   或者  outline: none;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>  <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">style</span>=<span class="string">"outline: 0;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="11-4-防止拖拽文本域-resize"><a href="#11-4-防止拖拽文本域-resize" class="headerlink" title="11.4 防止拖拽文本域 resize"></a>11.4 防止拖拽文本域 resize</h3><p>实际开发中，我们文本域右下角是不可以拖拽：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>  <span class="attr">style</span>=<span class="string">"resize: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="11-5-vertical-align-了解不推荐使用"><a href="#11-5-vertical-align-了解不推荐使用" class="headerlink" title="11.5 vertical-align (了解不推荐使用)"></a>11.5 vertical-align (了解不推荐使用)</h3><p><strong>行内</strong>、<strong>行内块</strong>、表单元格 垂直方向的对齐方式: vertical-align</p><p><img src="xian.jpg" alt></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vertical-align:baseline | sub | super | top(对齐line) | text-top(对齐文字) | middle | bottom | text-bottom | &lt;percentage&gt;(参照line-height向上) | &lt;length&gt;(参照baseline向上);</span><br><span class="line"><span class="selector-tag">baseline</span>: 当前元素的基线和父元素的基线对齐;</span><br><span class="line"><span class="selector-tag">middle</span>: 当前元素的中线和父元素的基线加上<span class="selector-tag">x</span>高度的一半对齐;</span><br></pre></td></tr></table></figure><ul><li><p>注意：</p><p>vertical-align 不影响块级元素中的内容对齐，它只针对于<strong>行内元素</strong>或者<strong>行内块元素</strong>，</p><p>但是由于操作非常复杂,我们工作中基本不使用</p></li></ul><p><strong>去除图片底侧空白缝隙</strong></p><p><img src="vertical.png" alt></p><ul><li><p>原因：</p><pre><code>图片或者表单等行内块元素，他的基线会和父级盒子的基线对齐。就是图片底侧会有一个空白缝隙。</code></pre></li><li><p>解决方法：</p><ul><li>给img vertical-align:middle等等。  让图片不要和基线对齐。</li><li>给img 添加 display：block; 转换为块级元素就不会存在问题了。<strong>推荐使用</strong></li></ul></li></ul><h3 id="文字溢出省略号显示"><a href="#文字溢出省略号显示" class="headerlink" title="文字溢出省略号显示"></a>文字溢出省略号显示</h3><h4 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a><code>white-space</code></h4><p>设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">white-space</span>:</span><br><span class="line">  <span class="selector-tag">normal</span>;  <span class="comment">/* 默认处理方式 */</span></span><br><span class="line">  <span class="selector-tag">nowrap</span>;　<span class="comment">/* 强制在同一行内显示所有文本，直到文本结束或者遭遇 br 标签才换行 */</span></span><br></pre></td></tr></table></figure><h4 id="text-overflow"><a href="#text-overflow" class="headerlink" title="text-overflow"></a><code>text-overflow</code></h4><p>设置或检索是否使用一个省略标记（…）标示对象内文本的溢出</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">text-overflow</span>:</span><br><span class="line">  <span class="selector-tag">clip</span>; 不显示省略标记(...)，而是简单的裁切</span><br><span class="line">  <span class="selector-tag">ellipsis</span>; 当对象内文本溢出时显示省略标记(...)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：一定要首先强制一行内显示，再次和 overflow 属性搭配使用</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 强制一行内显示文本 */</span></span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 强制最多三行显示文本 */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 超出的部分隐藏 */</span></span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="comment">/* 文字用省略号替代超出的部分 */</span></span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br></pre></td></tr></table></figure><h3 id="换行方式"><a href="#换行方式" class="headerlink" title="换行方式"></a>换行方式</h3><p>浏览器默认情况下，如果一个单词很长，导致一行中剩下的空间已经放不下时，浏览器会把这个单词挪到下一行去</p><p>word-wrap: break-word 标明是否允许浏览器在单词内进行断句，他会首先尝试挪到下一行，看看下一行的宽度够不够，不够的话就进行单词内的断句。</p><p>word-break 属性规定自动换行的处理方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word-break: normal|break-all|keep-all</span><br><span class="line">normal：使用浏览器默认的换行规则</span><br><span class="line">break-all：允许在单词内换行，它不会尝试把长单词挪到下一行，而是直接进行单词内的断句</span><br><span class="line">keep-all：只能在半角空格或连字符处换行</span><br></pre></td></tr></table></figure><p>white-space：normal | pre | nowrap | pre-wrap | pre-line</p><p>normal：连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nowrap：和 normal 一样，连续的空白符会被合并。但换行符无效，除非手动添加换行标签</span><br><span class="line">pre：所有空白符都会被保留。不会自动换行，原样输出</span><br><span class="line">pre-wrap：保留空白符序列，但是正常地进行换行</span><br><span class="line">pre-line：合并空白符序列，但是保留换行符</span><br></pre></td></tr></table></figure><h3 id="pre-标签换行"><a href="#pre-标签换行" class="headerlink" title="pre 标签换行"></a>pre 标签换行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pre</span> &#123;</span><br><span class="line">  <span class="attribute">white-space</span>: pre-wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-7-CSS精灵技术（sprite-重点"><a href="#11-7-CSS精灵技术（sprite-重点" class="headerlink" title="11.7 CSS精灵技术（sprite) 重点"></a>11.7 CSS精灵技术（sprite) 重点</h3><p>CSS精灵技术（也称CSS Sprites、CSS雪碧）。</p><p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），通过background属性精确定位到精灵图中的某个小图。</p><h3 id="11-8-滑动门"><a href="#11-8-滑动门" class="headerlink" title="11.8 滑动门"></a>11.8 滑动门</h3><p>各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。</p><p>一般的经典布局都是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>导航栏内容<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(images/wx.jpg) repeat-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">33px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">33px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>  <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(./images/to.png) no-repeat left ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">33px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(./images/to.png) no-repeat right ;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:hover</span>,</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>(./images/ao.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>a 设置 背景左侧，padding撑开合适宽度。</li><li>span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。</li><li>之所以a包含span就是因为 整个导航都是可以点击的。</li></ol><h2 id="12-CSS三角形"><a href="#12-CSS三角形" class="headerlink" title="12. CSS三角形"></a>12. CSS三角形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;  <span class="comment">/*宽度高度为0*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">0</span>; <span class="comment">/*照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;*/</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">10px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">10px</span> solid green;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid blue;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">10px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> html&amp;css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html 基础</title>
      <link href="/2018/html&amp;css/html/"/>
      <url>/2018/html&amp;css/html/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="认识WEB"><a href="#认识WEB" class="headerlink" title="认识WEB"></a>认识WEB</h2><h3 id="认识网页"><a href="#认识网页" class="headerlink" title="认识网页"></a>认识网页</h3><p>!&gt; 网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器是网页显示、运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。</p><h4 id="常见浏览器内核（了解）"><a href="#常见浏览器内核（了解）" class="headerlink" title="常见浏览器内核（了解）"></a>常见浏览器内核（了解）</h4><p>浏览器内核，英文叫做：Rendering Engine，中文翻译很多，排版引擎、解释引擎、渲染引擎，现在流行称为浏览器内核，负责读取网页内容，整理讯息，计算网页的显示方式并显示页面</p><p>因为浏览器太多啦， 但是现在主要流行的就是下面几个：</p><table><thead><tr><th align="left">浏览器</th><th align="center">内核</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">IE</td><td align="center">Trident</td><td align="left">IE、猎豹安全、360极速浏览器、百度浏览器</td></tr><tr><td align="left">firefox</td><td align="center">Gecko</td><td align="left">可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。</td></tr><tr><td align="left">Safari</td><td align="center">webkit</td><td align="left">从Safari推出之时起，它的渲染引擎就是Webkit，一提到 webkit，首先想到的便是 chrome，可以说，chrome 将 Webkit内核 深入人心，殊不知，Webkit 的鼻祖其实是 Safari。</td></tr><tr><td align="left">chrome</td><td align="center">Chromium/Blink</td><td align="left">在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发</td></tr><tr><td align="left">Opera</td><td align="center">blink</td><td align="left">现在跟随chrome用blink内核。</td></tr></tbody></table><p><strong>拓展阅读：</strong></p><ul><li><p>移动端的浏览器内核主要说的是系统内置浏览器的内核。</p></li><li><p>Android 手机而言，使用率最高的就是 Webkit 内核，大部分国产浏览器宣称的自己的内核，基本上也是属于 webkit 二次开发。</p></li><li><p>iOS 以及 WP7 平台上，由于系统原因，系统大部分自带浏览器内核，一般是 Safari 或者 IE 内核 Trident 的</p></li></ul><h3 id="Web标准（重点）"><a href="#Web标准（重点）" class="headerlink" title="Web标准（重点）"></a>Web标准（重点）</h3><p>Web标准是由W3C组织和其他标准化组织制定的一系列标准的集合。</p><p>W3C 万维网联盟是国际最著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。</p><p><strong>w3c就类似于现实世界中的联合国。</strong></p><h4 id="Web-标准的好处"><a href="#Web-标准的好处" class="headerlink" title="Web 标准的好处"></a>Web 标准的好处</h4><p>遵循web标准可以让不同我们写的页面更标准更统一外，还有许多优点：</p><ul><li><p>让Web的发展前景更广阔</p></li><li><p>内容能被更广泛的设备访问</p></li><li><p>更容易被搜寻引擎搜索</p></li><li><p>降低网站流量费用</p></li><li><p>使网站更易于维护</p></li><li><p>提高页面浏览速度</p></li></ul><h4 id="Web-标准构成"><a href="#Web-标准构成" class="headerlink" title="Web 标准构成"></a>Web 标准构成</h4><p><strong>构成：</strong> 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。</p><table><thead><tr><th align="left">标准</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">结构</td><td align="left">结构用于对<strong>网页元素</strong>进行整理和分类，咱们主要学的是HTML。</td></tr><tr><td align="left">表现</td><td align="left">表现用于设置网页元素的版式、颜色、大小等<strong>外观样式</strong>，主要指的是CSS</td></tr><tr><td align="left">行为</td><td align="left">行为是指网页模型的定义及<strong>交互</strong>的编写，咱们主要学的是 Javascript</td></tr></tbody></table><p> 理想状态我们的源码： .HTML      .css      .js</p><h3 id="web-标准小结"><a href="#web-标准小结" class="headerlink" title="web 标准小结"></a>web 标准小结</h3><ul><li>web标准有三层结构，分别是结构（html）、表现（css）和行为（javascript）</li><li>理想状态下，他们三层都是独立的， 放到不同的文件里面</li></ul><h3 id="深度阅读："><a href="#深度阅读：" class="headerlink" title="深度阅读："></a>深度阅读：</h3><p><a href="http://blog.csdn.net/summer_15/article/details/71249203" target="_blank" rel="noopener">五大主流浏览器内核的源起以及国内各大浏览器内核总结</a></p><h2 id="HTML-初识"><a href="#HTML-初识" class="headerlink" title="HTML 初识"></a>HTML 初识</h2><h3 id="超文本标记语言"><a href="#超文本标记语言" class="headerlink" title="超文本标记语言"></a>超文本标记语言</h3><ul><li><p>HTML 指的是超文本标记语言 (<strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage)是用来描述网页的一种语言。</p></li><li><p>HTML 不是一种编程语言，而是一种<strong>标记语言</strong> (markup language)</p></li><li><p>标记语言是一套标记标签 (markup tag)</p></li></ul><p><strong>所谓超文本，有2层含义：</strong></p><ol><li>因为它可以加入图片、声音、动画、多媒体等内容（*<em>超越文本限制 *</em>）</li><li>不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（*<em>超级链接文本 *</em>）。</li></ol><h4 id="HTML骨架标签"><a href="#HTML骨架标签" class="headerlink" title="HTML骨架标签"></a>HTML骨架标签</h4><p><strong>标签：</strong></p><p>在 HTML 页面中，带有 <code>&lt; &gt;</code> 符号的元素被称为HTML标签，</p><p>HTML 骨架格式（一个html的基本格式）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>   <span class="comment">&lt;!--HTML标签:页面中最大的标签，我们称为根标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>     <span class="comment">&lt;!--文档的头部,注意在head标签中我们必须要设置的标签是title--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="comment">&lt;!--文档的标题,让页面拥有一个属于自己的网页标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="comment">&lt;!--文档的主体包含文档的所有内容，页面内容基本都是放到body里面的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>HTML标签名、类名、标签属性和大部分属性值统一用小写</p></blockquote><h4 id="HTML标签分类"><a href="#HTML标签分类" class="headerlink" title="HTML标签分类"></a>HTML标签分类</h4><p><strong>分类：</strong></p><ol><li>双标签</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名</span>&gt;</span> 内容 <span class="tag">&lt;/<span class="name">标签名</span>&gt;</span>   比如 <span class="tag">&lt;<span class="name">body</span>&gt;</span>  我是文字  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。</li><li>和开始标签相比，结束标签只是在前面加了一个关闭符“/”。</li><li>我们以后接触的基本都是双标签</li></ul><ol start="2"><li>单标签</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名</span>&gt;</span>  比如  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>里面不需要包含内容， 只有一个开始标签不需要关闭。</li></ul><h4 id="HTML标签关系"><a href="#HTML标签关系" class="headerlink" title="HTML标签关系"></a>HTML标签关系</h4><p>主要针对于<strong>双标签</strong> 的相互关系分为两种：  请大家务必熟悉记住这种标签关系，因为后面我们标签嵌套特别多，很容易弄混他们的关系。</p><ol><li>嵌套关系</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.并列关系</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>书写规范：</strong></p><blockquote><p>如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位（一个tab是4个或2个空格）。如果是并列关系，最好上下对齐。</p></blockquote><h3 id="代码开发工具（书写代码）"><a href="#代码开发工具（书写代码）" class="headerlink" title="代码开发工具（书写代码）"></a>代码开发工具（书写代码）</h3><ul><li><p>Dreamweaver</p></li><li><p>SublimeText</p></li><li><p>WebStorm</p></li><li><p>HBuilder</p></li><li><p>VScode</p></li></ul><p>sublime有非常多的优点， 最开心的就是非常轻量级，打开速度超快，后面更高的功能，后面再接触。</p><p><strong>sublime生成html骨架小技巧</strong></p><ul><li><p>双击打开软件</p></li><li><p>新建文件（ctrl+n）</p></li><li><p>保存（ctrl+s）,保存为：文件名.html （ 注意 后缀名必须是 .html )</p></li><li><p>放大缩小代码  按住 ctrl  在 滚动鼠标滚轮  或者   ctrl+ 加号 键     和 ctrl +   减号键</p></li><li><p>生成页面骨架结构</p><ul><li>html: 5    按下tab键    或者</li><li>!    按下tab键</li></ul></li><li><p>在浏览器中预览页面</p><ul><li>右键在  浏览器中打开</li></ul></li></ul><h3 id="文档类型-lt-DOCTYPE-gt"><a href="#文档类型-lt-DOCTYPE-gt" class="headerlink" title="文档类型&lt;!DOCTYPE&gt;"></a>文档类型&lt;!DOCTYPE&gt;</h3><p><strong>用法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure><p><strong>作用：</strong></p><!DOCTYPE><p> 声明位于文档中的最前面的位置，处于 <html> 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。</html></p>   <!DOCTYPE html><p>  就是告诉浏览器按照HTML5 规范解析页面.</p><p><strong>团队约定：</strong></p><blockquote><p>HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明</p></blockquote><h3 id="页面语言-lang"><a href="#页面语言-lang" class="headerlink" title="页面语言 lang"></a>页面语言 lang</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>  指定html 语言种类</span><br></pre></td></tr></table></figure><p>最常见的2个：</p><ol><li><code>en</code>定义语言为英语</li><li><code>zh-CN</code>定义语言为中文</li></ol><blockquote><p> <code>&lt;html lang=&quot;zh-CN&quot;&gt;</code>  指定该 html 标签内容所用的语言为中文</p></blockquote><p><strong>团队约定：</strong></p><blockquote><p>考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值</p></blockquote><p><strong>@拓展阅读：</strong></p><p>简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理Html的程序对页面语言内容来做一些对应的处理或者事情。<br>比如可以</p><ul><li><p>告诉搜索引擎做精确的识别</p></li><li><p>让语法检查程序做语言识别</p></li><li><p>帮助翻译工具做识别</p></li><li><p>帮助网页阅读程序做识别等等</p></li></ul><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符集(Character set)是多个字符的集合。</span><br><span class="line">计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</span><br></pre></td></tr></table></figure><p>utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。</p><ul><li><p>gb2312 简单中文  包括6763个汉字  GUO BIAO</p></li><li><p>BIG5   繁体中文 港澳台等用</p></li><li><p>GBK包含全部中文字符    是GB2312的扩展，加入对繁体字的支持，兼容GB2312</p></li><li><p>这句话是告诉浏览器当前html文档使用UTF-8进行的字符编码。</p></li></ul><p><strong>团队约定：</strong></p><blockquote><p>一般情况下统一使用 “UTF-8” 编码, 请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。</p></blockquote><h3 id="HTML标签的语义化"><a href="#HTML标签的语义化" class="headerlink" title="HTML标签的语义化"></a>HTML标签的语义化</h3><p>白话： 所谓标签语义化，就是指标签的含义。</p><blockquote><p>根据标签的语义，在合适的地方给一个最为合理的标签，让结构更清晰。</p></blockquote><ol><li><p>方便代码的阅读和维护</p></li><li><p>同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容</p></li><li><p>使用语义化标签会具有更好地搜索引擎优化（SEO）</p></li></ol><p>语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。(  裸奔起来一样好看 )</p><p>遵循的原则：先确定语义的HTML ，再选合适的CSS。所以，<strong>我们接下来学习html标签，要根据语义去记忆。</strong> HTML网页中任何元素的实现都要依靠HTML标签。</p><h2 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h2><p> 首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。</p><p> HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。</p><h3 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h3><p>排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。</p><h4 id="标题标签h-熟记"><a href="#标题标签h-熟记" class="headerlink" title="标题标签h (熟记)"></a>标题标签h (熟记)</h4><p> 单词缩写：  head   头部. 标题       title  文档标题</p><p>为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即</p><p><strong>标题标签语义：</strong>  作为标题使用，并且依据重要性递减</p><p>其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>   标题文本   <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>   标题文本   <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>   标题文本   <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>   标题文本   <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>   标题文本   <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>   标题文本   <span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果如下：</p><p><img src="h.png" alt></p><p><strong>小结 :</strong></p><ul><li>加了标题的文字会变的加粗，字号也会依次变大</li><li>一行是只能放一个标题的</li></ul><h4 id="段落标签p-熟记"><a href="#段落标签p-熟记" class="headerlink" title="段落标签p ( 熟记)"></a>段落标签p ( 熟记)</h4><p>单词缩写：  paragraph  段落  [ˈpærəgræf]    无须记这个单词</p><p><strong>作用语义：</strong></p><p>可以把 HTML 文档分割为若干段落</p><p> 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>  文本内容  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</p><h4 id="水平线标签hr-认识"><a href="#水平线标签hr-认识" class="headerlink" title="水平线标签hr(认识)"></a>水平线标签hr(认识)</h4><p>单词缩写：  horizontal  横线    [ˌhɔrəˈzɑntl]    同上</p><p>在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，<hr>就是创建横跨网页水平线的标签。其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span>是单标签</span><br></pre></td></tr></table></figure><h4 id="换行标签br-熟记"><a href="#换行标签br-熟记" class="headerlink" title="换行标签br (熟记)"></a>换行标签br (熟记)</h4><p>单词缩写：  break   打断 ,换行</p><p>在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="div-和-span标签-重点"><a href="#div-和-span标签-重点" class="headerlink" title="div 和  span标签(重点)"></a>div 和  span标签(重点)</h4><p>div   span    是没有语义的     是我们网页布局主要的2个盒子   想必你听过  css+div</p><p>div 就是  division  的缩写   分割， 分区的意思  其实有很多div 来组合网页。</p><p>span   跨度，跨距；范围</p><p>语法格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 这是头部 <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">span</span>&gt;</span>今日价格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 只不过他们有区别，现在我们主要记住使用方法和特点就好了</p><ul><li>div标签  用来布局的，一行只能放一个div</li><li>span标签  用来布局的，一行上可以放好多个span</li></ul><p>后面后面讲显示模式的时候，会告诉大家</p><h4 id="排版标签总结"><a href="#排版标签总结" class="headerlink" title="排版标签总结"></a>排版标签总结</h4><table><thead><tr><th>标签名</th><th align="left">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td><code>&lt;hx&gt;&lt;/hx&gt;</code></td><td align="left">标题标签</td><td align="left">作为标题使用，并且依据重要性递减</td></tr><tr><td><code>&lt;p&gt;&lt;/p&gt;</code></td><td align="left">段落标签</td><td align="left">可以把 HTML 文档分割为若干段落</td></tr><tr><td><code>&lt;hr /&gt;</code></td><td align="left">水平线标签</td><td align="left">没啥可说的，就是一条线</td></tr><tr><td><code>&lt;br /&gt;</code></td><td align="left">换行标签</td><td align="left"></td></tr><tr><td><code>&lt;div&gt;&lt;/div&gt;</code></td><td align="left">div标签</td><td align="left">用来布局的，但是现在一行只能放一个div</td></tr><tr><td><code>&lt;span&gt;&lt;/span&gt;</code></td><td align="left">span标签</td><td align="left">用来布局的，一行上可以放好多个span</td></tr></tbody></table><h3 id="文本格式化标签-熟记"><a href="#文本格式化标签-熟记" class="headerlink" title="文本格式化标签(熟记)"></a>文本格式化标签(熟记)</h3><p>在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。</p><ul><li><code>&lt;strong&gt;&lt;/strong&gt;</code> 加粗强调</li><li><code>&lt;i&gt;&lt;/i&gt;</code> 倾斜</li></ul><h2 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h2><p>使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签名</span> 属性<span class="attr">1</span>=<span class="string">"属性值1"</span> 属性<span class="attr">2</span>=<span class="string">"属性值2"</span> …&gt;</span> 内容 <span class="tag">&lt;/<span class="name">标签名</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">手机</span> 颜色=<span class="string">"红色"</span> 大小=<span class="string">"5寸"</span>&gt;</span>  <span class="tag">&lt;/<span class="name">手机</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片标签img-重点"><a href="#图片标签img-重点" class="headerlink" title="图片标签img (重点)"></a>图片标签img (重点)</h3><p>单词缩写：   image  图像</p><p>要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签<code>&lt;img&gt;</code>以及和他相关的属性。（它是一个单身狗）</p><p>语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图像URL"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。</p><ul><li><p>src 图像的路径</p></li><li><p>alt 图像不能显示时的替换文本</p></li><li><p>title 鼠标悬停时显示的文本</p></li><li><p>width 设置图像的宽度</p></li><li><p>height 设置图像的高度</p></li></ul><p><strong>注意:</strong></p><ol><li><p>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</p></li><li><p>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</p></li><li><p>采取  键值对 的格式   key=”value”  的格式</p></li></ol><p>比如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">正常的<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cz.jpg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    带有边框的<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cz.jpg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span> <span class="attr">border</span>=<span class="string">"3"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">有提示文本的<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cz.jpg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span> <span class="attr">border</span>=<span class="string">"3"</span> <span class="attr">title</span>=<span class="string">"这是个小蒲公英"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">有替换文本的<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cz.jpg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span> <span class="attr">border</span>=<span class="string">"3"</span> <span class="attr">alt</span>=<span class="string">"图片不存在"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>重点掌握点：</strong></p><ul><li>请说出 图像标签哪个属性是必须要写的？</li><li>请说出 图像标签中 alt 和  title 属性区别？</li></ul><h3 id="链接标签-重点"><a href="#链接标签-重点" class="headerlink" title="链接标签(重点)"></a>链接标签(重点)</h3><p>单词缩写：  anchor 的缩写  [ˈæŋkə(r)] 。基本解释 锚, 铁锚 的</p><p>在HTML中创建超链接非常简单，只需用标签把文字包括起来就好。</p><p>语法格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"跳转目标"</span> <span class="attr">target</span>=<span class="string">"目标窗口的弹出方式"</span>&gt;</span>文本或图像<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:邮箱"</span>&gt;</span>文本或图像<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>href</td><td align="left">用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能</td></tr><tr><td>target</td><td align="left">用于指定链接页面的打开方式，其取值有<code>_self</code>、<code>_blank</code>、<code>inner</code>，其中_self为默认值，__blank为在新窗口中打开，inner在内部打开。</td></tr></tbody></table><p><strong>注意：</strong></p><ol><li><p>在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。图片链接： <code>&lt;a href=&quot; &quot;&gt;&lt;img src=&quot; &quot;&gt;&lt;/a&gt;</code></p></li><li><p>style属性：<strong>text-decoration:none</strong> 链接没有下划线</p></li><li><p><code>#</code> 链接到文档顶部（什么都不写也会返回到页面顶端）</p></li><li><p>跳转某一页面某一锚点<code>&lt;a href=&quot;index.html#锚点&quot;&gt;&lt;/a&gt;</code></p></li><li><p>空连接 <code>javascript:void(null)</code></p></li><li><p>链接css： <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;mycss.css&quot; /&gt;</code></p></li><li><p>链接js： <code>&lt;script type=&quot;text/javascript&quot; src=&quot;myscripts.js&quot;&gt;&lt;/script&gt;</code></p></li></ol><h3 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h3><p>在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。</p><p>简单解释：</p><p>注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。</p><p>语法格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释语句 --&gt;</span>     快捷键是：    ctrl + /       或者 ctrl +shift + /</span><br></pre></td></tr></table></figure><p>注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行</p><h3 id="表格标签-table"><a href="#表格标签-table" class="headerlink" title="表格标签 table"></a>表格标签 table</h3><p>目标：</p><ul><li><p>理解：</p><ul><li>能说出表格用来做什么的</li><li>表格的基本结构组成</li></ul></li><li><p>应用：</p><ul><li><p>能够熟练写出n行n列的表格</p></li><li><p>能简单的合并单元格</p></li></ul></li></ul><p><strong>表格作用：</strong></p><p> 表格现在还是较为常用的一种标签，但不是用来布局，而是<strong>显示、展示表格式数据。</strong></p><p>因为它可以让数据显示的非常的规整，可读性非常好。</p><p><strong>特别是后台展示数据的时候表格运用是否熟练就显得很重要</strong>，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然 div 布局也可以做到，但是总没有表格来得方便。</p><h4 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h4><p>在HTML网页中，要想创建表格，就需要使用表格相关的标签。</p><p><strong>创建表格的基本语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>table用于定义一个表格标签。</p></li><li><p>tr标签 用于定义表格中的行，必须嵌套在 table标签中。</p></li><li><p>td 用于定义表格中的单元格，必须嵌套在 <code>&lt;tr&gt;&lt;/tr&gt;</code> 标签中。</p></li><li><p>字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。</p></li></ol><p>*<em>总结： *</em></p><ul><li>表格的主要目的是用来显示特殊数据的</li><li>一个完整的表格有表格标签（table），行标签（tr），单元格标签（td）组成，没有列的标签</li></ul><ul><li><code>&lt;tr&gt;&lt;/tr&gt;</code> 中只能嵌套 <code>&lt;td&gt;&lt;/td&gt;</code> 类的单元格</li><li><code>&lt;td&gt;&lt;/td&gt;</code> 标签，他就像一个容器，可以容纳所有的元素</li></ul><h4 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h4><p>表格有部分属性我们不常用，这里重点记住 cellspacing 、 cellpadding。</p><ul><li><p><code>border</code>  设置表格的边框  <code>border=&quot;1px dashed #ccc&quot;</code> dashed 虚线</p></li><li><p><code>cellspacing</code> 设置单元格与单元格边框之间的空白距离</p></li><li><p><code>cellpadding</code> 设置单元格内容与单元格边框之间的空白距离</p></li><li><p><code>width</code> 设置表格宽度</p></li><li><p><code>height</code> 设置表格高度</p></li><li><p><code>align</code> 设置表格水平对齐方式 （left center right）</p><ul><li>写在table标签中控制表格位置</li><li>写在tr标签中控制表格内文本位置</li></ul></li></ul><h4 id="表头单元格标签-th"><a href="#表头单元格标签-th" class="headerlink" title="表头单元格标签 th"></a>表头单元格标签 th</h4><ul><li>作用：<ul><li>一般表头单元格位于表格的第一行或第一列，并且文本加粗居中</li></ul></li><li>语法：<ul><li>只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。</li></ul></li></ul><blockquote><p><code>th</code> 也是一个单元格   只不过和普通的 td单元格不一样，它会让自己里面的文字居中且加粗</p></blockquote><h4 id="表格标题caption"><a href="#表格标题caption" class="headerlink" title="表格标题caption"></a>表格标题caption</h4><p><strong>定义和用法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">caption</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">          我是表格标题</span><br><span class="line">       <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>*<em>注意： *</em></p><ol><li><p>caption 元素定义<strong>表格标题</strong>，通常这个标题会被居中且显示于表格之上。</p></li><li><p>caption 标签必须紧随 table 标签之后。</p></li><li><p>这个标签只存在表格里面才有意义。</p></li><li><p>caption 没有加粗效果，一般用 h 标签实现加粗</p></li></ol><h4 id="合并单元格-难点"><a href="#合并单元格-难点" class="headerlink" title="合并单元格(难点)"></a>合并单元格(难点)</h4><p>合并单元格2种方式：</p><ul><li>跨行合并（向下合并）：rowspan=”合并单元格的个数”</li><li>跨列合并（向右合并）：colspan=”合并单元格的个数”</li></ul><blockquote><p> 合并后需删除多余的单元格</p></blockquote><h4 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h4><table><thead><tr><th>标签名</th><th align="left">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td><code>&lt;table&gt;&lt;/table&gt;</code></td><td align="left">表格标签</td><td align="left">就是一个四方的盒子</td></tr><tr><td><code>&lt;tr&gt;&lt;/tr&gt;</code></td><td align="left">表格行标签</td><td align="left">行标签要再table标签内部才有意义</td></tr><tr><td><code>&lt;td&gt;&lt;/td&gt;</code></td><td align="left">单元格标签</td><td align="left">单元格标签是个容器级元素，可以放任何东西</td></tr><tr><td><code>&lt;th&gt;&lt;/th&gt;</code></td><td align="left">表头单元格标签</td><td align="left">它还是一个单元格，但是里面的文字会居中且加粗</td></tr><tr><td><code>&lt;caption&gt;&lt;/caption&gt;</code></td><td align="left">表格标题标签</td><td align="left">表格的标题，跟着表格一起走，和表格居中对齐</td></tr><tr><td><code>clospan</code> 和 <code>rowspan</code></td><td align="left">合并属性</td><td align="left">用来合并单元格的</td></tr></tbody></table><ol><li><p>表格提供了HTML 中定义表格式数据的方法。</p></li><li><p>表格中由行中的单元格组成。</p></li><li><p>表格中没有列元素，列的个数取决于行的单元格个数。</p></li><li><p>表格不要纠结于外观，那是CSS 的作用。</p></li><li><p>表格的学习要求：  能手写表格结构，并且能简单合并单元格。</p></li></ol><h4 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读@"></a>拓展阅读@</h4><p>表格划分结构（了解）</p><p>对于比较复杂的表格，表格的结构也就相对的复杂了，所以又将表格分割成三个部分：题头、正文和脚注。而这三部分分别用:thead, tbody, tfoot来标注， 这样更好的分清表格结构</p><ol><li><p><code>&lt;thead&gt;&lt;/thead&gt;</code>：用于定义表格的头部。用来放标题之类的东西。<code>&lt;thead&gt;</code> 内部必须拥有<code>&lt;tr&gt;</code> 标签！</p></li><li><p><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：用于定义表格的主体。放数据本体 。</p></li><li><p><code>&lt;tfoot&gt;&lt;/tfoot&gt;</code> 放表格的脚注之类。</p></li><li><p>以上标签都是放到table标签中。</p></li></ol><h3 id="列表标签（重点）"><a href="#列表标签（重点）" class="headerlink" title="列表标签（重点）"></a>列表标签（重点）</h3><ul><li>特点：用来布局</li></ul><h4 id="无序列表-ul-（重点）"><a href="#无序列表-ul-（重点）" class="headerlink" title="无序列表 ul （重点）"></a>无序列表 ul （重点）</h4><p>无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。</span><br><span class="line">2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。</span><br><span class="line">3. <span class="selector-tag">HTML5</span> 已不支持 &lt;<span class="selector-tag">ul</span>&gt; 属性,用<span class="selector-tag">css</span></span><br><span class="line">   <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style-type</span>:disc;&#125; 圆点列表</span><br><span class="line">   <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style-type</span>:circle;&#125; 圆圈列表</span><br><span class="line">   <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style-type</span>:square;&#125; 正方形列表</span><br><span class="line">   <span class="selector-tag">ul</span>&#123;<span class="attribute">list-style-image</span>: <span class="built_in">url</span>(<span class="string">''</span>);&#125; 指定列表项标记的图像</span><br><span class="line">   <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;<span class="attribute">background-image</span>:<span class="built_in">url</span>(/img.jpg);&#125;</span><br></pre></td></tr></table></figure><h4 id="有序列表-ol-（了解）"><a href="#有序列表-ol-（了解）" class="headerlink" title="有序列表 ol （了解）"></a>有序列表 ol （了解）</h4><p>有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  所有特性基本与ul 一致。  但是实际中比 无序列表 用的少很多。</p><ul><li><p><code>ol</code> start 属性 定义有序列表起始序号</p></li><li><p><code>ol</code> type 属性 定义序号类型</p><ul><li>“A” 大写字母列表</li><li>“a” 小写字母列表</li><li>“I” 罗马字母列表</li><li>“i” 小写罗马字母列表</li></ul></li><li><p><code>ol</code> css 属性 <code>list-style-type</code> 指定列表项标记的类型</p><ul><li>{list-style-type:upper-roman;} 大写罗马字体</li><li>{list-style-type:lower-alpha;} 小写字母</li></ul></li></ul><h4 id="自定义列表（理解）"><a href="#自定义列表（理解）" class="headerlink" title="自定义列表（理解）"></a>自定义列表（理解）</h4><p>定义列表常用于对术语或名词进行解释和描述，自定义列表的列表项前没有任何项目符号。其基本语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词2解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词2解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="列表总结"><a href="#列表总结" class="headerlink" title="列表总结"></a>列表总结</h4><table><thead><tr><th>标签名</th><th align="center">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td><code>&lt;ul&gt;&lt;/ul&gt;</code></td><td align="center"><strong>无序标签</strong></td><td align="left">里面只能包含li    没有顺序，我们以后布局中最常用的列表</td></tr><tr><td><code>&lt;ol&gt;&lt;/ol&gt;</code></td><td align="center">有序标签</td><td align="left">里面只能包含li    有顺序， 使用情况较少</td></tr><tr><td><code>&lt;dl&gt;&lt;/dl&gt;</code></td><td align="center">自定义列表</td><td align="left">里面有2个兄弟， dt 和 dd</td></tr></tbody></table><p>我们现在还没有学布局，现在只要保证2个点：</p><ol><li><p>学会什么时候用无序列表， 学会什么时候用自定义列表</p></li><li><p>无序列表和自定义列表代码怎么写？</p></li><li><p>具体的我们刚才看的布局，等我们学了css 在来全面布局。</p></li></ol><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><p><strong>语法</strong>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"url地址"</span> <span class="attr">method</span>=<span class="string">"提交方式"</span> <span class="attr">name</span>=<span class="string">"表单名称"</span>&gt;</span></span><br><span class="line">  各种表单控件</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>常用属性：</strong></p><table><thead><tr><th>属性</th><th align="left">属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td align="left">url地址</td><td>用于指定接收并处理表单数据的服务器程序的url地址。</td></tr><tr><td>method</td><td align="left">get/post</td><td>用于设置表单数据的提交方式，其取值为get或post。</td></tr><tr><td>name</td><td align="left">名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单。</td></tr></tbody></table><p><strong>作用</strong></p><p>表单目的是为了收集用户信息。</p><blockquote><p>在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。</p></blockquote><p><strong>常用标签</strong>：</p><p><code>&lt;form&gt;</code> 定义供用户输入的表单<br><code>&lt;input&gt;</code>    定义输入域<br><code>&lt;textarea&gt;</code> 定义文本域 (一个多行的输入控件)<br><code>&lt;label&gt;</code>    定义了input元素的标签，一般为输入标题<br><code>&lt;fieldset&gt;</code>    定义了一组相关的表单元素，并使用外框包含起来<br><code>&lt;legend&gt;</code> 定义了 fieldset 元素的标题<br><code>select&gt;</code>    定义了下拉选项列表<br><code>&lt;optgroup&gt;</code> 定义选项组<br><code>&lt;option&gt;</code> 定义下拉列表中的选项 <code>selected</code> 预选<br><code>&lt;button&gt;</code> 定义一个点击按钮<br><code>&lt;datalist&gt;</code> 指定一个预先定义的输入控件选项列表<br><code>&lt;output&gt;</code> 定义一个计算结果</p><p><strong>注意:</strong></p><p>每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form表单域。</p><p><strong>表单控件：</strong>包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</p><p><strong>提示信息：</strong>一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</p><p><strong>表单域：</strong>他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</p><h4 id="input-标签"><a href="#input-标签" class="headerlink" title="input 标签"></a>input 标签</h4><ul><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"属性值"</span> <span class="attr">value</span>=<span class="string">"你好"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>type 属性设置不同的属性值用来指定不同的控件类型</p></li><li><p>除了 type 属性还有别的属性</p></li></ul></li></ul><h5 id="type-属性"><a href="#type-属性" class="headerlink" title="type 属性"></a>type 属性</h5><ul><li>text 单行文本输入框</li><li>password 密码输入框</li><li>radio 单选按钮</li><li>checkbox 复选框</li><li>button 普通按钮</li><li>submit 提交按钮</li><li>reset 重置按钮</li><li>image 图片按钮 ，添加 src 属性引入图片</li><li>file 上传文件</li></ul><h4 id="value-属性值"><a href="#value-属性值" class="headerlink" title="value 属性值"></a>value 属性值</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- input 框在用户未输入时的默认值 --&gt;</span></span><br><span class="line">用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"请输入用户名"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>input <code>placeholder</code> 属性与 <code>value</code> 属性区别</strong></p><ul><li><p><strong>placeholder</strong> 属性提供一种提示，描述输入域所期待的值，提示会在输入字段为空时显示，并会在字段获得焦点时消失。属性适用于以下类型的input标签：text、search、url、telephone、email 以及 password</p></li><li><p><strong>value</strong> 属性为 input 元素设定值，对于不同的输入类型，value 属性的用法也不同</p><ul><li><code>type=&quot;button&quot;, &quot;reset&quot;, &quot;submit&quot;</code> - 定义按钮上的显示的文本</li><li><code>type=&quot;text&quot;, &quot;password&quot;, &quot;hidden&quot;</code> - 定义输入字段的初始值</li><li><code>type=&quot;checkbox&quot;, &quot;radio&quot;, &quot;image&quot;</code> - 定义与输入相关联的值</li></ul></li></ul><p><code>&lt;input type=&quot;checkbox&quot;&gt;</code> 和 <code>&lt;input type=&quot;radio&quot;&gt;</code> 中必须设置 <code>value</code> 属性。<br><code>value</code> 属性无法与 <code>&lt;input type=&quot;file&quot;&gt;</code> 一同使用。</p><h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>  <span class="attr">name</span>=<span class="string">“username”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>name表单的名字， 这样，后台可以通过这个name属性找到这个表单项。  页面中的表单项很多，name主要作用就是用于区别不同的表单项。</p><ul><li>name属性后面的值，是我们自己定义的。</li></ul><ul><li>radio  如果是一组，我们必须给他们命名相同的名字 name ，这样就可以多个选其中的一个啦</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>  /&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> /&gt;</span>女</span><br></pre></td></tr></table></figure><h5 id="checked属性"><a href="#checked属性" class="headerlink" title="checked属性"></a>checked属性</h5><ul><li>表示默认选中状态。  较常见于 单选按钮和复选按钮。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">性    别:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"男"</span> <span class="attr">checked</span>=<span class="string">"checked"</span> /&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">value</span>=<span class="string">"女"</span> /&gt;</span>女</span><br></pre></td></tr></table></figure><p>上面这个，表示就默认选中了 男 这个单选按钮</p><h4 id="label-标签-理解"><a href="#label-标签-理解" class="headerlink" title="label 标签(理解)"></a>label 标签(理解)</h4><p><strong>作用：</strong> 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。</p><p><strong>如何绑定元素呢？</strong></p><ul><li>第一种用法就是用label直接包括input表单。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span> 用户名： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"usename"</span> <span class="attr">value</span>=<span class="string">"请输入用户名"</span>&gt;</span>   <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   适合单个表单选择</p><ul><li>第二种用法 for 属性规定 label 与哪个表单元素绑定。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"sex"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>  <span class="attr">id</span>=<span class="string">"sex"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="textarea控件-文本域"><a href="#textarea控件-文本域" class="headerlink" title="textarea控件(文本域)"></a>textarea控件(文本域)</h4><ul><li>语法：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> &gt;</span></span><br><span class="line">  文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>作用：</p><p>通过textarea控件可以轻松地创建多行文本输入框.</p><p>cols=”每行中的字符数” rows=”显示的行数”  我们实际开发不用</p></li></ul><h5 id="文本框和文本域区别"><a href="#文本框和文本域区别" class="headerlink" title="文本框和文本域区别"></a>文本框和文本域区别</h5><table><thead><tr><th align="left">表单</th><th align="center">名称</th><th align="center">区别</th><th align="right">默认值显示</th><th align="right">用于场景</th></tr></thead><tbody><tr><td align="left">input type=”text”</td><td align="center">文本框</td><td align="center">只能显示一行文本</td><td align="right">单标签，通过value显示默认值</td><td align="right">用户名、昵称、密码等</td></tr><tr><td align="left">textarea</td><td align="center">文本域</td><td align="center">可以显示多行文本</td><td align="right">双标签，默认值写到标签中间</td><td align="right">留言板</td></tr></tbody></table><h4 id="select-标签"><a href="#select-标签" class="headerlink" title="select 标签"></a>select 标签</h4><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：</li></ul><ol><li>&lt;select&gt;  中至少包含一对 option</li><li>在option 中定义selected =” selected “时，当前项即为默认选中项，不写默认第一项。</li><li>multiple属性可以选多个</li></ol><h4 id="HTML5-新的表单属性"><a href="#HTML5-新的表单属性" class="headerlink" title="HTML5 新的表单属性"></a>HTML5 新的表单属性</h4><p>HTML5 的 form 和 input标签添加了几个新属性.</p><p>form新属性：<br><code>autocomplete</code> <code>novalidate</code></p><p>input新属性：<br><code>autocomplete</code><br><code>autofocus</code><br><code>form</code><br><code>ormaction</code><br><code>formenctype</code><br><code>formmethod</code><br><code>formnovalidate</code><br><code>ormtarget</code><br><code>height 与 width</code><br><code>list</code><br><code>min 与 max</code><br><code>multiple</code><br><code>pattern (regexp)</code><br><code>placeholder</code><br><code>required</code><br><code>step</code></p><h3 id="H5新增标签：六大结构标签"><a href="#H5新增标签：六大结构标签" class="headerlink" title="H5新增标签：六大结构标签"></a>H5新增标签：六大结构标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>网站的头部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>网站的底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>导航<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>侧边栏<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span>文章页<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>区块<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="路径-重点、难点"><a href="#路径-重点、难点" class="headerlink" title="路径(重点、难点)"></a>路径(重点、难点)</h2><p>实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们。</p><p>*<em>目录文件夹： *</em></p><p>就是普通文件夹，里面只不过存放了我们做页面所需要的 相关素材，比如 html文件， 图片 等等。</p><p>页面中的图片会非常多， 通常我们再新建一个文件夹专门用于存放图像文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： 相对路径和绝对路径</p><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>以引用文件的网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。</p><ul><li>同一级路径 只需输入图像文件的名称即可</li><li>下一级路径 <code>/</code></li><li>上一级路径 <code>../</code></li></ul><blockquote><p>相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的，而 我们所说的 上一级 下一级 同一级  简单说，就是 图片 位于 HTML 页面的位置</p></blockquote><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。</p><p>“D:\web\img\logo.gif”，或完整的网络地址，例如“<a href="http://www.itcast.cn/images/logo.gif”。" target="_blank" rel="noopener">http://www.itcast.cn/images/logo.gif”。</a></p><p><strong>注意：</strong></p><p>绝对路径用的较少，我们理解下就可以了。</p><h2 id="锚点定位-（难点）"><a href="#锚点定位-（难点）" class="headerlink" title="锚点定位 （难点）"></a>锚点定位 （难点）</h2><p>通过创建锚点链接，用户能够快速定位到目标内容。</p><p>创建锚点链接分为两步：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 使用相应的id名标注跳转目标的位置。 (找目标)</span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">"two"</span>&gt;</span>第2集<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2. 使用<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#id名"</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span>创建链接文本（被点击的）</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#two"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="base-标签"><a href="#base-标签" class="headerlink" title="base 标签"></a>base 标签</h3><p>描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接(包括 <code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;form&gt;</code>标签中的 URL)</p><p><strong>语法：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">"_blank"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>*<em>总结： *</em></p><ol><li>base 可以设置整体链接的打开状态</li><li>base 写到 <code>&lt;head&gt;  &lt;/head&gt;</code>  之间</li><li>把所有的连接 都默认添加 target=”_blank”</li></ol><h3 id="lt-pre-gt-标签"><a href="#lt-pre-gt-标签" class="headerlink" title="&lt;pre&gt;  标签"></a><code>&lt;pre&gt;</code>  标签</h3><p>可定义预格式化的文本。</p><p>被包围在 <pre> 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。</pre></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  此例演示如何使用 pre 标签</span><br><span class="line"></span><br><span class="line">  对空行和 空格</span><br><span class="line"></span><br><span class="line">  进行控制</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>所谓的预格式化文本就是 ，按照我们预先写好的文字格式来显示页面， 保留空格和换行等。</p></blockquote><p>有了这个标签，里面的文字，会按照我们书写的模式显示，不需要段落和换行标签了。但是，比较少用，因为不好整体控制。</p><h3 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h3><ul><li><code>&lt;meta&gt;</code> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词</li><li>每30秒中刷新当前页面: <code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt;</code></li></ul><h3 id="特殊字符-（理解）"><a href="#特殊字符-（理解）" class="headerlink" title="特殊字符 （理解）"></a>特殊字符 （理解）</h3><table><thead><tr><th>显示结果</th><th>描述</th><th>实体名称</th><th>实体编号</th></tr></thead><tbody><tr><td></td><td>空格</td><td><code>&amp;nbsp;</code></td><td><code>&amp;#160;</code></td></tr><tr><td><code>&lt;</code></td><td>小于号</td><td><code>&amp;lt;</code></td><td><code>&amp;#60;</code></td></tr><tr><td><code>&gt;</code></td><td>大于号</td><td><code>&amp;gt;</code></td><td><code>&amp;#62;</code></td></tr><tr><td><code>&amp;</code></td><td>和号</td><td><code>&amp;amp;</code></td><td><code>&amp;#38;</code></td></tr><tr><td><code>&quot;</code></td><td>引号</td><td><code>&amp;quot;</code></td><td><code>&amp;#34;</code></td></tr><tr><td><code>&#39;</code></td><td>撇号</td><td><code>&amp;apos;</code>(IE不支持)</td><td><code>&amp;#39;</code></td></tr><tr><td><code>￠</code></td><td>分</td><td><code>&amp;cent;</code></td><td><code>&amp;#162;</code></td></tr><tr><td><code>£</code></td><td>镑</td><td><code>&amp;pound;</code></td><td><code>&amp;#163;</code></td></tr><tr><td><code>¥</code></td><td>人民币</td><td><code>&amp;yen;</code></td><td><code>&amp;#165;</code></td></tr><tr><td><code>€</code></td><td>欧元</td><td><code>&amp;euro;</code></td><td><code>&amp;#8364;</code></td></tr><tr><td><code>§</code></td><td>小节</td><td><code>&amp;sect;</code></td><td><code>&amp;#167;</code></td></tr><tr><td><code>©</code></td><td>版权</td><td><code>&amp;copy;</code></td><td><code>&amp;#169;</code></td></tr><tr><td><code>®</code></td><td>注册商标</td><td><code>&amp;reg;</code></td><td><code>&amp;#174;</code></td></tr><tr><td><code>™</code></td><td>商标</td><td><code>&amp;trade;</code></td><td><code>&amp;#8482;</code></td></tr><tr><td><code>×</code></td><td>乘号</td><td><code>&amp;times;</code></td><td><code>&amp;#215;</code></td></tr><tr><td><code>÷</code></td><td>除号</td><td><code>&amp;divide;</code></td><td><code>&amp;#247;</code></td></tr></tbody></table><p><strong>总结：</strong></p><ol><li>是以<strong>运算符</strong><code>&amp;</code>开头,以<strong>分号运算符</strong><code>;</code>结尾。</li><li>他们不是标签，而是符号。</li><li>HTML 中不能使用小于号 “<” 和大于号 “>”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体</”></li></ol><h3 id="html5发展之路"><a href="#html5发展之路" class="headerlink" title="html5发展之路"></a>html5发展之路</h3><p><img src="html5.png" alt title=":size=600"></p><h3 id="什么是XHTML"><a href="#什么是XHTML" class="headerlink" title="什么是XHTML"></a>什么是XHTML</h3><p>XHTML 是更严格更纯净的 HTML 代码。</p><ul><li>XHTML 指<strong>可扩展超文本标签语言</strong>（EXtensible HyperText Markup Language）。</li><li>XHTML 的目标是取代 HTML。</li><li>XHTML 与 HTML 4.01 几乎是相同的。</li><li>XHTML 是更严格更纯净的 HTML 版本。</li><li>XHTML 是作为一种 XML 应用被重新定义的 HTML。</li><li>XHTML 是一个 W3C 标准。</li></ul><h2 id="查文档"><a href="#查文档" class="headerlink" title="查文档"></a>查文档</h2><p>经常查阅文档是一个非常好的学习习惯。</p><p>W3C :  <a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">http://www.w3school.com.cn/</a></p><p>MDN: <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a></p>]]></content>
      
      
      <categories>
          
          <category> html&amp;css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html&amp;css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
