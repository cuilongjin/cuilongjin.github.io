<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[icon 图标在 vue 项目中的使用]]></title>
    <url>%2F2019%2Fother%2Ficon%E5%9B%BE%E6%A0%87%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考链接：https://juejin.im/post/59bb864b5188257e7a427c09 使用 iconfont阿里开源图库 https://www.iconfont.cn/ 下载代码到本地（也可以使用在线链接）打开 demo_index.html 使用说明，有三种使用方式 unicode font-class symbolunicode 方式： &#x33; 这样，不直观，语意不明确，不支持多色图标font-class 方式： 使用 class 定义，有语意，需要注意命名空间的问题，也是不支持多色图标symbol 方式：使用 svg 不用再去请求 woff|eot|ttf| 这些字体库，且缩放不会失真，支持更加复杂的图标 symbol 方式使用步骤： 第一步：引入项目下面生成的 symbol 代码： &lt;script src="./iconfont.js"&gt;&lt;/script&gt; 或通过 import 导入 import './iconfont.js' 第二步：加入通用 CSS 代码： .icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden;&#125; 第三步：挑选相应图标并获取类名，应用于页面： &lt;svg class="icon" aria-hidden="true"&gt;&lt;use xlink:href="#icon-xxx"&gt;&lt;/use&gt;&lt;/svg&gt; symbol 其实使用了 SVG Sprite 技术， 所有的 svg-sprite 都是通过 iconfont 的 iconfont.js 生成的，所以： 所有图标 icon 都很不直观，完全不知道哪个图标名对应什么图标，每次增删改图标，或者添加一些自定义的 svg 图标，只能将其也上传到 iconfont 和原有的图标放在一个项目库中，之后再重新下载，将整体 js 文件一起替换，而且也做不到按需加载 导出的 svg 包含大量的无用信息，例如编辑器源信息、注释等。通常包含其它一些不会影响渲染结果或可以移除的内容 vue cli3 项目使用 svg-sprite-loader 打包 svgvue cli3 默认使用 file-loader 处理 svg： /* config.module.rule('svg') */&#123; test: /\.(svg)(\?.*)?$/, use: [ /* config.module.rule('svg').use('file-loader') */ &#123; loader: 'file-loader', options: &#123; name: 'static/img/[name].[hash:8].[ext]' &#125; &#125; ]&#125; 并路径指定为在 img 文件夹下，但我们的 svg 并不在 img 文件夹，而且 svg-sprite-loader 已经自带了 file-loader 的功能，所以，我们可以在我们自定义的 vue.config.js 文件下将 rule(svg) 清除： module.exports = &#123; chainWebpack: config =&gt; &#123; config.module.rule('svg').uses.clear() &#125;&#125; 或者添加忽略，然后加上自定义的 svg rule，最后的配置如下： /* 使用 svg-sprite-loader 处理 svg */// 默认规则忽略 src/icons 文件夹config.module .rule('svg') .exclude.add(path.resolve(__dirname, 'src/icons')) .end()// src/icons 文件夹下的 svg 使用 svg-sprite-loaderconfig.module .rule('svg-sprite-loader') .include.add(path.resolve(__dirname, 'src/icons')) .end() .test(/\.svg$/) .use('svg-sprite') .loader('svg-sprite-loader') .options(&#123; symbolId: 'icon-[name]' &#125;) .end() 之后可以通过如下方式使用 import '@/icons/qq.svg' &lt;!-- xlink:href="#icon-图标文件名 --&gt;&lt;svg&gt;&lt;use xlink:href="#icon-qq" /&gt;&lt;/svg&gt; 使用缺点：需要手动导入图标 自动导入使用 webpack 的 require.context api require.context 语法 require.context(directory, (useSubdirectories = false), (regExp = /^\.\//))// directory：说明需要检索的目录// useSubdirectories：是否检索子目录// regExp: 匹配文件的正则表达式// Examples:require.context('./test', false, /\.test\.js$/)// 表示在 test 文件夹（不包含子目录）下面的找所有文件名以 .test.js 结尾的能被 require 的文件 自动引入 @/icons 下面所有的图标 // 基础组件的自动化全局注册const requireComponent = require.context('../../components', false)// console.log(requireComponent.keys())requireComponent.keys().forEach(filename =&gt; &#123; const componentConfig = requireComponent(filename) // console.log(componentConfig) const componentName = filename .split('/') .pop() .replace(/\.\w+$/, '') // console.log(componentName) Vue.component( componentName, // 如果这个组件选项是通过 `export default` 导出的， // 那么就会优先使用 `.default`， // 否则回退到使用模块的根。 componentConfig.default || componentConfig )&#125;) const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context('@/icons', false)requireAll(req) 之后直接将图标放入 @/icons 文件夹下就可以直接使用了，删改图标同理 优化 svg删除无用信息 svgo阿里云导出的 svg 是带有默认的 fill 的，导致图标不能继承父级元素的颜色,可以通过删除默认 fill 解决 安装 npm i svgo svgo-loader -D config.module .rule('svg-sprite-loader') .include.add(path.resolve(__dirname, 'src/icons')) .use('svgo-loader') .loader('svgo-loader') .tap(options =&gt; &#123; options = &#123; plugins: [ &#123; removeXMLNS: true &#125;, // 删除xmlns属性（对于内联svg，默认情况下禁用） &#123; convertStyleToAttrs: true &#125; // 将css样式转换为svg元素属性 ] &#125; return options &#125;)]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[addEventListener 以及 vue 中的 .passive 修饰符]]></title>
    <url>%2F2019%2Fjavascript%2FaddEventListener%E4%BB%A5%E5%8F%8Avue%E4%B8%AD%E7%9A%84.passive%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener 添加事件 // 语法target.addEventListener(type, listener[, useCapture])// type: 事件的类型: click mouseover 字符串类型，不带 on// listener: 函数，每次点击，执行这个函数// useCapture: 可选，true: 事件在捕获阶段执行，false: 事件在冒泡阶段执行(默认)target.addEventListener(type, listener[, options]) options 可选，可用的选项如下：capture: Boolean，默认 false，等价于以前的 useCapture 参数once: Boolean，默认 false，如果是 true，表示 listener 在添加之后最多只调用一次。 listener 也会在其被调用之后自动移除passive: Boolean，默认 false，设置为 true 时，表示 listener 永远不会调用 preventDefault() 如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。 浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿 .passive 修饰符尤其能够提升移动端的性能vue .passive 事件修饰符 移除事件 removeEventListener 在第三个参数是布尔值的时候，addEventListener(“foo”, listener, true) 添加的监听器，必须用 removeEventListener(“foo”, listener, true) 才能删除掉, 因为这个监听器也有可能还注册在了冒泡阶段, 如果第三个参数为 false 则直接通过 removeEventListener(“foo”, listener) 就可以删除 通过 addEventListener(“foo”, listener, {capture: true}) 添加的监听器删除时也同样需要添加 {capture: true} 来删除，当然 {capture: true} 换成 true 也可以 通过 addEventListener(“foo”, listener, {passive: true}) 添加的监听器直接通过 removeEventListener(“foo”, listener) 就可以删除了因为一个监听器同时是 passive 和非 passive（以及同时是 once 和非 once）是说不通的，如果你添加了多个，那么后添加的会忽略 removeEventListener(“foo”, listener, {capture: true}) // {capture: true} 必须加，当然 {capture: true} 换成 true 也可以]]></content>
      <categories>
        <category>js</category>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端兼容性问题总结]]></title>
    <url>%2F2019%2F%E7%A7%BB%E5%8A%A8web%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. ios 移动端页面对点击事件有 300ms 延时使用 fastclick 库 https://github.com/ftlabs/fastclick 使用 FastClick 的时候，在需要使用的层上，实例化它。我们使用 document.body 是因为希望所有的按钮和链接都获得快速点击 import FastClick from 'fastclick'FastClick.attach(document.body) 2. ios 滚动卡顿div &#123; -webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */ /* -webkit-overflow-scrolling: auto; */ /* 当手指从触摸屏上移开，滚动会立即停止 */&#125; 3. ios 1px border 变宽以 dpr = 2 为例：你拿到一张标准的基于 iphone6 的设计稿(750px)你看到它设计的一个 border 宽度是 1px你兴致勃勃地写下了 border: 1px solid #000;然而 iphone6 实际渲染像素是 375px，那么设计需要 border 的其实是 border: 0.5px solid #000;然后你的是 1px不是 1px 变粗了，只是实际只是需要 0.5px 而已 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 意思是将物理设备的宽度设置给当前浏览器 在使用 table 标签设置 border: 1px 并使用 border-collapse: collapse; 合并边框后，发现 td 之间的边框宽度并不是 1px，而是比 1px 宽，大概为 1.5px 4. webapp 软键盘弹起时问题页面放大: &lt;meta name="viewport" content="user-scalable=no" /&gt; 输入框被遮挡，看不见输入的内容: element.scrollIntoView() 页面自动上移，但收回软键盘时页面少了一截: fixed 定位效果失效: ios 弹出软键盘的时候, webview 的高度没有变化导致超出屏幕范围 5. 手机端页面文件上传兼容性问题6. 移动和 PC 端中的 hover 处理 移动端点击时会有 pc 端 hover 效果7. webapp 禁用长按复制user-select: none; 8. ios a 链接 input type=”file” 等在点击时会出现灰色（touch 高亮）-webkit-tap-highlight-color: transparent; 9. 禁用浏览器自动调整字体大小移动端浏览器切换橫向模式时会调整字体大小（字体变大），解决方式: html &#123; -webkit-text-size-adjust: none; /* 或 100% */&#125; 谷歌浏览器已不支持这个属性了，不能通过该方式实现小于 12px 的字体，可使用缩放（transform:scale(0.8)）来实现小于 12px 的字体 10. appearance 属性normal|icon|window|button|menu|field所有主流浏览器都不支持 appearance 属性 -webkit-appearance: none; 去除默认样式，使 ios 端和安卓端显示效果一样，但有一个问题，input 的 checkbox 和 radio 类型在安卓端可能无法正常显示 11. -webkit-touch-callout: none;在 iOS 上，当你触摸并按住触摸的目标，比如一个链接，浏览器将显示链接有关的系统默认菜单。该属性可以禁用系统默认菜单 点击穿透假如页面上有两个元素 A 和 B。B 元素在 A 元素之上。我们在 B 元素的 touchstart 事件上注册了一个回调函数，该回调函数的作用是隐藏 B 元素。我们发现，当我们点击 B 元素，B 元素被隐藏了，随后，A 元素触发了 click 事件。这是因为在移动端浏览器，事件执行的顺序是 touchstart &gt; touchend &gt; click。而 click 事件有 300ms 的延迟，当 touchstart 事件把 B 元素隐藏之后，隔了 300ms，浏览器触发了 click 事件，但是此时 B 元素不见了，所以该事件被派发到了 A 元素身上。如果 A 元素是一个链接，那此时页面就会意外地跳转。跨页面点击穿透问题 点击页内按钮跳转至新页，然后发现新页面中对应位置元素的 click 事件被触发了]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3 配置通用模板及配置详解]]></title>
    <url>%2F2019%2Fvue%2Fvue-cli3%E9%85%8D%E7%BD%AE%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[安装： npm install -g @vue/cli 创建一个项目： vue create my-project# ORvue ui 如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具： npm install -g @vue/cli-init# `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同vue init webpack my-project 在现有的项目中安装插件每个 CLI 插件都会包含一个 (用来创建文件的) 生成器和一个 (用来调整 webpack 核心配置和注入命令的) 运行时插件。当你使用 vue create 来创建一个新项目的时候，有些插件会根据你选择的特性被预安装好。如果你想在一个已经被创建好的项目中安装一个插件，可以使用 vue add 命令： vue add @vue/eslint 提示 vue add 的设计意图是为了安装和调用 Vue CLI 插件。对于普通的 npm 包而言，这不意味有一个替代（命令）。对于这些普通的 npm 包，你仍然需要（根据所选的 npm 包）使用包管理器。 vue.config.js 配置官网配置参考 // vue.config.jsmodule.exports = &#123; // 选项...&#125; publicPath基本路径 vue-cli3.3 以下版本使用 baseUrl vue-cli3.3+ 使用 publicPath 默认 ‘/‘ ‘./‘ 或为空(‘’) 所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径, 当使用 pages 选项构建多页面应用时,应当避免使用相对路径 publicPath: './' outputDir默认 ‘dist’ 当运行 vue-cli-service build 时生成的生产环境构建文件的目录 outputDir: 'dist' assetsDir默认 ‘’ 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录 assetsDir: 'static' indexPath指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径 indexPath: 'index.html' filenameHashing默认 true 默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。然而，这也要求 index 的 HTML 是被 Vue CLI 自动生成的。如果你无法使用 Vue CLI 生成的 index HTML，你可以通过将这个选项设为 false 来关闭文件名哈希 pages默认 undefined 是否以多页模式构建应用程序 每个 ‘page’ 应该有一个对应的 JavaScript 入口文件。其值应该是一个对象，对象的 key 是入口的名字，value 是 一个指定了 entry, template, filename, title 和 chunks 的对象 (除了 entry 之外都是可选的) 或一个指定其 entry 的字符串 module.export = &#123; pages: &#123; index: &#123; // page 的入口 entry: 'src/pages/index/main.js', // 模板来源 template: 'public/index.html', // 在 dist/index.html 的输出 filename: 'index.html', // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; title: 'Index Page' &#125;, pageA: &#123; entry: 'src/pages/pageA/main.js', template: 'public/index.html', filename: 'pageA.html' &#125;, // 当使用只有入口的字符串格式时, 模板会被推导为 `public/pageB.html` // 并且如果找不到的话，就回退到 `public/index.html`, 输出文件名会被推导为 `pageB.html` pageB: 'src/pages/pageB/main.js' &#125;&#125; lintOnSave默认 true 是否在保存的时候检查，如果为 true ，build 时会启用 eslint-loader 进行代码检查，可以使用如下配置禁用 lintOnSave: process.env.NODE_ENV !== 'production' runtimeCompiler默认 false 是否使用包含运行时编译器的 Vue 构建版本 使用 template 语法需要开启，但是这会让你的应用额外增加 10kb 左右，使用渲染函数不需要开启 runtimeCompiler: false productionSourceMap默认 true 生产环境是否生成 sourceMap 文件，一般情况不建议打开 map 文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。有了 map 就可以像未加密的代码一样，准确的输出是哪一行哪一列有错 productionSourceMap: false chainWebpack对内部的 webpack 配置进行更细粒度的修改 const chainWebpack = config =&gt; &#123; // 删除预加载模块的 prefetch，降低带宽压力 // https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch // 移除 prefetch 插件 config.plugins.delete('prefetch') // 移除 preload 插件 config.plugins.delete('preload') // config.plugin('html').tap(args =&gt; &#123; // args[0].minify = false // return args // &#125;) /* 配置绝对路径 */ config.resolve.alias.set('~', path.resolve('public')) // 修改静态资源打包方式，下例为超过10k才用文件导入的方式，否则为base64.默认为4k config.module .rule('images') .use('url-loader') .loader('url-loader') .tap(options =&gt; Object.assign(options, &#123; limit: 10240 &#125;))&#125;module.export = &#123; chainWebpack&#125; https://cli.vuejs.org/zh/guide/html-and-static-assets.html#preload &lt;link rel=&quot;preload&quot;&gt;是一种 resource hint，用来指定页面加载后很快会被用到的资源，所以在页面加载的过程中，我们希望在浏览器开始主体渲染之前尽早 preload。 &lt;link rel=&quot;prefetch&quot;&gt; 是一种 resource hint，用来告诉浏览器在页面加载完成后，利用空闲时间提前获取用户未来可能会访问的内容。 configureWebpack// webpack 自定义配置// https://cli.vuejs.org/zh/guide/webpack.htmlconst configureWebpack = config =&gt; &#123; // 生产 and 测试环境 let pluginsPro = [ new CompressionPlugin(&#123; // 文件开启 Gzip，也可以通过服务端(如：nginx)(https://github.com/webpack-contrib/compression-webpack-plugin) filename: '[path].gz[query]', algorithm: 'gzip', test: new RegExp('\\.(' + ['js', 'css'].join('|') + ')$'), threshold: 8192, minRatio: 0.8 &#125;), // Webpack 包文件分析器(https://github.com/webpack-contrib/webpack-bundle-analyzer) new BundleAnalyzerPlugin(), // 打包时删除 debugger 和 console new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; drop_debugger: true, drop_console: true &#125; &#125;, sourceMap: true, parallel: true &#125;) ] // 开发环境 let pluginsDev = [ // 移动端模拟开发者工具 (https://github.com/diamont1001/vconsole-webpack-plugin https://github.com/Tencent/vConsole) // new vConsolePlugin(&#123; // filter: [], // 需要过滤的入口文件 // enable: true // 发布代码前记得改回 false // &#125;) ] if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置...process.env.NODE_ENV !== 'development' config.plugins = [...config.plugins, ...pluginsPro] &#125; else &#123; // 为开发环境修改配置... config.plugins = [...config.plugins, ...pluginsDev] &#125;&#125;module.export = &#123; configureWebpack&#125; 环境变量与分环境打包vue-cli-service-buildvue-cli-service build –mode 指定环境模式(默认值：production) npm run build 默认模式为 production ，命令执行时会把 process.env.NODE_ENV(环境变量) 设置为 ‘production’npm run serve 时会把 process.env.NODE_ENV 设置为 ‘development’ 所以可以根据 process.env.NODE_ENV 简单的区分出本地和线上环境 但是线上环境也可能分多种，比如测试环境和预发布环境等 配置 vue-cli3 区分不同的线上环境 在项目根目录创建下列文件来制定环境变量 .env # 在所有的环境中被载入.env.local # 在所有的环境中被载入，但会被 git 忽略.env.[mode] # 只在指定的模式中被载入.env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略 .env.test /* VUE_APP_CURRENTMODE 当前环境变量 */VUE_APP_CURRENTMODE = &apos;t&apos; // 表明开发环境模式信息NODE_ENV = &apos;development&apos; // 使用开发环境（因为默认开启 devtool，便于调试）// VUE_APP_BASEURL=&apos;&apos; // 测试服务器地址VUE_APP_ENV = &apos;test 环境&apos; 在 package.json 中添加 "scripts": &#123; "test": "vue-cli-service build --mode t",&#125; 修改 baseUrl.js 文件通过环境变量改变 baseUrl if (process.env.VUE_APP_CURRENTMODE === 't') &#123; // 测试环境 baseUrl = ''&#125; else &#123; // 正式环境 baseUrl = ''&#125; 当需要为测试环境进行打包的时候 , 只需要运行下面指令进行打包 npm run test 但是将打包环境设置为 NODE_ENV = ‘development’ 导致打包出来的 js 文件只有 index.js 文件并且在根目录下, 并不是我们想要的 所以我们可以这样配置 .env.test VUE_APP_CURRENTMODE = &apos;t&apos;NODE_ENV = &apos;production&apos;VUE_APP_ENV = &apos;test 环境&apos; main.js 配置 const isDebugMode = process.env.VUE_APP_CURRENTMODE === 't'Vue.config.debug = isDebugModeVue.config.devtools = isDebugModeVue.config.productionTip = isDebugMode vue 公共路径提取vue 项目中公共路径在打包之后一旦遇到整体的路径更改就需要再次打包。我们可以将公共路径提取出来，修改公共路径后不需要重新打包就能生效 在 public 文件夹下创建 config.js 文件，并配置 const serverConfig = &#123; baseUrl: '' // 配置 url&#125; 在 index.html 中引入该文件，之后在开发时就可以通过 serverConfig.baseUrl 使用变量 vue add routervue add vuex 配置 externals如果我们想引用一个包，但是又不想让 webpack 打包，并且又不影响我们在程序中以 CMD、AMD 或者 window/global 全局等方式进行使用，那就可以通过配置 externals 将包抽离出来。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用。 &lt;!-- script 标签引入vue element-ui --&gt;&lt;script src="cdn/vue.js"&gt;&lt;/script&gt;&lt;script src="cdn/element-ui.js"&gt;&lt;/script&gt; configureWebpack: config =&gt; &#123; config.externals = &#123; vue: 'Vue', // key 为库名称，value 为库在你项目中使用的关键字 'element-ui': 'ELEMENT' &#125;&#125; 修改本地 host 通过域名访问项目配置 host # host127.0.0.1 abc.baidu.com devServer: &#123; host: 'abc.baidu.com'&#125; npm run serve 启动服务后可以通过 abc.baidu.com 访问 如果访问不了，可能需要清理 dns 缓存 清空电脑的 DNS 缓存：cmd 运行 ipconfig /flushdns 清理浏览器中的 dns 缓存：浏览器打开 chrome://net-internals/#dns 如果 host 为 127.0.0.1 或 localhost，需要配置 disableHostCheck: true devServer: &#123; host: 'localhost', disableHostCheck: true&#125; 新版的 webpack-dev-server 出于安全考虑，默认检查 hostnamedisableHostCheck: true 目的是解决通过域名访问时出现 Invalid Host header 经测试 依然会出现 Invalid Host header，导致项目不能正常访问]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[less 使用 - mixin 混合]]></title>
    <url>%2F2019%2Ftool%2Fless-mixin%E6%B7%B7%E5%90%88%2F</url>
    <content type="text"><![CDATA[mixin 混合可以在 mixin 中使用类选择器和 id 选择器 .bgc 定义了一个属性集，在任何需要使用 .bgc 属性集的选择器中，只需像下面这样调用：(小括号是可选的) .bgc &#123; background-color: #ccc;&#125;div &#123; color: #f00; .bgc();&#125; 编译后的 CSS 代码为： .bgc &#123; background-color: #ccc;&#125;div &#123; color: #f00; background-color: #ccc;&#125; 总结：mixin 其实就是一种嵌套，简单的讲，mixin 就是规则级别的复用 mixin 的定义也会被原封不动的输出到编译生成的 CSS 代码中 如果希望编译生成的 CSS 代码中不包含 mixin 的定义，在定义 mixin 时，只需在 class、id 的后面添加一对小括号即可。如： .bgc() &#123; background-color: #ccc;&#125;div &#123; .bgc;&#125; 编译后的 CSS 代码为： div &#123; background-color: #ccc;&#125; mixin 可以包含选择器 .hover() &#123; &amp;:hover &#123; background-color: #ccc; &#125;&#125;div &#123; .hover;&#125; 编译后的 CSS 代码为： div:hover &#123; background-color: #ccc;&#125; 命令空间 Namespaces如果想要在一个更复杂的选择器中混合属性，可以堆叠多个 id 或类 可以将 mixin 置于 id 选择器之下，这样可以确保它不会和另一个库冲突 #bgc &#123; .inner() &#123; color: red; &#125;&#125;div &#123; #bgc.inner;&#125; !important 关键字在 mixin 后使用 !important 关键字，将会标记调用所有继承的属性为!important .bgc &#123; background-color: #ccc;&#125;div &#123; .bgc !important;&#125;// 编译后 css 为div &#123; background-color: #ccc !important;&#125; 带参数的 Mixin mixin 还可以接受参数，这些参数在混合时传递给选择器块 从上面的代码可以看出：mixin 其实就是一种嵌套，简单的讲，mixin 就是规则级别的复用。除了类选择器外，你也可以使用 id 选择器来定义 mixin。]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高阶函数与柯里化]]></title>
    <url>%2F2019%2Fjavascript%2F%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[高阶函数高阶函数定义：将函数作为参数或者返回值是函数的函数常见的 sort、reduce 等函数就是高阶函数 function add(a) &#123; return function(b) &#123; return a + b &#125;&#125;var sum = add(1)(2) // 3// es6写法let add = a =&gt; b =&gt; a + b// 等价于let add = (a, b) =&gt; a + b 柯里化wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术 柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要 n 个参数的函数变成只需要剩下的（n - 1 个）参数就可以调用 // 形如a =&gt; b =&gt; c =&gt; &#123;&#125;let add = a =&gt; b =&gt; a + blet add1 = add(1) // a = 1; b =&gt; a + badd1(2) // 1 + 2 = 3 add1 函数等价于有了 a 这个闭包变量的 b = a + b add 函数按照 wiki 的定义可以理解成只柯里化了一次，n 个连续箭头组成的函数实际上就是柯里化了 n - 1 次前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值 所以多个连续箭头函数就是多次柯里化的 es6 写法 应用： 函数懒执行函数式编程 柯里化函数使用场景： 减少重复传递不变的参数 function discount(price, discount) &#123; return price * discount&#125;// 每次都要重复传入 discount 参数，可以将这个函数柯里化function discount(price, discount) &#123; return price =&gt; &#123; return price * discount &#125;&#125;const tenPercentDiscount = discount(0.9) // 9折const twentyPercentDiscount = discount(0.8) // 8折// 现在每次计算价格只需要：tenPercentDiscount(500) // 500 * 0.9twentyPercentDiscount(1000) // 1000 * 0.8 柯里化实现function curry(func) &#123; return function curried(...args) &#123; if (args.length &gt;= func.length) &#123; return func.apply(this, args) &#125; else &#123; return function(...args2) &#123; return curried.apply(this, args.concat(args2)) &#125; &#125; &#125;&#125;function sum(a, b, c) &#123; return a + b + c&#125;let curriedSum = curry(sum)console.log(curriedSum(1, 2, 3)) // 6console.log(curriedSum(1)(2, 3)) // 6 偏函数]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[axios 取消请求]]></title>
    <url>%2F2019%2Fjavascript%2Faxios%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[原生 js abort() 方法 let A = $.ajax(&#123;&#125;)A.abort() Axios 提供了一个 CancelToken 的函数，这是一个构造函数，该函数的作用就是用来取消接口请求的 methods: &#123; getMsg () &#123; let CancelToken = axios.CancelToken let that = this axios.get('', &#123; cancelToken: new CancelToken(function executor(c) &#123; that.cancel = c console.log(c) // 这个参数 c 就是 CancelToken 构造函数里面自带的取消请求的函数，这里把该函数当参数用 &#125;) params: &#123;&#125; &#125;).then(res =&gt; &#123; this.items = res.data &#125;).catch(err =&gt; &#123; console.log(err) &#125;) &#125;, cancelGetMsg () &#123; this.cancel() &#125;&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3 多页模式]]></title>
    <url>%2F2019%2Fvue%2F%E5%A4%9A%E9%A1%B5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[vue-cli 多页面的配置官方介绍 vue.config.js 配置 // vue.config.jsmodule.exports = &#123; pages: &#123; index: &#123; // page 的入口 entry: 'src/pages/index/main.js', // 模板来源 template: 'public/index.html', // 在 dist/index.html 的输出 filename: 'index.html', // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; title: 'Index Page' &#125;, pageA: &#123; entry: 'src/pages/pageA/main.js', template: 'public/index.html', filename: 'pageA.html' &#125;, // 当使用只有入口的字符串格式时, 模板会被推导为 `public/pageB.html` // 并且如果找不到的话，就回退到 `public/index.html`, 输出文件名会被推导为 `pageB.html` pageB: 'src/pages/pageB/main.js' &#125;&#125; 一个页面一套 SPA，入口文件、路由、资源的路径都要根据实际情况进行设置 页面内可以继续使用SPA模式的&lt;router-link&gt;，但是页面之间的跳转需要使用： &lt;!-- index.html --&gt;&lt;a href="/pageA.html"&gt;前往 pageA 页面&lt;/a&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[keep-alive 实现页面缓存]]></title>
    <url>%2F2019%2Fvue%2Fkeep-alive%2F</url>
    <content type="text"><![CDATA[缓存 pageAList -&gt; pageADetail -&gt; pageAList，缓存 pageAList，同时如果 pageAList 发生变化需要更新 其他页面 -&gt; pageAList，pageAList 不缓存 router 配置 routes: [ &#123; path: '/home', name: 'home', component: Home, children: [ &#123; path: '/pageAList', name: 'pageAList', component: pageAList &#125;, &#123; path: '/pageADetail', name: 'pageADetail', component: pageADetail &#125; &#125; ] vuex 配置 store.js export default new Vuex.Store(&#123; state: &#123; includeComponents: [] // 需要缓存的组件 &#125;, mutations: &#123; addIncludeComponent(state, includeComponent) &#123; // includeComponent 可能是组件 name 字符串或者数组 let includeComponents = state.includeComponents if (Array.isArray(includeComponent)) &#123; state.includeComponents = [...new Set([...includeComponents, ...includeComponent])] &#125; else &#123; state.includeComponents = [...new Set([...includeComponents, includeComponent])] &#125; &#125;, removeIncludeComponent(state, includeComponent) &#123; let includeComponents = state.includeComponents if (Array.isArray(includeComponent)) &#123; for (let i = 0; i &lt; includeComponent.length; i++) &#123; let index = includeComponents.findIndex(v =&gt; v === includeComponent[i]) if (index &gt; -1) &#123; includeComponents.splice(index, 1) &#125; &#125; &#125; else &#123; for (let i = 0, len = includeComponents.length; i &lt; len; i++) &#123; if (includeComponents[i] === includeComponent) &#123; includeComponents.splice(i, 1) break &#125; &#125; &#125; state.includeComponents = includeComponents &#125; &#125;&#125;) home.vue &lt;!-- keep-alive 包裹 router-view --&gt;&lt;template&gt; &lt;keep-alive :include="includeComponents"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; includeComponents() &#123; return this.$store.state.includeComponents &#125; &#125; &#125;&lt;/script&gt; pageAList.vue export default &#123; name: 'pageAList', beforeRouteLeave(to, from, next) &#123; let reg = /pageADetail/ if (reg.test(to.name)) &#123; this.$store.commit('addIncludeComponent', 'pageADetail') &#125; else &#123; this.$store.commit('removeIncludeComponent', 'pageADetail') &#125; next() &#125;, activated() &#123; this.getList() &#125;&#125; pageADetail.vue export default &#123; name: 'pageADetail', beforeRouteLeave(to, from, next) &#123; let reg = /pageA/ if (reg.test(to.name)) &#123; this.$store.commit('addIncludeComponent', 'pageAList') &#125; else &#123; this.$store.commit('removeIncludeComponent', 'pageAList') &#125; next() &#125;, activated() &#123; this.getList() &#125;&#125; 总结 进入 pageAList，离开当前组件的时候有两种情况： 跳转进去 pageADetail，在 pageAList 的 beforeRouteLeave 钩子里面缓存 pageAList 跳转到非 pageADetail 的页面，在 pageAList 的 beforeRouteLeave 钩子里面清除 pageAList 的缓存 从 pageADetail 离开的时候，也有两种情况： 回到 pageAList，在 pageADetail 的 beforeRouteLeave 钩子里面缓存 pageAList，所以从 pageAList-pageADetail-pageAList 的时候，pageAList 可以被缓存，还是之前的页码状态 进入其他路由，在 pageADetail 的 beforeRouteLeave 钩子里面清除 pageAList 的缓存]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3.0 内存溢出 JavaScript heap out of memory]]></title>
    <url>%2F2019%2Fvue%2Fvue-cli3%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[错误内容： &lt;--- JS stacktrace ---&gt;==== JS stack trace ========================================= 0: ExitFrame [pc: 000002861B95C5C1]Security context: 0x002fdeb1e6e9 &lt;JSObject&gt; 1: DoJoin(aka DoJoin) [0000002FDEB05E91] [native array.js:~87] [pc=000002861C436409](this=0x0037aae826f1 &lt;undefined&gt;,l=0x01420be65761 &lt;JSArray[2]&gt;,m=2,A=0x0037aae828c9 &lt;true&gt;,w=0x0375f51b46d9 &lt;String[1]\: \n&gt;,v=0x0037aae829a1 &lt;false&gt;) 2: Join(aka Join) [0000002FDEB05EE1] [native array.js:~112] [pc=000002861BC4F978](this=0x0037aae826f1 &lt;undefined&gt;,l...FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 百度出的原因及解决方案基本都是： nodejs 内存限制，通过添加启动参数可以解决 vue-cli2： npm run dev 和 npm run build 直接在前面加上--max_old_space_size=4096 vue-cli3： npx --max_old_space_size=4096 vue-cli-service serve 或 npm i increase-memory-limit cross-envscripts 中添加指令 "fix-memory-limit": "cross-env LIMIT=4096 increase-memory-limit"npm run fix-memory-limitnpm run serve 但是通过以上设置并没有解决问题，最后将 lintOnsave: false 解决了 由此分析 lintOnsave 为 true 时 ，npm run serve|build 时会启用 eslint-loader 进行代码检查，某些插件可能无法进行代码检查并产生了递归，导致内存溢出，因为该项目使用了 Ueditor 插件，之后将 Ueditor 插件加入 eslintignore 并将 lintOnsave 恢复成 true，项目依然能够正常运行 参考链接: https://github.com/vuejs/vue-cli/issues/1453]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-cli 常用配置]]></title>
    <url>%2F2019%2Fvue%2Fvue-cli%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[vue-cli webpack 打包后 index.html 引入文件没有引号 解决办法： vue-cli2： 在 webpack.prod.conf.js 中修改： plugins: [ new HtmlWebpackPlugin(&#123; minify: &#123; removeAttributeQuotes: false // 如果该方法没有用那就把整个 minify 去掉 &#125; &#125;)] vue-cli3: 在 vue.config.js 中添加： chainWebpack: config =&gt; &#123; config.plugin('html').tap(args =&gt; &#123; args[0].minify = false return args &#125;)&#125; vue-cli 打包时删除 console、deugger、注释 vue-cli2： 在 webpack.prod.conf.js 中添加： plugins: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; drop_debugger: true, drop_console: true &#125;, output: &#123; comment: false &#125; &#125; &#125;)] vue-cli3： 安装 uglifyjs-webpack-plugin 在 vue.config.js 中添加： const UglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; configureWebpack: config =&gt; &#123; new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; drop_debugger: true, drop_console: true &#125;, output: &#123; comment: false &#125; &#125;, parallel: true, cache: true &#125;) &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js 中编码（encode）和解码（decode）的三种方法]]></title>
    <url>%2F2019%2Fother%2Fjs%20%E4%B8%AD%E7%BC%96%E7%A0%81%EF%BC%88encode%EF%BC%89%E5%92%8C%E8%A7%A3%E7%A0%81%EF%BC%88decode%EF%BC%89%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js 中编码（encode）和解码（decode）的三种方法js 对文字进行编码涉及 3 个函数：escape、encodeURI、encodeURIComponent，相应 3 个解码函数：unescape、decodeURI、decodeURIComponent escape()函数 定义和用法：escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串语法：escape(string)参数：string 必需，要被转义或编码的字符串。返回值：已编码的 string 的副本。其中某些字符被替换成了十六进制的转义序列说明：该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： -_.!~*&#39;() ，其他所有的字符都会被转义序列替换 encodeURI()函数 定义和用法：encodeURI() 函数可把字符串作为 URI 进行编码语法：encodeURI(URIstring)参数：URIstring 必需，一个字符串，含有 URI 或其他要编码的文本。返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：-_.!~*&#39;() ，该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,# encodeURIComponent() 定义和用法：encodeURIComponent() 函数可把字符串作为 URI 组件进行编码语法：encodeURIComponent(URIstring)参数：URIstring 必需，一个字符串，含有 URI 组件或其他要编码的文本返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：-_.!~*&#39;()，其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的 说明： encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号 传递参数时需要使用 encodeURIComponent，这样组合的 url 才不会被#等特殊字符截断]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[移动端(Safari)浏览网页时对数字禁用电话功能]]></title>
    <url>%2F2019%2F%E7%A7%BB%E5%8A%A8web%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF(Safari)%E6%B5%8F%E8%A7%88%E7%BD%91%E9%A1%B5%E6%97%B6%E5%AF%B9%E6%95%B0%E5%AD%97%E7%A6%81%E7%94%A8%E7%94%B5%E8%AF%9D%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[移动端(Safari)浏览网页时对数字禁用电话功能 标准的电话号码格式是： &lt;a href="tel:+86-123-456-7890"&gt;1234567890&lt;/a&gt; 有时候不是电话号码的数字会被浏览器自动解析为如上电话号码格式，导致样式和布局改变 忽略页面中的数字识别为电话号码, 只要把这个默认行为关闭就行 &lt;meta name="format-detection" content="telephone=no" /&gt; 这个关闭不会影响真正电话号码的识别 说明：Meta 标签中的 format-detection 属性及含义format-detection 中文的意思是 “格式检测”，它是用来检测 html 里的一些格式的 &lt;!-- 禁止了把数字转化为拨号链接 默认为 yes --&gt;&lt;meta name="format-detection" content="telephone=no" /&gt;&lt;!-- 禁止作为邮箱地址 默认为 yes --&gt;&lt;meta name="format-detection" content="email=no" /&gt;&lt;!-- 禁止跳转至地图 默认为 yes --&gt;&lt;meta name="format-detection" content="adress=no" /&gt;&lt;meta name="format-detection" content="telephone=no,email=no,adress=no" /&gt;]]></content>
      <categories>
        <category>移动web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npm 使用]]></title>
    <url>%2F2019%2Ftool%2Fnpm%2F</url>
    <content type="text"><![CDATA[npm 使用解决 npm 包无法下载electron sass 进入 ~/.npmrc，增加如下内容 registry=https://registry.npm.taobao.orgsass_binary_site=https://npm.taobao.org/mirrors/node-sass/phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjselectron_mirror=http://npm.taobao.org/mirrors/electron/ 淘宝 npm 镜像 https://npm.taobao.org/ npm 基本命令# 更新 npmnpm -v|--versionnpm install npm@latest -g# nvm : npm Version Manager# 搜索包npm search &lt;pkg&gt;# 安装包npm install [&lt;@scope&gt;/]&lt;pkg&gt; # [&lt;@scope&gt;/] 安装限定范围的包npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt;npm install &lt;folder&gt;npm install &lt;tarball file&gt; # .tar, .tar.gz, or .tgznpm install &lt;tarball url&gt;npm install &lt;github usename&gt;/&lt;guthub project&gt;npm install &lt;git:// url&gt;npm install &lt;pkg&gt; -S|--save # 安装到 dependenciesnpm install &lt;pkg&gt; -D|--save-dev # 安装到 devDependencies# 安装全局包npm install -g &lt;pkg&gt;# 更新包npm outdated # 检查可以更新的模块npm update # 更新全部本地包# 更新全局安装的包npm update -g # 更新全部npm update -g| --global &lt;pkg&gt; # 更新指定包# 更新方式 1# 手动修改 package.json 中依赖包版本，之后执行npm install --force# 更新方式 2 使用第三方插件：npm install -g npm-check-updatesncu # 查看可更新包ncu -u # 更新 package.jsonnpm install # 升级到最新版本# 删除本地包npm uninstall &lt;pkg&gt;npm uninstall --save &lt;pkg&gt; # 从 `package.json` 文件中删除依赖# 卸载全局安装的包npm uninstall -g &lt;pkg&gt;# 打开官网npm docs|home [&lt;pkg&gt;]# 打开源码仓库页面npm repo [&lt;pkg&gt;]# 创建 package.json 文件npm init# 创建默认 package.json 文件npm init --yes or -y npm 修改源 进入~/.npmrc 增加 registry=https://registry.npm.taobao.org 通过命令 npm config set registry http://registry.cnpmjs.org 临时使用指定源下载 npm install jquery --registry=https://registry.npm.taobao.org 使用 nrm 管理源 npm 配置文件# .npmrc 配置文件位置（~/.npmrc）npm config list# npm 缓存目录，默认 C:\Users\&lt;username&gt;\AppData\Roaming\npm-cachenpm config get cache# 删除 npm 缓存npm cache clean --force# npm 全局 node 包位置npm config get prefix# 或者npm root -g# 修改 npm 全局文件位置及缓存文件位置npm config set prefix "&lt;new_path&gt;"npm config set cache "&lt;new_path&gt;" 版本号使用 NPM 下载和发布代码时都会接触到版本号。NPM 使用语义版本号来管理代码 语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。 如果只是修复 bug，需要更新 Z 位 如果是新增了功能，但是向下兼容，需要更新 Y 位 如果有大变动，向下不兼容，需要更新 X 位 nrm 使用nrm ls 查看配置列表，带*号即为当前使用的配置 nrm use 源的别名：切换源 nrm add 别名 地址 ： 添加源 nrm test 别名 ： 测速 nrm del 别名 ：删除源]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端调试]]></title>
    <url>%2F2019%2Ftool%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[一些调试工具 直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法 100% 还原手机的真实情况 chrome 远程调试功能 chrome://inspect/#devices 需要连接数据线，其次是设置比较繁琐，而且还限制了 android 手机。对于 IOS 的调试则可能要使用 Safari 的另一套工具 weinre：远程调试，在 PC 上生成一个像 chrome 开发工具一样的调试器，需要手动引入 js Eruda、vConsole：在移动端页面上生成一个调试器，调试信息会挡住操作元素，查看复杂数据结构的 log 不方便，需要手动引入 js 安装各种虚拟机sdk，在电脑上进行手机调试。能比较真实模拟手机，但是安装繁琐，操作不方便，无法模拟真实的手势操作 Erudahttps://github.com/liriliri/eruda Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。 按钮拖拽，面板透明度大小设置。 Console面板：捕获Console日志，支持log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括%c自定义样式输出；支持按日志类型及正则表达式过滤；支持快捷命令加载underscore、jQuery库；支持JavaScript脚本执行。 Elements面板：查看标签内容及属性；查看应用在Dom上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看Dom上绑定的各类事件。 Network面板：捕获请求，查看发送数据、返回头、返回内容等信息。 Resources面板：查看并清除localStorage、sessionStorage及cookie；查看页面加载脚本及样式文件；查看页面加载图片。 Sources面板：查看页面源码；格式化html，css，js代码及json数据。 Info面板：输出URL及User Agent；支持自定义输出内容。 Snippets面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。 使用 通过 CDN 使用： &lt;script src="//cdn.bootcss.com/eruda/1.5.2/eruda.min.js"&gt;&lt;/script&gt;&lt;script&gt;eruda.init()&lt;/script&gt; 通过 npm 安装： npm install eruda --save 在页面中加载脚本： &lt;script src="node_modules/eruda/eruda.min.js"&gt;&lt;/script&gt;&lt;script&gt;eruda.init()&lt;/script&gt; Js文件对于移动端来说略重（gzip后大概100kb）。建议通过url参数来控制是否加载调试器，比如： ;(function() &#123; var src = 'node_modules/eruda/eruda.min.js' if (!/eruda=true/.test(window.location) &amp;&amp; localStorage.getItem('active-eruda') != 'true') return document.write('&lt;scr' + 'ipt src="' + src + '"&gt;&lt;/scr' + 'ipt&gt;') document.write('&lt;scr' + 'ipt&gt;eruda.init();&lt;/scr' + 'ipt&gt;')&#125;)() 初始化时可以传入配置： container：用于插件初始化的 Dom 元素，如果不设置，默认创建 div 作为容器直接置于 html 根结点下面 tool：指定要初始化哪些面板，默认加载所有 let el = document.createElement('div')document.body.appendChild(el)eruda.init(&#123; container: el, tool: ['console', 'elements'], useShadowDom: true&#125;) vConsolehttps://github.com/Tencent/vConsole 一个轻量、可拓展、针对手机网页的前端开发者调试面板。 特性 查看 console 日志 查看网络请求 查看页面 element 结构 查看 Cookies、localStorage 和 SessionStorage 手动执行 JS 命令行 自定义插件 使用说明 下载 vConsole 的最新版本。（不要直接下载 dev 分支下的 dist/vconsole.min.js） 或者使用 npm 安装： npm install vconsole 引入 dist/vconsole.min.js 到项目中： &lt;script src="dist/vconsole.min.js"&gt;&lt;/script&gt;&lt;script&gt; // 初始化 var vConsole = new VConsole() console.log('Hello world')&lt;/script&gt; weinrehttp://people.apache.org/~pmuellr/weinre/docs/latest/Home.html Element： 查看/修改dom，查看/修改 dom CSS Resources：查看/修改 localStorage, sessionStorage Network：查看网络请求 Timeline： Console：查看控制台输出 不能做 JS 调试 使用 # 安装npm install -g weinre# 启动 weinre 服务weinre --boundHost 192.168.3.44 --httpPort 8888启动调试客户端在浏览器中打开 'http://192.168.3.44:8888' 即可启动调试客户端在需要调试的页面中添加如下&lt;script src="http://192.168.3.44:8888/target/target-script-min.js#anonymous"&gt;&lt;/script&gt; spy-debuggerhttps://github.com/wuchangming/spy-debugger 微信调试，各种 WebView 样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP/HTTPS，无需USB连接设备 spy-debugger 集成了weinre，简化了weinre需要给每个调试的页面添加 js 代码。原理是拦截所有 html 页面请求注入weinre所需要的 js 代码。让页面调试更加方便 1、页面调试＋抓包2、操作简单，无需USB连接设备3、支持HTTPS4、spy-debugger内部集成了weinre、node-mitmproxy、AnyProxy。5、自动忽略原生 App 发起的 https 请求，只拦截 webview 发起的 https 请求。对使用了 SSL pinning 技术的原生App 不造成任何影响。6、可以配合其它代理工具一起使用(默认使用AnyProxy) (设置外部代理) 基本使用 # 安装npm install spy-debugger -g# 启动spy-debugger#设置手机的HTTP代理代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)# 手机安装证书手机浏览器访问 http://s.xxx设置-&gt;通用-&gt;描述文件与设备管理-&gt;找到node-mitmproxy CA（安装）设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到node-mitmproxy CA（打开） 自定义选项 # 自定义端口spy-debugger -p 8888# 设置页面内容为可编辑模式spy-debugger -w true# 是否只拦截浏览器发起的https请求(默认： true)spy-debugger -b false# 是否允许weinre监控iframe加载的页面(默认： false)spy-debugger -i true# 是否允许 HTTP 缓存(默认： false)spy-debugger -c true m-consolehttps://github.com/fwon/m-console 手机远程调试工具，手机通过代理连接上PC后，可以在PC版浏览器打印log和错误日志 需要手动给每个调试的页面添加 js 代码 DebugGap-VIDEhttps://www.debuggap.com/debug_webview.html Mobile Debughttps://www.mobiledebug.com/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>移动端调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker]]></title>
    <url>%2F2019%2Ftool%2Fdocker%2F</url>
    <content type="text"><![CDATA[安装 dcokerubuntu 16.04 (LTS) 安装 docker卸载旧版本 $ sudo apt-get remove docker docker-engine docker.io 镜像仓库方式安装 # 设置镜像仓库# 更新 apt 软件包索引：$ sudo apt-get update# 安装软件包，以允许 apt 通过 HTTPS 使用镜像仓库：$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common# 添加 Docker 的官方 GPG 密钥：$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 验证密钥指纹是否为 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。$ sudo apt-key fingerprint 0EBFCD88 设置 stable 镜像仓库 # amd64:sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" 安装 DOCKER CE $ sudo apt-get update$ sudo apt-get install docker-ce 验证是否正确安装 $ sudo docker run hello-world 此命令将下载一个测试镜像并在容器中运行它。容器运行时，它将输出一条参考消息并退出 升级 docker ce 如需升级 Docker CE，首先运行 sudo apt-get update，然后按照顺序执行操作，并选择您要安装的新版本 卸载 docker ce $ sudo apt-get purge docker-ce 主机上的镜像、容器、存储卷、或定制配置文件不会自动删除。如需删除所有镜像、容器和存储卷，请运行下列命令： $ sudo rm -rf /var/lib/docker 将 docker 配置为在启动时启动 centos 安装 docker卸载旧版本(如果安装过旧版本的话) $ sudo yum remove docker docker-common docker-selinux docker-engine 安装需要的软件包， yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的 $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 设置 yum 源 $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 可以查看所有仓库中所有 docker 版本，并选择特定版本安装 $ yum list docker-ce --showduplicates | sort -r 安装 $ sudo yum install docker-ce # 报错：Requires: container-selinux &gt;= 2:2.74You could try using --skip-broken to work around the problem$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo$ yum install epel-release # 阿里云上的 epel 源$ yum makecache$ yum install container-selinux 使用 docker安装镜像修改 docker 源 daemon.json &#123; "registry-mirrors": ["https://registry.docker-cn.com"]&#125; 重启 docker 安装 Ubuntu docker search ubuntu # 查找 Ubuntu 镜像docker pull ubuntu # 安装 Ubuntu 镜像docker images #查看 docker 镜像# 创建并运行 docker 容器docker run -it -d --name ubuntu_test -p 8088:80 ubuntu# --name 自定义容器名，-p 指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回 id# 多个 -p 指定多个端口映射# 运行 docker 容器 启动一个 bash 交互终端docker run -it 容器名:容器tag /bin/bashdocker start container_id# 查看所有启动的容器(查看所有容器加 -a)docker ps# 根据 id 查看容器信息docker inspect id# 进入docker(或者把容器id改为容器名，也可以进入)docker exec -it 容器id或容器名 /bin/bash# 退出容器exit# 停止容器docker stop id# 删除容器docker rm 容器id# 删除镜像docker rmi 删除镜像 备份镜像 # 制作 docker 镜像 1.0 为版本号docker commit 98 ubuntu_test:1.0# 查看镜像是否创建docker images# 保存镜像到 docker 账号中# 登录进 Docker 注册中心docker login# 推送镜像docker tag a25ddfec4d2a arunpyasi/container-backup:testdocker push arunpyasi/container-backup# 打包镜像并查看docker save -o ubuntu_test.tar ubuntu_test:1.0 恢复容器 # 从docker账号中拉取docker pull arunpyasi/container-backup:test# 从本地docker load -i ~/container-backup.tar# docker images# 用加载的镜像去运行Docker容器docker run -d -p 80:80 container-backup docker 给已存在的容器添加或修改端口映射 方式 1： 提交一个运行中的容器为镜像 $ docker commit containerid foo/live 运行镜像并添加端口 $ docker run -d -p 8000:80 foo/live /bin/bash 方式 2：iptable 转发端口 将容器的 8000 端口映射到 docker 主机的 8001 端口 $ iptables -t nat -A DOCKER -p tcp --dport 5001 -j DNAT --to-destination 45.77.150.20:8000 docker 容器使用问题Centos7 docker 容器报 docker Failed to get D-Bus connection 错误 $ systemctl start nginxFailed to get D-Bus connection: Operation not permitted。 原因是 dbus-daemon 没能启动 解决方法 docker run -it -d --name ubuntu_test -p 8088:80 ubuntu$ docker run --privileged -ti --name test1 centos /usr/sbin/init ssh 链接 docker 容器 进入容器 安装依赖 yum install passwd openssl openssh-server openssh-clients -y 安装 service 命令： yum install initscripts -y 修改密码： passwd 修改配置： vi /etc/ssh/sshd_config PubkeyAuthentication yes #启用公钥私钥配对认证方式AuthorizedKeysFile .ssh/authorized_keys #公钥文件路径 PermitRootLogin yes #root 能使用 ssh 登录 重启 ssh 服务，并设置开机启动： service sshd restartchkconfig sshd on 如果无法执行，可试着执行： systemctl start sshd.service systemctl enable sshd.serviceservice sshd restart docker-compose]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2019%2Fother%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[浏览器相关http 相关HTML css 相关js 相关jquery 相关工具类相关webpack 和 gulp 区别]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Webpack]]></title>
    <url>%2F2019%2Ftool%2Fwebpack%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Webpack webpack 官网 webpack 中文网 webpack 配置文件 概述webpack 是一个现代 JavaScript 应用程序的模块打包器（module bundler） webpack 是一个模块化方案（预编译） webpack 获取具有依赖关系的模块，并生成表示这些模块的静态资源 webpack 的两个特点：模块化、打包 四个核心概念：入口(entry)、输出(output)、加载器(loader)、插件(plugins) 模块化方案：webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）browserify 是与 webpack 相似的模块化打包工具 webpack 起源 webpack 解决了现存模块打包器的两个痛点： Code Spliting - 代码分离 静态资源的模块化处理方案 webpack 与模块 前端模块系统的演进 在 webpack 看来：所有的静态资源都是模块 webpack 模块能够识别以下等形式的模块之间的依赖： ES2015 import export CommonJS require() module.exports AMD define 和 require css/sass/less 文件中的 @import 图片连接，比如：样式 url(...) 或 HTML &lt;img src=...&gt; 字体等 在webpack提供的模块化环境中 想要加载一个JS文件，只需要 require(‘a.js’) 想要加载一个CSS文件，只需要 require(‘css/index.css’) 想要加载一个图片文件，只需要 require(‘images/a.png’) 入门 Webpack，看这篇就够了 webpack 打包原理：​ 入口文件： main.js ​ webpack 从入口出发，递归分析项目中所有的依赖项（模块），使用loader来处理对应的模块最终，打包生成一个 bundle.js 文件。 ​ 如果配置了 webpack 中的 代码分离（Code Spliting），webpack 会根据 分离点 将这个模块生成一个独立的JS文件 ​ 还可以通过配置，将 CSS 、 图片、 字体 等文件，从 bundle.js 中抽离为独立的文件 webpack 的基本使用安装：npm i -D webpack webpack-cli webpack：是 webpack 工具的核心包 webpack-cli：提供了一些在终端中使用的命令 -D(–save-dev)：表示项目开发期间的依赖 webpack 的两种使用方式：命令行、配置文件（webpack.config.js） 命令行使用说明 package.json中的scripts中可以存放一些 bash 命令，这些 bash 命令可以通过 npm run 命令名称 来执行 注意：npm 在执行 scripts 中的命令的时候，是在电脑系统后台默认开启一个 bash，将当前目录下的./node_modules/.bin这个文件夹临时加入了系统环境变量 使用方式：npm run build 设置开发状态： mode 如果没有设置 mode 配置项，webpack 会默认提供开发环境(production) 在入口文件中可以使用 import 引入 js css less 等文件 "scripts": &#123; // webpack 是 webpack-cli 提供的命令 // src/js/main.js 为入口文件 // --output dist/bundle.js 为出口文件 // --mode development 生产环境 "build": "webpack" "build1": "webpack src/js/main.js --output dist/bundle.js --mode development"&#125; 配置文件方式（推荐）项目根目录下创建一个 webpack.config.js文件，运行 webpack 命令时的默认配置文件 指定其他文件：--config webpack.XX.js 配置 package.json 中的 scripts , 脚本命令为： &quot;build&quot;: &quot;webpack&quot; 执行命令 : npm run build 示例代码 // webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置// 注意 : 不要再这个文件中使用ES6的的模块化 import语法const path = require('path')module.exports = &#123; // 入口 entry: path.join(__dirname, './src/js/main.js'), // 出口 output: &#123; // 出口目录 path: path.join(__dirname, 'dist'), filename: 'js/bundle.js' &#125;, // 开发模式 mode: 'development'&#125; webpack-dev-server安装：npm i -D webpack-dev-server 作用：配合 webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率 注意：无法直接在终端中执行 webpack-dev-server，需要在 package.json 配置 scripts 后使用 使用说明 webpack-dev-server将打包好的文件存储在内存中，提高编译和加载速度，效率更高（不会生成dist目录） 在内存中出口目录为项目根目录（命令行中的提示：webpack output is served from /） 在index.html页面中引入文件不需要加dist CLI 配置 --contentBase ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的 index.html） --contentBase ./src：当前目录下的 src 文件夹 --open true ：自动打开浏览器 --port 3000 ：指定端口号 --hot ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载 --progress：显示进度条 &#123; "scripts": &#123; "dev": "webpack-dev-server --contentBase src --open --port 8888 --hot" &#125;&#125; 配置文件配置配置 package.json 中的 scripts , 脚本命令为： &quot;dev&quot;: &quot;webpack-dev-server --hot&quot; 执行命令 : npm run dev // --hot 热更新写在命令行里，不然的话还要配其他插件麻烦module.exports = &#123; devServer: &#123; contentBase: path.join(__dirname, 'src'), // 自动打开浏览器 open: true, // 端口号 port: 3000, // hot: true, proxy: &#123; '/api': &#123; // api 表示当前项目请求的 key target: 'http://www.baidu.com', // 代理服务器路径 pathRewrite: &#123; '^/api': '/api' &#125;, // 重写路径 changeOrigin: true &#125; &#125; // 请求 localhost:8080/api/.. 会被代理到 http://www.baidu.com/api/.. &#125;, // plugins: [ // new webpack.HotModuleReplacementPlugin() // ]&#125; html-webpack-plugin 插件 安装：npm i -D html-webpack-plugin 作用：根据模板，在内存中自动生成 html 页面，并自动引入bundle.js、css等文件 配置文件配置： // 引入 html-webpack-plugin 插件const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; // 配置插件 plugins: [ // html-webpack-plugin 配置 new HtmlWebpackPlugin(&#123; // 模板页面路径 template: path.join(__dirname, 'src/index.html') &#125;) ]&#125; 打包非js文件webpack 默认只能处理 js 文件，非 js(css、less、图片、字体等)处理不了，借助 loader 加载器 处理 css 文件在 main.js中引入css文件 import &#39;../css/main.css&#39; 安装 : npm i -D style-loader css-loader 在 webpack.config.js 中，添加个新的配置项 module 在 module 中添加 loader 来处理 css module.exports = &#123; module: &#123; rules: [ // 处理 css // 注意点 use 执行loader 顺序 从右往左 // css-loader: 读取css文件内容，将其转化为一个模块 // style-loader: 拿到模块, 创建一个style标签，插入页面中 &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125;&#125; 处理 less 文件在 main.js中引入 less 文件 import &#39;../css/main.less&#39; 安装 : npm i -D less-loader less style-loader css-loader 在 webpack.config.js 中配置项 module-&gt;rules中添加 loader 来处理 less module.exports = &#123; module: &#123; rules: [ //处理 css &#123; test:/\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125; ] &#125;&#125; 处理图片文件安装 : npm i -D url-loader file-loader 在 webpack.config.js 中配置项 module-&gt;rules中添加 loader 来处理图片 module.exports = &#123; module: &#123; rules: [ // 处理图片 &#123; test: /\.(jpg|png)$/, use: [ &#123; loader: 'url-loader', options: &#123; // 图片大小 &lt;= 10000 =&gt; 转化为base64 // 图片大小 &gt;= 10000 =&gt; 不会转base64 内部调用 file-loader 加载图片 limit: 10000 &#125; &#125; ] &#125; ] &#125;&#125; url-loader 默认会将图片转化为 base64 编码格式，目的：提高性能 file-loader 在处理图片时，会对文件进行重命名 base64 编码格式的图片说明： 精灵图：将一些小图片合并为一张图片，减少请求次数，提高性能 字体图标：直接将一些小的图片,合并到字体文件中，并且不会失真 base64：是一种编码格式,能够将图片、文字等常见的文件，转化为 base64 格式，这种字符串格式浏览器能够识别并且读取显示到页面中 base64 是一个字符串，也可以直接被内嵌到页面中，或者 css 中 注意：大图片不适合用 base64 处理，只有小的图标才适合 base64 处理 处理字体文件在 main.js 中引入 css 文件 import &#39;../css/iconfont/iconfont.css&#39; 在 webpack.config.js 中配置 module.exports = &#123; module: &#123; rules: [ // 处理字体图标 &#123; test: /\.(svg|woff|woff2|ttf|eot)$/, use: 'url-loader' &#125; ] &#125;&#125; 处理 ES6 语法 现在的项目都是使用 ES6 开发的，但是这些新的 ES6 语法，并不是所有的浏览器都支持，所以就需要有一个工具，帮我们转成 es5 语法，这个就是：babel babel Babel is a JavaScript compiler. ==&gt; babel 是一个 JavaScript 编译器 webpack 只能处理 import / export 这个 es6 模块化语法，而其他的 js 新语法，应该使用 babel 来处理 babel 的使用 : 安装： npm i -D babel-core babel-loader@7 babel-core 是 babel 的核心包 babel-loader 加载 js 文件，并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js 安装：npm i -D babel-preset-env babel-preset-stage-2 babel-preset-env：表示能够解析 es2015、es2016、es2017、es2018 这些标准的语法 babel-preset-stage-2：用来解析还没有被采纳为标准的语法 babel-polyfill与babel-plugin-transform-runtime 也是做兼容处理的,以前都是用这个，兼容更早的 配置 : 在 webpack.config.js 中添加一个 loader module.exports = &#123; module: &#123; rules: [ // 处理 ES6 语法 &#123; test: /\.js$/, use: 'babel-loader', // 设置忽略 node-modules 文件夹 exclude: /node-modules/ &#125; ] &#125;&#125; 在项目根目录中创建 babel 的配置文件，叫：.babelrc &#123; &quot;presets&quot;: [ &quot;env&quot;, &quot;stage-2&quot; ], ----------- // 暂时不用 // 如果未来某一天真的用到了polify &quot;plugins&quot;: [ &quot;transform-runtime&quot;, &#123; &quot;helpers&quot;: false, &quot;polyfill&quot;: true, &quot;regenerator&quot;: true, &quot;moduleName&quot;: &quot;babel-runtime&quot; &#125; ]&#125; 项目打包上线执行 : npm run build 对项目进行打包，生成dist文件 模拟本地服务器 : 安装 : npm i -g http-server 把dist文件里的内容放到服务器里即可，直接运行http-server webpack 和 gulp 区别 Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给 gulp 配置不通的 task（通过Gulp 中的 gulp.task() 方法配置，比如启动 server、sass/less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程 Webpack 也称之为模块打包机 ，由此也可以看出 Webpack 更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块，最初 Webpack 本身就是为前端 JS 代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack 是通过 loader（加载器）和 plugins（插件）对资源进行处理的 gulp是构建工具，Webpack是 js 模块化的解决方案]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2019%2Fjavascript%2Fpromise%2F</url>
    <content type="text"><![CDATA[Promise Promise 是异步编程的一种解决方案，它允许你以一种同步的方式编写异步代码 promise：承诺、保证 ES6 - Promise JS 是通过回调函数来实现异步编程的，当异步操作多了以后，就会产生回调嵌套回调的问题，这就是回调地狱 Promise 方式：将异步操作以同步操作的方式表达出来，避免了层层嵌套的回调函数 封装一个 Promise// 按序读取文件：a -&gt; b -&gt; c// 按顺序读取 a b c 文件// 以前// 读取 a 文件fs.readFile('./a', (err, data) =&gt; &#123; if (err) return console.log('读取错误') console.log(data.toString()) // 读取 b 文件 fs.readFile('./b', (err, data) =&gt; &#123; if (err) return console.log('读取错误') console.log(data.toString()) // 读取 c 文件 fs.readFile('./a', (err, data) =&gt; &#123; if (err) return console.log('读取错误') console.log(data.toString()) &#125;) &#125;)&#125;)// 使用 Promise// 封装// Promise 是一个构造函数// 通过 new 创建 Promise 的实例对象function readFile (path) &#123; // 实例化 Promise const p = new Promise((resolve, reject) =&gt; &#123; // resolve 表示成功，异步操作成功调用 // reject 表示失败，异步操作失败调用 fs.readFile(path, (err, data) =&gt; &#123; // 读取错误，调用 reject() if (err) return reject(err) // 读取成功 调用 resolve resolve(data.toString()) &#125;) &#125;) // 返回 Promise 对象 return p&#125;// 使用readFile('a') .then(res =&gt; &#123; console.log(res) return readFile('a')&#125;) .then(res =&gt; &#123; console.log(res) return readFile('b')&#125;) .then(res =&gt; &#123; console.log(res)&#125;) promise 的三个状态 pending : 等待 (等待成功或者失败去调用) resolved : 成功调用 rejected : 失败调用 then 和 catch 说明：获取异步操作的结果 then() ：用于获取异步操作成功时的结果 -&gt; resolve catch()：用于获取异步操作失败时的结果 -&gt; reject 说明：then()方法可以有多个，按照先后顺序执行，通过回调函数返回值传递数据给下一个 then p // 成功 .then(value =&gt; &#123; console.log('文件a的内容为：', value) &#125;) // 失败（比如：文件路径错误） .catch(err =&gt; &#123; console.log('文件读取失败：', err) &#125;)// ----------- 或者 -----------p.then( value =&gt; &#123; // 成功 &#125;, err =&gt; &#123; // 失败 &#125;) all 和 race// 等待所有请求完成，才会执行后续代码const p = Promise.all([ axios('/a'), axios('/b')])p.then((res) =&gt; &#123; // res 是 all() 方法中所有异步操作的结果 console.log(res)&#125;)// 只要有一个请求完成，就会继续执行后续代码const p = Promise.race([ axios('/a'), axios('/b')])p.then((res) =&gt; &#123; // res 是 race() 方法中先完成的异步操作的结果 console.log(res)&#125;) async 和 await 异步编程终极方案 async / await 用同步编写代码的方式 处理异步操作的一个方案 async：修饰 (修饰一个内部有异步操作的函数) 格式 : async + 函数 (里面有异步操作的函数) await : 等待 (等上一个异步操作完成啊 , 修饰 一个结果是promise的)异步操作 格式 : await + 异步操作(结果promise对象) async 和 await 是成对出现的，await 只能在 async 函数中使用 // 第一步封装function readFile(path) &#123; // 1. 实例化 promise const p = new Promise((resolve, reject) =&gt; &#123; fs.readFile(path, (err, data) =&gt; &#123; if (err) &#123; // 操作错误 调用 =&gt; reject =&gt; catch return reject(err) &#125; // 操作成功 调用 =&gt; resolve =&gt; then resolve(data.toString()) &#125;) &#125;) // 2. 返回 promise 对象 return p&#125;// 第二步：使用 (async/await)// async + 函数 (里面有异步操作的函数)async function fn() &#123; // await + 异步操作(结果promise对象) // 读取a文件 try &#123; const res1 = await readFile('./data/a1.txt') console.log(res1) &#125; catch (error) &#123; console.log(error) &#125; // 读取 b 文件 const res2 = await readFile('./data/b.txt') console.log(res2) // 读取 c 文件 const res3 = await readFile('./data/c.txt') console.log(res3)&#125;fn() // 延时函数function sleep (a, b) &#123; const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(b) &#125;, a) &#125;) return p&#125;async function fn () &#123; const res1 = await sleep(1000, 'a') console.log(res1) const res2 = await sleep(5000, 'b') console.log(res2) const res3 = await sleep(3000, 'c') console.log(res3)&#125;// fn()sleep(1000, 'a') .then(res =&gt; &#123; console.log(res) return sleep(5000, 'b')&#125;) .then(res =&gt; &#123; console.log(res) return sleep(3000, 'c')&#125;) .then(res =&gt; &#123; console.log(res)&#125;)const p1 = Promise.all([sleep(1000, 'a'), sleep(5000, 'b')])p1.then(res =&gt; &#123; console.log(res)&#125;)const p2 = Promise.race([sleep(1000, 'a'), sleep(5000, 'b')])p2.then(res =&gt; &#123; console.log(res)&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue]]></title>
    <url>%2F2019%2Fvue%2Fvue%2F</url>
    <content type="text"><![CDATA[Vue vue 中文网 github 下载地址 Vue.js (读音 /vju:/ view) 渐进式 JavaScript 框架 渐进式：小型项目使用 vue 就够了，随着页面的复杂程度提高，就要学习 vue-rouer 来管理更多的页面，再随着项目的数据越来越多，管理数据也变得麻烦起来了，就开始使用 vuex 来管理数据 框架 : 一整套的解决方案 框架和库的区别库(Library) ，代表 : jquery 库就是一系列函数的集合，我们开发人员在使用库的时候，想要完成什么样的功能，就调用库中提供的某个方法 比如：想要添加样式，就调用 jquery 中的 .css() / .addClass() 库起到了一个辅助的作用，在使用库的是时候，是由开发人员说了算，也是由开发人员起主导作用 框架 (Framework)，代表 : vue 在使用框架的时候，是由框架说了算，由框架起到了主导作用 框架是一套完整的解决方案，框架中制定了一套规则，使用框架的时候，只需要按照规则把代码放到合适的地方，然后框架会在合适的时机，主动调用开发人员的代码 比如 : 想用 vue 组件里遍历就得使用 v-for，使用 for 不行 主要区别：控制反转 也就是 : 谁起到了主导作用 使用库的时候：开发人员起主导作用 使用框架的时候：框架起到了主导作用 从体量上看，框架一般比库大 会发现使用框架的时候，会受到很多限制 我们所说的前端框架与库的区别？ MVC + MVVMMVC MVC 是一种软件架构模式，也有人叫做设计模式 M : Model 数据模型 (专门用来操作数据，数据的 CRUD) V : View 视图 (对于前端来说就是页面) C : Controller 控制器 (是视图和数据模型沟通的桥梁，用于处理业务逻辑) MVVM Vue 使用的是 MVVM 模式 MVVM ===&gt; M / V / VM M : model 数据层 V : view 视图层 VM : ViewModel 视图模型 核心 : M &lt;===&gt; VM &lt;===&gt; V MVVM 优势 MVC 模式将应用程序划为三个部分，实现职责分离 但是，在前端中，经常要通过 js 代码来进行一些逻辑操作，最终还要把这些逻辑操作展示页面中，也需要频繁的操作DOM 比如 : ajax 请求、添加、修改、设置样式、动画 MVVM 的思想通过 数据双向绑定 让数据自动的双向同步 V (修改视图) –&gt; M M (修改数据) –&gt; V 采用的是 : 数据驱动视图的思想，数据是核心。不要再想着怎么操作 DOM，而是想着如何操作数据 Vue 中的 MVVM 注意 : 不推荐直接手动操作 DOM 每个人操作 DOM 的方法不一样，会造成性能不一样官网 : 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例 Vue 基本使用 安装 : npm i vue 导入 : &lt;script src=&#39;./vue.js&#39;&gt;&lt;/script&gt; 实例化 vue const vm = new Vue(&#123; // 指定 vue 管理的边界，不能是 body 或 html 节点 el: '#app', // 提供视图中需要的数据 // 视图可以直接使用 data 中的数据 data: &#123; msg: 'xxx' &#125;&#125;) 使用注意点使用 vm 表示 vue 实例 Vue 构造函数首字母大写 参数是一个对象 id=’#app’，其他也可以 边界外无法使用 msg 插值表达式1. &#123;&#123;&#125;&#125; : mustache 语法，小胡子语法，插值表达式2. 作用 : 使用`&#123;&#123;&#125;&#125;` 从`data`中获取数据，并展示在模板中3. 说明 : `&#123;&#123;&#125;&#125;` 中只能出现 js 表达式4. `&#123;&#123;&#125;&#125;` 语法不能作用在 HTML 元素的属性上 表达式 (有返回值的)： 基本的数据类型 1 &#39;abc&#39; false [] {} 数据类型 和 运算符结合在一起1+2 arr.join(&#39;-&#39;) true ? 123 : 321 语句： if 语句 for 语句 双向数据绑定input + v-modelv-model 指令：数据双向绑定的指令 作用：把 data 中的 num 值 和 input 上的值绑定到一起，一方的值发生了改变，另 一方也会跟着改变 注意：v-model 只能用在表单控件上（input checkbox 等） Object.defineProperty()let obj = &#123;&#125;let temp// 参数1：要给哪个对象设置属性// 参数2：给对象设置什么属性// 参数3：属性的修饰符Object.defineProperty(obj, 'name', &#123; set: function (newVal) &#123; console.log('赋值了', newVal) &#125;, get: function () &#123; console.log('取值了') return temp &#125;&#125;) 数据双向绑定的原理&lt;div id="app"&gt; &lt;input id="input" type="text" /&gt;&lt;/div&gt; let obj = &#123;&#125;let tempObject.defineProperty(obj, 'name', &#123; set: function (newVal) &#123; // 设置属性时会触发该函数 console.log('设置', newVal) temp = newVal input.value = newVal &#125;, get: function () &#123; // 获取属性时会触发该函数 console.log('获取') return temp &#125;&#125;)input.oninput = function () &#123; // console.log(this.value) obj.name = this.value console.log(obj.name)&#125; 深入响应式原理检测变化注意：受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 Vue 不允许在已经创建的实例上动态添加新的根级响应式属性，可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上，或者创建一个包含原对象属性和新属性的对象替换掉原对象 列表渲染数组更新检测数组的方法可以触发视图更新：方法如下： push()、pop()、shift()、unshift()、splice()、sort()、reverse() 替换数组 用一个含有相同元素的数组去替换原来的数组并不会导致 Vue 丢弃现有 DOM 并重新渲染整个列表 注意：由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 解决第一类问题： // Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 解决第二类问题： vm.items.splice(newLength) 指令学习指令 指令：就是一个特殊的标记，起一个辅助作用，使 html 具备原来没有的功能 vue 中所有的指令都是以 v- 开头的，比如 : v-model v-bind v-if v-for 等等 v-model (常用) 说明：用在表单元素中，用来实现数据双向绑定 (input checkbox 等等)作用：将 数据 和 文本框的值 绑定到一起，任何一方发生改变，都会引起对方的改变注意：v-model 在不同类型的表单元素中作用不同v-model 会忽略所有表单元素的 value、checked、selected 的初始值而总是将 Vue 实例的数据作为数据来源 &lt;div id="app"&gt; &lt;!-- 文本输入框 绑定的是值 --&gt; &lt;input type="text" v-model="num" /&gt; &lt;!-- 多选框 绑定的选中状态 --&gt; &lt;input type="checkbox" v-model="isChecked" /&gt;&lt;/div&gt; const vm = new Vue(&#123; el: '#app', data: &#123; num: 0, isChecked: true &#125;&#125;) v-text 和 v-html 说明 : 设置文本内容 v-text : 相当于之前的 innerText v-html : 相当于之前的 innerHTML，会解析 html 标签，（已经废弃三大括号的插值） &lt;div id="app"&gt; &lt;h1 v-text="msg1"&gt;&lt;/h1&gt; &lt;h1 v-html="msg2"&gt;&lt;/h1&gt;&lt;/div&gt; const vm = new Vue(&#123; el: '#app', data: &#123; msg1: '&lt;a href="#"&gt;haha&lt;/a&gt;', msg2: '&lt;a href="#"&gt;haha&lt;/a&gt;' &#125;&#125;) v-bind (常用) 说明：动态绑定数据 (单向)出现原因：在 HTML 属性中，无法使用插值表达式 &lt;div id="app"&gt; &lt;a v-bind:href="href"&gt;hahaha&lt;/a&gt; &lt;!-- v-bind 可以直接省略 --&gt; &lt;a :href="href"&gt;hahaha&lt;/a&gt;&lt;/div&gt; // v-bind：// 说明：动态数据绑定 (单向)，因为html的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据, 需要使用 v-bindconst vm = new Vue(&#123; el: '#app', data: &#123; href: 'https://www.baidu.com' &#125;&#125;) v-bind 和 v-model 的区别&lt;!-- v-model 数据双向绑定 --&gt;&lt;!--场景：表单元素中 --&gt;&lt;input type="checkbox" v-model="isChecked1" /&gt;&lt;!-- v-bind 数据动态绑定 (单向) --&gt;&lt;!--场景：主要用在属性中 --&gt;&lt;input type="checkbox" :checked="isChecked2" /&gt; 操作样式&lt;div id="app"&gt; &lt;!-- 操作样式 --&gt; &lt;!-- 1. 动态添加类，但不符合 vue 数据是核心的思想 --&gt; &lt;h1 :class="cls"&gt;hahaha&lt;/h1&gt; &lt;!-- 2. class 值是一个对象 --&gt; &lt;!-- 属性名为类名 --&gt; &lt;!-- 属性值为布尔值 --&gt; &lt;h1 :class="&#123;red: isRed, fz: isFz&#125;"&gt;hahaha&lt;/h1&gt; &lt;!-- 3. style --&gt; &lt;h1 :style="&#123;backgroundColor: 'red', fontSize: fz + 'px'&#125;"&gt;hahaha&lt;/h1&gt;&lt;/div&gt; // v-bind :// 说明 : 动态数据绑定 (单向)，因为 html 的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据 , 需要使用 v-bindconst vm = new Vue(&#123; el: '#app', data: &#123; href: 'https://www.baidu.com' &#125;&#125;) 其他操作 &lt;div id="app"&gt; &lt;div :class="['red', 'fz']"&gt;heheheh&lt;/div&gt; &lt;!-- ===&gt; &lt;div class="red fz"&gt;&lt;/div&gt; --&gt; &lt;!-- 多个样式对象写成数组的形式，如果有相同样式后面会覆盖前面 --&gt; &lt;div :class="[&#123;red: true&#125;, 'fz']"&gt;hehehe&lt;/div&gt; &lt;!-- ===&gt; &lt;div class="red fz"&gt;&lt;/div&gt; --&gt;&lt;/div&gt; v-on 注册事件/绑定事件 v-on:click 绑定了一个 click 事件 缩写 : @click=’fn’ 函数写在 methods 里面 &lt;div id="app"&gt; &lt;button v-on:click="fn"&gt;按钮&lt;/button&gt; &lt;!-- 简写 @ --&gt; &lt;button @click="fn1"&gt;按钮&lt;/button&gt; &lt;!-- 传参 --&gt; &lt;button @click="fn2(123)"&gt;按钮&lt;/button&gt;&lt;/div&gt; // v-on 注册事件// v-on:click =&gt; 绑定点击事件const vm = new Vue(&#123; el: '#app', data: &#123;&#125;, // 事件函数写在 methods 中 methods: &#123; fn () &#123; console.log('haha') &#125;, fn1 () &#123; console.log('haha') &#125;, fn2 (ref) &#123; console.log(ref) &#125; &#125;&#125;) 函数里面的 this 指的就是 vm 实例 this === vm // truethis.msg // 获取数据this.msg = 'XXX' // 修改数据 事件对象 $event &lt;!-- 绑定事件对象的时候, 没有添加小括号，此时，直接在方法中，通过参数 e 就可以获取到事件对象 --&gt;&lt;button @click="fn"&gt;按钮&lt;/button&gt;&lt;!-- 如果绑定事件的地方,事件函数有() @click='fn()' 则需要通过 $event 获取 --&gt;&lt;button @click="fn1($event, 123)"&gt;按钮&lt;/button&gt; const vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; fn (e) &#123; console.log(e) &#125;, fn1 (e, ref) &#123; console.log(e) console.log(ref) &#125; &#125;&#125;) v-for遍历数据，为数据中的每一项生成一个指令所在的标签 &lt;!-- 1: 最常用 遍历数组 --&gt;&lt;li v-for="(item, index) in list1"&gt;&#123;&#123; item &#125;&#125; - &#123;&#123; index &#125;&#125;&lt;/li&gt;&lt;!-- 2: 遍历元素是对象的数组 --&gt;&lt;li v-for="item in list2"&gt;&#123;&#123; item.name &#125;&#125; - id:&#123;&#123; item.id &#125;&#125;&lt;/li&gt;&lt;!-- 3: 遍历对象 --&gt;&lt;!-- item 是 属性值，key 是属性名 --&gt;&lt;li v-for="(item, key) in obj"&gt;&#123;&#123; item &#125;&#125;-&#123;&#123;key&#125;&#125;&lt;/li&gt;&lt;!-- 4: 生成10个h1 （item是1-10）--&gt;&lt;h1 v-for="item in 10"&gt;我是h1 &#123;&#123; item &#125;&#125;&lt;/h1&gt; v-if 和 v-show&lt;h1 v-if="isShow"&gt;我是h1 v-if&lt;/h1&gt;&lt;h1 v-show="isShow"&gt;我是h1 v-show&lt;/h1&gt; v-if 和 v-show 都可以切换元素的显示与隐藏，不同的是 v-if 通过创建删除节点来控制元素的显示与隐藏， v-show 的元素始终会被渲染并保留在 DOM 中，只是简单地切换元素的 CSS 属性 display，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else 使用场景 : v-if 因为要不断的创建和删除来切换显示与隐藏，所以性能不高 v-if：切换次数不频繁的时候 v-show：切换次数频繁的时候 v-else-if 和 v-elsev-else：两种情况的 &lt;h1 v-if="num &gt; 40"&gt;第一个&lt;/h1&gt;&lt;h1 v-else&gt;第三个&lt;/h1&gt; v-else-if：三种以上情况 &lt;h1 v-if="num &gt;= 40"&gt;第一个&lt;/h1&gt;&lt;h1 v-else-if="num &gt;= 30 &amp;&amp; num &lt; 40"&gt;第二个&lt;/h1&gt;&lt;h1 v-else&gt;第三个&lt;/h1&gt; v-once作用：告诉 vue 这个标签中的内容只需要解析一次，即便是数据再发送改变，这个标签中的内容也不会被更新 &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt;&lt;p v-once&gt;带 onece 的 &#123;&#123; num &#125;&#125;&lt;/p&gt; v-pre作用：告诉 vue 这段节点中没有指令或表达式，不需要解析，从而，提升性能 &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/p&gt;&lt;p v-pre&gt;带 v-pre &#123;&#123; num &#125;&#125;&lt;/p&gt; v-cloak使用遮盖 给要遮盖的元素添加一个 v-cloak 指令： &lt;h1 v-cloak&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; 使用属性选择器，添加样式：[v-cloak] { display: none } vue 会在解析模板后将 v-cloak 指令从页面中移除，移除指令的时候，差值表达式已经变为对应的数据 按键修饰符在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符 Vue 为最常用的按键提供了别名： &lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13="submit" /&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit" /&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit" /&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive &lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器 .ctrl .alt .shift .meta &lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear" /&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl="doSomething"&gt;Do something&lt;/div&gt; 鼠标按钮修饰符 .left .right .middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮 计算属性computed: &#123; message () &#123;&#125;,&#125; 特点：计算属性是基于它们的响应式依赖进行缓存的，只有跟计算属性相关的数据发生了改变，计算属性才会重新计算 注意点: 计算属性必须返回一个值 计算属性只能当属性用，不能当方法用 不能和 data 中的属性名重名 key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升 就地复用 &lt;!-- 显示组件 --&gt;&lt;p v-for="(item, index) in list" :key="index"&gt; &#123;&#123; item.name &#125;&#125; &lt;input type="text" /&gt;&lt;/p&gt;&lt;!-- 数据 --&gt;data: &#123;list: [&#123;id: 1, name: 'zs'&#125;, &#123;id: 2, name: 'ls'&#125;, &#123;id: 3, name: 'ww'&#125;]&lt;!-- 演示 --&gt;vm.list.unshift(&#123;id:4, name:'zl'&#125;) 使用 key 如果数组的元素是一个对象，使用对象里固定属性，一般情况下，对象里都有 id 如果数组的元素是一个简单类型，不是一个对象，就可以取索引作为 key 异步 DOM 更新 Vue 中采用了 异步DOM更新 的机制 数据发生改变后，vue 没有立即将数据的改变更新到视图中，而是等到数据不再变化的时候 一次性的将数据的改变更新到视图中 为什么是异步 DOM 更新? 性能的考虑 因为对于前端来说，修改数据进行 DOM 操作是常有的事情，如果频繁操作 DOM，会严重影响页面的加载性能 DOM 操作这是前端的性能的瓶颈 比如 : for (let i = 1; i &lt; 10000; i++&gt;) 如果同步 就要重新渲染 1000 次 验证异步 DOM 更新： // 通过dom来获取count的值// this.$el ==&gt; vue 边界元素console.log(this.$el.children[0].innerText) // 0this.count = 100console.log(this.$el.children[0].innerText) // 0 需求：在数据更新后，立即获取到更新后的内容 this.$nextTick(() =&gt; &#123; // DOM 更新后，会执行 this.$nextTick() 的回调函数，所以能拿到值 console.log(this.$el.children[0].innerText) // 100&#125;) 监听 watchvue 中可以通过 watch 配置项来监听 vue 实例中数据的变化 基本使用 data: &#123; num: 0&#125;,// 监听watch: &#123; // 监听 num 属性的数据变化 // 作用: 只要 num 的值发生变化，这个方法就会被调用 // 第一个参数: 新值 // 第二个参数: 旧值 num (newVal, oldVal) &#123; console.log('新:', newVal) console.log('旧:', oldVal) &#125;&#125; 监听对象 data: &#123; msg: '', obj: &#123; age: 18 &#125;&#125;watch: &#123; // 监听对象 obj (newVal) &#123; // 虽然 obj 中的属性值发生改变了，但 obj 引用的地址没有发生改变，所以不会触发事件 console.log(newVal) &#125;, // 监听对象的属性 // 从对象的角度来监听的 obj: &#123; // 深度监听 监听对象里面的属性 deep: true, // 页面刚进入立即触发监听，以表达式的当前值触发回调 immediate: true, // 对象里的属性值发生变化，调用 handler 方法 handler (newVal) &#123; this.msg = `obj.age 值变化了，新值：$&#123;newVal.age&#125;` &#125; &#125;, // 从属性的角度来监听 'obj.age' (newVal) &#123; this.msg = `obj.age 值变化了，新值：$&#123;newVal&#125;` &#125;&#125; 使用案例：需求 : 监听文本框字符个数，并显示格式验证码 &lt;input type="text" v-model="val" /&gt;&lt;span v-show="isTrue"&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt; data: &#123; val: '', msg: '请输入 6-12 位', isTrue: false&#125;,watch: &#123; val (newVal) &#123; if (/^[0-9a-zA-z]&#123;6,12&#125;$/.test(newVal)) &#123; this.isTrue = false &#125; else &#123; this.isTrue = true &#125; &#125;&#125; 生命周期函数 所有的 vue 组件，都是 vue 实例，一个组件对应一个实例，并且接收相同的选项对象（一些根实例特有的选项除外） 实例生命周期也叫做：组件生命周期 声明周期图：01 生命周期介绍vue 生命周期钩子函数 简单说：一个组件（实例）从开始到最后消化所经历的各种状态，就是一个组件的生命周期 生命周期钩子函数的定义：从组件被创建，到组件挂在到页面上运行，再到页面关闭组件被销毁，这三个阶段总是伴随着组件的各种事件，这些事件，统称为组件的生命周期函数（简称 : 钩子函数） 开发人员可以通过 vue 提供的钩子函数，让我们写的代码参与到 vue 的生命周期里面来，让我们的代码在合适的阶段起到相应的作用 注意： vue 在执行过程中会 自动调用 生命周期钩子函数，我们只需要提供这些钩子函数即可 钩子函数的名称都是 vue 中规定好的 vue 实例生命周期 参考 1 vue 实例生命周期 参考 2 钩子函数 - beforeCreate 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 此时组件的选项还未挂载，因此无法访问 methods，data，computed 上的方法或数据 使用场景 : 几乎不用 钩子函数 - created (掌握) 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见 可以调用 methods 中的方法、改变 data 中的数据，并且修改可以通过 vue 的响应式绑定体现在页面上、获取 computed 中的计算属性等 使用场景：发送 ajax、本地存储获取数据 钩子函数 - beforeMounted() 在挂载开始之前被调用（挂载：DOM 渲染） 钩子函数 - mounted() (掌握) el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 这个周期可以获取 DOM 指令的生效在 mounted 周期之前 在这个周期内，对 data 的改变可以生效。但是要进下一轮的 DOM 更新，DOM 上的数据才会更新 使用场景：发送 ajax、操作 DOM 钩子函数 - beforeUpdate() 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程 此处获取的数据是更新后的数据，但是获取页面中的 DOM 元素是更新之前的 小提示 : 打印 this.$el ，打开小三角是之后的，是因为打印是有监听的功能，展示的是后面更改之后的 钩子函数 - updated() 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子 组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作 应该避免在此期间更改状态。如果要相应状态改变，通常最好使用 计算属性 或 watcher 取而代之 钩子函数 - beforeDestroy() 实例销毁之前调用。在这一步，实例仍然完全可用。 使用场景：实例销毁之前，执行清理任务，比如：清除定时器等 created () &#123; this.timerId = setInterval(() =&gt; &#123; console.log(1111) &#125;, 500)&#125;, // 如果当组件销毁了,还不清除定时器会出现性能问题 // 在浏览器中可以尝试销毁 vm.$destroy() // 最后销毁beforeDestroy () &#123; clearInterval(this.timerId)&#125; 钩子函数 - destroyed() Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 使用接口的形式发送数据json-server 提供假数据接口 作用：根据指定的 JSON 文件，提供假数据接口 地址：json-server 使用步骤 1. 全局安装 json-server: `npm i -g json-server`2. 准备一个json数据3. 执行：`json-server data.json`data.json&#123; "todos": [ &#123; "id": 1, "name": "张三", "age": 20 &#125; ]&#125; REST API 格式 1. 查询：GET2. 添加：POST3. 删除：DELETE4. 更新： PUT：需要将对象里的所有属性提交 PATCH(打补丁)：只需要提交需要修改的属性 具体接口 查询全部数据 http://localhost:3000/todos查询指定数据 http://localhost:3000/todos/2 添加一个对象 http://localhost:3000/todosPOSTid 会自动帮我们添加 更新数据 http://localhost:3000/todos/3PUT 或者 PATCHPUT 需要提供该对象的所有数据PATCH 只需要提供要修改的数据即可 删除数据http://localhost:3000/todos/3DELETE 可以借助 postman 测试接口 axios 发送请求 作用 : 一个专门用来发送 ajax 请求的库, 可以在浏览器或者 node.js 中使用 使用步骤 本地安装 axios : npm i -g axios 导入 axios axios 使用说明 GTE 方式发送请求 // 方式1axios.get('http://localhost:3000/todoList/1').then(res =&gt; &#123; console.log('获取到数据了：', res.data)&#125;)// 方式2axios .get('http://localhost:3000/todoList', &#123; params: &#123; id: 1 &#125; &#125;) .then(res =&gt; &#123; console.log('获取到数据了：', res.data) &#125;) POST 方式发送请求 // post 请求axios // 第一个参数：表示接口地址 // 第二个参数：表示接口需要的参数 .post('http://localhost:3000/todoList', &#123; name: 'haha', done: true &#125;) .then(res =&gt; &#123;&#125;) 过滤器概念 : vue 中的过滤器(filter)：数据格式化，让数据按照我们规定的格式输出 比如 : 对于日期来说，将日期格式化转化为 年-月-日 小时:分:秒 &lt;!-- 直接显示 --&gt;&lt;h1&gt;&#123;&#123; date &#125;&#125;&lt;/h1&gt;显示：2019-01-11T10:11:19.566Z 不是我们想要的 我们想要的：2019-01-11 18-11-53 全局过滤器 和 局部过滤器 全局方式创建的过滤器，在任何一个 Vue 实例中都可以使用 (一般情况下，为了项目方便管理，都是一个 vue 实例) 局部创建的过滤器只能在当前 vue 实例中使用 全局过滤器应在 Vue 实例创建之前创建 注册全局过滤器 // 第一个参数：过滤器的名字// 第二个参数：是一个回调函数，只要使用过滤器的时候，这个回调函数就会执行，res =&gt; 原始数据// 必须要有返回值：通过回调函数的返回值得到格式化后的数据Vue.filter('date', res =&gt; &#123; return res&#125;) 注册局部过滤器 在 vm 的配置项里写一个 filters，对应的是一个对象 filters: &#123; date (res) &#123; return res &#125;&#125; moment 插件 moment 使用：npm i moment 日期 =&gt; 指定格式moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;) 时间戳 =&gt; 指定格式moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;) Vue.filter('dataFilter', res =&gt; &#123; return moment(res).format('YYYY-MM-DD HH-mm-ss')&#125;) 使用过滤器 &lt;!-- data: 原始数据 dataFilter: 过滤器名称 |：管道--&gt;&lt;h1&gt;&#123;&#123; date | dataFilter &#125;&#125;&lt;/h1&gt; // 全局Vue.filter('dataFilter', res =&gt; &#123; return moment(res).format('YYYY-MM-DD HH-mm-ss')&#125;)// 局部filters: &#123; date (res, format = 'YYYY-MM-DD', arg) &#123; return moment(res).format(format) &#125;&#125; 参数问题 &lt;h1&gt;&#123;&#123; date | dateFilter('YYYY-MM-DD HH-mm-ss', 888) &#125;&#125;&lt;/h1&gt; Vue.filter('dateFilter', (res, format = 'YYYY-MM-DD', arg) =&gt; &#123; // res: 原始数据 // format：dateFilter 中的第一个参数，等号后面为默认值 // arg: dateFilter 中的第二个参数 console.log(arg) // 888 return moment(res).format(format)&#125;) 组件 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常 可复用 的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树 注册组件的两种方式：全局组件、局部组件 Vue 实例中的配置项（如：methods、filters、watch、computed、directives、生命周期钩子函数）都可以在组件中使用 全局组件 说明：全局组件在所有的 vue 实例中都可以使用 注意： 注册全局组件应放在 vm 实例之前 模板只允许有一个根节点 组件中的 data 必须是函数，并且要返回一个对象 组件复用时如果 data 为对象，所有复用的组件的 data 指向同一片内存空间，一个组件被修改了会影响其他组件，这不是我们想要的 // 注册全局组件Vue.component('hello', &#123; template: '&lt;p&gt;A custom component!&lt;/p&gt;', data () &#123; return &#123; msg: '注意：组件的data必须是一个函数！！！' &#125; &#125;&#125;)// 给组件指定返回值// 组件名称为 Oneconst One = Vue.component('hello', &#123; template: '&lt;p&gt;A custom component!&lt;/p&gt;'&#125;)// 可以简写为 ==&gt;const One = &#123; template: '&lt;p&gt;A custom component!&lt;/p&gt;'&#125; &lt;!-- 使用：以自定义元素的方式 --&gt;&lt;div id="example"&gt; &lt;hello&gt;&lt;/hello&gt;&lt;/div&gt;&lt;!-- 渲染结果 --&gt;&lt;div id="example"&gt; &lt;p&gt;A custom component!&lt;/p&gt;&lt;/div&gt; 局部组件 局部组件是在某一个具体的 vue 实例（组件）中定义的，只能在当前 vue 实例（组件）中使用 const vm = new Vue(&#123; el: '#app', // 局部组件 components: &#123; // 子组件 com-a 'com-a': &#123; template: `&lt;h1&gt;局部组件：&#123;&#123; num &#125;&#125;&lt;/h1&gt;`, data () &#123; return &#123; num: 10 &#125; &#125; &#125; &#125;&#125;) 组件通讯 组件是一个独立、封闭的个体 也就是说：组件中的数据默认情况下，只能在组件内部使用，无法直接在组件外部使用 可以将 vue 实例看做一个组件 对于组件之间需要相互使用彼此的情况，应该使用 组件通讯机制 来解决 组件通讯的三种情况 : 父组件将数据传递给子组件(父 -&gt; 子) 子组件将数据传递给父组件 (子 =&gt; 父) 非父子组件(兄弟组件) 父组件到子组件 将要传递的数据，通过属性传递给子组件 &lt;child :msg="pmsg"&gt;&lt;/child&gt; 子组件通过 props 配置项来指定要接收的数据，props 是一个数组 在使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名代替 如果使用字符串模板，那么这个限制就不存在了 props: ['msg'] 传递过来的 props 属性的用法与 data 属性的用法相同 子组件不能直接修改父组件传过来的数据，可以将父组件传过来的值保存在一个临时变量中 如果 props 传过来的数据为引用类型，只要不是重新赋值，修改数据不会报错，但不推荐这样做 &lt;!-- 第一步：将你要传递的数据,作为属性传递给子组件 --&gt;&lt;hello :num="pnum"&gt;&lt;/hello&gt; Vue.component('hello', &#123; template: `&lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;`, // 第二部：子组件通过 props 配置项来指定要接收的数据 props: ['num']&#125;) 子组件到父组件 方式：父组件给子组件传递一个函数，由子组件调用这个函数 说明：借助 vue 中的自定义事件(v-on:cunstomFn=”fn”) $emit()：触发事件 第一步：父组件了里准备一个方法 const vm = new Vue(&#123; el: '#app', data: &#123; pnum: 1 &#125;, methods: &#123; pfn (num) &#123; this.pnum += num &#125; &#125;&#125;) 第二步：把这个方法作为事件传递给子组件 &lt;hello @fn="pfn"&gt;&lt;/hello&gt;&lt;!-- 或&lt;hello @fn="num += $event"&gt;&lt;/hello&gt;$event 为传过来的参数--&gt; 第三步：子组件调用父组件传过来的方法 Vue.component('hello', &#123; template: `&lt;button @click='click'&gt;按钮&lt;/button&gt;`, data () &#123; return &#123; num: 5 &#125; &#125;, methods: &#123; click () &#123; // 第一个参数：表示要触发的自定义事件名称，也就是 @fn // 第二个参数：表示要传递给父组件的数据 this.$emit('fn', this.num) &#125; &#125;&#125;) 非父子组件通讯 是通过 事件总线 (event bus 公交车) 机制 来实现的 事件总线：实际上就是一个 空 Vue 实例 可以实现任意两个组件之间的通讯而不管两个组件到底有什么样的层级关系 $emit()：发送数据 $on()：接收数据 // 第一步：实例化事件总线 busconst bus = new Vue()// 触发组件 A 中的事件bus.$emit('id', 1)// 在组件 B 创建的钩子中监听事件bus.$on('id', id =&gt; &#123; // ...&#125;) 示例：组件 A —&gt; 组件 B &lt;div id="app"&gt; &lt;com-a&gt;&lt;/com-a&gt; &lt;com-b&gt;&lt;/com-b&gt;&lt;/div&gt; // 第一步：实例化事件总线 busconst bus = new Vue()// 组件 AVue.component('com-a', &#123; template: `&lt;h1 @click="click"&gt;组件A&lt;/h1&gt;`, methods: &#123; click () &#123; // 第二部：发送数据 bus.$emit('hello', '你好') &#125; &#125;&#125;)// 组件 BVue.component('com-b', &#123; template: `&lt;h1&gt;组件B&lt;/h1&gt;`, created () &#123; // 第三步：接收数据 bus.$on('hello', res =&gt; &#123; console.log('接收到数据', res) &#125;) &#125;&#125;)const vm = new Vue(&#123; el: '#app', data: &#123;&#125;&#125;) [开关灯案例] 单向数据流(组件与组件之间)所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。 当 todo-head 中的 todoName 设置数据后回车添加到 todoList，todoList 的长度就会发生变化，然后就会根据(组件与组件之间的)单向数据流，把数据单向下流到子组件中而且必须是通过 props 往下传递的才可以 refsvm.$refs 一个对象，持有已注册过 ref 的所有子组件 ( HTML 元素) 使用 : &lt;!-- 在 HTML元素 中，添加ref属性 --&gt;&lt;div ref="div"&gt;哈哈&lt;/div&gt;&lt;child ref="child"&gt;&lt;/child&gt; // 在JS中通过 $refs.属性 来获取// 在 mounted 函数中使用Vue.component('child', &#123; template: `&lt;h1&gt;组件A&lt;/h1&gt;`, data () &#123; return &#123; num: 100 &#125; &#125;, methods: &#123; fn () &#123;&#125; &#125;&#125;)const vm = new Vue(&#123; el: '#app', data: &#123;&#125;, mounted () &#123; console.log(this.$refs) console.log(this.$refs.div) // div 标签 console.log(this.$refs.child) // child 组件 &#125;&#125;) 如果获取的是一个子组件，那么通过 ref 就能获取到子组件中的 data 和 methods console.log(this.$refs.child.num) // 100console.log(this.$refs.child.fn) // fn 一般在第三方的组件中， 可能会用到这个功能 单页面应用程序SPA : Single Page Application 单页面应用程序 MPA : Multiple Page Application 多页面应用程序 单页 web 应用，就是只有一个 web 页面的应用，是加载单个 HTML 页面，并在用户与应用程序交互时动态更新该页面的 web 应用程序 区别 对于传统的多页面应用程序来说，每次请求服务器返回的都是一个完整的页面 对于单页应用程序来说，只有第一次会加载页面，以后的每次请求，仅仅是获取必要的数据，然后由页面中 js 解析获取的数据展示在页面中 优势 : 减少了请求体积，加快页面响应速度，降低了对服务器的压力 更好的用户体验，让用户在 web app 感受 native app 的流畅 路由 路由 : 是浏览器 URL 中的哈希值( # hash) 与 展示视图内容 之间的对应规则 在 web App 中，通过一个页面来展示和管理整个应用的功能。SPA 往往是功能复杂的应用，为了有效管理所有视图内容，前端路由应运而生。简单来说，路由就是一套映射规则(一对一的对应规则)，由开发人员制定规则。当 URL 中的哈希值( # hash) 发生改变后，路由会根据制定好的规则，展示对应的视图内容。 vue 中的路由；是 hash 和 component 的对应关系，一个哈希值对应一个组件 基本使用安装路由 : npm i vue-router 引入路由 &lt;script src="./vue.js"&gt;&lt;/script&gt;&lt;script src="./node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; 详细使用步骤 实例路由对象并挂载到 vue 实例 上 // 路由实例 与 Vue 实例 关联到一起const router = new VueRouter()const vm = new Vue(&#123; el: '#app', router&#125;) 入口 (#哈希值) &lt;!--方式1 : url地址为入口 输入url地址改变哈希值router.html#/one方式2 : router-link+toto 属性：实际上就是哈希值，将来要参与路由规则中进行与组件匹配router-link 标签最终会转化为 a 标签，to 属性转化为 a 标签的 href 属性--&gt;&lt;router-link to="/one"&gt;One&lt;/router-link&gt;&lt;router-link to="/two"&gt;Tow&lt;/router-link&gt; 注册组件并设置返回值 const One = &#123; template: `&lt;div&gt;组件 One&lt;/div&gt;`&#125;const Two = &#123; template: `&lt;div&gt;组件 Two&lt;/div&gt;`&#125; 设置规则 // path : 路由路径// component : 将来要展示的路由组件const router = new VueRouter(&#123; routes: [&#123; path: '/one', component: One &#125;, &#123; path: '/two', component: Two &#125;]&#125;) 出口 &lt;!-- 出口：组件要展示的地方--&gt;&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 示例 ： &lt;div id="app"&gt; &lt;!-- 入口 --&gt; &lt;!-- 可以直接通过url地址访问路由 --&gt; &lt;!-- to 属性：路由匹配路径router-link 最终会转化为 a 标签--&gt; &lt;router-link to="/one"&gt;One&lt;/router-link&gt; &lt;router-link to="/two"&gt;Tow&lt;/router-link&gt; &lt;!-- 5. 出口 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; // 3. 注册组件并设置返回值const One = &#123; template: `&lt;div&gt;组件 One&lt;/div&gt;`&#125;const Two = &#123; template: `&lt;div&gt;组件 Two&lt;/div&gt;`&#125;// 1. 实例化路由对象const router = new VueRouter(&#123; routes: [ // 4. 配置路由规则，路由和实例一一对应 &#123; path: '/one', component: One &#125;, &#123; path: '/two', component: Two &#125; ]&#125;)const vm = new Vue(&#123; el: '#app', data: &#123;&#125;, // 2. 将路由挂载到 vue 实例上，让 vue 和路由关联在一起 router&#125;) 多出口情况 &lt;div id="app"&gt; &lt;!-- 多个出口的形式 --&gt; &lt;router-view name="one"&gt;&lt;/router-view&gt; &lt;router-view name="two"&gt;&lt;/router-view&gt;&lt;/div&gt; const One = &#123; template: `&lt;div&gt;组件 One&lt;/div&gt;`&#125;const Two = &#123; template: `&lt;div&gt;组件 Two&lt;/div&gt;`&#125;const router = new VueRouter(&#123; routes: [ // 配置路由规则，一个路由对应多个实例 &#123; path: '/', // conponents 为一个对象 components: &#123; // key 为出口的 name 属性值 // value 为组件实例 one: One, two: Two &#125; &#125; ]&#125;) 入口菜单高亮处理点击导航会给链接添加两个类名： &lt;a href="#/one" class="router-link-exact-active router-link-active"&gt;One&lt;/a&gt;&lt;a href="#/two" class=""&gt;Two&lt;/a&gt; 修改方式 1：直接修改类的内容 .router-link-exact-active,.router-link-active &#123; color: red; font-size: 50px;&#125; 修饰方式 2：给默认高亮类名设置别名，别名为已经定义好样式的类名 (推荐) const router = new VueRouter(&#123; routes: [], // 修改默认高亮的a标签的类名 linkActiveClass: 'red'&#125;) 精确匹配和模糊匹配 精确匹配：router-link-exact-active 类名 : 只有当浏览器地址栏中的哈希值 与 router-link 的 to 属性值完全匹配才会添加该类 模糊匹配：router-link-active 类名 : 只要浏览器地址栏中的哈希值包含 router-link 的 to 属性值就会添加该类名 解决办法：加个 exact &lt;router-link to="/" exact&gt; One&lt;/router-link&gt; 注意：精确匹配和模糊匹配，只对添加类名这个机制有效，与路由的匹配规则无关 路由参数入口 &lt;!-- 1. 入口 --&gt;&lt;router-link to="/detail/1"&gt;手机1&lt;/router-link&gt;&lt;router-link to="/detail/2"&gt;手机2&lt;/router-link&gt;&lt;router-link to="/detail/3"&gt;手机3&lt;/router-link&gt; 传参 动态路由匹配 const Detail = Vue.component('detail', &#123; template: `&lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;`&#125;)routes: [ // 方式1：手动一个一个配置 &#123; path: '/detail/1', component: Detail &#125;, &#123; path: '/detail/2', component: Detail &#125;, &#123; path: '/detail/3', component: Detail &#125;， // 正确的方式：把传过去的 1/2/3 当成参数 &#123; path: '/detail/:id?', component: Detail &#125;] ? 代表参数可传可不传，即可识别的路径包括：detail、detail/1、detail2、detail3 获取参数的三种正确方式 // $route =&gt; 路由配置对象const Detail = Vue.component('detail', &#123; // 方式1：组件中直接读取 // $route.path 为路由路径 // $route.params.id 为路由参数 template: ` &lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt; `, created() &#123; // 方式2：js直接读取 // 打印只会打印一次，因为组件是复用的，每次进来钩子函数只会执行一次 // #/detail/2?name=zs console.log(this.$route) // 路由配置对象 console.log(this.$route.path) // #/detail/2 console.log(this.$route.params) // &#123;id: "2"&#125; console.log(this.$route.query) // &#123;name: 'zs'&#125; console.log(this.$route.params.id) // 2 &#125;, // 方式3：监听路由的参数变化(因为不是 data 中的数据，不需要深度监听) watch: &#123; // to：新值 // from：旧值 $route(to, from) &#123; console.log(to.params.id) &#125; &#125;&#125;) 编程式导航 const userId = '123'// 字符串router.push('/user') // -&gt; /user// 对象, path为路由的path属性值router.push(&#123; path: '/user' &#125;) // -&gt; /userrouter.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 命名的路由，name 为路由的 name 属性值router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123// 如果提供了 path，params 会被忽略// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user// 带查询参数router.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) // -&gt; /register?plan=privateroutes: [&#123; path: '/user/:id?', name='user', component: User &#125;] 重定向redirect // 将 / 重定向到 /home&#123; path: '/', redirect: '/home' &#125; 单文件组件vue 是单文件组件后缀为 .vue 的文件 单文件组件，无法直接在浏览器中使用，必须经过 webpack 这种打包工具处理后，才能在浏览器中使用 单文件组件的三个组成部分 template (模板结构) script 组件的代码逻辑 style 样式 脚手架介绍vue-cli 是 vue 的脚手架工具 因为 webpack 配置繁琐，阻止一批想用 vue 但是不会 webpack 的开发人员 vue-cli 提供了一条命令，我们直接通过这条命令就可以快速的生成一个 vue 项目 (vue init XX)，项目的基本结构、以及 webpack 配置项 全部配置 好了 Vue Loader 手动配置置 webpack Vue CLI3 Vue webpack 配置 使用安装：npm i -g vue-cli 初始化 vue 项目：vue init webpack 项目名称 进入到项目根目录运行项目：npm run dev 项目安装过程： ? Project name demo? Project description A Vue.js project? Author? Vue build standalone =&gt; 运行时+编译? Install vue-router? Yes? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Set up unit tests No? Setup e2e tests with Nightwatch? No 项目目录介绍https://vuejs-templates.github.io/webpack/structure.html .├── build/ # webpack config files├── config/index.js # main project config├── src/│ ├── main.js # app entry file│ ├── App.vue # main app component│ ├── components/ # ui components│ └── assets/ # module assets (processed by webpack)├── static/ # pure static assets (directly copied)├── test/│ └── unit/ # unit tests│ └── e2e/ # e2e tests├── .babelrc # babel config├── .editorconfig # settings for your editor├── .eslintrc.js # eslint config├── .eslintignore # eslint ignore rules├── .gitignore # sensible defaults for gitignore├── .postcssrc.js # postcss config├── index.html # index.html template├── package.json # build scripts and dependencies└── README.md # Default README file build 和 config 不要动，都是一些配置好的，还有一些他们之间的约定 .gitkeep：static 为预留的文件夹，空文件夹默认不会上传到 github，添加这个文件让 static 文件夹被 git 上传 .editorconfig 编译器配置，需要安装 vscode 插件：Editorconfig charset = utf-8 utf-8 格式编码indent_style = space 空格和tab都可以缩进indent_size = 2 缩进为2个end_of_line = lf 回车换行insert_final_newline = true 结束最后一行+一个空白trim_trailing_whitespace = true 开头去除空白 eslint 校验 忽略文件中有这个 =&gt; /*.js =&gt; 意思是根目录下的.js 文件不校验,,但是发现根目录就没有.js 文件 /* eslint-disable no-new */ eslint 忽略 no-new 规则 /* eslint-disable */ 也可以 如果去掉,就会提示你 不要以 new 开头 可以前面给个变量 var vm = new Vue() 但是又提示没有用,还要打印一下,其实这个赋值是没有意义的 不要去掉.这是 eslint 的不校验下一行代码 standard 代码规范 postcssrc 处理 less css 等 src assets 静态资源 components 组件 router 路由 App.vue 根组件 =&gt; 指定路由出口 脚手架之后，所有的组件都将渲染到 app.vue 中 vm 中的 #app 还是 index.html 中的 #app， app.vue 中的会覆盖前者可以通过分别添加 title 属性验证一下 &lt;router-view/&gt; 路由出口要写在 app.vue 组件模板中 main.js 入口 js 文件 作用：创建 vue 实例，导入其他组件并挂在到 vue 实例上 Vue.config.productionTip = false 不要打印提示 route/index.js：路由 @：build/ webpack.base.config.js =&gt; &#39;@&#39;: resolve(&#39;src&#39;) 如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能 https://router.vuejs.org/zh/installation.html 两种编译模式完整版和运行时版 参考官网 编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码 运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切 使用 完整版 (包含编译器) new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 只使用运行时 new Vue(&#123; el: '#app', router, render: h =&gt; h(App)&#125;) 查看编译模式：build =&gt; webpack.base.config.js =&gt; &#39;vue\$&#39;: &#39;vue/dist/vue.esm.js&#39;, 手动配置路由安装路由 npm i vue-router 准备工作：创建一个文件夹 router/router.js 具体配置： /* router.js */// 引入路由import Vue from 'vue'import VueRouter from 'vue-router'// 导入组件import Home from '@/components/home/Home' (template + script + style)import Login from '@/components/login/Login'// 把路由当成插件安装Vue.use(VueRouter)// 创建路由，配置路由const router = new VueRouter(&#123; // 路由规则routes: [ &#123; path : '/home', component : Home &#125;, &#123; path : '/login', component : Login &#125;]&#125;)// 导出路由export default router// 在 main.js 中绑定路由router在跟组件 App.vue 下配置出口&lt;router-view&gt;&lt;/router-view&gt; /* main.js */new Vue(&#123; // 绑定路由 router&#125;) &lt;!-- App.vue --&gt;&lt;!-- 配置出口 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 编辑器配置插件 vetur：vue 单文件组件的高亮 eslint 关闭 eslint：打开 config/index.js，将 26 行 : dev.useEslint设置为 false，重启项目 ( npm run dev) Prettier：格式化插件 TODOMVC 案例准备工作 Vue-TodoMVC 下载模板地址 git clone https://github.com/tastejs/todomvc-app-template.git 安装依赖包 : npm i 安装 vue : npm i vue 开始 https://github.com/cuilongjin/todomvc-app-template/tree/master 列表渲染 渲染任务列表：&lt;label&gt;&lt;/label&gt; 任务完成 : :class=&quot;{ completed : item.done }&quot; 多选框选中状态 : v-model=&#39;item.done&#39; 添加任务 获取文本输入框的内容 (关键点) 把 input 通过 v-model 双向数据绑定 == todoName @keyup.enter 触发事件 addTodo =&gt; 拿到 todoName 的值 判断文本框不能为空 按回车添加任务 对象{done: false, id: , name : todoName} 获取数组里最后一个元素的 id+1 如果数组之前一个元素都没有 , id = 1 将对象添加进数组 添加完，清除文本框内容 删除任务 传索引this.todoList.splice(index, 1) 传 id // 根据 id 找到对应的元素索引const index = this.todoList.findIndex(item =&gt; item.id === id)// 根据索引删除this.todoList.splice(index, 1) 传 id 过滤 // 传过来一个 id, 过滤出来不等于这个 id 的元素，重新赋值给 todoListthis.todoList = this.todoList.filter(item =&gt; item.id !== id) 编辑任务 显示编辑框 ( editing : true) (难点) 在 data 中添加一个 editId : -1 在 :classediting: item.id === editId 双击 : 接收过来双击元素的 idthis.editId = id 关键点 :vue 中 data 中的数据一旦发生改变，当前页面的指令和表达式都会重新计算 读取内容&lt;input class=&quot;edit&quot; v-model=&quot;item.name&quot;&gt; 回车隐藏编辑框 底部的显示与隐藏 v-if/v-show // 组件部分&lt;footer class="footer" v-show="isFooter()"&gt;// js isFooter() &#123; return this.todoList.length &gt; 0 &#125; 因为 vue 中 data 的数据发送了改变，当前页面中的指令和表达式都会重新计算，所以只要文本框里的内容发生改变，todoName 也会发送改变，isFooter 会一直被调用，性能不好。我们需要的是数组列表的个数改变才会影响底部的变化，所以需要用到计算属性 计算属性 &lt;footer class="footer" v-show="isFooter"&gt;&lt;/footer&gt; computed: &#123; // 计算属性 判断底部是否显示 // 1. 计算属性只会跟着相关属性的值发生变化而变化 // 2. 一定要有返回值 // 3. 一定要写在 computed 里面 // 4. 写起来像一个方法，用起来像一个属性 isFooter () &#123; return this.todoList.length &gt; 0 &#125;&#125; 数据持久化 存储数据 监听 list 数据的改变，只要 list 数据变了，就调用保存数据的方法 使用 vue 的 watch 监听 list 的数据改变 保存值，记得把对象转化为字符串(存的快省空间) watch: &#123; // 监听 todoList todoList: &#123; deep: true, handler (newVal) &#123; localStorage.setItem('todoList', JSON.stringify(newVal)) &#125; &#125;&#125; 获取数据 // 在 data 中可以初始值// 设置一个默认值 空数组 []todoList: JSON.parse(localStorage.getItem('todoList')) || [] 使用钩子函数来完善数据存储created () &#123; this.todoList = JSON.parse(localStorage.getItem('todoList')) || []&#125; 获取接口数据json-server 提供假数据接口 axios 发送请求 npm i -g json-servernpm i axiosjson-server data.json 组件化 TODOMVChttps://github.com/cuilongjin/todomvc-app-template/tree/zujianhua]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 生命周期]]></title>
    <url>%2F2019%2Fvue%2Fvue-lifecycle%2F</url>
    <content type="text"><![CDATA[生命周期 下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex]]></title>
    <url>%2F2019%2Fvue%2Fvue%2Belementui%2F</url>
    <content type="text"><![CDATA[vue组件抽离 // 标签不要动，只需要把内容题出去后，添加 src 引入即可&lt;template src=&quot;./Roles.html&quot;&gt;&lt;/template&gt;&lt;script src=&quot;./Roles.js&quot;&gt;&lt;/script&gt;&lt;style src=&quot;./Roles.less&quot; lang=&quot;less&quot; scoped&gt;&lt;/style&gt; scoped vue 组件之间的样式有自动复用的问题，给一个类设置样式，其他组件中相同类的元素也会被设置样式 解决：在 style 标签上添加 scoped 字段，设置样式只作用于当前组件 &lt;style scoped&gt;&lt;/style&gt; 作用 1：让当前组件内的样式，只能在当前组件上起效果作用 2：如果添加了 scoped，样式只会对本来就存在的标签/组件起效果，如果是动态添加的组件/标签，是无效的 动态添加的组件/标签，在 .vue文件里添加一个 style 标签，在标签里设置该样式属性，或者在选择器前添加/deep/ vm.$nextTick( [callback] )：将回调延迟到下次 DOM 更新循环之后执行 如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise：await this.$nextTick() 插槽 &lt;template slot-scope=&quot;scope&quot;&gt; 通过 scope.row 获取当前行的数据&lt;/template&gt; // 页面跳转this.$router.push('/login')this.$router.push(&#123; name: 'login' &#125;)this.$router.go(-1) elementspan=&#39;1&#39;：赋值 span 的是一个字符串 ‘1’ :span=&#39;1&#39;：前面加一个: 意思是动态数据绑定，赋值 span 的是具体数据类型的数据，即数字 1 时间日期选择器日期选择器限制选择范围 &lt;el-date-picker v-model="options.endDate" type="date" :picker-options="endDateOptions"&gt;&lt;/el-date-picker&gt; endDateOptions: &#123; disabledDate: time =&gt; &#123; // 限制结束时间范围为大于开始时间，并在一周内 return time.getTime() &lt; this.options.startDate || time.getTime() &gt; this.options.startDate + 24 * 60 * 60 * 1000 * 7 &#125;&#125; Tree 树形控件 Attributes show-checkbox：节点是否可被选择 default-expand-all：是否默认展开所有节点 node-key： 每个树节点用来作为唯一标识的属性，整棵树应该是唯一的 方法 this.$refs.tree.setCheckedKeys：通过 keys 设置目前勾选的节点，使用此方法必须设置 node-key 属性 this.$refs.tree.getCheckedKeys：若节点可被选择（即 show-checkbox 为 true），则返回目前被选中的节点的 key 所组成的数组 NavMenu 导航菜单Menu Attributerouter：是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转 background-color：菜单的背景色（仅支持 hex 格式）#ffffff text-color：菜单的文字颜色（仅支持 hex 格式） active-text-color：当前激活菜单的文字颜色（仅支持 hex 格式） default-active：当前激活菜单的 index unique-opened：是否只保持一个子菜单的展开 Table 表格Table-column Attributes type：设置 index 则显示该行的索引（从 1 开始计算）；设置 expand 则显示为一个可展开的按钮； 设置了 selection 则显示多选框 自定义索引 index：如果设置了 type=index，可以通过传递 index 属性来自定义索引，属性传入数字时，将作为索引的起始值。传入方法是，它提供当前行的行号（从 0 开始）作为参数，返回值将作为索引展示。 type=&quot;index&quot; :index=&quot;indexMethod&quot; indexMethod(index) {return index} Radio 单选框基础用法&lt;el-radio v-model=&quot;radio&quot; label=&quot;1&quot;&gt;备选项&lt;/el-radio&gt;&lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;备选项&lt;/el-radio&gt; 选中意味着变量的值为相应 label 属性的值，label可以是String、Number或Boolean。 禁用状态设置disabled属性true为禁用 单选框组结合 el-radio-group 元素和子元素 el-radio 可以实现单选组，在 el-radio-group 中绑定 v-model，在 el-radio 中设置好 label 即可，无需再给每一个 el-radio 绑定变量，另外，还提供了 change 事件来响应变化，它会传入一个参数 value Radio Eventschange：绑定值变化时触发的事件 选中的 Radio label 值 Cascader 级联选择器Attributesoptions：可选项数据源，键名可通过 props 属性配置 props：配置选项，对象 ​ value：指定选项的值为选项对象的某个属性值 ​ label：指定选项标签为选项对象的某个属性值 ​ children：指定选项的子选项为选项对象的某个属性值 Upload 上传Attribute action: 必选参数，上传的完整地址 multiple: 是否支持多选文件 :on-preview: 点击文件列表中已上传的文件时的钩子 function(file) :on-remove: 文件列表移除文件时的钩子 function(file, fileList) list-type: 文件列表的类型 :before-upload: 对文件校验 function(file)，若返回 false 或者返回 Promise 且被 reject，则停止上传 :on-success: 文件上传成功时的钩子 function(response, file, fileList) ​ response：参数一， 接口的响应结；file：参数二， 文件对象；fileLIst：参数三，文件对象列表 ​ 自定义参数 :on-success=&quot;(res, file, fileList) =&gt; UploadImg(1, res, file, fileList)&quot; headers: 设置上传的请求头部 object :auto-upload=”false”：手动调用this.$refs.upload.submit()上传 on-progress: 文件上传时的钩子 function(event, file, fileList) Steps 步骤条active 设置当前激活步骤 number 设置active属性，接受一个Number，表明步骤的 index，从 0 开始 Tabs 标签页Tabs Attributesvalue / v-model 绑定值，选中选项卡的 name string — 第一个选项卡的 name tab-position 选项卡所在位置 string top/right/bottom/left top Tabs Eventstab-click tab 被选中时触发 被选中的标签 tab 实例 element 中的 Events 和 Methods// 假设有个 el-box ,如果看文档,有个 Events 和 Methods // Eventsclose // MethdosgetData // 使用&lt;el-box ref=’box’ @close=’函数名自己写’&gt; this.$refs.box.getData() 项目上线打包 : npm run build把打好的包放到 http-server 里面 介绍 vendor : 里面放一些第三方包 vue/vue-router/element-ui 包等 优化 : 按需加载 首屏加载时间，是衡量一个网站性能快慢的很重要的一个指标 如何提高加载速度呢? 只加载首屏中看到的内容，没有看到的内容都不加载，需要用到的时候，再去加载进来减少首屏的请求次数 vue 项目打包的时候，如何实现按需加载功能 ? vue 的异步组件(路由) 配合 webpack 代码分割的功能实现按需加载功能 路由懒加载：https://router.vuejs.org/zh/guide/advanced/lazy-loading.html import Home from 'Home.vue'==&gt;const Home = () =&gt; import('Home.vue')// 将两个组件打包在一起const Goods = () =&gt; import(/* webpackChunkName: 'goods' */ 'Goods.vue')const GoodsAdd = () =&gt; import(/* webpackChunkName: 'goods' */ 'GoodsAdd.vue') CDN 在 index.html 引入 CDN 提供的文件 在 webpack.base.conf.js 中配置 externals: &#123; // 键：表示 导入包语法 from 后面跟着的名称 // 值：表示 script 引入JS文件时，在全局环境中的变量名称 vue: 'Vue', 'vue-router': 'VueRouter', axios: 'axios', 'element-ui': 'ELEMENT'&#125; 在 index.html 引入 css 文件就不需要在 main.js 中引入了]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex]]></title>
    <url>%2F2019%2Fvue%2Fvuex%2F</url>
    <content type="text"><![CDATA[Vuexvuex 是什么? 状态管理工具 状态即数据，状态管理就是管理组件中的 data(数据) Vuex 中的状态管理工具采用 集中式 统一管理项目中组件之间需要通讯的数据 最佳实践：只将组件之间共享的数据放在 vuex 中，而不是将所有的数据都放在 vuex 中，也就是如果数据只是在组件内部使用的，这个数据应该放在组件中，而不要放在 vuex vuex 中的数据也是响应式的，如果一个组件中修改了 vuex 中的数据，另外一个使用的 vuex 数据的组件，就会自动更新 任何组件中都可以直接获取 vuex 前端状态该管理的思想最早是由 react 团队提出来的，就是 Flux(思想以及具体的实现) 前端状态管理工具 : Flux / Redux / Mobx / vuex 等等 什么时候用? 项目体量很小，不需要使用 vuex，如果项目中组件通讯不复杂，也不需要使用 vuex 写项目的时候，发现组件通讯多，组件之间的关系复杂，项目已经无法继续开发了，此时就应该使用 vuex 基本使用 安装 : npm i vuex 导入 vuex 创建 vuex 示例 vuex 中的概念state 状态 , 状态即数据 状态是由 store 提供的 状态也是响应的 推荐通过 mutations 中提供的方法去修改数据，因为在严格模式下不允许在 mutation 外部修改 state 下的数据，否则会报错 mutations 作用：提供修改 state 的状态数据的方法 只要想改变 state 中的状态数据，就应该在 mutations 中提供一个方法来修改，接受 state 作为第一个参数（如果定义在模块中，则为模块的局部状态），payload 作为第二个参数（可选） 通过 $store.commit(&#39;方法名&#39;) 调用 mutations 中的方法 传参数的话，紧挨着方法名后面继续传就可以了，推荐传入一个对象（payload 即可） methods: &#123; addTodo () &#123; // commit =&gt; 找 mutations this.$store.commit('addTodo', &#123; todoName: this.todoName &#125;) &#125;&#125; mutations: &#123; addTodo (state, playload) &#123; state.list.push(playload) &#125;&#125; actions提供异步修改 state 的状态数据的方法 处理函数总是接受 context 作为第一个参数，payload作为第二个参数（可选） 通过 $store.dispatch(&#39;方法名&#39;) 调用 actions 中的方法 methods: &#123; addTodo () &#123; // 异步: 分发 dispatch =&gt; actions this.$store.dispatch('addTodoAsync', &#123; todoName: this.todoName &#125;) &#125;&#125; actions: &#123; addTodoAsync (context, playload) &#123; setTimeout(() =&gt; &#123; context.commit('addTodo', playload) &#125;, 1000) &#125;&#125; getters可以认为是 store 的计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算 getter 接受 state 作为其第一个参数，Getter 也可以接受其他 getter 作为第二个参数 getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125;&#125; Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值：store.getters.doneTodos vue 和 vuex 的配合使用 实例 vue 和实例 store 一定要把 store 挂在到 vue 上 读取 组件读取: js 读取: this.$store.state.count js 操作: 在 mutations 里放一个方法，在方法里修改 js 中触发这个方法 this.​$store.commit(&#39;addCount&#39;, { num : 8})]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs]]></title>
    <url>%2F2018%2Fjavascript%2Fnodejs%2F</url>
    <content type="text"><![CDATA[nodejs基本介绍为什么要学习nodejs 降低编程语言切换的成本(nodejs实质上用的还是javascript) NodeJS是前端项目的基础设施，前端项目中用到的大量工具 (大前端) nodejs在处理高并发上有得天独厚的优势(利用nodejs做中间层) 对于前端工程师，面试时对于nodejs有一定的要求 node.js 是什么？node.js，也叫作node，或者nodejs，指的都是一个平台 node.js官方网站 node.js中文网 node.js 中文社区 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，nodejs 允许 javascript 代码运行在服务端 1. nodejs不是一门新的编程语言，nodejs是在服务端运行javascript的运行环境2. 运行环境：写得程序想要运行必须要有对应的运行环境 php代码必须要有apache服务器 在web端，浏览器就是javascript的运行环境 在node端，nodejs就是javascript的运行环境2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎 nodejs的本质：不是一门新的编程语言，nodejs是javascript运行在服务端的运行环境，编程语言还是javascript nodejs与浏览器的区别相同点：nodejs与浏览器都是js的运行环境，都能够解析js程序。对于ECMAScript语法来说，在nodejs和浏览器中都能运行 不同点：nodejs无法使用DOM和BOM的操作，浏览器无法执行nodejs中的文件操作等功能 nodejs可以干什么？ 开发服务端程序 开发命令行工具（CLI），比如npm，webpack，gulp，less，sass等 开发桌面应用程序（借助 node-webkit、electron 等框架实现） 安装nodejsnodejs版本下载地址 当前版本 历史版本 官网术语解释 LTS 版本：Long-term Support 版本，长期支持版，即稳定版。 Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入 查看node版本 node -v 运行nodejs程序方式一：使用node执行js文件 创建js文件 helloworld.js 写nodejs的内容：console.log(&#39;hello nodejs&#39;) 打开命令窗口 cmd shift加右键打开命令窗口，执行 node 文件名.js即可 执行命令：node helloworld.js 注意：在nodejs中是无法使用DOM和BOM的内容的，因此document， window等内容是无法使用的 方式二：REPL介绍 REPL 全称: Read-Eval-Print-Loop（交互式解释器） R 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中 E 执行 - 执行输入的数据结构 P 打印 - 输出结果 L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出 在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能） 直接在控制台输入 node 命令进入 REPL 环境 按两次 Control + C 退出REPL界面 或者 输入 .exit 退出 REPL 界面 按住 control 键不要放开, 然后按两下 c 键 环境变量当要求系统运行一个程序 而没有告诉它程序所在的完整路径时 首先在当前目录中查找和该字符串匹配的可执行文件 进入用户 path 环境变量查找 进入系统 path 环境变量查找 配置环境变量： 找到环境变量：计算机 --右键--&gt; 属性 --&gt; 高级系统设置 --&gt; 高级 --&gt; 环境变量 global模块-全局变量JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。 在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。 在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。 常用的 global 属性 console: 用于打印日志setTimeout/clearTimeout: 设置清除延时器setInterval/clearInterval: 设置清除定时器__dirname: 当前文件的路径，不包括文件名__filename：当前文件的路径，包括文件名// 与模块化相关的，模块化的时候会用到requireexportsmodule fs 模块 fs 模块是 nodejs 中最常用的一个模块，因此掌握fs模块非常的有必要，fs模块的方法非常多，用到了哪个查哪个即可。 文档地址：http://nodejs.cn/api/fs.html 在 nodejs 中，提供了 fs 模块，这是 node 的核心模块 注意： 除了 global 模块中的内容可以直接使用，其他模块都是需要加载的。 fs 模块不是全局的，不能直接使用。因此需要导入才能使用。 const fs = require('fs') 读取文件 语法：fs.readFile(file[, options], callback) 方式一：不传编码参数 // 参数1：文件路径// 参数2：读取文件的回调函数 // 参数1：错误对象，如果读取失败，err 会包含错误信息，如果读取成功，err 是 null // 参数2：读取成功后的数据（是一个Buffer对象）fs.readFile('data.txt', function(err, data)&#123; console.log(err) console.log(data) console.log(data.toString()) // 将Buffer对象转换成字符串&#125;) 方式二：传编码参数 // 参数1：文件的路径// 参数2：编码，如果设置了，返回一个字符串，如果没有设置，会返回一个buffer对象// 参数3：回调函数fs.readFile('data.txt', 'utf8', function (err, data) &#123; console.log(err) console.log(data)&#125;) 关于Buffer对象 1. Buffer对象是Nodejs用于处理二进制数据的2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象4. Buffer对象可以调用toString()方法转换成字符串 写文件 语法：fs.writeFile(file, data[, options], callback) // 参数1：文件路径(如果文件不存在，会自动创建)// 参数2：写入的文件内容（注意：写入的内容会覆盖以前的内容）// 参数3：写文件后的回调函数fs.writeFile('2.txt', 'hello world', function (err) &#123; if (err) return console.log('写入文件失败', err) console.log('写入文件成功')&#125;) 注意： 写文件的时候，会把原来的内容给覆盖掉 语法：fs.appendFile(path, data[, options], callback) // 参数1：追加的文件名(如果文件不存在，会自动创建)// 参数2：追加的文件内容// 参数3：追加文件后的回调函数fs.appendFile('2.txt', '我是追加的内容', function (err) &#123; if (err) return console.log('追加文件内容失败') console.log('追加文件内容成功')&#125;) 思考：如果没有appendFile，通过readFile与writeFile应该怎么实现？ 文件同步与异步的说明 fs中所有的文件操作，都提供了异步和同步两种方式 异步方式：不会阻塞代码的执行 // 异步方式const fs = require('fs')console.log(111)fs.readFile('2.txt', 'utf8', function (err, data) &#123; if (err) &#123; return console.log('读取文件失败', err) &#125; console.log(data)&#125;)console.log('222') 同步方式：会阻塞代码的执行 //同步方式console.log(111);const result = fs.readFileSync("2.txt", "utf-8");console.log(result);console.log(222); 总结：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。 其他api（了解）方法有很多，但是用起来都非常的简单，学会查文档 文档：http://nodejs.cn/api/fs.html 方法名 描述 fs.readFile(path, callback) 读取文件内容（异步） fs.readFileSync(path) 读取文件内容（同步） fs.writeFile(path, data, callback) 写入文件内容（异步） fs.writeFileSync(path, data) 写入文件内容（同步） fs.appendFile(path, data, callback) 追加文件内容（异步） fs.appendFileSync(path, data) 追加文件内容（同步） fs.rename(oldPath, newPath, callback) 重命名文件（异步） fs.renameSync(oldPath, newPath) 重命名文件（同步） fs.unlink(path, callback) 删除文件（异步） fs.unlinkSync(path) 删除文件（同步） fs.mkdir(path, mode, callback) 创建文件夹（异步） fs.mkdirSync(path, mode) 创建文件夹（同步） fs.rmdir(path, callback) 删除文件夹（异步） fs.rmdirSync(path) 删除文件夹（同步） fs.readdir(path, option, callback) 读取文件夹内容（异步） fs.readdirSync(path, option) 读取文件夹内容（同步） fs.stat(path, callback) 查看文件状态（异步） fs.statSync(path) 查看文件状态（同步） path模块路径操作的问题在读写文件的时候，文件路径可以写相对路径或者绝对路径 data.txt 是相对路径，读取当前目录下的 data.txt，相对路径相对的是指向node命令的路径 // 如果node命令不是在当前目录下执行就会报错，在当前执行node命令的目录下查找data.txt，找不到fs.readFile('data.txt', 'utf8', function (err, data) &#123; if (err) &#123; return console.log('读取文件失败', err) &#125; console.log(data)&#125;) 相对路径：相对于执行node命令的路径 推荐使用绝对路径：__dirname: 当前文件的目录，__filename: 当前文件的目录，包含文件名 path模块的常用方法 关于路径，在linux系统中，路径分隔符使用的是/，但是在windows系统中，路径使用的\ 在我们拼写路径的时候会带来很多的麻烦，经常会出现windows下写的代码，在linux操作系统下执行不了，path模块就是为了解决这个问题而存在的。 常用方法： path.join() // 拼接路径，返回拼接后的结果// windows系统下path.join('abc', 'def', 'gg', 'index.html')'abc\def\gg\a.html'// linux系统下path.join('abc','def','gg', 'index.html')'abc/def/gg/index.html'【优化读写文件的代码】其他方法:path.basename(path[, ext]) 返回文件的最后一部分path.dirname(path) 返回路径的目录名path.extname(path) 获取路径的扩展名(后缀名)var path = require('path')var temp = 'abc\\def\\gg\\a.html'console.log(path.basename(temp)) //a.htmlconsole.log(path.dirname(temp)) //abc\def\ggconsole.log(path.extname(temp)) //.html path模块其他api（了解） 方法名 描述 path.basename(path[, ext]) 返回文件的最后一部分 path.dirname(path) 返回路径的目录名 path.extname(path) 获取路径的扩展名 path.isAbsolute(path) 判断目录是否是绝对路径 path.join([...paths]) 将所有的path片段拼接成一个规范的路径 path.normalize(path) 规范化路径 path.parse(path) 将一个路径解析成一个path对象 path.format(pathObj) 讲一个path对象解析成一个规范的路径 http 模块创建服务器基本步骤// 1. 导入http模块，http模块是node的核心模块，作用是用来创建 http 服务器的const http = require('http')// 2. 创建服务器let server = http.createServer()// 3. 服务器处理请求server.on('request', (req, res) =&gt; &#123; console.log('我接收到请求了')&#125;)// 4. 启动服务器，监听某个端口server.listen(9999, (err) =&gt; &#123; console.log('服务器启动成功了, 请访问： http://localhost:9999')&#125;) 详细说明 给服务器注册 request 事件，只要服务器接收到了客户端的请求，就会触发 request 事件 request事件有两个参数，req表示请求对象，可以获取所有与请求相关的信息，res是响应对象，可以获取所有与响应相关的信息 服务器监听的端口范围为：1-65535之间，推荐使用3000以上的端口，因为3000以下的端口一般留给系统使用 request 对象详解文档地址：http://nodejs.cn/api/http.html#http_message_headers 常见属性： headers: 所有的请求头信息method：请求的方式rawHeaders：所有的请求头信息（数组的方式）url：请求的地址（url地址的路径部分） 请求 http://127.0.0.1:3000/index 获取到的是：/index 请求 http://127.0.0.1:3000 获取到的是：/ 注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个favicon.ico的请求 小结：request对象中，常用的就是 method 和 url 两个参数 response 对象详解文档地址：http://nodejs.cn/api/http.html#http_class_http_serverresponse 常见的属性和方法： res.write(data): 给浏览器发送响应体，可以调用多次，从而提供连续的响应体res.end()：通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成res.end(data)：结束请求，并且响应一段内容，相当于res.write(data) + res.end()res.statusCode: 响应的的状态码 200 404 500res.statusMessage: 响应的状态信息（不能有中文）， 如果不设置会根据statusCode自动设置res.setHeader(name, value)：设置响应头信息，比如'content-type'，'text/html;charset=utf-8'res.writeHead(statusCode, statusMessage, options)：设置响应头，同时可以设置状态码和状态信息 options 是对象，写响应头的键值对 注意：必须先设置响应头，才能设置响应主体。 注意：浏览器中输入的URL地址，仅仅是一个标识，可以不与服务器中的文件路径一致。也就是说：返回什么内容是由服务端的逻辑决定 路由 : url标示和对应文件/数据的一一对应关系 模拟Apache服务器 根据 req.url 读取不同的页面内容，返回给浏览器 // 需求: 简单模仿apache服务器，浏览器发送127.0.0.1:8888/index.html// 对应的返回www文件夹下面的index.html的内容const fs = require('fs')const http = require('http')const path = require('path')// 创建服务器let server = http.createServer()// 监听请求server.on('request', (req, res) =&gt; &#123; // 根据不同请求输出不同响应数据 if (req.url === '/' || req.url === '/i') &#123; // 读取www下面的index.html let filename = path.join(__dirname, 'www', 'index.html') fs.readFile(filename, 'utf-8', (err, data) =&gt; &#123; if (err) console.log('文件读取失败') // 服务器响应文件 res.statusCode = 200 res.statusMessage = 'ok' res.setHeader('content-type', 'text/html;charset=utf-8') res.end(data) &#125;) &#125; else if (req.url === '/l') &#123; // 读取list.html let filename = path.join(__dirname, 'www', 'list.html') fs.readFile( filename, 'utf-8', (err, data) =&gt; &#123; if (err) return console.log('文件读取失败') // 服务器响应文件 res.writeHead(200, 'OOOOOOK', &#123; 'content-type': 'text/html;charset=utf-8' &#125;) res.end(data) &#125;) &#125; else &#123; // 返回浏览器, 未找到资源 res.writeHead(404, 'NOT FOUND', &#123; 'content-type': 'text/html;charset=utf-8' &#125;) res.end('404 ,资源未找到') &#125;&#125;)// 开启服务器server.listen(8888, ()=&gt;&#123; console.log('服务器开启了')&#125;) MIME类型 MIME(Multipurpose Internet Mail Extensions)多用途Internet邮件扩展类型 是一种表示文档性质和格式的标准化方式 浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的MIME类型附加到响应对象的头部是非常重要的 MIME 类型 mime模块 作用：获取文件的MIME类型 安装：npm i mime let mime = require('mime')// 获取路径对应的 MIME 类型mime.getType('txt') // 'text/plain'// 根据 MIME 获取到文件后缀名mime.getExtension('text/plain') // 'txt' npm - Node 包管理工具npm 的基本概念 node package manager npm官网 npm中文文档 1. npm 是node的包管理工具，2. 它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。3. 来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。npm 由三个独立的部分组成： 网站 注册表（registry） 命令行工具 (CLI) 作用：通过npm来快速安装开发中使用的包 npm不需要安装，只要安装了node，就自带了npm npm 基本使用初始化包# 这个命令用于初始化一个包，创建一个package.json文件，我们的项目都应该先执行npm initnpm init# 快速的初始化一个包， 不能是一个中文名npm init -y 安装包# 安装指定的包名的最新版本到项目中npm install 包名# 安装指定包的指定版本npm install 包名@版本号# 简写npm i 包名 卸载包# 卸载已经安装的包npm uninstall 包名 package.json 文件package.json文件，包（项目）描述文件，用来管理组织一个包（项目），它是一个纯JSON格式的 作用：描述当前项目（包）的信息，描述当前包（项目）的依赖项 如何生成：npm init或者npm init -y 作用 作为一个标准的包，必须要有package.json文件进行描述 一个项目的node_modules目录通常都会很大，不用拷贝node_modules目录，可以通过package.json文件配合npm install直接安装项目所有的依赖项 描述内容 &#123; "name": "03-npm", // 描述了包的名字，不能有中文 "version": "1.0.0", // 描述了包的的版本信息， x.y.z 如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。 "description": "", // 包的描述信息 "main": "index.js", // 入口文件（模块化） "scripts": &#123; // 配置一些脚本，在vue的时候会用到，现在体会不到 "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], // 关键字（方便搜索） "author": "", // 作者的信息 "license": "ISC", // 许可证，开源协议 "dependencies": &#123; // 重要，项目的依赖， 方便代码的共享 通过 npm install "bootstrap": "^3.3.7", "jquery": "^3.3.1" &#125;&#125; 注意：一个合法的package.json，必须要有 name 和 version 两个属性 本地安装和全局安装有两种方式用来安装 npm 包：本地安装和全局安装。选用哪种方式来安装，取决于你如何使用这个包。 全局安装：如果你想将其作为一个命令行工具，那么你应该将其安装到全局。这种安装方式后可以让你在任何目录下使用这个命令。比如nrm, nodemon等命令 本地安装：如果你自己的模块依赖于某个包，并通过 Node.js 的 require 加载，那么你应该选择本地安装，这种方式也是 npm install 命令的默认行为 # 全局安装，会把 npm 包安装到C:\Users\用户名\AppData\Roaming\npm目录下，作为命令行工具使用npm install -g 包名# 本地安装，会把 npm 包安装到当前项目的node_modules文件中，作为项目的依赖npm install 包名# 注意： 如果网速慢的话，会导致下载失败。 再重新下载之前,建议使用以下命令,清除刚才下载的缓存.否则有可能一直无法下载成功npm cache clean -f npm下载加速nrm nrm：npm registry manager（npm仓库地址管理工具） 安装：npm i -g nrm # 带*表示当前正在使用的地址# 查看仓库地址列表nrm ls# 切换仓库地址nrm use taobao nodemon 自动重启 作用：监听到 js 文件修改后，自动重启node程序 安装：npm i -g nodemon 使用：nodemon app.js 运行node程序 hacknews案例 Hacker News 示例 路由（route）：就是一套映射规则，根据url地址分配到对应的处理程序 功能划分 1 新闻列表页 - /index get 2 新闻详情页 - /details get 3 新闻添加页 - /submit get 4 新闻添加请求 - /add post art-template 模板引擎 文档 安装 npm install art-template 核心方法 // 基于模板路径渲染模板// 参数1：文件的路径// 参数2：数据// 返回值：返回渲染后的内容// template(filename, data)let html = template(path.join(__dirname, 'pages', 'index.html'), &#123;name: '大吉大利，今晚吃鸡'&#125;) 注意点：文件的路径必须是绝对路径；会将整个html当做模板返回 url 模块 说明：用于 URL 处理与解析 注意：通过 url 拿到的查询参数都是字符串格式 // 导入url模块var url = require('url')// 解析 URL 字符串并返回一个 URL 对象// 第一个参数：表示要解析的URL字符串// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象var ret = url.parse('http://localhost:3000/details?id=1&amp;name=jack', true)console.log(ret.query) // &#123;id: '1', name: 'jack'&#125; querystring 模块 用于解析与格式化 URL 查询字符串 注意：只在专门处理查询字符串时使用 // foo=bar&amp;abc=xyz&amp;abc=123var querystring = require('querystring')// 将查询参数转化为对象// 第一个参数: 要解析的 URL 查询字符串querystring.parse('foo=bar&amp;abc=xyz') // &#123;foo: 'bar', abc: 'xyz'&#125; 服务端重定向 HTTP 状态码说明 301 和 302 说明：服务端可以通过HTTP状态码让浏览器中的页面重定向 res.writeHead(302, &#123; 'Location': '/'&#125;)res.end() POST 请求参数的处理 说明：POST请求可以发送大量数据，没有大小限制 // 接受POST参数var postData = []// data事件：用来接受客户端发送过来的POST请求数据var result = ''req.on('data', (chunk) =&gt; &#123; result += chunk&#125;)// end事件：当POST数据接收完毕时，触发req.on('end', () =&gt; &#123; cosnole.log(result)&#125;) 模块化改造hackerNews]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6（ECMAScript）]]></title>
    <url>%2F2018%2Fjavascript%2FES6%2F</url>
    <content type="text"><![CDATA[ES6（ECMAScript）ECMAScript 6.0（以下简称 ES6）是在 2015 年 6 月正式发布的标准。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言 ECMAScript 6 入门 阮一峰 let 与 const ES6 中提供了两个声明变量的关键字：const 和 let 参考链接 [知乎]我用了两个月的时间才理解 let [MDN]变量提升 let 的使用ES6 新增了let命令，用来声明变量。它的用法类似于var let 声明的变量只有在当前作用域(块作用域)有效 if (true) &#123; var a = 1 let b = 2&#125;console.log(a) // 1console.log(b) // ReferenceError: b is not defined 不允许重复声明 let a = 10let a = 1 // SyntaxError: Identifier 'a' has already been declared 不绑定全局作用域 var c = 1console.log(window.c) // 1let c = 1console.log(window.c) // undefined 存在变量提升 let a = 1&#123; a = 2 let a&#125;// 如果 let 不会提升，那么 a = 2 就会将外面的 a 由 1 变成 2// 但运行发现 a = 2 报错：Uncaught ReferenceError: Cannot access 'a' before initialization 总结1： let 声明会提升到块顶部 从块顶部到该变量的初始化语句，这块区域叫做 TDZ（临时死区） 如果你在 TDZ 内使用该变量，JS 就会报错 总结2： let 的「创建」过程被提升了，但是初始化没有提升 var 的「创建」和「初始化」都被提升了 function 的「创建」「初始化」和「赋值」都被提升了 所谓暂时死区，就是不能在初始化之前，使用变量 总结3： a = 1; let a; // Uncaught ReferenceError: Cannot access 'a' before initializationa // Uncaught ReferenceError: Cannot access 'a' before initialization 如果 let x 的初始化过程失败了，那么 x 变量就将永远处于 created 状态 你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了） 由于 x 无法被初始化，所以 x 永远处在暂时死区 const 的使用const声明一个常量。常量：代码执行的过程中，不可以修改常量里面的值 const 声明的量不可以改变 const PI = 3.1415PI = 3 // TypeError: Assignment to constant variable const 声明的变量必须赋值 const num// SyntaxError: Missing initializer in const declaration 如果 const 声明了一个对象，仅仅保证地址不变，可以修改对象的属性 const obj = &#123;name: 'zs'&#125;obj.age = 18 // 正确obj = &#123;&#125; // TypeError: Assignment to constant variable 其他用法和 let 一样 只能在当前代码块中使用不能重复声明不绑定全局作用域 模板字符串(模板字面量)模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能 // 1. 通过``可以定义一个字符串let str = `hello world`// 2. 模板字符串内部允许换行let str = ` hello world`// 3. 模板字符串内部可以使用表达式let str = ` 你好，我是$&#123;name&#125;` 箭头函数ES6 标准新增了一种新的函数：Arrow Function（箭头函数） 为什么叫 Arrow Function？因为它的定义用的就是一个箭头 基本使用let fn = function (x, y) &#123; console.log(x + y)&#125;相当于// 语法： (参数列表) =&gt; &#123;函数体&#125;let fn = (x, y) =&gt; &#123; console.log(x + y)&#125; 参数详解 如果没有参数列表，使用()表示参数列表 let sum = function () &#123; console.log('哈哈')&#125;// 等同于：let sum = () =&gt; &#123; console.log('哈哈')&#125; 如果只有一个参数，可以省略() let sum = function (n1) &#123; console.log('哈哈')&#125;// 等同于：let sum = n1 =&gt; &#123; console.log('哈哈')&#125; 如果有多个参数，需要使用 () 把参数列表括起来 let sum = function (n1, n2) &#123; console.log('哈哈')&#125;// 等同于：let sum = (n1, n2) =&gt; &#123; console.log('哈哈')&#125; 给参数指定默认值 let a = (n = 1) =&gt; console.log(n)a() // 1a(3) // 3 不存在 prototype 这个属性 let a = () =&gt; &#123;&#125;console.log(a.prototype) // undefined 没有 arguments 箭头函数没有自己的 arguments 对象，箭头函数可以访问外围函数的 arguments 对象 function a () &#123; return () =&gt; arguments&#125;console.log(a(1, 2)()) // [Arguments] &#123; '0': 1, '1': 2 &#125;// 访问箭头函数的参数// Rest 参数接受函数的多余参数组成一个数组let a = (a, b, ...Args) =&gt; console.log(Args)a(1, 2, 3, 4, 5) // [3, 4, 5]console.log(a.length) // 2 Rest 参数和 arguments 对象的区别： rest 参数只包括那些没有给出名称的参数，arguments 包含所有参数 rest 参数之后不能再有其他参数，否则会报错 函数的 length 属性，不包括 rest 参数 arguments 对象不是真正的数组，而 rest 参数是数组实例，可以直接使用数组的方法 arguments 对象拥有一些自己额外的功能 返回值详解 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来 let sum = function (n1) &#123; console.log('哈哈') return n1&#125;// 等同于：let sum = n1 =&gt; &#123; console.log('哈哈') return n1&#125; 如果函数体只有一行一句，并且需要返回这个值，那么可以省略 {} 和 return let fn = function(n1, n2) &#123; return n1 + n2&#125;let fn = (n1, n2) =&gt; n1 + n2 箭头函数的注意点 箭头函数内部没有 this，因此箭头函数内部的 this 指向了外部的 this 因为箭头函数没有 this，因此箭头函数不能作为构造函数 不能用 call()、apply()、bind() 这些方法改变 this 的指向 【定义一个对象，定时器打招呼】 let obj = &#123; name: 'zs', sayHi: function() &#123; setInterval(() =&gt; &#123; console.log('大家好，我是' + this.name) &#125;, 1000) &#125;&#125;obj.sayHi() 对象简化语法// 当属性的 key 和变量的名相同时可以简写let person = &#123;name: name&#125; ==&gt; let person = &#123;name&#125;// 声明函数let cal = &#123; add: function () &#123; return 1 &#125;, // 可以省略 `:function` add()&#123; return 1 &#125;&#125; 属性名表达式 ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。 let propKey = 'foo'let methodKey = 'bar'let obj = &#123; [propKey]: true, // foo: true ['a' + 'bc']: 123, // abc: 123 [methodKey]() &#123; return 'hi' &#125;&#125; class 关键字ES5 中通过 构造函数 + 原型 的方式来实现面向对象 // 构造函数function Person () &#123; this.name = 'jack' this.age = 18&#125;// 在原型中添加实例方法Person.prototype.say = function () &#123; console.log(this.name, this.age)&#125;// 创建实例const p = new Person()p.say() ES6 中出现了 class 关键字，用来实现面向对象。 class 仅仅是一个语法结构（语法糖），本质上还是通过构造函数+原型的方式来实现继承的 // 基本使用// 创建 Person 类class Person &#123; // 类的构造函数 // constructor 固定名称 constructor (name, age) &#123; this.name = name this.age = age &#125; // 添加实例方法 say () &#123; console.log(this.name, this.age) &#125;&#125;// 创建实例const p = new Person('tom', 18)console.log(p)p.say() 继承：要实现至少需要两个class（子类 和 父类），子类继承自父类，继承后，子类就可以使用父类中的属性或方法 // 继承// 父类class Person &#123; constructor (name, age) &#123; this.name = name &#125; say () &#123; console.log('父类中的 say 方法') &#125;&#125;// 子类class Chinese extends Person &#123; constructor () &#123; // 子类中使用 constructor 必须手动调用 super // super 表示父类的构造函数 // 先调用 super() 在使用 this super() this.name = 'ls' this.age = 18 &#125;&#125;// 创建实例const c = new Chinese()console.log(c)c.say() // 父类中的方法 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring） // 1. 对象解构var &#123; a, b&#125; = &#123; a: 10, b: 20 &#125;console.log(a, b) // 10 20// 提取变量并赋值var &#123; a: p, b: q&#125; = &#123; a: 10, b: 20 &#125;console.log(p, q) // 10 20// 将剩余数组赋值给一个变量var &#123; a, b, ...rest &#125; = &#123; a: 10, b: 20, c: 30, d: 40 &#125;// ;(&#123; a, b, ...rest &#125; = &#123; a: 10, b: 20, c: 30, d: 40 &#125;)console.log(a, b, rest) // 10 20 &#123;c: 30, d: 40&#125;// 提供默认值var &#123; a = 1, b = 1 &#125; = &#123; a: 10 &#125;console.log(a, b) // 10 1// 赋值并提供默认值var &#123;a:aa = 10, b:bb = 1&#125; = &#123;a: 10&#125;console.log(aa, bb) // 10 1// 2. 数组解构var [a, b] = [1, 2]console.log(a, b) // 1 2// 将剩余数组赋值给一个变量var [a, b, ...rest] = [1, 2, 3, 4]console.log(a, b, rest) // 1 2 [3, 4]// ==&gt; var a = arr[0]; var b = arr[1]// 提供默认值var [c = 2, d = 2] = [10]console.log(c, d) // 10 2// 忽略某些值var [a = 2, , b = 2] = [10, 20, 30]console.log(a, b) // 10 30// 3. 函数参数的解构赋值function foo(&#123; x &#125;) &#123; console.log(x) // 1&#125;foo(&#123; x: 1, y: 2 &#125;)// 函数参数默认值function foo(&#123; x = 10 &#125;) &#123; console.log(x) // 10&#125;foo()// 4. 解构的特殊应用// 交换变量var a = 1var b = 3[a, b] = [b, a]console.log(a) // 3console.log(b) // 1// 字符串解构var str = 'love'var [a, b, c, d] = strconsole.log(a, b, c, d) // l o v e 数组扩展运算符扩展运算符（spread）是三个点（…）。作用：将一个数组转为用逗号分隔的参数序列 var arr = ['a', 'b', 'c']console.log(...arr)// 上面这句代码相当于：console.log(arr[0], arr[1], arr[2]) 应用 // 数组深拷贝var arr = [1, 2, 3]var arr1 = [...arr]console.log(arr === arr1) // false, 说明arr1和arr指向不同数组// 把一个数组插入另一个数组字面量var arr2 = [...arr, 4, 5, 6]console.log(arr2) // [1, 2, 3, 4, 5, 6]// 字符串转数组var str = 'love'var arr3 = [...str]console.log(arr3) // [ 'l', 'o', 'v', 'e' ] ES6 模块化]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流]]></title>
    <url>%2F2018%2Fother%2F%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[防抖和节流都是为了解决短时间内大量触发某函数而导致的性能问题，比如触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象 防抖（debounce）在事件被触发n秒后再执行回调函数，如果在这n秒内又被触发，则重新计时 应用场景 用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源 window 的 resize、scroll 事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次 节流（throttle）规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内事件被触发多次，只有一次能生效 应用场景 鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次 在页面的无限加载场景下，需要用户在滚动页面时，每隔一段时间发一次 ajax 请求，而不是在用户停下滚动页面操作时才去请求数据 监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断 区别防抖的作用是将多个连续的debounced调用合并为一次func调用。防抖是基于最近次 debounced 调用来重置 waitTime，如果debounced事件触发间隔小于 waitTime，func就不会执行； 节流的作用是限制func调用的频率（每waitTime调用一次）。是基于上次 func 调用来计算 waitTime 的，不管func 事件触发有多频繁，只要距离上次 func 调用超过了 waitTime，就一定会进行下次 func 调用。 – 原理： 防抖是 debounced 维护了一个计时器，规定在 waitTime 时间后触发 func，但是在 waitTime 时间内再次触发 debounced 的话，会清除当前的 timer 然后重新计时，这样一来，只有最后一次debounced 操作才能触发 func； 节流是通过判断是否到达一定时间 (waitTime) 来再次触发 func ， func 在 waitTime 时间内不能被再次触发。]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gulp 前端自动化环境]]></title>
    <url>%2F2018%2Ftool%2Fgulp%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前端自动化环境实现一些简单的功能： 1. 版本控制2. 编译SASS3. 检查JS4. 图片合并5. 压缩CSS6. 压缩JS... 这些都是每个Web项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。 构建工具： Gulp、Grunt、Webpack、… gulp 环境Gulp 是基于 Node.js 的，需要要安装 Node.js 安装 # 4.0版本# 检查 node 环境$ node -v# 全局安装 gulp$ npm install -g gulp$ gulp -v #4.0# 切换到你的在项目根文件夹下，运行$ npm install gulp# 安装 gulp 功能插件依赖包$ npm install gulp-less gulp-sass gulp-concat gulp-connect gulp-rename 配置新建 gulpfile.js 配置文件放在项目根目录下 // gulp3.x 配置不能直接在 4.0 上使用// gulp4.0 配置内容// 引入 gulpconst gulp = require('gulp')// 引入组件const less = require('gulp-less')const fileinclude = require('gulp-file-include')const connect = require('gulp-connect')// 启动 servefunction serve () &#123; connect.server(&#123; root: './', port: '8888', // 启用https // https: true, livereload: true &#125;)&#125;// 编译 lessfunction compileLess () &#123; return gulp // '!./**' 忽略文件 .src(['./less/*.less', '!./less/_*.less']) .pipe(less()) .pipe(gulp.dest('./public/css'))&#125;// html 刷新function refreshHtml () &#123; return gulp.src('./*.html') .pipe(connect.reload())&#125;// 引入外部 html 文件function compileHtml () &#123; return gulp .src(['./*.html', '!./_*.html']) .pipe( fileinclude(&#123; prefix: '@@' &#125;) ) .pipe(gulp.dest('./public'))&#125;// 在 html 中使用 `@@include('_header-aside.html')` 引入公共 html 结构// 监听文件变化function watch () &#123; gulp.watch(['./less'], compileLess) gulp.watch(['./image'], compileImg) gulp.watch(['./js'], compileJs) gulp.watch(['./*.html'], compileHtml) gulp.watch(['./public'], refreshHtml)&#125;// 默认任务，执行 gulp 会自动执行的任务gulp.task('default', gulp.parallel(serve, watch))// 复制 lib 文件夹function copyLib () &#123; return gulp.src('./lib/**/*').pipe(gulp.dest('./dest/lib'))&#125;// 清空 dest 文件夹function clean () &#123; return del(['./dest'])&#125; 运行 gulp 任务# 执行定义的 default 任务# $ gulp default$ gulp# 单独运行 sass 任务$ gulp less !./** 忽略文件 gulp.parallel() –并行运行任务 gulp.series() –运行任务序列 插件其他 gulp 插件参考gulp-imagemin: 压缩图片gulp-minify-css: 压缩cssgulp-uglify: 压缩jsgulp-concat: 合并文件gulp-rename: 重命名文件gulp-htmlmin: 压缩htmlgulp-clean: 清空文件夹del: 删除文件 gulp-connect 启动服务本机可以打开，局域网下手机打不开解决办法 connect.server(&#123; host: '0.0.0.0' 或 host: '::'&#125;) 在gulp 3.x 版本中报错会暂停监听需重新开启任务，4.0 修复了此问题 https://www.tuicool.com/articles/nAzqiaN]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动 web]]></title>
    <url>%2F2018%2F%E7%A7%BB%E5%8A%A8web%2F%E7%A7%BB%E5%8A%A8web%2F</url>
    <content type="text"><![CDATA[移动 web 基础移动端开发现状 移动 web 开发指的是需要适配移动设备的网页开发 移动 web 开发与 pc 端 web 开发没有本质的区别，使用的还是 HTML/CSS/JavaScript 的技术 移动 web 开发与 pc 端 web 开发的区别是什么？ 移动端的浏览器与 pc 端不同 谷歌浏览器 苹果浏览器、 UC浏览器 QQ浏览器 欧朋浏览器 百度手机浏览器 360安全浏览器 搜狗浏览器 猎豹浏览器等国内的手机浏览器都是根据webkit内核修改过来的，国内没有自主研发的内核，国内的操作系统也是基于Android系统修改的。因此在移动端，css3 属性只需要加 webkit 前缀即可 移动端设备尺寸不一样(尺寸非常多，碎片化很严重) Android： 320*480 480*800 540*960 720*1280 1080*1920 2k屏 4k屏iphpne： 640*960 640*1136 750*1334 1242*2208 移动端开发分类 原生 app（native app） 混合 app（Hybrid app） web 应用（webApp） 原生 app（native app） 原生 app 是基于操作系统的开发，比如安卓，ios，windows phone,他们只能在各自的操作系统上运行。 优点： 可以访问操作系统，获取更多的资源（gps，摄像头，传感器，麦克风等） 速度快，性能高，用户体验好 可以离线使用 缺点： 开发成本高 需要安装和更新，更新与发布需要审核。 Web App Web 应用使用 H5C3 开发页面，为浏览器设计的基于 web 的应用，可以在各种智能设备的手机浏览器上运行。不需要安装即可运行。 优点： 支持设备广泛 开发成本低（使用） 可以随时上线与更新，无需审核 缺点： 用户体验极度依赖网速 要求联网 无法获取手机的资源（gps，摄像头） 混合 app（Hybrid App） Hybrid App 是指介于 web-app、native-app 这两者之间的 app,它虽然看上去是一个 Native App，但只有一个 UI WebView，里面访问的是一个 Web App。（淘宝、京东、手机百度） Hybird App 说白了就是使用了 Native app 的壳，里面其实还是 HTML5 页面 优点： 开发成本和难度更低，兼容多个平台 也可以访问手机的操作系统资源。 更新维护更方便 缺点： 用户体验相比原生 app 稍差 性能依赖于网速 总结： 三种开发各有优缺点，具体用什么需要根据实际情况而定，比如预算，app 注重功能还是内容等 屏幕与分辨率理解设备像素、设备独立像素和 css 像素 移动设备与 PC 设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面 屏幕尺寸 通常我们所指的屏幕尺寸，实际上指的是屏幕对角线的长度（一般用英寸来度量） 1英寸 = 2.54厘米 屏幕分辨率 分辨率则一般用像素来度量，表示屏幕水平和垂直方向的像素数，例如 1920*1080 指的是屏幕垂直方向和水平方向分别有 1920 和 1080 个像素点而构成 像素：指计算机显示设备中的最小单位，即一个像素点的大小。每一个像素点可以理解为就是屏幕上的一个发光点 像素密度 ppi PPI (Pixels Per Inch)表示屏幕每英寸的像素数 PPI 值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙 设备像素 设备像素 (device pixels）也叫物理像素 设备像素指的是显示器上的真实像素，每个像素的大小是屏幕固有的属性，屏幕出厂以后就不会改变了 设备分辨率描述的就是这个显示器的宽和高分别是多少个设备像素 设备像素和设备分辨率交给操作系统来管理，浏览器不知道、也不需要知道设备分辨率的大小，浏览器只需要知道逻辑分辨率就可以了 设备独立像素 设备独立像素（Device Independent Pixels）也叫逻辑像素、设备无关像素。在 IOS 设备上叫PT，Android 设备上叫DP，在 css 中，叫PX 为了能够保证 图像内容在不同的 PPI 设备看上去大小应该差不多 ，操作系统定义了一个单位：设备独立像素，用设备独立像素定义的尺寸，不管屏幕的参数如何，都能以合适的大小显示（这也是设备独立像素名字的由来） 对于那些像素密度高的屏幕，操作系统将多个设备像素划分为一个逻辑像素。屏幕的像素密度越高，就需要更多的设备像素来显示一个设备独立像素。至于将多少设备像素划分为一个逻辑像素，这由操作系统决定 获取设备的像素比 window.devicePixelRatio // 物理像素 与 css 像素的比值 DPR 通过 screen.width/height得到的屏幕宽度和高度就是逻辑分辨率（单位：设备独立像素） css 像素与缩放在缩放比例为 100% 的情况下，一个 css 像素大小等于一个设备独立像素 缩放页面的时候，元素的 css 像素数量不会改变，改变的只是每个 css 像素的大小 缩放比例 = css 像素边长 / 设备独立像素边长 如果原本元素宽度为 128 个设备独立像素，那么缩放 200% 以后元素宽度为 256 个设备独立像素（css 像素宽度始终是 128） 桌面浏览器上缩放机制是 page zoom，缩放会导致 CSS 像素边长的改变，从而导致 window.devicePixelRatio 的改变 在移动端缩放机制是 pinch zoom，计算 window.devicePixelRatio 时，不考虑 pinch zoom 对 CSS 像素尺寸的影响，因此 window.devicePixelRatio 不会随缩放而改变 2 倍图与 3 倍图 以后同学在工作的过程中，从 UI 那拿到的设计图通常都是 640 的设计图或者是 750 的设计图 把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度 设备像素比 devicePixelRatio：即像素的压缩比例 结论 ：在移动端为了在高清屏手机上显示得更加细腻，通常会使用更大的图片，比如 2 倍图或者 3 倍图 视口 viewport问题：一个电脑上的网站，在手机端访问，效果是什么样的？iPhone5 的设备宽度只有 320px，一张宽度为 640px 的图片在手机端访问，显示的效果是什么？1. 在手机端，html的 大小都是 980px，为什么？这主要是历史原因导致的，因为在移动设备刚流行的时候，网站大多都是pc端的，pc端的页面宽度一般都比较大，移动设备的宽度比较小，如果pc端页面直接在移动端显示的话，页面就会错乱。为了解决这个问题，移动端html的大小直接就定死成了980px（因为早起的pc端网站版心就是980px居多）2. 视口在 pc 端，html 的大小默认是继承了浏览器的宽度，即浏览器多宽，html 的大小就是多宽，但是在移动端，多出来了一个视口的概念（乔布斯）,视口说白了就是介于浏览器与 html 之间的一个东西，视口的宽度默认定死了 980px，因此 html 的宽度默认就是 980px，视口的特点是能够根据设备的宽度进行缩放3. 视口设置对于现在的移动端页面来说，视口默认为 980px 肯定不合适，因为设备宽度不够的话，视口会进行缩放，导致页面展示效果不好看 视口参数设置 // width 设置视口的宽度// width=device-width 设置视口宽度为设备的宽度（常用）// initial-scale 设置初始缩放比例// initial-scale=1.0 表示不缩放// user-scalable 设置是否允许用户缩放// user-scalable=no 不允许用户缩放// maximum-scale 设置允许的最大缩放比例// maximum-scale=1.0 可以不设置，因为都禁止用户缩放了// minimum-scale 设置允许最小缩放比// minimum-scale=1.0 不设置，因为都禁用用户缩放了// 标准写法：// 快捷键： meta:vp + tab键&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0"&gt; 移动端调试问题 模拟器调试 真机调试：使用手机进行访问。 手机设备五花八门，屏幕尺寸都大不一样，尤其是安卓端，给我们的页面预览带来了一些麻烦。在实际工作中，作为开发者不可能有足够的设备让我们去测试（除了测试部门 ），即便有，效率也特别的低，因此开发者一般都是通过浏览器的手机模拟器来模拟不同的设备。 流式布局移动端的特点 手机端的兼容性问题比 PC 端小很多，因为手机端的浏览器版本比较新 手机端屏幕比较小，能够放的内容比较少。 问题：布局的时候怎么解决屏幕大小不一致的问题？ PC 端，固定版心，让所有分辨率的电脑的版心都是一样的，比如京东 移动端：移动端无法设置版心，因为移动端的设备屏幕本身就小，设置版心不合适。因此移动端大多会采用流式布局（百分比布局） 流式布局，也叫百分比布局，是移动端开发中经常使用的布局方式之一。 流式布局的特征： 宽度自适应，高度写死，并不是百分百还原设计图 图标都是固定死大小的，包括字体等也是固定死的。并不是所有的东西都是自适应的。 一些大的图片，设置宽度为百分比自适应即可，随着屏幕大小进行变化 流式布局无法做到所有设备都非常逼真的还原设计图，有些设备显示效果不是特别的好看。但是流式布局是移动端非常常用的一种布局方式，比较简单，需要掌握（携程、京东) 最后一天会学习 rem 布局，配合 less 非常的方便，并且能够实现完全的自适应，包括字体以及图标等 经典的流式布局 1. 左侧固定，右侧自适应2. 右侧固定，左侧自适应3. 两侧固定，中间自适应（圣杯布局，双飞翼布局）4. 等分布局 touch 事件移动端新增了 4 个与手指触摸相关的事件 touchstart: 手指放到屏幕上时触发 touchmove: 手指在屏幕上滑动式触发（会触发多次） touchend: 手指离开屏幕时触发 touchcancel: 系统取消 touch 事件的时候触发，比如电话 每个触摸事件被触发后，会生成一个 event 对象，event 对象中changedTouches会记录手指滑动的信息 e.touches // 当前屏幕上的手指e.targetTouches // 当前dom元素上的手指。e.changedTouches // 触摸时发生改变的手指(重点)(如手指离开屏幕) 这些列表里的每次触摸由 touch 对象组成，touch 对象里包含着触摸信息，主要属性如下 // e.changedTouches[0].clientXclientX / clientY // 触摸点相对浏览器窗口的位置pageX / pageY // 触摸点相对于页面的位置 !&gt; 使用 jquery 注册 touch 类事件时，获取手指使用 e.originalEvent.touchs[0] ，因为 jq 对事件对象进行了封装 【案例：jdm-滑动轮播图】 【案例：jdm-区域滚动】 iscroll 插件使用https://github.com/cubiq/iscroll iscroll 参考文档 注意：使用 iscroll 需要满足的条件 父盒子嵌套了子盒子（一个） 如果有多个子盒子，所以我们需要使用一个盒子把所有的子盒子包裹起来 如果有图片，我们需要保证图片加载完成，如果有浮动，需要清除浮动，为了保证子盒子的高度获取的是正确的 子盒子大小一定要超过父盒子的大小 // 使用：box为父盒子var box = document.querySelector('.box')new IScroll(box, &#123; scrollX: false, // 横向滚动 scrollY: true // 纵向滚动&#125;) zepto 框架 Zepto是一个轻量级的针对现代高级浏览器的 JavaScript 库， **它与 jquery有着类似的 api**。 如果你会用 jquery，那么你也会用 zepto github 地址 中文文档 zepto 与 jquery 的区别 jquery 针对 pc 端，主要用于解决浏览器兼容性问题，zepto 主要针对移动端 zepto 比 jquery 轻量，文件体积更小 zepto 封装了一些移动端的手势事件 zepto 的基本使用zepto 的使用与 jquery 基本一致，zepto 是分模块的，需要某个功能，就需要引入某个 zepto 的文件 &lt;script src="zepto/zepto.js"&gt;&lt;/script&gt;&lt;script src="zepto/event.js"&gt;&lt;/script&gt;&lt;script src="zepto/fx.js"&gt;&lt;/script&gt; $(function() &#123; $('.box').addClass('demo') $('button').on('click', function() &#123; $('.box').animate(&#123; width: 500 &#125;, 1000) &#125;)&#125;) zepto 的定制安装 Nodejs 环境 1、下载 zepto.js 2、解压缩 3、cmd 命令行进入解压缩后的目录 4、执行npm install命令 5、编辑 make 文件的41行，添加自定义模块并保存 7、然后执行命令 npm run-script dist 8、查看目录 dist 即构建好的 zepto.js zepto 手势事件zepto 中根据touchstart touchmove touchend封装了一些常用的手势事件，这些事件都是基于 touchstart touchmove touchend 封装 tap // 轻触事件,用于替代移动端的click事件，因为click事件在老版本中会有300ms的延迟swipe //手指滑动时触发swipeLeft //左滑swipeRight //右滑swipeUp //上滑swipeDown //下滑 响应式什么是响应式布局 响应式布局（respond layout）是 Ethan Marcotte 在 2010 年 5 月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端（手机、平板、pc 电脑、手表） ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的 为什么要有响应式布局？ 在移动互联日益成熟的时候，在 PC 端开发的网页已经无法满足移动设备的要求 通常的做法是针对移动端单独做一套特定的版本 如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及） 响应式布局 ：一个网站能够兼容多个终端（节约开发成本） 优点： 面对不同分辨率设备灵活性强 能够快捷解决多设备显示适应问题 *缺点： * 兼容各种设备工作量大，效率低下 代码累赘，会出现隐藏无用的元素，加载时间加长 其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况 响应式开发现状： 如果已经存在 PC 的网站了，那么一般不会使用响应式开发，而是针对移动端再开发一套系统（比如京东、淘宝） 在新建站点 上采用响应式开发的越来越多 在国内，响应式开发还不是特别的流行。但响应式开发是大势所趋，会越来越流行 响应式开发与移动 web 开发的比较 开发方式 移动 web 开发+pc 开发 响应式开发 引用场景 一般已经有了 PC 端网站，只需要端独开发移动端网站即可 针对一些新建网站，并且要求适配移动端 开发 针对性强，开发效率高 兼容各种终端，效率低 适配 只能适配移动端或者 PC 端，pad 上体验比较差 可以适配各种终端 效率 代码简介，加载快 代码相对复杂，加载慢 媒体查询 媒体查询（Media Query）是 CSS3 提出来的一个新的属性，通过媒体查询可以查询到 screen 的宽度，从而指定某个宽度区间的网页布局 设备分类 分类 宽度范围 大屏设备 &gt;1200px 中屏设备 992px~1200px 小屏设备 768px~992px 超小屏设备 &lt; 768px 媒体查询的使用需求： &lt;!-- 大屏设备(&gt;1200px) 版心：1170px 背景色：红色 中屏设备(992-1200) 版心：970px 背景色：蓝色 小屏设备(768-992) 版心：750px 背景色：黄色 超小屏设备(&lt;768px) 版心：100% 背景色：绿色--&gt; 响应式开发的原理：使用媒体查询实现不同终端的布局和样式的切换 媒体查询语法： /* 查询屏幕 *//* screen 和第一个 and 可以省略 */@media screen and 条件 &#123;&#125;/* 条件的写法 *//* min-width: 只要屏幕宽度超过这个值的设备样式就能生效 *//* max-width: 只要屏幕宽度小于这个值的设备样式就能生效 */@media screen and (min-width: 1200px) &#123; .container &#123; width: 1170px; background-color: red; &#125;&#125;@media screen and (min-width: 992px) and (max-width: 1200px) &#123; .container &#123; width: 970px; background-color: blue; &#125;&#125;@media screen and (min-width: 768px) and (max-width: 992px) &#123; .container &#123; width: 750px; background-color: yellow; &#125;&#125;@media screen and (max-width: 768px) &#123; .container &#123; width: 100%; background-color: green; &#125;&#125; bootstrap 框架【项目：微金所】 REMrem 是什么？rem（font size of the root element）是指相对于根元素的字体大小的单位。它就是一个相对单位。 em（font size of the element）是指相对于 当前元素的字体大小 的单位。它也是一个相对单位。 它们之间其实很相似，只不过计算的规则一个是依赖根元素，一个是当前元素计算。 html &#123; font-size: 16px;&#125;body &#123; font-size: 20px;&#125;div.em &#123; /* em 的计算方式参照的当前元素的 font-size，如果不设置，默认继承自父盒子 */ width: 2em; height: 2em; background-color: red;&#125;/* rem 的计算方式参照的是 html 的 font-size */div.rem &#123; width: 2rem; height: 2rem; background-color: blue;&#125; 为什么要用 rem？ rem 的主要目的就是解决用于不同屏幕的适配问题。rem 能够等比例的适配所有的屏幕。 由于市面上手机种类繁多，导致移动端的屏幕种类非常的混乱，比如有常见的320px 360px 375px 384px 480px 640px等。在开发中，美工一般只会提供 750px 或者是 640px 的设计稿，这就要求我们通过一张设计稿能够适配所有的屏幕。通常解决方案如下： 流式布局：虽然可以让各种屏幕都适配，但是显示效果不是非常的友好，因为只有几个尺寸的手机能够完美的显示出来视觉设计师和交互最想要的效果。但是目前使用流式布局的公司非常多，比如 亚马逊 、京东 、携程 响应式布局：响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是工作大，维护性难 。所以一般都是中小型的门户或者博客类站点会采用响应式的方法从 PC 端页面到移动端页面以及 web app 直接一步到位，因为这样反而可以节约成本。 rem 布局：rem 能够适配所有的屏幕，与 less 配合使用效果会更好。目前使用 rem 布局的有：淘宝 、 苏宁 rem 布局因为 rem 的基准点是根元素 html 的字体大小，因此我们只需要设置不同屏幕的 html 的 font-size 大小不一样就可以达到不同屏幕的适配了。 rem 配合媒体查询使用 rem 配合媒体查询可以适配多个终端 @media(min-width: 320px) &#123; html &#123; /* 基准值 / 设计图的大小 = 某个屏幕的font-size / 屏幕的宽度 */ /* 100/750 = x/370 */ font-size: 50px; &#125;&#125;... 优点：使用媒体查询适配，速度快。 缺点：适配多个终端时，需要添加响应的代码。 rem 配合 javascript通过 javascript 获取可视区的宽度，计算 font-size 的值，也可以适配多个终端 // 根据屏幕的大小动态设置 html的 font-sizefunction responsive () &#123; var uiWidth = 750 // 设计图宽度 var base = 100 // 设计图中1rem的大小 // 当前屏幕的大小 var pageWidth = window.innerWidth if(pageWidth &gt;= 750) &#123; pageWidth = 750 &#125; if(pageWidth &lt;= 320) &#123; pageWidth = 320 &#125; // 说白了就是把一个屏幕分成了 7.5 rem document.documentElement.style.fontSize = (base / uiWidth * pageWidth).toFixed(2) + ’px‘&#125; 优点：直接适配所有的终端 缺点：必须在页面加载之前设置 html 的 font-size 值，不然会出现文字大小调动的情况。 rem 配合 flexible 插件 flexible 插件基准值（base）是设计图的 1/10 使用 flexible 在 header 中引入 flexible.js 这个文件 根据设计图能够确定基准值， 配合 px2rem 插件 ，需要设置一个 rootFontSize 【案例：苏宁易购】 swiper 插件 Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端 swiper 中文网 othera &#123; /* 取消链接高亮, 移动端特有的样式 */ -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125;]]></content>
      <categories>
        <category>移动web</category>
      </categories>
      <tags>
        <tag>移动web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LESS 基本是引用]]></title>
    <url>%2F2018%2Ftool%2Fless%2F</url>
    <content type="text"><![CDATA[LESSLess 简介 Less 是一门 CSS 预处理语言（预先处理）,它扩展了 CSS 语言，增加了变量、Mixin、函数等特性 浏览器不直接识别 less 文件，浏览器只识别 css 文件，所以我们写了 less 文件之后，我们需要预先把 less 文件转换成 css 文件。 本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。 less 仅仅是写 css 的另一种方式，写出来的 less 文件浏览器也不识别，所以啊，我们写完了 less 文件，还需要通过 less 解析器解析成 css，最终浏览器引入的还是 css 文件。 学习网站： 官网 http://lesscss.org/中文网 http://lesscss.cn/ less 的编译 如何把 less 文件变成 css 文件 使用打包工具gulp webpack 使用考拉 koala 是一个前端预处理器语言（less/sass）图形编译工具，支持 Less、Sass、Compass、CoffeeScript，帮助 web 开发者更高效地使用它们进行开发。跨平台运行，完美兼容 windows、linux、mac。 考拉官网 使用步骤： 把less文件夹拖进去 会在当前目录生成一个css目录 优点：不用 node 环境，不用 less 环境，koala 内置了 使用插件easy less Less 语法变量注释 /* 这是CSS中的注释，因此会编译到css中 */// 这是less的注释，css不能识别这个注释， 最后不会编译到css文件 变量 // @变量名: 变量值;@color: #ccc;p &#123; color: @color;&#125; mixin 函数混入函数 // 定义一个函数：不带参数.btn() &#123; background-color: #ccc;&#125;// 调用函数.my_btn &#123; .btn();&#125;// 定义一个函数：带参数.btn_border(@width) &#123; border: @width solid #000;&#125;.my_btn &#123; // 如果函数定义了参数，调用的时候必须传入参数，否则会报错 .btn_border(10px);&#125;// 定义一个函数：带参数默认值.btn_border(@width: 1px) &#123; border: @width solid #000;&#125;.my_btn &#123; // 因为有默认值，所以不会报错 .btn_border(); .btn_border(10px);&#125; 应用：定义兼容多浏览器的圆角 .border_radius(@value: 5px) &#123; -webkit-border-radius: @value; -moz-border-radius: @value; -ms-border-radius: @value; border-radius: @value;&#125;div &#123; .border_radius(10px);&#125; 嵌套 我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。 使用伪类的时候 可以使用&amp; 表示自己 .father &#123; width: 100px; // 子代 .son1 &#123; &#125; // 后代 &gt; .son2 &#123; &#125; // 交集： &amp; 表示本身 &amp;.now &#123; &#125; &amp;::before &#123; &#125; &amp;:hover &#123; &#125;&#125; 导入// 可以省略后缀名@import 'variable';@import 'maxin'; 模块化的思想，分模块进行管理这些 less 文件，最终只需要使用 import 将 less 引入到一起即可 函数（运算） 在我们的 CSS 中充斥着大量的数值型的 value，less 可以直接支持运算，也提供了一系列的函数提供给我们使用。 li &#123; float: left; width: round(100%/6, 2); height: 100px + 100px;&#125; http://www.1024i.com/demo/less/reference.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>less</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap 框架]]></title>
    <url>%2F2018%2Fbootstrap%2Fbootstrap%2F</url>
    <content type="text"><![CDATA[bootstrap 框架Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷 bootstrap 中文网 特点： 组件简洁大方、代码规范精简、界面自定义性强 Bootstrap 是基于 HTML5 和 CSS3 开发的，它在 jQuery 的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分 jQuery 插件 Bootstrap 中包含了丰富的 Web 组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站 优点： 有自己的生态圈，不断的更新迭代 提供了一套简洁、直观、强悍的组件 标准化的 HTML+CSS 编码规范 让开发更简单，提高了开发效率 扩展性强，虽然界面组件样式已经定义好了，我们还可以自定义，修改默认样式 版本： 2.x.x 停止维护 优点：兼容性好 IE678 缺点：代码不够简洁、功能不够完善 3.x.x 目前使用最多（H5C3 很多东西） 优点：稳定，偏向于开发响应式布局，移动设备优先的 WEB 项目 缺点：放弃了 IE67，对 IE8 支持但是界面效果不友好 4.x.x 测试阶段 基本模板!&gt; 但凡看到 role属性 aria-*的属性 class=&#39;sr-only&#39;的标签 都可以直接删除，因为是给屏幕阅读器用的 &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;bootstrap基本模板&lt;/title&gt; &lt;!-- 引入 bootstrap 的核心样式文件 --&gt; &lt;link href="lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" /&gt; &lt;!-- html5shiv 是用来解决 IE8 以下浏览器不支持 HTML5 语义化标签的问题 --&gt; &lt;!-- respond 是用来解决 IE8 以下浏览器不支持媒体查询的问题，注意：respond 不支持 file 协议打开 --&gt; &lt;!-- 条件注释：IE浏览器专属 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- bootstrap 依赖于 jquery，因此需要在 bootstrap 之前引入jquery文件 --&gt; &lt;script src="lib/jquery/jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;!-- 引入 bootstrap 的核心js文件 --&gt; &lt;script src="lib/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt; 全局样式normalize.cssNormalize.css 是一种 CSS reset 的替代方案。经过@necolas 和@jon_neal 花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样 官网 github 网址 normalize 的特点： 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分 HTML 元素提供 修复浏览器自身的 bug并保证各浏览器的一致性 优化 CSS 可用性：用一些小技巧 Normalize.css 支持包括手机浏览器在内的超多浏览器，同时对 HTML5 元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。 Normalize.css 与 CSS reset 区别 布局容器Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。默认带了 15px 的 padding 值 .container 类用于固定宽度并支持响应式布局的容器 &lt;div class="container"&gt; ...&lt;/div&gt; .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器 &lt;div class="container-fluid"&gt; ...&lt;/div&gt; 这两种容器类不能互相嵌套 栅格系统栅格系统，也叫网格系统，bootstrap 栅格系统把一个盒子分成 12 格 栅格参数：col-xx-yy xx：lg 大屏(≥1200px)、md 中屏(≥992px)、sm 小屏(≥768px)、xs 超小屏(&lt;768px) yy：取值范围为 1 - 12 表示占几格 col-xx-12：可以省略不写 列偏移：col-xx-offset-yy xx ：lg、md、sm、xs yy：取值范围为 1 - 12 表示往右偏移几格 列偏移：实际上是给当前元素增加了左侧的边距（margin） 多余列（column）的元素将作为一个整体单元被另起一行排列 .row用于抵消 .container容器的 15px 的 padding 值，实际上是给元素添加了 margin: -15px 可以在.row中嵌套column 列排序：.col-md-push-* 和 .col-md-pull-* 栅格系统常用类（总共 12 列） 类名 例子 解释 .col-xs-xx .col-xs-6 在超小屏幕（及以上）生效 .col-sm-xx .col-sm-6 在小屏幕（及以上）生效 .col-md-xx .col-md-6 在中屏幕（及以上）生效 .col-lg-xx .col-lg-3 在大屏幕及生效，占 1/4 .col-lg-xx .col-lg-4 在大屏幕及生效，占 1/3 .col-lg-xx .col-lg-5 在大屏幕及生效，占 1/2 【案例：列嵌套.html】 &lt;div class="col-lg-4"&gt; &lt;!-- 栅格系统无处不在，只要父盒子有宽度，就可以使用栅格系统 --&gt; &lt;div class="row"&gt; &lt;div class="col-lg-6"&gt;&lt;/div&gt; &lt;div class="col-lg-6"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 【案例：列偏移.html】 &lt;!-- 使用 .col-md-offset-* 类可以将列向右侧偏移--&gt;&lt;div class="row"&gt; &lt;div class="col-lg-3"&gt;&lt;/div&gt; &lt;!-- col-lg-offset-3:在大屏下，这个div将向右侧偏移3个单位 --&gt; &lt;div class="col-lg-6 col-lg-offset-3"&gt;&lt;/div&gt;&lt;/div&gt; 排版标题：h1 到 h6 标签、.h1 到 .h6 类、 &lt;small&gt; 标签或 .small 类用来标记副标题 文本：&lt;mark&gt;标记、&lt;del&gt;删除、&lt;s&gt;无用文本、&lt;ins&gt;插入文本、&lt;u&gt;下划线文本、 .small 类或&lt;small&gt; 小号文本、&lt;strong&gt;着重 对齐：text-left、text-center、text-right、text-justify、text-nowrap 按钮&lt;a&gt;、&lt;button&gt; 或 &lt;input&gt; 预定义样式：btn、btn-default、btn-primary(蓝)、btn-success(绿)、btn-info(浅蓝)、btn-warning(橙)、btn-danger(红)、btn-link(链接) 尺寸：btn-lg(大)、(默认)、btn-sm(小)、btn-xs(超小)btn-block (块元素 100%宽度) 激活状态：active 禁用状态：button 元素 添加 disabled 属性、链接&lt;a&gt;元素添加 .disabled 类（建议通过 JavaScript 代码来禁止链接的原始功能） 图片响应式图片：img-responsive 实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性 图片形状：img-rounded、img-circle、img-thumbnail 辅助类文本颜色：text-muted、text-muted、text-primary、text-success、text-info、text-warning、text-danger 背景颜色：bg-primary、bg-success、bg-info、bg-warning、bg-danger 关闭按钮：&lt;button type=&quot;button&quot; class=&quot;close&quot;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; 三角符号：&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; 快速浮动：pull-left、pull-right 让内容块居中：&lt;div class=&quot;center-block&quot;&gt;...&lt;/div&gt; 清除浮动：clearfix 显示隐藏内容：show、hidden、invisible 响应式工具 超小屏 小屏幕 中等屏幕 大屏幕桌面.visible-xs-* 可见 隐藏 隐藏 隐藏.visible-sm-* 隐藏 可见 隐藏 隐藏.visible-md-* 隐藏 隐藏 可见 隐藏.visible-lg-* 隐藏 隐藏 隐藏 可见.hidden-xs 隐藏 可见 可见 可见.hidden-sm 可见 隐藏 可见 可见.hidden-md 可见 可见 隐藏 可见.hidden-lg 可见 可见 可见 隐藏 * -&gt; block inline inline-block 推荐使用 hidden 相关的属性 bootstrap-validator 插件基于 bootstrap 的前端校验插件 http://bootstrapvalidator.votintsev.ru/api 引包引入 css 文件 &lt;link rel="stylesheet" href="lib/bootstrap/css/bootstrap.css" /&gt;&lt;link rel="stylesheet" href="lib/bootstrap-validator/css/bootstrapValidator.css" /&gt; 引入 js 文件 &lt;script src="lib/jquery/jquery.js"&gt;&lt;/script&gt;&lt;script src="lib/bootstrap/js/bootstrap.js"&gt;&lt;/script&gt;&lt;script src="lib/bootstrap-validator/js/bootstrapValidator.js"&gt;&lt;/script&gt; 初始化表单校验插件bootstrap-validator 插件会在表单提交的时候进行校验，如果校验成功了，表单会继续提交，但是如果校验失败了，就会阻止表单的提交 // 使用表单校验插件$(formSelector).bootstrapValidator(&#123; // 1. 指定不校验的类型，默认为[':disabled', ':hidden', ':not(:visible)'],可以不设置 excluded: [], // 全部校验 // 2. 指定校验时的图标显示，默认是bootstrap风格 feedbackIcons: &#123; valid: 'glyphicon glyphicon-ok', invalid: 'glyphicon glyphicon-remove', validating: 'glyphicon glyphicon-refresh' &#125;, // 3. 指定校验字段 fields: &#123; username: &#123; // 设置校验规则 validators: &#123; // 不能为空 notEmpty: &#123; message: '' &#125;, stringLength: &#123; min: 6, max: 12, message: '' &#125;, // 正则校验 regexp: &#123; regexp: /^[a-zA-Z0-9_\.]+$/, message: '用户名由数字字母下划线和.组成' &#125;, callback: &#123;&#125; &#125; &#125;, password: &#123;&#125; &#125;&#125;) 注册表单校验成功的事件当表单校验成功时，会触发success.form.bv事件，此时会提交表单，通常我们需要禁止表单的自动提交，使用 ajax 进行表单的提交 $('#form').on('success.form.bv', function(e) &#123; e.preventDefault() // 使用ajax提交逻辑 $.ajax(&#123;&#125;)&#125;) 获取 validator 实例(对象)当我们初始化好表单校验插件时，我们可以通过以下方法来获取表单校验的 validator 实例，通过 validator 实例调用一些方法来完成某些功能 // 获取表单校验实例var validator = $('#form').data('bootstrapValidator')// 使用表单校验实例可以调用一些常用的方法validator.methodName(params) 常用方法重置表单重置表单中设置过校验的内容，将隐藏所有错误提示和图标 // 重置表单，隐藏所有的错误提示和图标 传入参数 true 会将内容也清空validator.resetForm() 更新字段的状态BootstrapValidator 在用户输入内容的时候，会做校验，当调用 bootstrap 的插件的方法可以手动会改变字段值的状态 validator.updateStatus(field*, status*, validator) Parameter Type Description field String|jQuery The field name or field element status String Can be NOT_VALIDATED, VALIDATING, INVALID or VALID validator String The validator name. If null, the method updates validity result for all validators]]></content>
      <categories>
        <category>框架</category>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术栈]]></title>
    <url>%2F2018%2Fother%2F%E6%8A%80%E6%9C%AF%E6%A0%88%2F</url>
    <content type="text"><![CDATA[技术栈：ajax + jquery + art-template：较原始的开发方式 vue + vuex + vue-router + webpack + less + weex + nuxt(ssr) react + react-router + redux + webpack + less + react-native angular + webpack + typescript + less + ionic 小程序]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器的工作原理]]></title>
    <url>%2F2018%2Fother%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器的工作原理浏览器的组成 用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分 浏览器引擎－ 用来查询及操作渲染引擎的接口 渲染引擎（浏览器内核）－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来 网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作 UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口 JS解释器－ 用来解释执行JS代码 数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了Storage技术，这是一种轻量级完整的客户端存储技术 主流的渲染引擎 浏览器的渲染引擎也叫排版引擎，或者是浏览器内核 主流的 渲染引擎 有 Chrome浏览器: Blink引擎（WebKit的一个分支）。 Safari浏览器: WebKit引擎，windows版本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发Windows版的Safari。 FireFox浏览器: Gecko引擎。 Opera浏览器: Blink引擎(早期版使用Presto引擎）。 Internet Explorer浏览器: Trident引擎。 Microsoft Edge浏览器: EdgeHTML引擎（Trident的一个分支）。 渲染引擎工作原理渲染引擎解析的基本流程： 解析 HTML 构建 Dom树，同时解析所有的 css 样式，构建 css 规则。DOM 是 W3C 组织推荐的处理可扩展置标语言的标准编程接口。 根据 DOM 树和 css 规则合并构建 渲染树 DOM树上的节点没有样式的，渲染树的节点有样式的 渲染树上的节点都是需要渲染的，所以渲染树上没有像head标签 或 display: none这样的元素，但是它们在Dom树中 对渲染树进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫layout 或 reflow。 绘制渲染树，调用操作系统底层API(UI Backend)进行绘图操作。 webkit内核工作流程 gecko内核工作流程 结论：浏览器能够解析HTML文件，并且显示到页面中。所以我们写的文件能够使用浏览器打开并且能够看到效果。 重绘与回流重绘与回流回流(reflow): 又叫重排，当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。 重绘(repaint)：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。 每个页面至少需要一次回流+重绘。 回流必将引起重绘 回流什么时候发生？ 1、添加或者删除可见的DOM元素 2、元素位置改变 3、元素尺寸改变——边距、填充、边框、宽度和高度 4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变 5、页面渲染初始化 6、浏览器窗口尺寸改变——resize事件发生时 var s = document.body.styles.padding = "2px" // 回流+重绘s.border = "1px solid red" // 再一次 回流+重绘s.color = "blue" // 再一次重绘s.backgroundColor = "#ccc" // 再一次 重绘s.fontSize = "14px" // 再一次 回流+重绘// 添加node，再一次 回流+重绘document.body.appendChild(document.createTextNode('abc!')) 聪明的浏览器 从上个实例代码中可以看到几行简单的JS代码就引起了6次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句JS操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如： offsetTop, offsetLeft, offsetWidth, offsetHeight scrollTop/Left/Width/Height clientTop/Left/Width/Height width,height 请求了getComputedStyle(), 或者 IE的 currentStyle 如何性能优化 减少回流与重绘的次数，就需要简单对渲染树的操作 直接使用 className 修改样式，少用 style 设置样式 让要操作的元素进行”离线处理”，处理完后一起更新 使用 DocumentFragment 进行缓存操作，引发一次回流和重绘 使用 display:none 技术，只引发两次回流和重绘 将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow 完成功能是前提，在完成功能的情况下想着优化代码]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS3 基础]]></title>
    <url>%2F2018%2Fhtml%E4%B8%8Ecss%2Fcss3%2F</url>
    <content type="text"><![CDATA[CSS3如同人类的的进化一样，CSS3 是 CSS2 的“进化”版本，在 CSS2 基础上，增强 或 新增 了许多特性， 弥补了 CSS2 的众多不足之处，使得 Web 开发变得更为高效和便捷。 现状 PC 端浏览器支持程度差，需要添加私有前缀 移动端支持优于 PC 端 不断改进中 应用相对广泛 关于私有前缀： 在标准还未确定时，部分浏览器已经根据最初草案实现了部分功能，为了与之后确定下来的标准进行兼容，所以每种浏览器使用了自己的私有前缀与标准进行区分，当标准确立后，各大浏览器将逐步支持不带前缀的 css3 新属性 目前已有很多私有前缀可以不写了，但为了兼容老版本的浏览器，可以仍沿用私有前缀和标准方法，逐渐过渡 一般来说，CSS3 主要是为移动端而生的，因此我们在移动端没必要写太多的前缀，因为移动端的 ios 和 Android 的浏览器都是 webkit 内核 谷歌、苹果浏览器：-webkit-火狐浏览器：-moz-IE 浏览器：-ms-欧朋浏览器：-o- 一般工作中不用去加，会通过打包工具 webpack 自动添加 选择器阴影 text-shadow: 文字阴影 语法：text-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]* &lt;shadow&gt; =&gt; &lt;length&gt;&#123;2,3&#125; &amp;&amp; &lt;color&gt;?text-shadow：水平偏移 垂直偏移 羽化大小 颜色水平偏移 垂直偏移 可以为负值，羽化大小可选且不可为负可以设置多组阴影值，用逗号隔开 box-shadow: 边框阴影 语法：box-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]* &lt;shadow&gt; =&gt; inset? &amp;&amp; &lt;length&gt;&#123;2,4&#125; &amp;&amp; &lt;color&gt;?box-shadow：水平偏移 垂直偏移 羽化大小 阴影外延 颜色水平偏移、垂直偏移、阴影外延可以为负值，羽化大小、阴影外延可选，羽化大小不允许负值可以设置多组阴影值，用逗号隔开inset：设置对象的阴影类型为内阴影。该值为空时，则对象的阴影类型为外阴影 背景background-size bakground-clip background-origin 渐变线性渐变 linear-gradient() 指沿着某条直线朝一个方向产生的渐变效果 渐变实际上相当与一张图片，因为需要加给 background-image 才会生效 /* 最简单的渐变 颜色至少两个 方向默认从上到下 */background-image: linear-gradient(red, green);/* 设定渐变的方向 */background-image: linear-gradient(to right, red, green);/* 也可以设定渐变的角度 */background-image: linear-gradient(45deg, red, green);/* 设定渐变的范围 */background-image: linear-gradient(to right, red 20%, green 80%)/* 每一个区间表示渐变颜色的范围 */background-image: linear-gradient(to right, red 20%, green 20%) 径向渐变 radial-gradient 指从一个中心点开始沿着四周产生渐变效果 /* 最简单的渐变 */background-image: radial-gradient(red, green);/* 指定圆的半径和圆心 */background-image: radial-gradient(200px at center, red, green);/* 指定椭圆 */background-image: radial-gradient(200px 80px at center, red, green);/* 指定范围 */background-image: radial-gradient(200px at center, green 50%, red 50%); 盒子模型 CSS3 中可以通过 box-sizing 来指定盒模型，即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变 可以分成两种情况： box-sizing: border-box 计算方式为 content = width – border - padding box-sizing: content-box 计算方式为 content = width calc() 函数用于动态计算长度值 注意：运算符前后都需要保留一个空格，例如：width: calc(100% - 10px) 任何长度值都可以使用 calc() 函数进行计算 calc() 函数支持 + 、-、 * 、/ 运算 calc() 函数使用标准的数学运算优先级规则 过渡 过渡的属性 如果两个状态发生改变，没有过渡，效果是瞬间变化的，如果加上了过渡，那么这个过程就会有动画的效果，整个状态变化的过程是由浏览器来完成的，我们只需要关注开始状态与结束状态即可 /* transition-property：设置过渡属性 默认值为 all 表示全部*//* 多个用逗号分隔 */transition-property: all;/* transition-duration:设置过渡时间 */transition-duration: 1s;/* transition-delay：设置过渡延时 */transition-delay: 2s;/* transition-timing-function:设置过渡的速度 *//* linear(匀速)，ease(平滑)，ease-in，ease-out，ease-in-out， steps(10)(分步动画) */transition-timing-function: linear; 注意： 过渡必须要有两个状态的变化 过渡除了可以加到初始的状态，可以加到 hover 状态，但效果不一样，如果加到 hover 状态，回来就没有过渡了 属性合写 /* 属性 时间 延时 速度 *//* 多个过渡用逗号隔开 */transition: width 1s 3s linear, border-radius 3s; 2D 转换 transform: 转换，是 CSS3 最具颠覆性的几个特性之一，既可以用于 2D 转换，也可以用于 3D 转换 transform: 2D 转换，元素在平面上实现移动、旋转、缩放、斜切等操作 scale 缩放transform: scaleX(0.5); /* 让宽度变化 */transform: scaleY(0.5); /* 让高度变化，注意不能写多个transform，不然会覆盖 */transform: scale(0.5); /* 让宽度和高度同时变化 */ 注意： scale 接收的值是倍数，因此没有单位 scale 是一个值时，宽度高度会等比例同事缩放 scale 缩放时内部内容也会缩放 可以通过 transition-origin 设定缩放原点 （可以是数值或方位词 top、left…) translate 平移transform: translateX(100px);transform: translateY(100px);transform: translate(100px, 100px);transform: translate(50%, 50%); 注意： translate 的值可以是 px，也可以是百分比，如果是百分比，那么参照的是自身的宽高 translate 移动的元素并不会影响其他盒子，类似于相对定位 rotate 旋转transform: rotate(360deg); /* 旋转360度 */transform: rotate(-360deg); /* 逆时针旋转360度 */ 注意： 单位是 deg，角度，不是 px 正值顺时针转，负值逆时针转 可以通过 transition-origin 设定旋转原点 rotate 旋转会让坐标轴也跟着旋转 skew 斜切(变形)skew 在实际开发中，是用的最少的一个属性。一般来说，x 和 y 只会倾斜其中的一个 /* 在水平方向倾斜30deg */transform: skewX(30deg);/* 在垂直方向倾斜30deg */transform: skewY(30deg); 【案例：扫光效果.html】 transform-origin 转换原点 通过 transform-origin 可以设置转换的中心原点 transform-origin: center center;transform-origin: 40px 40px; 转换合写问题 transform 属性只能写一个，如果写了多个会覆盖，属性的值可以写多个， 用空格隔开即可 transform: translateX(800px) scale(1.5) rotate(360deg); transform 属性可以连写，但是顺序对效果影响的，因为它会在第一个效果的基础上执行第二个效果，然后执行第三个效果（通常会把 rotate 放后面） 如果对 transform 进行过度效果的时候，初始状态和结束状态要一一对应 【案例：盾牌打散与合并效果.html】 3D 转换思考：2D 与 3D 的区别？ 坐标轴 用 X、Y、Z 分别表示空间的 3 个维度，三条轴互相垂直。注意+Y 是向下的 perspective 透视 电脑显示屏是一个 2D 的平面，因为我们看不出来旋转的方向，通过 perspective 属性，可以定义 3D 元素距视图的距离，单位是 px。 说白了，设置了 perspective 属性后，就有了进大远小的效果了，在视觉上，让我们能看出来 3d 的效果。 注意：当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。 perspective：500px; 对于我们眼睛来说，离我们越近的房子，我们会感觉到这个房子越大，离我们越远的房子，就会感觉越小，其实房子的大小都是一样的，只是在视觉上的一种不同。 rotate 旋转transform: rotate(45deg); /* 让元素在平面2D中旋转，相当于沿着Z轴旋转 */transform: rotateX(45deg); /* 让元素沿着X轴转45度 */transform: rotateY(45deg); /* 让元素沿着Y轴转45度 */transform: rotateZ(45deg); /* 让元素沿着Z轴转45度 */ 【3D 旋转.html】 translate 平移/* 沿着X轴的正方向移动45px */transform: translateX(45px);/* 沿着Y轴的正方向移动45px */transform: translateY(45px);/* 沿着Z轴的正方向移动45px */transform: translateZ(45px); 【3D 平移.html】 【立方体.html】 transform-styletransform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注意这个属性只能给父元素添加 flat: 默认值，2d显示preserve-3d: 3d显示 transform-style 与 perspective 区别 透视：透视只是相当于设置了一个距离，辅助我们查看 3D 效果的工具 preserve-3d：给父盒子添加，让子元素保留 3D 的位置，说白了，只有设置了 preserve-3d，这个元素才能被称之为 3d 元素 一个 3d 元素可以没有 perspective，但是不能没有 transform-style 【3D 导航案例.html】 【切割轮播图案例】 【3D 相册案例】 过渡结束事件// 给最后一个ul添加过渡结束事件（节流阀）uls[uls.length - 1].addEventListener('transitionend', function() &#123; isCanAnimate = true&#125;) 动画 动画可以通过设置多个节点来精确控制一个或者一组动画，常用来实现复杂的动画效果 动画与过渡的区别： 过渡必须触发，需要两个状态的改变。动画可以一直运行下去，不需要触发。实现效果与过渡差不多 使用一个动画的基本步骤： 1.通过 @keyframes 指定动画序列2.通过百分比或者 from/to 将动画分割成多个节点3.在各个节点中分别定义样式4.通过 animation 将动画应用于相应的元素 animationanimation 是一个复合属性，一共有 8 个参数 animation-name: 动画名称，由@keyframes定义的animation-duration: 动画的持续时间 默认0sanimation-timing-function: 动画的过渡类型 ease(默认) linear stepsanimation-delay: 动画的延迟时间 默认0sanimation-iteration-count: 动画的循环次数 默认1次 infinite：无限循环animation-direction: 设置动画在循环中的方向 normal：正向(默认) reverse(反向) alternate(往复循环)animation-fill-mode: 设置动画结束时的状态 none：默认 backwards：动画结束时停留在开始状态 forwards: 动画结束时停留在结束的状态animation-play-state: 设置动画的状态。running：运动(默认) paused：暂停 动画库的使用https://daneden.github.io/animate.css/ 字体图标我们经常把网页常用的一些小的图标，做成精灵图，然后通过 background-position 去调整位置，但是这个需要引入图片，并且图片大小改变之后会失真。在 CSS3 中可以使用字体图片，即使用图标跟使用文字一样 优点： 1、将所有图标打包成字体库，减少请求 2、具有矢量性，可保证清晰度，可以修改文字的颜色或者样式 3、使用灵活，便于维护 阿里巴巴矢量图标：http://www.iconfont.cn/ Font Awesome 使用 http://fontawesome.dashgame.com/ 弹性布局(伸缩布局) 布局：其实就是调整元素在水平和垂直方向上的布局方式 CSS3 在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。 当给一个盒子设置了 display：flex 之后，这个盒子就有了 主轴 和 侧轴 的概念主轴：默认是水平方向向右，子元素在主轴上排列侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向向下 给容器设置的样式 flex-direction 用来调整主轴的方向，默认是水平方向，可选值有： row：主轴方向为水平向右（默认）column：主轴方向为竖直向下row-reverse: 主轴方向为水平向左column-reverse: 主轴方向是竖直向上 justify-content 用来设置子元素在 主轴方向的对齐方式 ，可选的值有： flex-start: 弹性盒子元素将向起始位置对齐flex-end: 弹性盒子元素将向结束位置对齐center: 弹性盒子元素将向行中间位置对齐space-between: 第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的space-around: 弹性盒子元素会平均地分布在行里（不会贴边） align-items 用于调整 侧轴的对其方式 ，可选的值有： flex-start：元素在侧轴的起始位置对其flex-end：元素在侧轴的结束位置对其center：元素在侧轴上居中对其stretch：元素的高度会被拉伸到最大（不能给死高度） flex-wrap 控制 flex 容器是单行或者多行，默认不换行 nowrap：不换行（默认），会压缩子盒子的宽度wrap：当宽度不够的时候，会换行 align-content 用来设置多行时侧轴的排列方式 flex-start：各行向侧轴的起始位置堆叠flex-end：各行向弹性盒容器的结束位置堆叠center：各行向弹性盒容器的中间位置堆叠space-between：第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布space-around：各行在侧轴中平均分布stretch：拉伸，不设置高度的情况下 align-items 与 align-content 的区别 align-items调整的是侧轴的对其方式，不换行一般用align-itemsalign-content: 必须是多行才生效，如果单行，没有效果。换行了就用 align-content; !&gt; 上述属性都是给父盒子设置的，这些样式影响的是所有的子元素，接下来的几个属性是给子盒子设置的，用来单独设置子元素的样式 给子元素设置的样式 flex 用来设置子盒子如何分配主轴剩余空间 flex: 1; order 定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 order: 1; align-self align-self 用于设置当前元素在侧轴的位置，是给子元素设置，优先级比 align-items 的优先级高 取值与 align-items 的取值一样 阮一峰的博客http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 【案例：6 面神骰】 【案例：携程网】 【案例：360 浏览器】 other微调元素 margin-top: - ; transform：translateY(); position: relative; top: - ;]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>html&amp;css</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 基本概念]]></title>
    <url>%2F2018%2Fhtml%E4%B8%8Ecss%2Fhtml5%2F</url>
    <content type="text"><![CDATA[HTML5 基本概念什么是 HTML5？ HTML5 并不仅仅是作为 HTML 标记语言的一个最新版本， 更重要的是它制定了 web 应用开发的一系列标准，成为第一个将 web 作为应用开发平台的 HTML 语言。 HTML5 定义了一系列新元素，如 新语义标签、多媒体标 签等，可以帮助开发者开发更加丰富的应用，同时有令人眼花缭乱的 css3，还提供了一些 Javascript API，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用，制作 webApp，甚至结合 Canvas 我们可开发网页游戏 我们日常讨论的 H5 其实指的是一个泛称，它是由HTML5+CSS3+javascript 等技术组合而成的一个应用开发平台 HTML5 的历史 1. WHATWG: Web Hypertext Application Technology Working。 WHATWG成立的原因是W3C意图放弃HTML，而力图发展XML技术2. HTML5 的第一份正式草案已于2008年1月22日公布3. 2014年10月29日，万维网联盟宣布，经过接近8年的艰苦努力，该标准规范终于制定完成 思考：问什么 HTML5 在 2008 年就发布草案了，到 2014 年才火起来？ 因为移动端的推动，HTML 在老的浏览器上兼容性很严重，并且 HTML5 很多新特性其实就是为移动端而出现的，可以说HTML5 是为移动端而生的 HTML5 语义化标签常用语义化标签 在 HTML5 之前，我们布局大多使用 div，但是 div 并没有语义化，HTML5 推出了一系列的语义化标签，可以用来表示 header、footer 等。 HTML5 新的语义化标签 header 头部、nav 导航、footer 底部、aside 侧边栏、article 文章、section 区块、main 主体区域 本质上新语义标签与&lt;div&gt;、&lt;span&gt;没有区别，只是其具有语义性，使用时除了在 HTML 结构上需要注意外，其它和普通标签的使用无任何差别，&lt;nav&gt;完全可以理解成&lt;div class=&quot;nav&quot;&gt;。不要好奇，它只是一个标签！就是增加了语义性，更加利于 SEO 的优化。 html5 还推出了一些其他的标签：http://www.w3school.com.cn/tags/index.asp 兼容性处理IE678 不识别这个标签 document.createElement('header') // 创建这个标签即可让IE678识别// 创建的标签默认是行内样式。// 还需给标签加一个 display:block 的属性。 借助 html5shiv.js 我们每次都要去创建标签，并且还需要设置 display：block 属性，非常麻烦，因此我们可以引入一个第三方 js 文件，这个 js 文件的功能就是创建元素和设置 display 属性。 &lt;!-- [if lte IE 8] &gt; // lte ==&gt; 小于等于&lt;script src="js/html5shiv.min.js"&gt;&lt;/script&gt;&lt;! [endif] --&gt;&lt;!-- 当 ie 浏览器的版本小于等于8的时候，才会引入 html5shiv.js --&gt;&lt;!-- css hack --&gt;&lt;!-- 条件注释 IE独有的注释 --&gt; 类名操作(重点) js 在 H5 中给所有的 DOM 对象新增了一个属性 classList classList 是一个集合，会存储某个元素上所有的类名，使用 classList 来替代 className 操作 class 类 // 添加类div.classList.add('classname')// 移除类div.classList.remove('classname')// 切换类div.classList.toggle('classname')// 判断类div.classList.contains('classname') 【tab 栏案例】 自定义属性操作（重点） H5 规定，以后但凡给标签增加自定义属性，都应该用 data- 开头 (规范) H5 给所有的 DOM 对象增加了一个 dataset 的属性，这个属性中会包含所有 data- 开头的属性 html 5 中操作自定义属性 dataset 属性 &lt;div id="box" data-name="zs" data-age="10" data-user-name="ls"&gt;&lt;/div&gt;&lt;script&gt; var box = document.querySelector('#box') console.log(box.dataset) // DOMStringMap &#123;name: 'zs', age: '10', userName: 'ls'&#125; console.log(box.dataset.name) // zs console.log(box.dataset['age']) // 10 console.log(box.dataset.userName) // ls box.dataset.aaBb = 'cc' // 在html结构中或添加 data-aa-bb="cc" 的自定义属性&lt;/script&gt; 注意：html 中属性是忽略大小写的，相当于是小写字母，如果需要大写，应使用中划线 - 进行分隔，在 js 中会转换成驼峰的形式，如data-user-name ==&gt; userName jquery 中操作自定义属性 jquery 并没有把 data- 当成自定义属性来用，jq 中封装了 data() 方法 &lt;div data-id="1" data-name="zs" id="box" data-a='&#123;"b":"c"&#125;'&gt;&lt;/div&gt;&lt;script&gt; console.log($('#box').data()) // &#123;id: 1, name: "zs"&#125; // console.log($('#box').attr()) // error console.log(box.dataset) // DOMStringMap&#123;id: "1", name: "zs"&#125; console.log($('#box').data('id')) // 1 =&gt; 获取到自定义属性 $('#box').data('id', 2) // 并不会修改原标签中的自定义属性 console.log($('#box').data('id')) // 2 =&gt; html中data-id依然是1 console.log($('#box').attr('data-id')) // 1 console.log(box.dataset['id']) // 1 =&gt; 获取到的还是原来的 data-id $('#box').attr('data-id', 3) console.log($('#box').data('id')) // 3 console.log(box.dataset['id']) // 3 // 属性里使用json语法，但通过data()设置的不能解析成对象 $('#box').data('d', '&#123;"e":"f"&#125;') console.log($('#box').data('a')) // &#123;b: "c"&#125; =&gt; 对象 console.log($('#box').data('d')) // '&#123;"e":"f"&#125;' $('#box').removeData() // 删除之前通过 data() 方法设置的数据&lt;/script&gt; !&gt; jq 的 data() 方法内部使用了缓存来实现，该方法设置的属性只能通过该方法获取，在 html 页面中看不到属性值，通过原生 dataset 属性也获取不到值 网络状态 在移动端，我们经常需要检测设置是在线还是离线，HTML5 为此定义了一个 navigator.onLine 属性，这个属性用于检测设备是否联网。navigator.onLine 在不同浏览器中有细微的差别。 网络状态navigator.onLine 返回用户当前的网络状况，是一个布尔值1. 如果浏览器连不上网(包括局域网)，就是离线状态，也就是脱机状态，会返回 false2. 否则就是在线状态，返回 true 注意：返回 true 不一定就是说一定能访问互联网，因为有可能连接的是局域网。但是返回 false 则表示一定连不上网。 监听网络变化 为了更好的确定网络是否连接，HTML5 还定义了两个事件，用于监听网络状态的变化。 // 网络连接时会被调用window.addEventListener('online', function() &#123; alert('online')&#125;)// 当网络断开时会被调用window.addEventListener('offline', function() &#123; alert('offline')&#125;) 地理位置 在 HTML 规范中，增加了获取用户地理信息的 API，这样使得我们可以基于用户位置开发互联网应用，即基于位置服务 LBS(Location Base Service) 隐私HTML5 规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。在获取地理位置之前，会询问用户，只有在获得许可之后，才能获取到用户的位置信息。 H5 提供的获取地理位置信息并不是特别的精确，会一定的误差，如果需要非常精确的定位，还是需要使用安卓或者 ios，访问基于操作系统的方法。 （小程序） 相关的方法// successCallback:获取成功后会调用,并返回一个position对象，里面包含了地理位置信息// 获取失败了会调用，并返回error对象，里面包含了错误信息。// 获取当前的地理位置信息navigator.geolocation.getCurrentPosition(successCallback, errorCallback)// 重复的获取当前的地理位置信息navigator.geolocation.watchPosition(successCallback, errorCallback) 实例： navigator.geolocation.getCurrentPosition( function(position) &#123; // 定位成功会调用该方 // 法谷歌浏览器进行了限制，看不到，可以再IE浏览器下查看 // position.coords.latitude 纬度 // position.coords.longitude 经度 // position.coords.accuracy 精度 // position.coords.altitude 海拔高度 &#125;, function(error) &#123; // 定位失败会调用该方法 // error 是错误信息 &#125;) 苹果浏览器对 webkit 定位权限进行了修改，所有定位请求的页面必须是 https 协议的。 百度地图、高德地图、腾讯地图 仅仅获取到经纬度对于用户来说意义并不大，因为用户也不知道经度和纬度表示的是地球上的哪一个地方，因为我们可以结合百度地图，准确的将用户的位置显示出来。 百度地图官网：http://lbsyun.baidu.com/ 1. 在开发中，找到 javascript API2. 直接查看示例 demo3. 复制相应的代码，替换掉秘钥就行，秘钥只需创建一个新的应用就可以了 web 存储 在代码执行的时候，数据都是存储在内存中的，当页面关闭或者浏览器关闭的时候，内存就被释放掉了。数据只有存储在硬盘上，才不会被释放。 cookie特点： 在浏览器端的存储数据的容器 大小 4k 生命周期，默认会话级别，但是可以设置过期时间 cookie 中的数据可以在同一个网站的页面共享 cookie 中的数据，在请求时会进行自动携带 不同浏览器的 cookie 不能共享 cookie 是以字符串形式存在的，这个字符串有固定的格式：key=value;key1=value1；在获取 cookie 内容时，一般需要通过正则或者字符串的方法进行处理，转换成对象，最终得到数据 一般用于存储 sessionId，可以实现登录状态保持 (会话保持) document.cookie = 'name=zhangsan'document.cookie = 'age=18'document.cookie = 'sex=23'// 设置过期时间document.cookie = 'sex=12;max-age=3600'// 读取cookievar result = document.cookieconsole.log(result) WebStorage HTML5 规范提出使用 sessionStorage 和 localStorage 存储数据。设置、读取、删除操作很方便 sessionStorage 和 localStorage 特点 都保存在客户端 大小为 5M 左右 使用方法相同 以键值对的方式，存储字符串格式的数据 sessionStorage 和 localStorage 区别 sessionStorage 生命周期默认为一个会话周期，且不能设置周期，一旦关闭浏览器，就销毁了，不能在多个窗口下共享数据 localStorage 永久生效，除非手动删除，可以多个窗口共享 使用方法 setItem(key, value) // 设置存储内容getItem(key) // 读取存储内容removeItem(key) // 删除键值为key的存储内容clear() // 清空所有存储内容（谨慎使用） 存取复杂数据类型：先将复杂数据转换成 JSON 字符串 JSON.stringify(obj/arr) 在进行存储；使用时将 JSON 字符串转换成复杂数据类型 JSON.parse( jsonStr ) 【案例-换肤效果】 Cookie 和 WebStorage 比较cookie 大小受限 用户可以操作（禁用）cookie，使功能受限 安全性较低 有些状态不可能保存在客户端。 每次访问都要传送 cookie 给服务器，浪费带宽 WebStorage 存储空间更大：cookie 为 4KB，而 WebStorage 是 5MB WebStorage 不会传送到服务器，存储在本地的数据可以直接获取，速度更快，并且减少了客户端和服务器端的交互，节省了网络流量 对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage 会非常方便 安全性：WebStorage 不会随着 HTTP header 发送到服务器端，所以安全性相对于 cookie 来说比较高一些，不会担心截获，但是仍然存在伪造问题 WebStorage 提供了一些方法，数据操作比 cookie 方便 自定义播放器全屏切换 API： // requestFullScreen 这个方法还没有标准化，需要添加私有前缀video.requestFullScreen()video.webkitRequestFullScreen()video.mozRequestFullScreen() video/audio 属性： currentTime: 设置或返回音频/视频中的当前播放位置（以秒计） duration: 返回当前音频/视频的长度（以秒计） autoplay: 默认 false 设置或返回是否在加载完成后随即播放音频/视频 volume: 设置或返回音频/视频的音量 paused: 设置或返回音频/视频是否暂停， true 指示音频/视频已暂停 方法： load(): 重新加载音频/视频元素 play(): 开始播放音频/视频 pause(): 暂停当前播放的音频/视频 事件： timeupdate: 播放进度更改时触发 参考文档http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp 推荐：https://www.awesomes.cn/repo/videojs/video-js 文件读取 通过 FileReader 对象我们可以读取本地存储的文件（用户通过 input:file 上传的文件），可以使用 File 对象来指定所要读取的文件或数据。其中 File 对象可以是来自用户在一个&lt;input&gt;元素上选择文件后返回的 FileList 对象，也可以来自由拖放操作生成的 DataTransfer files对于 file 类型的 input 框，在这个 DOM 对象中，存在一个 files 属性，这个属性是 FileList 对象，是一个伪数组，里面存储着上传的所有文件，当 input 框指定了 multiple 属性之后，就可以上传多个文件了。 也就是说，通过 files 这个属性，我们就可以获取到所有上传的文件。 file 对象File 对象中包含了文件的最后修改时间、文件名、文件类型等信息。 FileReader 对象FileReader 是一个 HTML5 新增的对象，用于读取文件（必须通过 input:file 上传） var file = input.files[0]// 创建一个fileReader对象var fr = new FileReader// 读取文件的两个方法fr.readAsText(file) 以文本的方式读取文件 ,文本文件fr.readAsDataURL(file) 以DataURL形式读取文件，图片，视频// 文件读取完成事件：fr.onload = function()&#123; // 当文件读取完成，可以通过result属性获取结果 console.log(fr.result)&#125; 案例：图片预览 // 1. FileReader 是异步的var file = document.getElementById('file')var box = document.getElementById('box')file.addEventListener('change', function() &#123; console.dir(this) // file 中files 属性里面存储了所有上传的文件 // 这个data就是我们上传的那个文件 var data = file.files[0] // 1. 创建一个文件读取器 var fr = new FileReader() // 2. 让文件读取器读取整个文件 fr.readAsDataURL(data) // 3. 等待文件读取完 // onload：文件读取完成后，就会触发 fr.onload = function() &#123; // 通过 fr.result 就可以获取到最终的结果 var img = document.createElement('img') img.src = fr.result box.innerHTML = '' box.appendChild(img) &#125;&#125;) // 2. URL.createObjectURL(file) 缺点： 1. 试验中 2. 同步（阻塞）var file = document.getElementById('file')file.addEventListener('change', function() &#123; var data = this.files[0] var result = URL.createObjectURL(data) img.src = result&#125;)]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>html&amp;css</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fullpage 全屏网站插件]]></title>
    <url>%2F2018%2Fjquery%2Ffullpage%2F</url>
    <content type="text"><![CDATA[fullpagefullPage.js 是一个基于 jQuery 的插件，它能够很方便、很轻松的制作出全屏网站 参考文档 http://www.dowebok.com/77.html 下载地址 https://github.com/alvarotrigo/fullPage.js 基本使用 引入jQuery文件，因为fullpage是jquery插件 引入fullpage的js文件 页面结构 编写js代码 &lt;!-- 页面结构 --&gt;&lt;div id="box"&gt; &lt;!-- 每一个class为section的div都是一屏,section这个类是固定的 --&gt; &lt;div class="section"&gt;我是内容1&lt;/div&gt; &lt;div class="section"&gt;我是内容2&lt;/div&gt; &lt;div class="section"&gt;我是内容3&lt;/div&gt; &lt;div class="section"&gt;我是内容4&lt;/div&gt;&lt;/div&gt; // 编写js代码$(function () &#123; $('#box').fullpage()&#125;) 鼠标滚轮滚动事件window.addEventListener('mousewheel', function (e) &#123; console.log(e.wheelDelta) if (e.wheelDelta &gt; 0) &#123; console.log('往上滚了') &#125; else &#123; console.log('往下滚了') &#125; console.log('鼠标滚轮事件触发了')&#125;) 常用参数 属性名称 描述 sectionsColor 设置每一个section的背景颜色（为一个数组） controlArrows 定义是否使用箭头来控制幻灯片，默认true verticalCentered 设定每一个section的内容是否垂直居中，默认true， resize 设定字体是否随着窗口缩放而缩放，默认false，一般不修改 scrollingSpeed 设置滚动的速度，默认700毫秒 easing 设置动画的方式，默认是easeInOutCubic,如果想要修改此页，需要引入jquery.easing.js css3 是否使用css3 transform来实现滚动效果，默认true，不用修改，CSS3的动画效率比较js高。 loopTop 滚动到顶部后是否连续滚动到底部，默认false loopBottom 滚动到底部后是否连续滚动到顶部，默认false loopHorizontal 设置幻灯片是否循环滚动，默认true continuousVertical 是否循环滚动，默认为false，如果设置为true，则页面会循环滚动，不会出现loopTop与loopBottom那样的跳动。 autoScrolling 是否使用插件的滚动方式，默认true，如果选择false，会出现浏览器子代的滚动条，将不会按页滚动，按照滚动进行滚动。 scrollBar 是否包含滚动条，默认false，如果设置为true，那么浏览器自定的滚动条会出现，这个时候，页面滚动还是按页滚动，但是浏览器也能滚动。不建议开启，不然会不同步。 paddingTop/paddingBottom 给每一个section设置一个paddingTop或者paddingBottom,默认值为0，如果需要给页面设置一个固定定位的头部菜单或者底部菜单的时候，可以使用这两个选项。 keyboardScrolling 是否可以使用键盘方向键导航，默认true navigation 是否显示导航，默认为false，设置为true，会显示小圆点，作为导航 navigationPositon 导航小圆点的位置，设置left或者right，默认是right navigationTooltips 小圆点的提示信息，鼠标一上去能看到提示信息 showActiveTooltip 是否显示当前页面的导航的tooltip信息，默认是false slidesNavigation 是否显示横向幻灯片的导航，默认为false slidesNavPosition 设置横向幻灯片的位置，top或者bottom，默认bottom sectionSelector section的选择器，默认是.section slideSelector slide的选择器，默认是.slide 常用回调函数 方法名 描述 afterLoad(anchorLink, index) 滚动到某一个section,当滚动结束后，会触发一次这个回调函数，anchorLink是锚链接的名称，index从1开始计算 onLeave(index,nextIndex,diretion) 当我们离开一个section时，会触发这个函数，index是离开的页面的序号，从1开始计算。 nextIndex是滚动到的页面的序号，direction是往上还是往下滚动，值是up或者down. return false可以取消滚动 afterResize() 窗口大小发生改变后会触发的回调函数 afterSlideLoad(anchor,index, slideAnchor,slideIndex) 页面滚动到某一个幻灯片的时候会触发这个回调函数 afterSlideLeave(anchor,index,slideIndex, diretion,nextSlideIndex) 当离开某一个幻灯片的时候会触发一次这个回调函数。]]></content>
      <categories>
        <category>框架</category>
        <category>jquery</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码规范及配置 ESLint]]></title>
    <url>%2F2018%2Ftool%2F%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E5%8F%8A%E9%85%8D%E7%BD%AEESLint%2F</url>
    <content type="text"><![CDATA[编码规范 Airbnb JavaScript Style Guide Google JavaScript Style Guide JavaScript Standard Style Guide ESLint JavaScript 语句后应该加分号么？ Vue + ESLint + Prettier[vue 官方风格指南(https://cn.vuejs.org/v2/style-guide/)] 安装 nodehttps://nodejs.org/zh-cn/ 配置 ESlint$ npm install eslint -g$ npm install eslint-plugin-html -g$ eslint -v$ eslint --init# google 标准# $ npm install eslint-config-google -g# airbnb 标准# $ npm install eslint-config-airbnb eslint-plugin-jsx-a11y eslint-plugin-import eslint-plugin-react -g# standard 标准$ npm install eslint-plugin-standard eslint-config-standard eslint-plugin-node eslint-plugin-promise -g# vue$ npm install eslint-plugin-vue -g# es6 语法支持$ npm install babel-eslint vue-eslint-parser -g .eslintrc.json 文件 &#123; // plugin与extend的区别：extend提供的是eslint现有规则的一系列预设 // 而plugin则提供了除预设之外的自定义规则，当你在eslint的规则里找不到合适的的时候 "extends": ["google", "plugin: vue/essential"], "plugins": ["html"], "parserOptions": &#123; "sourceType": "module" &#125;, "rules": &#123; "valid-jsdoc": 2, "require-jsdoc": 0, "no-var": 0, "vars-on-top": 0, "eqeqeq": 2, "space-before-function-paren": [2, "always"], "semi": [2, "never"], "comma-dangle": [2, "never"], "linebreak-style": [2, "unix"], "no-invalid-this": 0, "max-len": 0, "prefer-const": 0, "arrow-parens": 0 &#125;&#125;&#123; "extends": ["standard", "plugin:vue/essential"], "plugins": ["html"], "parser": "vue-eslint-parser", "parserOptions": &#123; "parser": "babel-eslint", "ecmaVersion": 6, "sourceType": "module" &#125;, "env": &#123; "browser": true, "node": true &#125;, "rules": &#123; "no-new": 0, "no-undef": 0, "no-unused-vars": 1, "space-before-function-paren": [2, "always"] &#125;&#125; vscode 插件安装 ESLint vscode 配置 User Settings &#123; "javascript.validate.enable": false, "typescript.validate.enable": false, "eslint.nodePath": "C:\\Program Files\\nodejs\\node.exe", "eslint.options": &#123; "configFile": "C:/Users/C/.vscode/.eslintrc.json" &#125;, "eslint.alwaysShowStatus": true, "eslint.autoFixOnSave": true, "eslint.validate": ["javascript", "javascriptreact", &#123; "language": "html", "autoFix": true &#125;, &#123; "language": "vue", "autoFix": true &#125;]&#125; 配置 prettier$ npm install prettier -g$ npm install eslint-plugin-prettier -g vscode 插件安装 prettier vscode 配置 User Settings &#123; // 禁用默认html格式化 "html.format.enable": false, "prettier.semi": false, "prettier.singleQuote": true, "prettier.jsxSingleQuote": true, "prettier.eslintIntegration": true, "prettier.htmlWhitespaceSensitivity": "ignore", // 标签换行长度 "prettier.printWidth": 800, "prettier.bracketSpacing": true&#125; vuter &#123; "vetur.format.defaultFormatter.js": "none", // HTML Default Formatter "vetur.format.defaultFormatter.html": "prettyhtml" "vetur.format.defaultFormatterOptions": &#123; "prettyhtml": &#123; "printWidth": 1000, "singleQuote": false, "wrapAttributes": false, "sortAttributes": false &#125; &#125;&#125; ESLint 规则列表.eslintrc.json 规则值： &quot;off&quot;或者0 // 关闭规则关闭&quot;warn&quot;或者1 // 在打开的规则作为警告（不影响退出代码）&quot;error&quot;或者2 // 把规则作为一个错误（退出代码触发时为1 忽略检测警告 // 忽略检测下一行/* eslint-disable-next-line */// 忽略当前整个文件/* eslint-disable */// 忽略 no-new 规则/* eslint-disable no-new */ 规则列表 https://eslint.org/docs/rules/ "rules": &#123; "no-alert": 0,//禁止使用alert confirm prompt "no-array-constructor": 2,//禁止使用数组构造器 "no-bitwise": 0,//禁止使用按位运算符 "no-caller": 1,//禁止使用arguments.caller或arguments.callee "no-catch-shadow": 2,//禁止catch子句参数与外部作用域变量同名 "no-class-assign": 2,//禁止给类赋值 "no-cond-assign": 2,//禁止在条件表达式中使用赋值语句 "no-console": 2,//禁止使用console "no-const-assign": 2,//禁止修改const声明的变量 "no-constant-condition": 2,//禁止在条件中使用常量表达式 if(true) if(1) "no-continue": 0,//禁止使用continue "no-control-regex": 2,//禁止在正则表达式中使用控制字符 "no-debugger": 2,//禁止使用debugger "no-delete-var": 2,//不能对var声明的变量使用delete操作符 "no-div-regex": 1,//不能使用看起来像除法的正则表达式/=foo/ "no-dupe-keys": 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125; "no-dupe-args": 2,//函数参数不能重复 "no-duplicate-case": 2,//switch中的case标签不能重复 "no-else-return": 2,//如果if语句里面有return,后面不能跟else语句 "no-empty": 2,//块语句中的内容不能为空 "no-empty-character-class": 2,//正则表达式中的[]内容不能为空 "no-empty-label": 2,//禁止使用空label "no-eq-null": 2,//禁止对null使用==或!=运算符 "no-eval": 1,//禁止使用eval "no-ex-assign": 2,//禁止给catch语句中的异常参数赋值 "no-extend-native": 2,//禁止扩展native对象 "no-extra-bind": 2,//禁止不必要的函数绑定 "no-extra-boolean-cast": 2,//禁止不必要的bool转换 "no-extra-parens": 2,//禁止非必要的括号 "no-extra-semi": 2,//禁止多余的冒号 "no-fallthrough": 1,//禁止switch穿透 "no-floating-decimal": 2,//禁止省略浮点数中的0 .5 3. "no-func-assign": 2,//禁止重复的函数声明 "no-implicit-coercion": 1,//禁止隐式转换 "no-implied-eval": 2,//禁止使用隐式eval "no-inline-comments": 0,//禁止行内备注 "no-inner-declarations": [2, "functions"],//禁止在块语句中使用声明（变量或函数） "no-invalid-regexp": 2,//禁止无效的正则表达式 "no-invalid-this": 2,//禁止无效的this，只能用在构造器，类，对象字面量 "no-irregular-whitespace": 2,//不能有不规则的空格 "no-iterator": 2,//禁止使用__iterator__ 属性 "no-label-var": 2,//label名不能与var声明的变量名相同 "no-labels": 2,//禁止标签声明 "no-lone-blocks": 2,//禁止不必要的嵌套块 "no-lonely-if": 2,//禁止else语句内只有if语句 "no-loop-func": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） "no-mixed-requires": [0, false],//声明时不能混用声明类型 "no-mixed-spaces-and-tabs": [2, false],//禁止混用tab和空格 "linebreak-style": [0, "windows"],//换行风格 "no-multi-spaces": 1,//不能用多余的空格 "no-multi-str": 2,//字符串不能用\换行 "no-multiple-empty-lines": [1, &#123;"max": 2&#125;],//空行最多不能超过2行 "no-native-reassign": 2,//不能重写native对象 "no-negated-in-lhs": 2,//in 操作符的左边不能有! "no-nested-ternary": 0,//禁止使用嵌套的三目运算 "no-new": 1,//禁止在使用new构造一个实例后不赋值 "no-new-func": 1,//禁止使用new Function "no-new-object": 2,//禁止使用new Object() "no-new-require": 2,//禁止使用new require "no-new-wrappers": 2,//禁止使用new创建包装实例，new String new Boolean new Number "no-obj-calls": 2,//不能调用内置的全局对象，比如Math() JSON() "no-octal": 2,//禁止使用八进制数字 "no-octal-escape": 2,//禁止使用八进制转义序列 "no-param-reassign": 2,//禁止给参数重新赋值 "no-path-concat": 0,//node中不能使用__dirname或__filename做路径拼接 "no-plusplus": 0,//禁止使用++，-- "no-process-env": 0,//禁止使用process.env "no-process-exit": 0,//禁止使用process.exit() "no-proto": 2,//禁止使用__proto__属性 "no-redeclare": 2,//禁止重复声明变量 "no-regex-spaces": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/ "no-restricted-modules": 0,//如果禁用了指定模块，使用就会报错 "no-return-assign": 1,//return 语句中不能有赋值表达式 "no-script-url": 0,//禁止使用javascript:void(0) "no-self-compare": 2,//不能比较自身 "no-sequences": 0,//禁止使用逗号运算符 "no-shadow": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 "no-shadow-restricted-names": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用 "no-spaced-func": 2,//函数调用时 函数名与()之间不能有空格 "no-sparse-arrays": 2,//禁止稀疏数组， [1,,2] "no-sync": 0,//nodejs 禁止同步方法 "no-ternary": 0,//禁止使用三目运算符 "no-trailing-spaces": 1,//一行结束后面不要有空格 "no-this-before-super": 0,//在调用super()之前不能使用this或super "no-throw-literal": 2,//禁止抛出字面量错误 throw "error"; "no-undef": 1,//不能有未定义的变量 "no-undef-init": 2,//变量初始化时不能直接给它赋值为undefined "no-undefined": 2,//不能使用undefined "no-unexpected-multiline": 2,//避免多行表达式 "no-underscore-dangle": 1,//标识符不能以_开头或结尾 "no-unneeded-ternary": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false; "no-unreachable": 2,//不能有无法执行的代码 "no-unused-expressions": 2,//禁止无用的表达式 "no-unused-vars": [2, &#123;"vars": "all", "args": "after-used"&#125;],//不能有声明后未被使用的变量或参数 "no-use-before-define": 2,//未定义前不能使用 "no-useless-call": 2,//禁止不必要的call和apply "no-void": 2,//禁用void操作符 "no-var": 0,//禁用var，用let和const代替 "no-warning-comments": [1, &#123; "terms": ["todo", "fixme", "xxx"], "location": "start" &#125;],//不能有警告备注 "no-with": 2,//禁用with "array-bracket-spacing": [2, "never"],//是否允许非空数组里面有多余的空格 "arrow-parens": 0,//箭头函数用小括号括起来 "arrow-spacing": 0,//=&gt;的前/后括号 "accessor-pairs": 0,//在对象中使用getter/setter "block-scoped-var": 0,//块语句中使用var "brace-style": [1, "1tbs"],//大括号风格 "callback-return": 1,//避免多次调用回调什么的 "camelcase": 2,//强制驼峰法命名 "comma-dangle": [2, "never"],//对象字面量项尾不能有逗号 "comma-spacing": 0,//逗号前后的空格 "comma-style": [2, "last"],//逗号风格，换行时在行首还是行尾 "complexity": [0, 11],//循环复杂度 "computed-property-spacing": [0, "never"],//是否允许计算后的键名什么的 "consistent-return": 0,//return 后面是否允许省略 "consistent-this": [2, "that"],//this别名 "constructor-super": 0,//非派生类不能调用super，派生类必须调用super "curly": [2, "all"],//必须使用 if()&#123;&#125; 中的&#123;&#125; "default-case": 2,//switch语句最后必须有default "dot-location": 0,//对象访问符的位置，换行的时候在行首还是行尾 "dot-notation": [0, &#123; "allowKeywords": true &#125;],//避免不必要的方括号 "eol-last": 0,//文件以单一的换行符结束 "eqeqeq": 2,//必须使用全等 "func-names": 0,//函数表达式必须有名字 "func-style": [0, "declaration"],//函数风格，规定只能使用函数声明/函数表达式 "generator-star-spacing": 0,//生成器函数*的前后空格 "guard-for-in": 0,//for in循环要用if语句过滤 "handle-callback-err": 0,//nodejs 处理错误 "id-length": 0,//变量名长度 "indent": [2, 4],//缩进风格 "init-declarations": 0,//声明时必须赋初值 "key-spacing": [0, &#123; "beforeColon": false, "afterColon": true &#125;],//对象字面量中冒号的前后空格 "lines-around-comment": 0,//行前/行后备注 "max-depth": [0, 4],//嵌套块深度 "max-len": [0, 80, 4],//字符串最大长度 "max-nested-callbacks": [0, 2],//回调嵌套深度 "max-params": [0, 3],//函数最多只能有3个参数 "max-statements": [0, 10],//函数内最多有几个声明 "new-cap": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 "new-parens": 2,//new时必须加小括号 "newline-after-var": 2,//变量声明后是否需要空一行 "object-curly-spacing": [0, "never"],//大括号内是否允许不必要的空格 "object-shorthand": 0,//强制对象字面量缩写语法 "one-var": 1,//连续声明 "operator-assignment": [0, "always"],//赋值运算符 += -=什么的 "operator-linebreak": [2, "after"],//换行时运算符在行尾还是行首 "padded-blocks": 0,//块语句内行首行尾是否要空行 "prefer-const": 0,//首选const "prefer-spread": 0,//首选展开运算 "prefer-reflect": 0,//首选Reflect的方法 "quotes": [1, "single"],//引号类型 `` "" '' "quote-props":[2, "always"],//对象字面量中的属性名是否强制双引号 "radix": 2,//parseInt必须指定第二个参数 "id-match": 0,//命名检测 "require-yield": 0,//生成器函数必须有yield "semi": [2, "always"],//语句强制分号结尾 "semi-spacing": [0, &#123;"before": false, "after": true&#125;],//分号前后空格 "sort-vars": 0,//变量声明时排序 "space-after-keywords": [0, "always"],//关键字后面是否要空一格 "space-before-blocks": [0, "always"],//不以新行开始的块&#123;前面要不要有空格 "space-before-function-paren": [0, "always"],//函数定义时括号前面要不要有空格 "space-in-parens": [0, "never"],//小括号里面要不要有空格 "space-infix-ops": 0,//中缀操作符周围要不要有空格 "space-return-throw-case": 2,//return throw case后面要不要加空格 "space-unary-ops": [0, &#123; "words": true, "nonwords": false &#125;],//一元运算符的前/后要不要加空格 "spaced-comment": 0,//注释风格要不要有空格什么的 "strict": 2,//使用严格模式 "use-isnan": 2,//禁止比较时使用NaN，只能用isNaN() "valid-jsdoc": 0,//jsdoc规则 "valid-typeof": 2,//必须使用合法的typeof的值 "vars-on-top": 2,//var必须放在作用域顶部 "wrap-iife": [2, "inside"],//立即执行函数表达式的小括号风格 "wrap-regex": 0,//正则表达式字面量用小括号包起来 "yoda": [2, "never"]//禁止尤达条件&#125;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>esLint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历总结]]></title>
    <url>%2F2018%2Fother%2F%E9%81%8D%E5%8E%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[原生 js 中 for 语句 循环 、遍历数组 // 语法： // 1. for循环使用分号分隔 // 2. for循环有2个分号，两个分号不能少for (初始化语句; 判断语句; 自增语句) &#123; // 循环体&#125;// 普通循环for (var i = 1; i&lt;=5; i++) &#123; console.log(i);&#125;// 遍历数组for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125;// 遍历函数的参数(arguments) for (var i = 0; i &lt; arguments.length; i++) &#123; &#125; 原生 js 中数组的 forEach 方法 遍历数组 // 语法array.forEach (function(item, index, arr), thisArg)// item 必需。数组中正在处理的当前元素// index 可选。数组中正在处理的当前元素的索引// arr 可选。forEach()方法正在操作的数组，就是当前数组// thisArg 可选。当执行回调函数时用作this的值var arr = ["zs", "ls", "ww"];arr.forEach (function(item, index, arr) &#123; console.log(item); console.log(this);&#125;)// 返回值: undefined// 不支持 return 操作输出，return 只用于控制循环是否跳出当前循环 原生 js 中 for…in 语句 遍历对象 // 语法：for (var key in obj) &#123; console.log(key); // 键 console.log(obj[key]); // 值 console.log(key + "==" + obj[key]);&#125;// in 操作符：判断对象能否访问到该属性（不管这个属性是自己提供的，还是从原型上继承来的），如果可以访问到， 都会返回 true// console.log("name" in obj) 返回布尔值if ("name" in obj) &#123; console.log('是');&#125; jquery 中的 each 方法 遍历 jQuery 对象集合，为每个匹配的元素执行一个函数 // 语法：$(selector).each(function(index,element)&#123; // index 表示当前元素在所有匹配元素中的索引号 // element 表示当前元素 dom对象 // this 在函数内部，this指向了element&#125;);$("li").each(function(index, ele)&#123; // $(ele).css("backgroundColor", arr[index]); $(this).css("backgroundColor", arr[index]);&#125;); php 中 foreach 语句 用来遍历数组(关联数组和索引数组均可)。 // 语法foreach($arr as $key =&gt; $value)&#123; // $arr: 要遍历的数组 // $key: 键，可以是任意变量名 // $value: 值，可以是任意变量名&#125;foreach($arr as $value)&#123;&#125; // 遍历关联数组$arr = array( "name"=&gt;"zs", "age"=&gt;18, "sex"=&gt;20);foreach($arr as $k =&gt; $v) &#123; echo $k . "=" . $v . "&lt;br&gt;";&#125;]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ajax 笔记]]></title>
    <url>%2F2018%2Fjavascript%2Fajax%2F</url>
    <content type="text"><![CDATA[前言我们使用 php 动态渲染页面时，有很多比较麻烦的地方。 在前端写好页面以后，需要后台进行修改，意味这后端程序员也需要懂前端的知识，其实渲染的工作应该交给前端来做。 前端没有写好页面的话，后端无法开始工作，需要等待前端的页面完成之后才能开始工作，拖延项目的进度。 这种渲染，属于同步渲染，先获取数据, 如果数据获取的慢了, 会严重影响整个页面渲染速度, 且数据更新需要页面刷新 AJAX 即 Asynchronous [e’sɪŋkrənəs] Javascript And XML， AJAX 不是一门新的语言，而是对现有技术的综合利用。 本质是在HTTP协议的基础上以异步的方式与服务器进行通信 同步与异步同步和异步概念： 同步：指的就是事情要一件一件做。等做完前一件才能做后一件任务 异步：不受当前任务的影响，两件事情同时进行，做一件事情时，不影响另一件事情的进行 编程中：异步程序代码执行时不会阻塞其它程序代码执行，从而提升整体执行效率 网页异步应用： 验证你的用户名是否已经存在（一边输入，一边获取你的信息，和后台比对）。 百度搜索提示，及相关内容展示（一边输入，一边找出了你可能要的内容）。 新浪微博评论（异步加载）。 XMLHttpRequest 可以以异步方式的请求数据处理程序, 可实现对网页的部分更新， 而不是刷新整个页面 XMLHttpRequest 对象 浏览器内建对象，用于与服务器通信(交换数据) ， 由此我们便可实现对网页的部分更新，而不是刷新整个页面。这个请求是异步的，即在往服务器发送请求时，并不会阻碍程序的运行，浏览器会继续渲染后续的结构。 发送 get 请求XMLHttpRequest 以异步的方式发送 HTTP 请求，因此在发送请求时，一样需要遵循 HTTP 协议。 使用 XMLHttpRequest 发送 get 请求的步骤 // 1. 创建一个 XMLHttpRequest 对象var xhr = new XMLHttpRequest();// 2. 设置请求行// 第一个参数:请求方式 get/post// 第二个参数:请求的地址 需要在url后面拼上参数列表// 第三个参数：true 为异步，false为同步，默认为true，设为false没有意义xhr.open("get", "01.php?name=zs");// 3. 设置请求头(get不用设置)// 请求头中可以设置 Content-Type,用以说明请求主体的内容是如何编码// get 请求时没有请求体,无需设置请求头// 4. 设置请求体// get 请求的请求体为空,因为参数列表拼接到 url 后面了xhr.send(null); // 参数为 null 或什么都不写 注意点 : get 请求，设置请求行时，需要把参数列表拼接到 url 后面 get 请求不用设置请求头，不用说明请求主体的编码方式 get 请求的请求体为 null 发送 post 请求// 1. 创建一个 XMLHttpRequest 对象var xhr = new XMLHttpRequest();// 2. 设置请求行 post请求的参数列表在请求体xhr.open("post", "02.php");// 3. 设置请求头, post 请求必须要设置 content-type, 标记请求体内容的解析方式// 如果不设置请求头,请求能够发送出去，但是后端无法解析获取数据xhr.setRequestHeader( "content-type", "application/x-www-form-urlencoded" );// 4. 设置请求体xhr.send( "name=Jepson&amp;age=18" ); 注意点 : post 请求，设置请求行时，不拼接参数列表 post 必须设置请求头中的 content-type 为 application/x-www-form-urlencoded， 标记请求体解析方式 post 请求需要将参数列表设置到请求体中 获取响应 readyStatereadyState：记录了 XMLHttpRequest 对象的当前状态 readyState 有五种可能的值： xhr.readyState = 0时，UNSENT open尚未调用 xhr.readyState = 1时，OPENED open已调用 xhr.readyState = 2时，HEADERS_RECEIVED 接收到头信息 xhr.readyState = 3时，LOADING 接收到响应主体 xhr.readyState = 4 时，DONE 响应完成 HTTP 响应分为 3 个部分，状态行、响应头、响应体。 // 给xhr注册一个 onreadystatechange 事件，当 xhr 的状态发生状态发生改变时，会触发这个事件。// onreadystatechange 只会监听 2， 3， 4 的状态变化xhr.onreadystatechange = function () &#123; console.log(xhr.readyState); if(xhr.readyState == 4)&#123; //1. 获取状态行 console.log("状态行:"+xhr.status); // 成功返回 200 if(xhr.status == 200) &#123; //2. 获取响应头 console.log("所有的响应头:"+xhr.getAllResponseHeaders()); console.log("指定响应头:"+xhr.getResponseHeader("content-type")); //3. 获取响应体 console.log(xhr.responseText); &#125; &#125;&#125; 案例【判断用户名是否存在】 【用户登录案例】 【聊天机器人案例】 数据交互 浏览器端只是负责用户的交互和数据的收集以及展示，真正的数据都是存储在服务器端的。 我们现在通过 ajax 的确可以返回一些简单的数据（一个字符串），但是在实际开发过程中，肯定会会设计到大量的复杂类型的数据传输，比如数组、对象等，但是每个编程语言的语法都不一样。 因此我们会采用通过的数据交换格式（ XML 、JSON ）来进行数据的交互。 XML(了解即可)什么是XML XML 指可扩展标记语言（EXtensible Markup Language） XML 是一种标记语言，很类似 HTML XML 的设计宗旨是传输数据，而非显示数据 XML 标签没有被预定义。您需要自行定义标签。 语法规范 第一行必须是版本信息 必须有一个根元素（有且仅有一个） 标签不可有空格、不可以数字或 . 开头、大小写敏感 不可交叉嵌套，都是双标签，如果是单标签，必须闭合 属性双引号（浏览器自动修正成双引号了） 特殊符号要使用实体 注释和HTML一样 &lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;students&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;desc&gt;路人甲&lt;/desc&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;desc&gt;路人乙&lt;/desc&gt; &lt;/student&gt;&lt;/students&gt; php 获取 xml 文件的内容 // 注意: 如果需要返回 xml 数据, 需要将 content-type 改成 text/xml, 不然浏览器以 text/html 解析header( 'content-type:text/xml;charset=utf-8' );// file_get_content 用于获取文件的内容// 参数: 文件的路径$result = file_get_content( "data.xml" );echo $result; js 解析 xml // 获取服务端返回的 xml 数据，需要使用 xhr.responseXML，这是一个 document 对象，可以使用 DOM 中的方法查找元素。var data = xhr.responseXML;// 获取所有的学生var students = data.querySelectorAll("student"); 缺点：虽然可以描述和传输复杂数据，但是其解析过于复杂, 并且体积较大，所以实现开发已经很少使用了。 JSON 数据JSON (JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript 规范，采用独立于编程语言的文本格式来存储和表示数据。 数据在键值对中 数据由逗号分隔(最后一个 键值对不能带逗号) 花括号保存对象，方括号保存数组 键和值使用双引号 var obj = &#123;a: 'Hello', b: 'World'&#125;; // 这是一个对象// 这是一个 JSON 字符串，本质是一个字符串var json = '&#123;"a": "Hello", "b": "World"&#125;'; JSON 数据在不同语言进行传输时，类型为字符串，不同的语言各自也都对应有解析方法，解析完成后就能很方便的使用了 php 处理 json php关联数组 ==&gt; json ( json_encode ) // php的关联数组$obj = array( "a" =&gt; "hello", "b" =&gt; "world", "name" =&gt; "鹏鹏");// json字符串$json = json_encode( $obj );echo $json; json ==&gt; php对象/关联数组 ( json_decode ) $json = '&#123;"a": "Hello", "b": "World"&#125;'; // json字符串// 第一个参数：json字符串// 第二个参数：// false，将json转换成对象(默认)// true：将json转换成数组(推荐)$obj = json_decode($json,true);echo $obj['a'];// 通过json文件获取到的内容就是一个json字符串。$data = file_get_contents("data.json");// 将json转换成数组$result = json_decode($data, true);print_r($result); JS 处理 json JSON.stringify(obj) ：JS对象 ==&gt; JSON字符串 var obj = &#123;a: 'Hello', b: 'World'&#125;var result = JSON.stringify(obj); // '&#123;"a": "Hello", "b": "World"&#125;' JSON.parse(obj) ：JSON字符串 ==&gt; JS对象 var json = '&#123;"a": "Hello", "b": "World"&#125;';var obj = JSON.parse(json); // &#123;a: 'Hello', b: 'World'&#125; 【案例：获取表格数据.html】 兼容性处理 (了解, 不用处理)现在一般最多兼容到 IE8, 这里以后见到了知道是在处理兼容性就行了 var xhr = null;if(XMLHttpRequest)&#123; //现代浏览器 IE7+ xhr = new XMLHttpRequest();&#125;else&#123; //老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象： xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");&#125; 封装 ajax 工具函数 每次发送ajax请求，其实步骤都是一样的，重复了大量代码，我们完全可以封装成一个工具函数。 //1. 创建xhr对象//2. 设置请求行//3. 设置请求头//3. 设置请求体//4. 监听响应状态//5. 获取响应内容 参数提取 参数名 参数类型 描述 传值 默认值 type string 请求方式 get/post 只要不传post，就是get url string 请求地址 接口地址 如果不传地址，不发送请求 async boolean 是否异步 true/fase 只要不传false，那就是true，异步请求 data object 请求数据 {key:value,key1:value2} 需要把这个对象拼接成参数的格式 uname=hucc&amp;upass=12345 dataType string 返回的数据类型 xml/json/text text success function 响应成功时调用 - - error function 响应失败时调用 - - 参数检测// 要求参数obj必须传递，否则直接不发送请求if(!obj || typeof obj !== "object")&#123; return;&#125;// 如果type传递的是post，那就发送post请求，否则发送get请求var type = obj.type == "post"?"post":'get';var url = obj.url;if(!url)&#123; return;&#125;// 只有当async传递了false，才会发送同步请求，不然只发送异步请求var async = obj.async == false? false:true; 完整版本var $ = &#123; ajax: function (options) &#123; // 如果options参数没有传递，直接返回。 if (!options || typeof options !== "object") &#123; return; &#125; // 处理默认参数 // 如果参数不是post，那就默认为get var type = options.type === "post" ? "post" : "get"; // 如果没有传url，直接返回 var url = option.url; if(!url) &#123; return; &#125; // 如果参数不是false，那就默认是true，发异步请求 var async = options.async == false ? false : true; // 把option.data对象中的数据拼接成键值对的字符串 var data = this.getData(options.data); var xhr = new XMLHttpRequest(); // 设置请求行 // 如果是get请求，并且要上传参数，需要把参数拼接到url后面 if (type === "get") &#123; url += "?" + data; data = null; &#125; xhr.open(type, url, async); // 设置请求头 if (type === "post") &#123; xhr.setRequestHeader("content-type", "application/x-www-form-urlencoded"); &#125; // 设置请求参数 xhr.send(data); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; //判断一下,如果dataType的值是json,就转成js对象.如果是xml,就返回dom对象,其他都是普通文本 if(options.dateType === "json") &#123; var result = JSON.parse(xhr.responseText); &#125; else if(option.dataType === "xml") &#123; var result = xhr.responseXML; &#125; else &#123; var result = xhr.responseText; &#125; /*执行成功函数*/ options.success &amp;&amp; options.success(result); &#125; else &#123; options.error &amp;&amp; options.error(); &#125; &#125; &#125; &#125;, getData: function (obj) &#123; // 将obj对象转换成参数 // 将对象转换成参数列表 if (!obj || typeof obj !== "object") &#123; return null; &#125; var arr = []; for (var k in obj) &#123; arr.push(k + "=" + obj[k]); &#125; return arr.join("&amp;"); &#125;&#125; 【登录案例】 jQuery 中的 ajax方法 jQuery为我们提供了更强大的Ajax封装 $.ajax参数列表 参数名称 描述 取值 示例 url 接口地址 url:”02.php” type 请求方式 get/post type:”get” timeout 超时时间 单位毫秒 timeout:5000 dataType 服务器返回的格式 json/xml/text(默认) dataType:”json” data 发送的请求数据 对象 data:{name:”zs”, age:18} beforeSend 调用前的回调函数 function(){} beforeSend:function(){ alert(1) } success 成功的回调函数 function (data) {} success:function (data) {} error 失败的回调函数 function (error) {} error:function(data) {} complete 完成后的回调函数 function () {} complete:function () {} 使用示例： $.ajax(&#123; type:"get", // 请求类型 url:"02.php", // 请求地址 data:&#123;name:"zs", age:18&#125;, // 请求数据 dataType:"json", // 希望接受的数据类型 timeout:5000, // 设置超时时间 beforeSend:function () &#123; // alert("发送前调用"); // jq的ajax方法中beforeSend函数中如果执行了return false,那么请求就不发送了 &#125;, success:function (res) &#123; // 如果有 dataType:"json"，或后台有header(content-type: text/json)，res就是已经转换好的js对象 // alert("成功时调用"); console.log(data); &#125;, error:function (error) &#123; // alert("失败时调用"); console.log(error); &#125;, complete:function () &#123; // alert("请求完成时调用"); // 不管成功失败都会执行 &#125;&#125;); 【案例：登录案例.html】 接口化开发请求地址即所谓的接口，通常我们所说的接口化开发，其实是指一个接口对应一个功能， 并且严格约束了请求参数 和响应结果 的格式，这样前后端在开发过程中，可以减少不必要的讨论， 从而并行开发，可以极大的提升开发效率，另外一个好处，当网站进行改版后，服务端接口进行调整时，并不影响到前端的功能。 获取短信验证码【案例：register】 需求文档(产品) 总需求：点击获取验证码按钮，向服务端发送请求, 调用服务器端短信接口, 服务器端根据传参, 调用第三方短信接口, 给手机发送验证码需求1：格式校验(1) 手机号码不能为空 如果为空提示"手机号不能为空"(2) 手机号码格式必须正确, 提示"请输入正确的手机号码"需求2：点击发送时，按钮显示为"发送中",并且不能重复提交请求需求3：根据不同的响应结果，进行响应。(1)如果接口调用成功 如果响应代码为100，倒计时 如果响应代码为101，提示手机号重复(2)如果接口调用失败，告诉用户"服务器繁忙，请稍候再试" 接口文档 接口说明：获取短信验证码接口地址：getCode.php请求方式：get接口传参：mobile 手机号返回类型 json接口返回：&#123; "code":"101", "msg":"手机号码存在", "mobile":"18511249258" &#125;参数说明: code 当前业务逻辑的处理成功失败的标识 100:成功 101:手机号码存在 msg 当前系统返回给前端提示 mobile 当前的手机号码 注册接口【案例：register】 表单序列化 serialize jquery提供了一个serialize()方法序列化表单，说白就是将表单中带有name属性的所有参数拼成一个格式为name=value&amp;name1=value1这样的字符串。方便我们获取表单的数据。 // serialize 方法将表单参数序列化成一个字符串。必须指定 name 属性// name=pp&amp;pass=123456&amp;repass=123456&amp;mobile=15751776629&amp;code=1234$('form').serialize(); jquery的ajax方法，data参数能够直接识别表单序列化的数据 $.post(&#123; url:"register.php", data:$('form').serialize(), dataType:'json', success:function (info) &#123; console.log(info); &#125;&#125;); 需求文档 注册功能总需求：点击注册按钮，向服务端发送请求需求1:表单校验 1.1 用户名不能为空，否则提示"请输入用户名" 1.2 密码不能为空，否则提示"请输入密码" 1.3 确认密码必须与密码一直，否则提示"确认密码与密码不一致" 1.4 手机号码不能为空，否则提示"请输入手机号码"; 1.5 手机号码格式必须正确，否则提示"手机号格式错误" 1.6 短信验证码必须是4位的数字，否则提示"验证码格式错误"需求2：点击注册按钮时，按钮显示为"注册中...",并且不能重复提交请求需求3：根据不同响应结果，处理响应 3.1 接口调用成功 100 提示用户注册成功，3s后跳转到首页 101 提示用户"用户名已经存在" 102 提示用户"验证码错误" 3.2 接口调用失败，提示"服务器繁忙，请稍后再试",恢复按钮的值 接口文档 接口说明：注册接口地址：register.php请求方式：post接口传参：name:用户名 pass:密码 code:验证码 mobile:手机号返回类型 json接口返回：&#123; "code":"100", "msg":"注册成功", "name":"Jepson" &#125;参数说明: code 当前业务逻辑的处理成功失败的标识 100:成功 101:用户存在 102:验证码错误 msg 当前系统返回给前端提示 name: 注册的用户名 模板引擎 是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。 为什么要使用模板引擎我们通过ajax获取到数据后，需要把数据渲染到页面，在学习模板引擎前，我们的做法是大量的拼接字符串，对于结构简单的页面，这么做还行 ，但是如果页面结构很复杂，使用拼串的话代码可阅读性非常的差，而且非常容易出错，后期代码维护也是相当的麻烦。 总结来说拼串渲染两大缺点： js中大量充斥着 html 结构拼串代码， 很冗余， 可读性差 字符串拼接很麻烦， 且维护起来也很麻烦， 容易出错 常见的模板引擎BaiduTemplate：http://tangram.baidu.com/BaiduTemplate/velocity.js：https://github.com/shepherdwind/velocity.js/ArtTemplate：https://github.com/aui/artTemplate artTemplate是使用最广泛，效率最高的模板引擎，需要大家掌握。 artTemplategithub地址 中文api地址 artTemplate 的基本使用1. 引入模板引擎的 js文件 &lt;script src="template-web.js"&gt;&lt;/script&gt; 2. 准备模板 &lt;!-- 指定了type为text/html后，这一段script标签并不会解析，也不会显示。--&gt;&lt;script type="text/html" id="myTmp"&gt; &lt;p&gt;姓名：隔壁老王&lt;/p&gt; &lt;p&gt;年龄：18&lt;/p&gt; &lt;p&gt;技能：查水表&lt;/p&gt; &lt;p&gt;描述：年轻力气壮&lt;/p&gt;&lt;/script&gt; 3. 准备数据 //3. 准备数据,数据是后台获取的，可以随时变化var json = &#123; userName:"隔壁老王", age:18, skill:"查水表", desc:"年轻气壮"&#125; 4. 将模板与数据进行绑定 //第一个参数：模板的id//第二个参数：数据//返回值：根据模板生成的字符串。var html = template("myTmp", json);console.log(html); 5. 修改模板 &lt;script type="text/html" id="myTmp"&gt; &lt;p&gt;姓名：&#123;&#123;userName&#125;&#125;&lt;/p&gt; &lt;p&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/p&gt; &lt;p&gt;技能：&#123;&#123;skill&#125;&#125;&lt;/p&gt; &lt;p&gt;描述：&#123;&#123;desc&#125;&#125;&lt;/p&gt;&lt;/script&gt; 6. 将数据显示到页面 var div = document.querySelector("div");div.innerHTML = html; artTemplate 标准语法if 语法 &#123;&#123;if gender='男'&#125;&#125; &lt;div class="man"&gt;&#123;&#123;else&#125;&#125; &lt;div class="woman"&gt;&#123;&#123;/if&#125;&#125; each 语法 &lt;!-- 1. &#123;&#123;each data&#125;&#125; 可以通过$value 和 $index获取值和下标 2. &#123;&#123;each data v i&#125;&#125; 自己指定值为v，下标为i--&gt;&#123;&#123;each data v i&#125;&#125;&lt;li&gt; &lt;a href="&#123;&#123;v.url&#125;&#125;"&gt; &lt;img src="&#123;&#123;v.src&#125;&#125;" alt=""&gt; &lt;p&gt;&#123;&#123;v.content&#125;&#125;&lt;/p&gt; &lt;/a&gt; &lt;/li&gt;&#123;&#123;/each&#125;&#125; //如果返回的数据是个数组，必须使用对象进行包裹，因为在&#123;&#123;&#125;&#125;中只写书写对象的属性。var html = template("navTmp", &#123;data:info&#125;); 瀑布流案例封装jQuery瀑布流插件// 特点分析：// 1. 跟以前将的瀑布流不一样的是，这次的瀑布流固定版心为1200px// 2. 瀑布流固定摆放5列，每一列的宽度固定为232px。// 思路分析：// 1. 计算每一列之间的缝隙// 2. 初始化一个数组，用户存储每一列的高度 [0,0,0,0,0]// 3. 查找数组的最小列，每次都把图片定位到最小列的位置// 4. 更新数组最小列的高度（加上定位过来的图片的高度） 代码参考： $.fn.waterfall = function () &#123; var $box = $(this); var $item = $box.children(); var boxWidth = $box.width();//父盒子的宽度 var itemWidth = 232;//每个盒子固定宽度为232 var columns = 5;//固定摆放5列 var gap = (boxWidth - columns * itemWidth) / (columns - 1);//缝隙的宽度 10 var arr = [0, 0, 0, 0, 0]; //初始化数组 $item.each(function () &#123; //查找最小列 var min = arr[0]; var minIndex = 0; for (var i = 0; i &lt; arr.length; i++) &#123; if (min &gt; arr[i]) &#123; min = arr[i]; minIndex = i; &#125; &#125; //设置位置 $(this).css(&#123; left: minIndex * (itemWidth + gap), top: min &#125;); //更新数组 arr[minIndex] = min + $(this).outerHeight() + gap; &#125;);&#125; 瀑布流完整版// 需求分析：// 1. 页面刚开始，没有任何一张图片。因此需要从通过ajax获取图片// 2. 使用模版引擎将获取到的数据渲染到页面// 3. 因为图片路径是从服务端获取的，加载需要时间，需要等待图片加载完成后才能使用瀑布流进行布局。// 4. 给window注册scroll事件，当触底时，需要动态的加载图片。// 5. 加载时，显示加载中的提示信息，并且要求不能重复发送ajax请求// 6. 当服务端返回图片数量为0时，提示用户没有更多数据。 同源与跨域同源同源策略的基本概念 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。同源策略：最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓”同源”指的是”三个相同”：协议相同、域名相同、端口相同 同源策略的目的 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 同源策略的限制范围 随着互联网的发展，“同源策略”越来越严格，目前，如果非同源，以下三种行为都将收到限制。 Cookie、LocalStorage 和 IndexDB 无法读取 DOM 无法获得 AJAX 请求响应被拦截 虽然这些限制是很有必要的，但是也给我们日常开发带来不好的影响。比如实际开发过程中，往往都会把服务器端架设到一台甚至是一个集群的服务器中，把客户端页面放到另外一个单独的服务器。那么这时候就会出现不同源的情况，如果我们知道两个网站都是安全的话，我们是希望两个不同源的网站之间可以相互请求数据的。这就需要使用到 跨域 。 跨域jsonp( 无兼容性问题 ) JSONP(JSON with Padding) 可用于解决主流浏览器的跨域数据访问的问题。 原理：服务端返回一个定义好的 js 函数的调用，并且将服务器的数据以该函数参数的形式传递过来，这个方法需要前后端配合 script 标签是不受同源策略的限制的，它可以载入任意地方的 JavaScript 文件。类似的还有img和link标签 jsonp 演化过程1php 文件 header("content-type:text/html;charset=utf-8");echo "alert(1111)"; html 文件 &lt;script src="http://www.api.com/testjs.php"&gt;&lt;/script&gt; 原理：其实src的路径是什么文件不重要，无论引入js文件还是php文件，最后返回给浏览器的都是字符串，因此我们script标签是可以引入一个php文件的。 jsonp 演化过程2php 文件 header("content-type:text/html;charset=utf-8");echo "var a = 118;"; html 文件 &lt;script src="http://www.api.com/testjs.php"&gt;&lt;/script&gt;&lt;script&gt; // a打印出来了118 console.log(a)&lt;/script&gt; 我们现在做到了一件事情，从不同源的php文件中获取到了数据 缺点：获取数据的 script 标签必须写在使用的 script 标签的前面，必须保证先有数据才能对数据进行渲染。 jsonp 演化过程3php 代码 header("content-type:text/html;charset=utf-8");$arr = array( "name"=&gt;"zs", "age"=&gt;18);$result = json_encode($arr);// 这是一段js函数的调用的代码，$result就是我们想要的数据echo "func($result)"; js 代码 &lt;script&gt; function func(data) &#123; console.log(data) &#125;&lt;/script&gt;&lt;script src="http://www.api.com/testjs.php"&gt;&lt;/script&gt; 缺点：后端必须知道前端声明的方法的名字，后端才能调用。 jsonp 演化过程4php代码 header("content-type:text/html;charset=utf-8");$arr = array( "name"=&gt;"zs", "age"=&gt;18);$result = json_encode($arr);// 这是一 段js函数的调用的代码，$result就是我们想要的数据echo $_GET['callback']."($result)"; javascript代码 function fun(data) &#123; console.log(data)&#125;var button = document.querySelector('button')button.onclick = function () &#123; var script = document.createElement('script') script.src = 'http://www.api.com/testjs.php?callback=fun' document.body.appendChild(script)&#125; jsonp 的原理就是 借助 script 标签 src 请求资源时，不受同源策略的限制 在服务端返回一个函数的调用，将数据作为当前调用函数的实参 在浏览器端，声明一个全局函数，通过形参就可以获取到服务端返回的对应的值 jquery 对于 jsonp 的封装!&gt; jsonp 仅支持 get 请求 // 使用起来相当的简单，跟普通的get请求没有任何的区别，只需要把 dataType 固定成 jsonp 即可$.ajax(&#123; type: 'get', url: 'http://www.Jepson.com/testjs.php', dataType: 'jsonp', data:&#123; uname: 'zs', upass: '123456' &#125;, success:function (info) &#123; console.log(info) &#125;&#125;) XMLHttpRequest2.0 XMLHttpRequest 是一个 javascript 内置对象，使得 Javascript 可以进行异步的HTTP通信。2008年2月，就提出了XMLHttpRequest Level 2 草案。 老版本的XMLHttpRequest的缺点： 仅支持传输文本数据，无法传输二进制文件，比如图片视频等。 传输数据时，没有进度信息，只能提示完成与否。 受到了”同源策略”的限制 新版本的功能： 可以设置 timeout 超时时间 可以使用 formData 对象管理表单数据 允许请求不同域名下的数据（跨域） 支持上传二进制文件 可以获取数据传输的进度信息 注意：我们现在使用 new XMLHttpRequest 创建的对象就是2.0对象了，我们之前学的是1.0的语法，现在学习一些2.0的新特性即可。 timeout 设置超时xhr.timeout = 3000; // 设置超时时间xhr.ontimeout = function()&#123; alert("请求超时");&#125; formData 管理表单数据formData 对象类似于 jquery 的 serialize 方法，序列化表单，实现表单的异步提交 !&gt; 但 serialize 方法无法实现文件上传 使用： 实例化一个 formData 对象， new FormData(form); form 就是表单元素，DOM对象 formData 对象可以直接作为 xhr.send(formData) 的参数。注意此时数据是以二进制的形式进行传输。 formData 有一个 append 方法，可以添加参数。formData.append(“id”, “1111”); 这种方式只能以 post 形式传递，不需要设置请求头，浏览器会自动为我们设置一个合适的请求头。 代码示例： // 1. 使用formData必须发送post请求 xhr.open("post", "02-formData.php");// 2. 获取表单元素var form = document.querySelector("#myForm");// 3. 创建form对象，可以直接作为send的参数。var formData = new FormData(form);// 4. formData可以使用append方法添加参数formData.append("id", "1111");// 5. 发送，不需要指定请求头，浏览器会自动选择合适的请求头xhr.send(formData); 如果要获取 formData 中的数据，可以使用 formData.get(&#39;&#39;) 获取 文件上传 以前，文件上传需要借助表单进行上传，但是表单上传是同步的，也就是说文件上传时，页面需要提交和刷新，用户体验不友好，xhr2.0 中的 formData 对象支持文件的异步上传。 var formData = new FormData();// 获取上传的文件，传递到后端var file = document.getElementById("file").files[0];console.dir(file);formData.append("file", file);xhr.send(formData);$('#upload').on('change', function () &#123; // FormData 用于管理表单数据的 var form = document.querySelector("#form1"); var formData = new FormData(form); // 发送给服务器 var xhr = new XMLHttpRequest(); xhr.open('post','upload.php'); xhr.send(formData); // 直接发送 formData xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; var r = xhr.responseText; &#125; &#125;&#125;)// jquery$('#upload').on('change', function () &#123; // 准备要上传的数据 var formData = new FormData(); // 如果 formData 中有文件对象了，就不需要再添加了 formData.append('file', this.files[0]); // 发送 AJAX 请求，上传文件 $.ajax(&#123; url: 'upload.php', contentType: false, // 设置编码类型 processData: false, // 设置传递值方式 data: formData, type: 'post', success: function (res) &#123; if (res.success) &#123; &#125; &#125; &#125;)&#125;) !&gt; 如果使用 $.ajax 发送 ， 需要添加如下两项参数​ contentType: false, 设置编码类型​ processData: false, 设置传递值方式 显示文件进度信息 xhr2.0 还支持获取上传文件的进度信息，因此我们可以根据进度信息可以实时的显示文件的上传进度。 需要注册 xhr.upload.onprogress = function(e){} 事件，用于监听文件上传的进度。注意：需要在send之前注册。 上传的进度信息会存储事件对象 e 中 e.loaded 表示已上传的大小；e.total 表示整个文件的大小 代码参考： xhr.upload.onprogress = function (e) &#123; inner.style.width = (e.loaded/e.total*100).toFixed(2)+"%"; span.innerHTML = (e.loaded/e.total*100).toFixed(2)+"%";&#125;// toFixed(2) 保留两位小数xhr.send(formData); 默认上传文件限制 8M，需要配置 php.ini，允许 php上传大文件。 跨域资源共享(CORS)CORS 的使用 新版本的XMLHttpRequest对象，可以向不同域名的服务器发出HTTP请求。这叫做“跨域资源共享”（Cross-origin resource sharing，简称CORS）。 跨域资源共享（CORS）的前提 浏览器支持这个功能( 兼容性IE10+ ) 服务器必须允许这种跨域 服务器允许跨域的代码： // 允许所有的域名访问这个接口header("Access-Control-Allow-Origin:*");// 允许 www.abc.com 这个域名访问这个接口header("Access-Control-Allow-Origin:http://www.abc.com"); CORS 的具体流程（了解） 浏览器发送跨域请求 服务器端收到一个跨域请求后，在响应头中添加Access-Control-Allow-Origin Header资源权限配置。发送响应 浏览器收到响应后，查看是否设置了header(&#39;Access-Control-Allow-Origin:请求源域名或者*&#39;); 如果当前域已经得到授权，则将结果返回给浏览器，否则浏览器忽略此次响应 结论： 跨域行为是浏览器行为，响应是回来了, 只是浏览器安全机制做了限制, 对于跨域响应内容进行了忽略。 服务器与服务器之间是不存在跨域问题的 jsonp 与 cors 的对比 jsonp 兼容性好，老版本浏览器也支持，但是 jsonp 仅支持 get 请求，发送的数据量有限，使用麻烦 cors 需要浏览器支持 cors 功能才行。使用简单，只要服务端设置允许跨域，对于客户端来说，跟普通的get、post请求并没有什么区别 跨域的安全性问题：因为跨域是需要服务端配合控制的 ，也就是说不论 jsonp 还是 cors，如果没有服务端的允许，浏览器是没法做到跨域的 【案例：图灵机器人】]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP]]></title>
    <url>%2F2018%2Fphp%2Fphp%2F</url>
    <content type="text"><![CDATA[PHP服务器什么是服务器？ 通过安装服务器软件，提供服务 的计算机 服务器可以从硬件、软件(系统软件、应用软件)几个角度描述。 按硬件描述： 服务器就是一台超级计算机(配置很高)。 按操作系统划分： 在硬件上安装了什么操作系统，就可以称为该系统的服务器​ 例如: linux服务器、windows服务器、unix服务器等。 按软件划分： 在操作系统中安装了什么软件，就可以称作该软件的服务器 iis tomcat​ 例如: web服务器、数据库服务器、邮件服务器等。 什么是Web服务器Web服务器就是安装了Web服务软件，web服务器的作用是能够提供网站服务的服务器。淘宝、京东、新浪等等 常见的Web软件： Apache、Nginx、IIS、Tomcat、Node等。Apache服务器、Nginx服务器、IIS服务器、Tomcat服务器、Node服务器 Apache是世界使用排名第一的Web服务器软件。我们将编写好的html、css、js等文件存入apache，就能够通过网络来访问这些文件了。 PS: web服务器又叫做http/httpd服务器 phpStudy 介绍 phpStudy是一个PHP调试环境的程序集成包 该程序包集成最新的 Apache+PHP+MySQL 安装phpStudy，一定不能有中文，否则肯定启动不起来 *注意: *将要访问的文件(html,php,img等)，放到安装路径下的 www 目录下，通过浏览器就可以访问到了 phpStudy的错误解决如果phpStudy启动发生错误，参数下列几点。 一是防火墙拦截， 二是80端口已经被别的程序占用，如IIS等； 三是没有安装VC9运行库,php和apache都是VC9编译。 PHP 基础(重点)###PHP 简介 PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。主要适用于 Web领域的开发 ，能够完成 动态网页 的制作。 ###PHP 特点 PHP 是目前最流行的网站开发语言（B/S结构）之一。 PHP 是一种在服务器端执行的嵌入 HTML 文档的脚本语言。 支持几乎所有流行的 数据库 以及操作系统。 源码开放、免费（free) php 是世界上最好的语言 ###动态网站与静态网站(了解) 静态网站：使用浏览器端语言进行编程，网站由静态代码（HTML,CSS,JS）组成。 动态网站 ：网页通过服务器的程序(php等)动态生成。用户可以和服务器进行交互（可以根据用户输入的不同信息，返回不同的运行结果） 总结 动态网站的 **动** 指的是网站 **数据的动** 而不是 **视觉上的动**###软件架构(了解) 软件架构可以分为BS架构与CS架构 ####C/S架构 Client/Server架构，即客户端/服务器架构。需要安装对应的客户端软件，才能获取服务器的服务。 常见的CS架构：QQ、LOL、微信等 特点： 需要安装才能使用 性能高效，使用更加稳定和流畅 ####B/S架构 Broswer/Server架构，即浏览器/服务器架构。随着Internet的兴起，无需安装专门客户端软件，通过浏览器去请求服务器； 不需要安装，只需要浏览器即可。 相比CS架构，性能相对较差，没有那么流畅和稳定。 php 基本语法结构// 避免使用中文目录和中文文件名// 文件以.php后缀结尾，所有程序包含在&lt;?php 这里是代码 ?&gt;// php页面无法直接打开需要运行在服务器环境当中// 末尾必须加分号，不然就报错了（最后一行可以不加分号）&lt;?php echo "hello world";?&gt; 输出中文乱码问题：如果使用 echo 输出中文，可能会乱码 &lt;?php // 解决中文乱码的问题 header("content-Type:text/html;charset=utf-8"); // 返回HTML文档文本并设置编码集 echo "hello world"; echo "&lt;br/&gt;"; echo "大家好，我是一名摄影工作者";?&gt; ##PHP运行原理 ###HTML运行原理 1) 在浏览器的URL地址栏中输入 www.baidu.com/index.html 地址，点回车。请求就发送给百度服务器。2) 百度服务器找到index.html文件，并将文件的内容返回给浏览器3) 浏览器接收到index.html中的内容，渲染到页面上。 同理: localhost/a.html , 则会返回 本机web服务器根目录下 a.html文件的内容。浏览器拿到内容后进行渲染。 ###PHP运行原理 apache 不认识 php 浏览器也不认识 php 1) 在浏览器地址栏中输入 localhost/index.php ,点回车之后。将请求发送给apache服务器。 2) 服务器找到 index.php文件之后，转发给php解释器 3) php解释器将index.php文件中的php代码全部转为字符串，再返回给apache 4) apache将处理好的字符串返回给浏览器，浏览器渲染后就可以看到页面 变量 php 是一门弱类型语法，变量的类型可以随意改变。变量其实就是存储数据的容器 变量的命名规则 不需要关键字进行声明，变量在第一次赋值的时候被创建 必须以 $ 符号开始 $ 后面的命名规则与js的变量命名规则一致。 变量操作声明变量 声明变量的时候也一定要同时赋值,否则变量无法声明成功 // 变量在声明的时候一定要同时赋值,否则变量无法声明成功$name = "呵呵";echo $name; 删除变量 unset() unset($name); // 销毁指定的变量 判断变量是否设置值 isset() isset($name);echo isset($name); // 用 echo 打印，如果为 true 会打印出 1 ， 如果为 false 打印空var_dump(isset($name)); // 会打印出 bool(true)/bool(false) 变量未设置或者设置为null，返回false（认为变量没有设置），其余情况全部为true。一般用来判断变量是否设置，因为变量未设置，无法直接使用。(变量先赋值，在使用！） 判断变量是否为空 empty() var_dump(empty($name)); // 为空打印出 bool(true)，不为空则打印 bool(false) PHP中认为变量的值为：&quot;&quot;、0、&quot;0&quot;、null、false、[] 时，变量虽然赋值了，但是无实际的意义。为空。 数据类型 php数据类型: 8种数据类型 基本数据类型: 布尔, 字符串, 整数, 浮点数 复合数据类型:数组, 对象 特殊的类型:resource(资源) null 简单数据类型输出语句//1. echo 输出简单数据类型//2. print_r 输出数据结构，一般用于输出复杂类型。print_r($arr); // print_r 是一个函数，不要忘记小括号//3. var_dump 输出完整的数据结构，包括类型，一般用于精准调试var_dump($arr); 字符串$str = "php是世界上是最好的语言";echo $str; 字符串连接符 php中，+ 号只有算数的功能，并不能拼串，拼串使用 . $name = "大象";echo "大家好，我是" . $name . "，今年18岁"; php 中的单引号与双引号 //1. 字符串的定义可以使用单引号，也可以使用双引号//2. 双引号可以解析变量//3. 单引号的性能会高于双引号（了解）$name = "大象";$desc = '很帅';$str = '$name 很帅';echo $str; // $name 很帅$str = "$name 很帅";echo $str; // 大象 很帅 整数$num = 100;echo $num; 浮点型$float = 11.11;echo $float; 布尔类型$flag = true;// 当布尔类型值为true时，输出1echo $flag;$flag = false;// 当布尔类型为false时，输出空字符串echo $flag; 数组 在 php 中，数组分为两种，索引数组 和 关联数组 计算数组长度的方法：count(数组名)； 索引数组（类似与JS中的数组） $arr = array("张飞","赵云","马超");echo $arr; // Array // echo 只能打印基本数据类型// 使用 print_r() 打印print_r($arr); // Array ([0] =&gt; 张飞 [1] =&gt; 赵云 [2] =&gt; 马超)echo $arr[0]; // 张飞 关联数组（类似与JS中的对象） // 属性名必须用引号引起来$arr = array("name"=&gt;"zhangsan", "age"=&gt;18);print_r($arr); // Array ( [name] =&gt; zhangsan [age] =&gt; 18 )echo $arr["name"]; 二维数组与多维数组 数组中的每个元素又是一个数组二维数组的存取元素，需要两次访问，依次确定行和列 $arr[x][y]; 多维数组数组里面嵌套了两层以上的数组 对象(了解) 在php以及其他高级语言中，都有类的概念，表示一类对象，跟js中构造函数类似。 //定义一个类（类似js的构造函数）class Person &#123; public $name = "小明"; private $sex = "男";&#125;$zs = new Person;print_r($zs);//打印对象的结构信息 Person Object ([name] =&gt; 小明[sex:Person:private] =&gt; 男 )echo $zs-&gt;name; // 对象中取值用 -&gt;echo $zs-&gt;sex; // 私有属性，无法获取 流程控制分支结构(if/switch)基本上来说，所有语言的if..else语法都是一样 $age = 17;if ($age &gt;= 18) &#123; echo "终于可以抽烟喝酒烫头了";&#125; else &#123; echo "哎......";&#125;//===================switch(变量)&#123; case 值1: 程序块1； break; case 值2: 程序块2； break; ... default: 程序块&#125; 循环结构(while / for / do…while)while(判断表达式)&#123; 程序块;&#125;for(赋值表达式; 判断表达式; 步进表达式)&#123; 程序块;&#125;do&#123; 程序块&#125; while(判断表达式) 遍历索引数组 $arr = array("张三", "李四", "王五", "赵六", "田七", "王八");// 获取数组的长度： count($arr)for($i = 0; $i &lt; count($arr); $i++) &#123; echo $arr[$i]; echo "&lt;br&gt;";&#125; foreach 语句结构 用来遍历数组(关联数组和索引数组均可)。 foreach($arr as $key =&gt; $value)&#123; 程序体&#125;foreach($arr as $value)&#123; 程序体&#125; $arr : 要遍历的数组 $key: 键，可以是任意变量名 $value: 值，可以是任意变量名 //遍历关联数组$arr = array( "name"=&gt;"zs", "age"=&gt;18, "sex"=&gt;20);foreach($arr as $k =&gt; $v) &#123; echo $k . "=" . $v . "&lt;br&gt;";&#125; 函数 注意，在php中函数不能重复声明 php 中函数的语法与js中函数的语法基本一样，不同点在于 函数名大小写不敏感 函数的形参可以设置默认值 &lt;?php header("content-Type:text/html;charset=utf-8"); function sayHello ($name="周杰伦") &#123; echo "大家好，我是$name"; echo "&lt;br&gt;"; [return 返回值;] &#125; sayHello(); // 不传参数，会使用默认值 sayHello("大象"); // 传参数，默认值不生效?&gt; 在 php 中函数不能重复声明 函数体内的变量只在函数体内有效 函数体外的变量只在函数体外有效 &lt;?php $age = 18 function fn()&#123; $name = '大象'; echo $name; // 有效 echo $age; // 无效 &#125; fn(); echo $name; // 无效 echo $age; // 有效?&gt; 常量保存不会发生改变的数据(如：3.1415， 路径等)时，最好使用常量。 常量的使用方法： define(常量名, 常量值, [是否区分大小写]);// 默认 false 区分大小写， true 不区分大小写define("PI", 3.1415, true);echo PI;echo pi; 注意: 一般在实际工作中，常量都用大写，常量不能被重新赋值 PHP内置函数数学函数 max(),min() 分别返回一组数的最大值及最小值； abs() 返回绝对值。 floor() 向下取整。 ceil() 向上取整。 round() 四舍五入。 rand() 返回随机整数，可以取到两端的值。 日期函数 time() 返回当前的时间戳 (1970到现在的时间的秒数) date(format,time) 格式化一个本地时间或日期 格式：Y(年) m(月) d(日) H(时) i(分) s秒 $time = time(); // 获取时间戳echo date('Y-m-d H:i:s',$time); // 格式化时间戳// Y, m, d, H, i, s 分别代表 年 月 日 时 分 秒 默认时区会不太正确, 我们在东八区, 比0时区会多八小时 路径: D:\phpStudy\php\php-5.4.45在php.ini里加上找到date.timezone项，设置date.timezone = "PRC"，重启环境就ok了。PRC: 中华人民共和国 字符串函数 str_replace(查找的值，替换的值，执行替换操作的字符) 字符串替换（会把符合的值全部替换） trim(字符串); 去除首尾空白字符 explode(分割符，执行分割的字符串); 使用一个字符分割一个字符串，返回一个数组(类似split) implode(连接符，执行连接的数组); 将数组根据连接符拼接成字符串(类似join) substr(字符串，起始索引，截取长度); 截取字符串，注意中文占3个字节长度 strchr(字符串，标识字符); 从左向右找标识字符，返回该字符后全部字符(包括该字符) strrchr(字符串，标识字符); 从右向左找标识字符，返回该字符后全部字符(包括该字符) 主要用于获取后缀名 补充查找数组中是否含有指定内容 // in_array(查找的内容, 数组) 如果查找到返回 true ，查找不到返回 falseresult = in_array($uname, $arr);// 可用来判断用户名是否已存在数据库中 从数组中随机获取数据 // array_rand(被操作的数据, 数据长度) 返回一个随机的下标$arr = array_rand($results, 2); // 返回一个数组，随机两个下标$index = array_rand($results, 1); // 返回一个随机的下标$results[$index]; // 用来随机获取数组中的一项 页面动态渲染 PHP本身支持与HTML混编 混编的文件后缀必须为 .php， Apache 才会调用 PHP 解析 PHP与HTML混编时，服务器中的 PHP 引擎 只会执行php标签内部的PHP代码，非PHP的代码(PHP标签外部的内容)直接忽略，最后会将PHP的执行结果和非PHP代码 一起返回给浏览器,由浏览器进行解析 一个php页面当中,可以写多个php语法结构,但是php语法结构 不能嵌套 &lt;?php header('content-type:text/html;charset=utf-8'); echo 2+3; // php的引擎 只会执行php代码块中代码，代码块外面的代码会被忽略最后 服务器会将php执行的结果和代码块外面的内容一起返回给浏览器，由浏览器进行解析?&gt;// 在php语法结构外面， 可以写 html ，会直接在浏览器中渲染&lt;a href="http://www.baidu.com"&gt;百度一下&lt;/a&gt; include 文件引入介绍：不同的页面中有相同的代码部分，可以将其分离为单个文件。需要调用时，include 引入对应的文件即可调用。提高代码的复用率。类似于 js 中 script 标签导入, 可以用于函数复用 语法 // 可以是html、php或其他类型的页面include | include_once "文件的路径" include 与 include_once 区别 include 可以重复引入文件 include_once 只引入一次，防止多次引入文件 如果文件中有函数，include 重复引入会报错，include_once 不会报错 PHP 数据读写到文件(数据持久化)程序运行过程中，数据存储在内存中的，程序结束, 数据会销毁 如果希望可以永久存储某些数据，可以将数据存储在硬盘上（存储在文件中） 将数据由内存存储到硬盘的过程，称为数据持久化； file_get_contents(path) 根据路径读取文件内容, 返回一个字符串 file_put_contents(path,$str) 将一个字符串写入到一个文件中。(只能存储字符串) file_put_contents(string $file, string $data[, constants flag]);参数1: 文件路径参数2: 要写入文件的字符串参数3: 可选参数，默认不写，新内容覆盖原文件中的内容；FILE_APPEND 是向文件中追加内容返回值: 写入文件的字符串长度(不用记) 使用 file_put_contents 存储数组的时候，会丢失数据 $arr = ['zs', 'ls', 'ww'];$arr1 = ['name'=&gt;'zs', 'age'=&gt;18];file_put_contents("02-test.txt", $arr); // zslswwfile_put_contents("02-test.txt", $arr1); // zs18 把一个数组，转成一个 json 格式的字符串 json_encode($data) 将PHP数组转成JSON格式字符串。 json_decode($str,true) 将 JSON 字符串, 转换为 PHP 数组。（不传true, 有可能转完之后是个对象, 传了true,一定是数组） 表单处理 表单（form）：表单用于收集用户输入信息，并将数据提交给服务器。是一种常见的与服务端数据交互的一种方式 action: 指定表单的提交地址（如果提交到当前页面，action 可以为空） method: 指定表单的提交方式，get/post，默认 get input 的数据想要提交到后台，必须指定 name 属性，后台通过 name 属性获取值 想要提交表单，不能使用 input:button 必须使用 input:submit php 获取表单数据// $_GET 是 PHP 系统提供的一个超全局变量，是一个数组，里面存放了表单通过 get 方式提交的数据// $_POST 是 PHP 系统提供的一个超全局变量，是一个数组，里面存放了表单通过 post 方式提交的数据 get 与 post 的区别 get 方式数据会拼接在 url 地址的后面 (?username=pp&amp;password=123456)地址栏有长度限制，因此 get 方式提交数据大小不会超过 4k post 方式数据不会在 url 中显示，相比 get 方式，post 更安全提交的数据没有大小限制，可用于文件上传 文件上传html要求 文件上传的提交方式必须是 post 方式 需要给 form 指定 enctype=&quot;multipart/form-data&quot; 指定 name 属性，后台才能获取到 php 相关 文件上传时，通过 $_FILES 才能获取到，这是一个二维数组。 Array( [photo] =&gt; Array ( [name] =&gt; 001.jpg // 文件名字 [type] =&gt; image/jpeg // 文件类型 // 上传图片保存的位置 [tmp_name] =&gt; C:\Users\Jepson\AppData\Local\Temp\phpF2A0.tmp [error] =&gt; 0 // 上传错误码, 错误码为 0 表示没有错误 [size] =&gt; 6000 // 文件大小, 单位字节, 大小 6kb 左右 )) 上传文件时，文件会临时保存在服务器上，如果文件最终没有保存，那么临时文件会被删除，保证服务器安全。 sleep(10) 可以让代码延迟10秒钟才执行。 move_uploaded_file($path, $newPath); 可以转存临时文件，真正把文件存储起来 unlink(filename,context) 删除文件，若成功，则返回 true，失败则返回 false // 保存图片的完整代码// 思路:// 1. 在文件上传成功的情况下, 进行图片的保存 error == 0// 2. 获取临时文件路径// 3. 随机生成新的文件名, 注意文件中后缀名是不能改变的// 4. 根据新的文件名, 转移临时文件$file = $_FILES['photo'];// 判断上传是否成功if ( $file['error'] == 0 ) &#123; // 上传成功 // 1. 获取临时文件路径 $ftemp = $file['tmp_name']; // 2. 随机生成新的文件名, 后缀不能随便起, 要获取一下 $name = $file['name']; $text = strrchr($name, '.'); // 为了防止重复, 生成随机的文件名以当前时间秒数+随机数组成 $newName = time().rand(10000,99990).$text; // 3. 进行转存 move_uploaded_file($ftemp, "./upload/$newName");&#125; 学生信息管理系统1.0基本功能 学生添加功能 展示学生信息功能 删除学生信息 // array_splice(数组, 开始的下标, 截取长度) 将匹配到的数据截取掉，会改变原来的数组array_splice($arr, $_GET["index"], 1);// 添加内容到数组：将 $stuArr 添加到数组 $arr 中$arr[] = $stuArr; HTTP协议协议： 协议，就是事先的一种约定、规则、规范、标准 常见协议 HTTP、HTTPS 超文本传输协议 FTP 文件传输协议 SMTP 简单邮件传输协议 HTTP 协议 HTTP 协议即超文本传输协议, 是一个 [浏览器端] 和 [服务器端] 请求和响应的标准 常用请求方法 GET, POST 请求 (request)：请求行、请求头、请求主体。 响应 (response)：状态行、响应头、响应主体。 请求和请求报文​ 请求由浏览器发起，其规范格式为：请求行、请求头、请求主体。 get 请求的请求报文 // --------------------------请求行--------------------------------// GET 请求方式// /day02/01.php?username=pp&amp;password=123456 请求路径+参数（注意点）// HTTP/1.1 HTTP的版本号GET /day03/01.php?username=pp&amp;password=123456 HTTP/1.1//--------------------------请求头--------------------------------// Host:主机地址Host: www.study.com// HTTP1.1版本默认开启，建立过连接后，TCP连接不会断开，下次连接可以继续使用（底层，不用管）Connection: keep-alive// chrome浏览器自己增加的，不用管Upgrade-Insecure-Requests: 1// 浏览器的代理字符串（版本信息）User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36// 浏览器端可以接受的类型。Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,`*/*`;q=0.8// 从哪个页面发出的请求Referer: http: // www.study.com/day02/01-login.html// 检查浏览器支持的压缩方式Accept-Encoding: gzip, deflate, sdch// 浏览器支持的语言，优先中文。Accept-Language: zh-CN,zh;q=0.8,en;q=0.6// ----------------------------请求主体-------------------------------------// get 请求没有请求体，因为要传递的数据已经拼接到了请求主头中 POST 请求的请求报文 // -----------------------请求行---------------------------------------------POST /day02/01.php HTTP/1.1// -----------------------请求头--------------------------------------------Host: www.study.comConnection: keep-alive// 传递的参数的长度Content-Length: 29Cache-Control: max-age=0Origin: http: // www.study.comUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.96 Safari/537.36// 内容类型：表单数据，如果是post请求，必须指定这个属性。Content-Type: application/x-www-form-urlencodedAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,`*/*`;q=0.8Referer: http: // www.study.com/day02/01-login.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.8,en;q=0.6// ------------------------请求体------------------------------------------username=pp&amp;password=123456 GET 请求与 POST 请求的对比 GET 请求没有请求体，因为 GET 请求的参数拼接到地址栏中了 POST 请求有请求体，就是传递的参数。 响应与响应报文​ 响应由服务器发出，其规范格式为：响应行(状态行)、响应头、响应主体。 // ---------------------响应行（状态行）-------------------------------// HTTP/1.1 HTTP版本// 200 响应的状态 // 200表示成功 // 302页面重定向 // 304表示文档未修改 // 404表示找不到资源 // 500表示服务端错误HTTP/1.1 200 OK// ----------------------响应头-----------------------------------------------Date: Thu, 22 Jun 2017 16:51:22 GMT // 服务器的时间Server: Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.4.45 // 服务器的版本信息X-Powered-By: PHP/5.4.45 // 后台编程语言信息Content-Length: 18 // 服务器的响应主体长度// 内容类型，告诉浏览器该如何解析响应结果Content-Type: text/html;charset=utf-8// -----------------------响应主体------------------------------------------------用户登录成功 Mysql数据库数据库概念专门用来存储、管理数据的仓库 英文：Database, DB。 数据库的分类 关系型数据库: 基于表，表与表之间可以存在关系，可以进行多表查询的存储方式，适合较为复杂的存储 如: MySQL, SQL Server, oracle 表结构: 每一行代表一条数据 — 记录 每一列都是一类数据 — 字段 订单编号 商品名称 价格 数量 100123 华为mate10 4999 2 100124 花裙子 499 1 订单编号 用户 配送地址 100123 隔壁老王 北京市京顺路99号 100124 隔壁老宋 北京市清华大学1号楼 非关系型数据库: 基于键值对的存储方式，数据之间没有耦合性，特点执行效率高 如：mongodb // 类似对象的键值对形式&#123; "username": "gblw", "password": 123456, "uid": 007&#125; MySQL 数据库软件 MySQL 数据库软件中可以有多个数据库,每一个数据库中可以有多个表 可视化工具 navicat MySQL 只是一个数据库软件，如果我们要创建数据库，或对数据库进行增删改查，刚开始可以用可视化工具来操作，让我们更加直观的了解数据库 安装 navicat让 navicat 和 MySQL 建立连接点击左上角 连接 =&gt; MySQL =&gt; 常规 =&gt; 端口 3306 =&gt; 数据库表的操作数据库的数据类型 也就是数据库中可以存储的数据类型(又叫做字段类型) 字段类型 整型 int ​ 存储如年龄，产品数量，编号等。 小数类型 float , decimal 重量，工资，奖金，价格等使用decimal类型，实现小数的精确存储,一般用来存储与钱有关的数字。3.333333331 字符串型 varchar(M)，char(M) M 为该字段可以存储的最多字符数(字节) ，如varchar(10)最大可以存储10个字节 varchar 一般用来存储长度变化比较大的字符串，如文章标题，商品名称 char 存储长度比较固定的字符串，如手机号，身份证号，序列号，邮编 此外可以使用text类型，存储较长的字符串，无需指定字符串的具体长度 日期时间型 datetime, date(年月日)，time(时分秒) 字段约束 字段约束: 字段数据的属性规则（特征） not null 不为空，可以限制字段值不能为空 default 默认值，可以设置字段的默认值，在没有录入时自动使用默认值填充。 primary key 主键 ：唯一标识，不能重复，不能为空 设置字段为主键，主键字段的值不能重复，不能为空。而且一个数据表中只能设置一个字段为主键，作为每行记录的唯一身份信息（索引）。 auto_increment 自动增长 设置字段为自动增长，默认从1开始自动分配编号。自增长字段必须为一个key（索引，数据结构，便于快速查找数据，相当于书的目录），一般与 primary key 结合使用。类型必须为整型。 unique key 不能重复 唯一键，设置字段的值为唯一的，可以设置多个字段为唯一键。唯一键字段的值可以为空。 创建数据表 注意 创建表时，每个表必须有一个主键 SQL-操作数据库的语言 SQL：structured Query Language 结构化查询语言。 通过这个语言可以对数据库进行增删改查 SQL编写注意点: 注释用 -- , 语句结束加分号 ; 基本用法：增删改查 插入数据 insert -- insert into 表名 (字段列表) values (值列表)insert into book (name, age, sex) values ('zs','18','m'); 修改数据 update -- update 表名 set 字段名称1=值1,字段名称2=值2,... where 条件-- 如果不加条件会修改表中所有对应的字段update book set name='ls', age='30' where id=10; 删除数据 delete -- delete from 表名 where 条件delete from book -- 会删除所有数据delete from book where id=10; 查询数据 select -- select 字段列表 from 表名select name, age from book -- 只查询表中 name 和 author 的信息-- select * from 表名 where 条件 * 表示所有字段select * from book where id = 2;select * from book where name='zs' and age=20; 高级用法 where 条件 查询时，不添加 where 条件, 返回数据表所有行。需要添加限定条件，只返回需要的行。 -- select 字段列表 from 表名 where 条件；-- 条件 : =, &gt;, &lt;, &gt;=, &lt;=, and, or like 模糊匹配 % 通配符 -- 查找姓张的人select * from 表名 where name like '张%';​ in 语法：一次查询多个符合条件的数据 -- select * from 表名 where 字段 in (value1,value2,value3);select * from stu where name in ('zs', 'ls', 'ww'); -- 查找name值为zs, ls, ww 的数据 count() 获取返回数据的总条数 -- 查询满足条件数据的总条数-- select count(*) from 表名 where 条件 order 排序 -- select * from 表名 order by 字段名称; 默认升序-- select * from 表名 order by age; -- 按照年龄来排序-- select * from 表名 order by 字段名称 desc; desc 表示降序 limit 对结果集进行截取 一般用于取数据的前几条 -- select * from 表名 limit 截取的起始索引，截取的长度 联合查询（多个表联合查询） select 字段列表 from 表A join 表B on 表A.字段=表B.字段 where 条件join 将表A和表B联合起来on 根据什么字段把表A和表B联合起来select * from teacher join class on class.id=teacher.classid; -- 老师表和班级表联合查询select teacher.*, class.classname from teacher join class on class.id=teacher.classid; -- 老师表和班级表联合查询,但只显示老师表的全部内容和班级表的名称-- 注意: 多表联合查询时,字段要写明是那个表的字段 如 表.字段名 PHP 操作数据库连接数据库基本步骤 连接数据库 准备sql语句 执行sql语句 获取执行的结果并分析 关闭数据库 操作数据库常用 API mysqli_connect(IP, 用户名，密码，数据库名)，端口号 连接数据库 mysqli_query($link, $sql) 执行SQL语句 mysqli_error($link); 返回错误描述 mysqli_close($link); 关闭连接 mysqli_fetch_assoc($res); 从结果集中取得一行作为关联数组返回 mysqli_num_rows($res); 返回结果集的行数 sql 操作 使用 PHP 发送 SQL 语句前，可以先打印 SQL 语句，检查语句的正确性。 修改数据库的数据时, 使用变量拼接SQL语句=，字段的值为字符串类型时，需要在变量的两侧使用单、双引号包裹。可以将所有的字段外面都使用双引号包含。 // 1. 连接数据库// mysqli_connect(ip地址, 用户名, 密码, 数据库的名称, 端口号);// 执行结果// 1. 连接成功, 返回一个数据库连接对象// 2. 连接失败, 返回 false// @ 表示错误抑制符, 可以抑制错误的输出$link = @ mysqli_connect('127.0.0.1', 'root', 'root', 'study', 3306);// var_dump($link);// 如果数据库连接失败if ( !$link ) &#123; echo "数据库连接失败"； return false; // 程序结束, die 方法, 终止当前程序执行, 输出一段语句 die("数据库连接失败");&#125;echo "数据库连接成功&lt;br&gt;";// 2. 准备 sql 语句: 删除一条数据$sql = "delete from stu where id = 14";$name = "gblw";$age = 31;$sq2 = "insert into stu (name, age) values ('$name', $age)";// sql 语句一般用双引号包裹// 如果语句中含有拼接的变量，需要用单引号包裹// 3. 让数据库执行 sql 语句, 并分析结果// mysqli_query(数据库连接对象, 要执行的sql语句)// 非查询语句：执行成功返回 true, 执行失败返回 false// 4. 根据结果不同做逻辑判断if ( mysqli_query( $link, $sql ) ) &#123; // 如果删除的数据不存在，也会返回 true， echo "删除成功";&#125;else &#123; // sql 语句错误，才会返回 false echo "删除失败"; // mysqli_error 可以查看错误消息 echo mysqli_error($link);&#125;// 查询语句： 成功返回结果集, 失败返回 false// 数据查询不到也会返回结果集，只是数据条数为 0，sql 语句有错误才会返回 false$res2 = mysqli_query( $link, $sq2 );// $res2 是返回的结果集,是一个对象，表面上看没有我们要的数据,如果我们想要数据,需要调用mysqli_fetch_assoc($res2)去获取// 结果集中 field_count 表示字段数，num_rows 表示查询到的数据条数// 注意: mysqli_fetch_assoc($res2)执行一次,只会从结果集中拿一条数据出来(执行几次就拿出几条数据)// 4. 根据结果不同做逻辑判断if ( !$res ) &#123; echo mysqli_error( $link ); die('数据库查询失败');&#125;// mysqli_fetch_assoc 查询成功, 从结果集中取数据, 以关联数组的形式返回// 一次只取一条数据, 如果没取到, 返回 null$arr = [];while( $row = mysqli_fetch_assoc( $res ) ) &#123; // 将值推到数组中 $arr[] = $row;&#125;// 也可以采用 for 循环遍历// mysqli_num_rows($res) 方法返回获取到的数据条数 ，for($i = 0; $i &lt; mysqli_num_rows($res); $i++)&#123; // echo $i; $arr[] = mysqli_fetch_assoc($res);&#125;// echo '&lt;pre&gt;';// print_r($arr);// echo '&lt;/pre&gt;';// 5. 关闭数据库连接 (挂电话)mysqli_close( $link ); 数据库工具函数的封装 为了提高代码的复用性，把数据增删改的操作封装成一个方法 // 定义常量define( 'HOST', '127.0.0.1' );define( 'UNAME', 'root' );define( 'PWD', 'root' );define( 'DB', 'test02' );define( 'PORT', 3306 );// 非查询语句封装// 封装一个执行非查询语句的方法, 提高代码的复用性// 参数: $sql 要执行的 sql 语句// 返回值: true / falsefunction my_exec( $sql ) &#123; // 1. 连接数据库 $link = @ mysqli_connect( HOST, UNAME, PWD, DB, PORT); if( !$link ) &#123; echo '数据库连接失败'; return false; &#125; // 2. 准备 sql 语句, 就是传递过来的 $sql // 3. 执行 sql 语句, 分析结果 if ( mysqli_query( $link, $sql ) ) &#123; // 执行成功 mysqli_close( $link ); // 关闭数据库 return true; &#125; else &#123; // 执行失败 mysqli_close( $link ); // 关闭数据库 return false; &#125;&#125;// 查询语句的封装// 参数: $sql 要执行的 sql 语句// 返回值:// (1) 成功, 返回数据(二维数组)// (2) 失败, 返回 falsefunction my_query( $sql ) &#123; // 1. 建立连接 $link = @ mysqli_connect( HOST, UNAME, PWD, DB, PORT ); if ( !$link ) &#123; echo "数据库连接失败"; return false; &#125; // 2. 准备 sql 语句 $sql // 3. 执行 sql 语句, 分析结果 $res = mysqli_query( $link, $sql ); // 结果集 或者 false if ( !$res ) &#123; echo "获取数据失败&lt;br&gt;"; echo mysqli_error($link); mysqli_close( $link ); return false; &#125; // 得到结果集, 将结果集的所有内容取出到数组中 $arr = []; while ( $row = mysqli_fetch_assoc($res) ) &#123; $arr[] = $row; &#125; mysqli_close( $link ); return $arr; // 返回结果数组&#125; 学生管理系统2.0基本功能 添加学生功能 展示学生列表功能 删除学生功能 查看学生详情 更新学生数据 实现思路注册功能思路： 表单设计，点击提交按钮向服务器提交表单数据 在后台获取表单提交的数据，保存到数据库中 先获取表单的标签的数据 保存上传的图片（并保存图片存储的路径） 将表单的数据和图片的路径一起保存到数据库中 保存完成，跳转到列表页，查看新添加的数据 展示功能思路： 先从数据库中获取数据（二维数组arr） 遍历二维数组，将数组中数据渲染到页面中 删除功能思路： 获取要删除数据的id 根据id删除数据库中指定的数据 删除完毕，返回列表页 详情展示功能 获取要查看详情数据的id 根据id通过联合查询，获取到需要用数据 把数据显示在页面中 点击返回按钮，可以返回到列表页 更新数据思路：更新数据的思路=先渲染 再 提交 获取要查看详情数据的id 把对应id的数据填充到修改页面中 点击修改按钮，获取表单的数据，提交给服务器 在服务器更新数据 更新完成后跳转到列表页 隐藏域表单：和其他表单标签一样，只是看不到而已 &lt;input type="hidden" name="id" value="&lt;?php echo $data['id'] ?&gt;"&gt;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 高级]]></title>
    <url>%2F2018%2Fjavascript%2Fjavascript%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[JavaScript 高级课程大纲 面向对象编程基本概念 Everything is object （万物皆对象） 对象到底是什么，我们可以从两次层次来理解 (1) 对象是具体事物的抽象 一本书、一辆汽车、一个人都可以是对象，当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程 问： 书是对象吗 (2)对象是无序键值对的集合，其属性可以包含基本值、对象或者函数 每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型 什么是面向对象？面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目 面向对象与面向过程： 面向过程就是亲历亲为，事无巨细，有条不紊，面向过程是解决问题的一种思维方式，（执行者的角度） 关注点在于解决问题的过程（先xx，然后xx，在xx） 面向对象就是找一个对象，让她去做这件事情（指挥者的角度） 关注点在找到能解决问题的对象上 面向对象不是面向过程的替代，而是面向过程的封装 面向对象的特性： 封装性 将功能的具体实现，全部封装到对象的内部，外界使用对象时，只需要关注对象提供的方法如何使用，而不需要关心对象的内部具体实现，这就是封装 继承性 在 js 中，继承的概念很简单，一个对象没有的一些属性和方法，另外一个对象有，拿过来用，就实现了继承 注意：在其他语言里面，继承是类与类之间的关系，在 js 中，是对象与对象之间的关系 [多态性] 多态是在强类型的语言中才有的；js 是弱类型语言，所以 js 不支持多态 创建对象的方式内置构造函数创建我们可以直接通过 new Object() 创建： // 在 js 中，对象有动态特性，可以随时的给一个对象增加属性或者删除属性var person = new Object()person.name = 'zs'person.age = 18person.sayName = function () &#123; console.log(this.name)&#125; 缺点：麻烦，每个属性都需要添加 对象字面量创建var person = &#123; name: 'zs', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125; 缺点：无法批量生成多个对象，代码冗余 简单改进：工厂函数我们可以写一个函数，解决代码重复问题 function createPerson (name, age) &#123; return &#123; name: name, age: age, sayName: function () &#123; console.log(this.name) &#125; &#125;&#125; 然后生成实例对象： var p1 = createPerson('zs', 18)var p2 = createPerson('ls', 18) 缺点：没有解决对象识别的问题，创建出来的对象都是Object类型的 继续改进：自定义构造函数构造函数是一个函数，用于实例化对象，需要配合 new 操作符使用 function Person (name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125;&#125;var p1 = new Person('zs', 18)p1.sayName() // zsvar p2 = new Person('ls', 23)p2.sayName() // ls 构造函数的缺点使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题： function Person (name, age) &#123; this.name = name this.age = age this.sayHello = function () &#123; console.log('hello' + this.name) &#125;&#125;var p1 = new Person('zs', 18)var p2 = new Person('ls', 16)console.log(p1.sayHello === p2.sayHello) // false 解决方案： function sayHello() &#123; console.log('hello ' + this.name)&#125;function Person (name, age) &#123; this.name = name this.age = age this.sayHello = sayHello&#125;var p1 = new Person('zs', 18)var p2 = new Person('ls', 16)console.log(p1.sayHello === p2.sayHello) // true 缺点：会暴漏很多的函数，容易造成全局变量污染 术语： 实例（实例对象）：通过构造函数创建出来的对象，叫做实例，实例可以有多个 实例化：构造函数创建对象的过程 成员：对象的属性和方法 原型原型基本概念Javascript 规定，每一个函数都有一个 prototype 属性，属性值是一个对象，这个对象就叫做原型（原型对象），这个对象的所有属性和方法，都会被构造函数的实例继承 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上 function Person (name, age) &#123; this.name = name this.age = age&#125;console.log(Person.prototype)Person.prototype.sayName = function () &#123; console.log(this.name)&#125;var p1 = new Person(...)var p2 = new Person(...)console.log(p1.sayName === p2.sayName) // true 这时所有实例的 sayName() 方法，其实都指向同一个内存地址 __proto__任意对象都有 __proto__ 属性，这个属性指向了构造函数的 prototype 属性，也就是原型对象 获取原型对象： 通过 构造函数.prototype 可以获取 通过 实例.__proto__ 可以获取（隐式原型） 它们指向了同一个对象 构造函数.prototype === 实例.__proto__ 注意：__proto__是浏览器的一个隐藏（私有）属性，IE浏览器不支持，不要通过它来修改原型里的内容，如果要修改原型中的内容，使用 构造函数.prototype 去修改 constructor 属性默认情况下，原型对象中只包含了一个属性：constructor，constructor 属性指向了当前原型对象的构造函数 function Person () &#123;&#125;console.log(Person.prototype)console.log(Person.prototype.constructor) // 构造函数本身var p = new Person()console.log(p)// p 实例对象没有constructor 属性， 该属性来源于原型上console.log(p.constructor == Person.prototype.constructor) // true 构造函数、实例、原型三者之间的关系构造函数：构造函数就是一个函数，配合 new 可以新建对象 实例：通过构造函数实例化出来的对象我们把它叫做构造函数的实例。一个构造函数可以有很多实例 原型：每一个构造函数都有一个属性prototype，函数的 prototype 属性值就是原型。通过构造函数创建出来的实例能够直接使用原型上的属性和方法 原型三角关系： 构造函数和原型：配偶关系 构造函数（妈妈），通过 prototype 属性访问原型（爸爸） 原型通过 constructor 属性访问到构造函数 构造函数 和 实例对象：母子关系 构造函数可以创建实例对象 实例对象不能直接访问到构造函数 原型 和 实例对象关系：父子关系 实例对象可以直接访问到原型上的所有成员 实例对象可以间接的访问到构造函数（通过原型上的 constructor 属性） 原型链原型链概念任何一个对象，都有原型对象，原型对象本身又是一个对象，所以原型对象也有自己的原型对象，这样形成的链式结构，就是原型链 绘制对象的原型链结构： var p = new Person()// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; nullvar o = new Object()// o ==&gt; Object.prototype ==&gt; nullvar arr = new Array()// arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; nullvar date = new Date()// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null// Math 是个内置对象，不是个构造函数// Math ==&gt; Object.prototype ==&gt; null 总结：Object.prototype 是原型链的尽头，Object.prototype 的原型是 null 属性查找原则属性搜索（查找）原则： 沿着原型链进行查找 首先在当前对象上查找是否有该属性，如果有，直接返回属性值 如果没有，去对象的原型上查找，如果有，直接返回属性值 如果也没有， 沿着原型链进行查找，直到 Object.prototype ，如果找到了，就返回属性值，如果还没有，返回 undefined 属性修改（设置）原则： 只会修改对象自身的属性 如果自身没有这个属性，那么就会添加这个属性，并不会修改原型中的属性 function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype.name = 'zs'Object.prototype.gender = 'male'var p = new Person('ls', 19)var p1 = new Person()console.log(p)// p 的原型链：// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; nullconsole.log(p.name) // lsconsole.log(p.age) // 19console.log(p.gender) // maleconsole.log(p.sex) // undefinedconsole.log(p1.name) // undefinedconsole.log(p1.age) // undefined// p1 对象依旧有 name 和age 属性， 只不过属性值都是 undefinedconsole.log(p1.gender) // maleconsole.log(p1.sex) // undefinedp.gender = '不详'console.log(p.gender) // 不详p.name = 'ww'console.log(p.name) // ww Object.prototype 成员介绍 任何对象的原型链上都有 Object.prototype，根据属性搜索原则(沿着原型链进行查找)，任何对象都可以访问到 Object.prototype 上的成员 constructor：指向了构造函数 Object hasOwnPropertyhasOwnProperty() 方法会返回一个布尔值，判断对象自身是否具有该属性 var obj = &#123; name: 'zs'&#125;// 判断name属性是不是obj自己提供的console.log(obj.hasOwnProperty('name')) // trueconsole.log(obj.hasOwnProperty('toString')) // false hasOwnProperty 与 in 的区别 in 操作符：判断对象能否访问到该属性（不管这个属性是自己提供的，还是从原型上继承来的），如果可以访问到， 都会返回 true hasOwnProperty：该属性必须是自己提供，才返回 true，否则返回 false hasOwnProperty 的使用场景：用在for…in 循环中 for (var k in p) &#123; // 可以遍历到对象自身的属性以及对象原型链上的属性 console.log(k) // 只遍历得到对象自身的属性，if 条件过滤下 // if (p.hasOwnProperty(k)) &#123; // console.log(k) // &#125;&#125; isPrototypeOfisPrototypeOf() 方法用于测试一个对象是否存在于另一个对象的原型链上 // 判断 A 对象是否在 B 对象的原型链上// 返回值：true，在原型链上 false：不在原型链上A.isPrototetypeOf(B)function Person () &#123;&#125;var p = new Person()// p 的原型链：// p ==&gt; Person.prototype ==&gt; Object.prototype ==&gt; nullconsole.log(Person.isPrototypeOf(p)) // false Person 是构造函数console.log(Person.prototype.isPrototypeOf(p)) // trueconsole.log(Object.prototype.isPrototypeOf(p)) // true isPropertyOf 与 instanceof 运算符的区别 instanceof 运算符用来测试一个对象的原型链中是否存在一个构造函数的 prototype 属性。作用和isPrototypeOf 类似 语法： 实例对象 instanceof 构造函数 作用：构造函数的 prototype 属性是否在实例对象的原型链上 A.isPrototypeOf(B) 判断A是否在B的原型链上 A： 是一个原型对象 B instanceof A 判断A的prototype是否在B的原型链上 A：是一个构造函数 console.log(Array.isPrototypeOf([])) // falseconsole.log(Array.prototype.isPrototypeOf([])) // trueconsole.log([] instanceof Array) // trueconsole.log([] instanceof Array.prototype) // 语法错误，instanceof 的右边是个构造函数 propertyIsEnumerablepropertyIsEnumerable() 方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性 function Person (name) &#123; this.name = name&#125;Person.prototype.age = 19var p = new Person('lw')console.log(p.propertyIsEnumerable('name')) // trueconsole.log(p.propertyIsEnumerable('age')) // false 拓展：给对象添加不可遍历的属性 : Object.defineProperty() // 语法： Object.defineProperty(obj, prop, desc)// 参数：// obj： 给哪个对象添加属性// prop：属性， 类型是字符串// desc： 属性描述符， 类型是个对象// 作用： 定义对象的属性特征var obj = &#123; name: 'zs', age: 19&#125;// 给obj 添加一个不可遍历的 gender 属性Object.defineProperty(obj, 'gender', &#123; value: 'female', // 配置该属性的默认值 writable: true, // 配置该属性是否可以被修改， 默认值是false， 不可修改 enumerable: true // 配置该属性是否可遍历， 默认值是false， 不可遍历&#125;)obj.gender = 'male'console.log(obj)console.log(obj.propertyIsEnumerable('gender')) // false toString/toLocaleString返回对象的字符串格式 每个内置对象的原型上都有属于自己的 toString 方法 var obj = &#123; name: 'zs', age: 19&#125;// obj ==&gt; Object.prototype ==&gt; nullconsole.log(obj.toString()) // '[object Object]'console.log(obj.toLocaleString()) // '[object Object]'var arr = [1, 2, 3]// arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; null// toString() toString()console.log(Array.prototype) // 含有自己的 toString 方法console.log(arr.toString()) // '1,2,3'console.log(arr.toLocaleString()) // '1,2,3'var date = new Date()// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; null// toString() toString()console.log(Date.prototype) // 含有自己的 toString 方法console.log(date.toString()) // Wed Oct 10 2018 16:00:51 GMT+0800 (中国标准时间)console.log(date.toLocaleString()) // 2018/10/10 下午4:00:51 得到的是本地时间格式 valueOf语法： 对象.valueOf() 作用： 返回对象的原始值（简单数据类型），默认的 valueOf 方法（Object.prototype 上的valueOf 方法）只会返回对象自身；日期对象的 valueOf 方法返回的是时间戳，因为 Date 的原型链上有自己的 valueOf 方法，该valueOf 的作用就是返回日期的时间戳 var obj = &#123; name: 'zs', age: 19&#125;// obj ==&gt; Object.prototype ==&gt; nullconsole.log(obj.valueOf()) // objvar arr = [1,2,3]// arr ==&gt; Array.prototype ==&gt; Object.prototype ==&gt; nullconsole.log(arr.valueOf()) // arrvar date = new Date()// date 原型链// date ==&gt; Date.prototype ==&gt; Object.prototype ==&gt; nullconsole.log(Date.prototype) // 含有 valueOf 方法console.log(date.valueOf()) // 时间戳 valueOf 和 toString 的应用当对象在参与运算和比较的时候，js 内部会自动的调用 valueOf 和 toString 方法 调用规则： 默认先调用 vauleOf， 尝试将对象转成简单数据类型， 如果没有转成简单数据类型， 会继续在调用 toString 方法 如果 valueOf 和 toString 方法都没有转成简单数据类型，会报错 沙箱模式沙箱其实就是一个独立的环境，这个环境中任何的改变，都不会对外部环境产生影响 函数自调用一样，在自调用函数内部的变量是不会影响到外部的，因此函数自调用模式也叫沙箱模式 (function(window)&#123; var fn = function()&#123; console.log("这是fn函数"); &#125;&#125;)(window); 代码写在自调用函数里面，减少全局污染 想要在外面使用 fn 函数，可将 fn 暴露到全局 window.fn = fn; 将fn函数的地址赋值给了 window上的 fn 属性 一般，我们一个js文件只会暴露一个核心的功能（函数、方法）： 目的还是为了减少全局污染 严格模式 语法：&#39;use strict&#39; 作用：让js引擎以更加严格的模式执行js代码 最佳实践：在某个函数内部开启严格模式，而不是在全局环境中开启 注意： 严格模式只对当前作用域起作用 应该在当前作用域最顶端使用use strict，否则严格模式无效 使用严格模式好处： 规范 提高代码执行效率 // 严格模式应该配合沙箱模式一起使用。// 沙箱模式 + 严格模式：(function () &#123; 'use strict'&#125;)() 严格模式规定 变量必须显示声明 函数参数不能重名 禁止使用八进制 不能使用保留字作为变量名称：implements, interface, let, package, private, protected, public, static, yield 如果不符合上述规范，会直接报错 继承 继承：子承父业 在 js 中的继承概念非常简单，拿来主义：一个对象自己没有的属性和方法，另一个对象有，拿过来使用，就实现了继承。 继承的目的：让一个对象可以使用另一个对象的属性和方法。 混入式继承（mixin） 把一个对象中的属性和方法拷贝到另一个对象中。 var ls = &#123; name: 'zs', extend: function (obj) &#123; // 只拷贝对象obj自身的成员，原型链上的成员不用拷贝给this if (obj.hasOwnProperty(k)) &#123; this[k] = obj[k] &#125; &#125;&#125; 原型链继承一个对象可以访问构造函数的原型中的属性和方法，那么如果想要让一个对象增加某些属性和方法， 只需要把这些属性和方法放到原型对象中即可。这样就实现了继承, 称之为原型链继承 直接给原型增加属性和方法 原型替换（注意：constructor） mixin+原型替换 function Person () &#123;&#125;// 1. 直接给原型增加属性和方法（麻烦）Person.prototype.color = 'lime'Person.prototype.legs = 2Person.prototype.sayHi = function () &#123; console.log('sayHi')&#125;// 2. 原型替换，将原型替换成一个对象Person.prototype = &#123; // 手动添加一个constructor属性，如果不手动添加，会找到 Object 的 constructor 属性 constructor: Person, color: 'lime', legs: 2, sayHi: function () &#123; console.log('sayHi') &#125;&#125;// 3. 原型链 + 混入式继承function Person () &#123;&#125;var lw = &#123; skill: '翻墙'&#125;// 给原型添加 extend 方法 -- 混入式继承Person.prototype.extend = function (obj) &#123; for (var k in obj) &#123; if (obj.hasOwnProperty(k)) &#123; this[k] = obj[k] &#125; &#125;&#125;// 把 lw 的成员添加到了 Person 的原型上， Person 的实例就可以访问到原型上的这个成员Person.prototype.extend(lw)console.log(Person.prototype)var p = new Person()console.log(p.skill) Object.create 最初是由道格拉斯丶克罗克福德发布的一篇文章提出的，ECMAScript5 新增了 Object.create() 方法来规范化了这种继承 ES5 中新增了一个方法 Object.create()，方法会使用指定的原型对象及其属性去创建一个新的对象 // 参数：proto 一个对象// 返回值：obj 新对象，新对象的原型就是 protovar obj = Object.create(proto)console.log(obj) 函数进阶定义函数的三种方式函数声明fn() // 函数声明可以先调用，在声明function fn () &#123; console.log('这是函数声明')&#125; 函数表达式var fn = function () &#123; console.log('这是函数表达式')&#125;fn() // 函数表达式必须先声明，再调用 构造函数 Function// 函数也是对象，可以使用 Function 构造函数 new 出来// 相当于var fn = function () &#123;&#125;var fn = new Function()// 语法：new Function(arg1,arg2,arg3..,body)// 1. 所有的参数都是字符串类型// 2. 前面可以定义任意多个形参，最后一个参数是代码体var fn = new Function('alert(1)')fn()var fn1 = new Function('a1', 'a2', 'alert(a1 + a2)')fn1(1, 2) 【案例：代码实时预览效果.html】 eval 函数–了解 eval 可以和 new Function 一样，执行字符串代码 注意：eval 函数的功能非常的强大，但是实际使用的情况并不多。 eval('var num = 10; console.log(num)') // 10 eval 形式的代码难以阅读 eval 形式的代码无法打断点，因为本质还是还是一个字符串 在浏览器端执行任意的 JavaScript 会带来潜在的安全风险，恶意的 JavaScript 代码可能会破坏应用，特别是在用它执行用户输入数据的情况下。可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）推荐了解下xss攻击 函数的四种调用模式分析 this 的指向问题 任何函数都有属于自己的 this this 是动态的，this 在函数声明的时候是确定不了的，只有当函数被调用了才能够确定 this 的指向，this 的指向和函数在哪被调用没有关系 分析 this 的问题的思路： this 是属于哪个函数 这个函数是何种调用模式 函数：当一个函数不是一个对象的属性时，我们称之为函数方法：当一个函数被保存为对象的一个属性时，我们称之为方法 函数调用模式如果一个函数不是一个对象的属性时，就是被当做一个函数来进行调用的。此时 this 指向了 window // 函数名() 的调用方式function fn () &#123; console.log(this) // 指向window&#125;fn() 方法调用模式当一个函数被保存为对象的一个属性时，我们称之为一个方法。当一个方法被调用时，this 被绑定到当前对象 // 通过点语法或者中括号语法来访问方法，都是属于方法调用模式var f = function () &#123; console.log(this)&#125;var obj = &#123; a: 1, fn: f&#125;obj.fn() // objobj['fn']() // objvar arr = [f, 10, 30]// 也是方法调用模式arr[0]() // arr 构造函数调用模式如果函数是通过 new 关键字进行调用的，此时 this 被绑定到创建出来的新对象上 function Person () &#123; console.log(this)&#125;Person() // this 指向 windowvar p = new Person() // this 指向 p 总结：分析 this 的问题，主要就是区分函数的调用模式，看函数是怎么被调用的 // 分析思路：1. 看 this 是哪个函数的 2. 看这个函数是怎么调用的，处于什么调用模式// 1.var age = 38var obj = &#123; age: 18, getAge: function () &#123; console.log(this.age) &#125;&#125;var f = obj.getAgef() // window ==&gt; 38// 2.var age = 38var obj = &#123; age: 18, getAge: function () &#123; console.log(this.age) // obj ==&gt; 18 function foo () &#123; console.log(this.age) // window ==&gt; 38 &#125; foo() &#125;&#125;obj.getAge()// obj['getAg']()// 3.var length = 10var age = 18function fn () &#123; console.log(this.length)&#125;var arr = [fn, '222']fn() // 10arr[0]() // 2// 4.var length = 10function fn () &#123; console.log(this.length)&#125;var obj = &#123; length: 5, method: function (fn) &#123; fn() // window ==&gt; 10 arguments[0]() // argument ==&gt; 3 &#125;&#125;obj.method(fn, 10, 5) 方法借用模式 上下文调用模式也叫方法借用模式，分为 apply，call ，bind 使用方法：函数.call() 或者 函数.apply() 任何函数都可以调用 apply，call ，bind 这三个方法 call 方法call 方法可以调用一个函数，并且可以指定这个函数的 this 指向 // call 方法也可以和 () 一样，进行函数调用// 第一个参数：指定函数的 this，如果不传，则 this 指向 window// 其余参数：和函数的参数列表一模一样var zs = &#123; name: 'zs', sayHi: function () &#123; console.log('hello ,我是' + this.name) &#125;&#125;// zs.sayHi()var ls = &#123; name: 'ls'&#125;// ls 借用 zs 的 sayHi 方法zs.sayHi.call(ls) 伪数组与数组 伪数组也叫类数组 伪数组其实就是一个对象，但是跟数组一样，伪数组也会有length属性，也有0, 1, 2, 3等属性 伪数组并没有数组的方法，不能使用push/pop等方法 伪数组可以跟数组一样进行遍历，通过下标操作 常见的伪数组：arguments、document.getElementsByTagName的返回值、jQuery对象 var obj = &#123; 0: 'zs', 1: 'ls', 2: 'ww', length: 3&#125; 伪数组借用数组的方法 // 给 obj 添加一项 3: 'zl'Array.prototype.push.call(obj, 'zl')// 把 obj 中的每一项使用 '-' 拼接起来返回一个字符串Array.prototype.join.call(obj, '-') 将伪数组转换成真数组 var arr = Array.prototype.slice.call(obj) apply 方法apply 的语法：apply(thisArg, 实参列表)thisArg ==&gt; 改变函数内的 this 指向的实参列表 ==&gt; 是一个数组或者是伪数组 apply()方法的作用和 call()方法类似，只有一个区别，就是apply()方法接受的是一个包含多个参数的数组。而call()方法接受的是若干个参数的列表 // 1. apply 能够调用函数function fn () &#123; console.log(1)&#125;fn.apply() // 1// 2. apply 改变 this 指向function fn () &#123; console.log(this)&#125;fn.apply([10, 20, 30]) // [10, 20, 30]// 3. apply 第二个参数是数组function fn (n1, n2) &#123; console.log(this) console.log(n1 + n2)&#125;fn.apply(&#123; name: 'zs' &#125;, [10, 20]) // &#123;name: 'zs'&#125;, 30// apply 的特性： 平铺性，把数组中的每一项取出来作为函数的实参// fn.call(&#123;name: 'ls'&#125;, 10, 20) // &#123;&#125;, 30 call 和 apply 的使用场景： 如果参数比较少，使用 call 会更加简洁 如果参数存放在数组中，此时需要使用 apply 课后练习： 求数组的最大值和最小值封装一个函数，能够打印出来所有的参数 bind 方法*bind() *方法创建一个新的函数、可以绑定新的函数的this指向 // 返回值：新的函数(不会被调用)// 参数：新函数的 this 指向，当绑定了新函数的 this 指向后，无论使用何种调用模式，this 都不会改变// var newFn = fn.bind(window)var fn = function () &#123; console.log(this)&#125;var newFn = fn.bind([1, 2, 3])// newFn 是 bind 创建并返回出来的console.log(newFn)newFn() // this ==&gt; [1,2,3] 几种特殊的 this 指向 定时器中的 this 指向了window，因为定时器的 function 最终是由 window 来调用的 事件中的 this 指向的是当前的元素，在事件触发的时候，浏览器让当前元素调用了 function 函数也是对象 函数是由 new Function 创建出来的，因此函数也是一个对象，所有的函数都是 new Function 的实例 函数的原型链结构// 内部：var Person = new Function()function Person () &#123;&#125;// Person 实例对象的原型链：// Person ==&gt; Function.prototype ==&gt; Object.prototype ==&gt; null// Function.prototype 原型类型是个函数console.dir(Function.prototype) Function.prototype 成员 arguments：获取函数的实参，已经被废弃了，现在推荐的做法是使用函数内部可用的 arguments对象来访问函数的实参 （废弃的意思：已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性） length：获取形参的长度 name：获取函数的名字，此属性不允许修改 caller: 用于获取当前函数是在哪个函数中调用的，已经被废弃了 constructor：指向当前构造函数，Function call：调用函数，重新指定 this apply：调用函数，重新指定 this bind：重新指向 this，返回一个新的函数，不调用 toString : 得到函数的字符串格式 案例【封装getType函数（获取数据类型）】 function getType (obj) &#123; return Object.prototype.toString.call(obj).slice(8, -1) // '[object 构造函数]'&#125; 完整版原型链 绘制完整版原型链的目的是辅助大家理解 js 中对象的继承关系 总结： 所有函数都是 new Function 创建出来的，因此 所有函数.__proto__ 都是 Function.prototype 所有对象都是 new Object 创建出来的，因此 所有对象.__proto__ 都是 Object.prototype 作用域与预解析作用域 作用域：变量起作用的区域，也就是说：变量定义后，可以在哪个范围内使用该变量 全局作用域 ：在script标签内，函数外的区域就是全局作用域，在全局作用内声明的变量叫做全局变量 。全局变量可以在任意地方访问。（if/while/for 语句中声明的变量也是全局变量） 函数作用域 ：在函数内的区域叫做函数作用域，在函数作用域内声明的变量叫做局部变量 ，局部变量只有在当前函数内才能访问到。 自由变量：对于一个函数来说，函数内部没有声明该变量，但在函数内部有访问该变量。对于这个函数来说， 该变量就是一个自由变量。 隐式全局变量：没有使用 var 定义的变量也是全局变量，叫做隐式全局变量。(不要使用) var num = 11function fn() &#123; var num1 = 22 num2 = 33 num = 33 console.log(num1)&#125;fn()console.log(num)// console.log(num1)console.log(num2) 变量的查找规则： 函数内部可以使用函数外部的变量 有局部变量就用局部变量，没有局部变量就用全局变量。 函数作用域是在函数定义的时候作用域就确定下来了，和函数在哪调用无关 var num = 123function f1 () &#123; console.log(num)&#125;function f2 () &#123; var num = 456 f1()&#125;f2() // 123var num = 10var num1 = 10function test()&#123; var num = 20 num = 30 // num 在局部声明过，只能修改局部的 num 值 num1 = 20 // 修改全局的 num1 值 var num2 = 40 num3 = 50 // 隐式全局 console.log(num) // 30 console.log(num1) // 20 console.log(num2) // 40 console.log(num3) // 50&#125;test()console.log(num) // 10console.log(num1) // 20// 如果 test 函数没执行过，则 num1 值为 10console.log(num3) // 50console.log(num2) // 报错 作用域链作用域链：只要是函数，就会形成一个作用域，如果这个函数被嵌套在其他函数中，那么外部函数也有自己的作用域，这个一直往上到全局环境，就形成了一个作用域链 变量的搜索原则： 从当前作用域开始查找是否声明了该变量，如果存在，那么就直接返回这个变量的值 如果不存在，就会往上一层作用域查询，如果存在，就返回 如果不存在，一直查询到全局作用域，如果存在，就返回。如果在全局中也没有找到该变量会报错 // 1.var num = 10fn1()function fn1 () &#123; console.log(num) // undefined var num = 20 console.log(num) // 20&#125;console.log(num) // 10// 2 -- 改造上面的面试题var num = 10fn1()function fn1 () &#123; console.log(num) // 10 num = 20 console.log(num) // 20&#125;console.log(num) // 20// 3var num = 123function f1 (num) &#123; console.log(num) // 456 undefined&#125;function f2 () &#123; var num = 456 f1(num) f1()&#125;f2()// 4var num1 = 10var num2 = 20function fn (num1) &#123; num1 = 100 num2 = 200 num3 = 300 console.log(num1) // 100 console.log(num2) // 200 console.log(num3) // 300 var num3&#125;fn()console.log(num1) // 10console.log(num2) // 200console.log(num3) // error// 5var num = 1function fn () &#123; var num = 100 num++ console.log(num)&#125;fn() // 101fn() // 101console.log(num) // 1// 6.var color = 'red' // bluefunction outer () &#123; var anotherColor = 'blue' // red function inner () &#123; var tmpColor = color // red color = anotherColor anotherColor = tmpColor // red console.log(anotherColor) // red &#125; inner()&#125;outer()console.log(color) // blue 预解析 预解析：预先解析 js执行代码分为两个过程： 预解析过程（变量与函数提升） 代码一行一行执行 预解析过程：JavaScript 解析器在执行代码前，会把所有变量的声明和函数的声明提升到当前作用域的顶部。例如var a = 11其实会分为var a 和a = 11两部分，其中var a;会被提升 预解析规则 : var 声明的变量：只提升声明，不会提升赋值 函数声明：整体提升 先提升 var 声明的变量，后提升函数声明 遇到重名的 var 声明， var 声明会被忽略，值会保留 遇到重名的函数声明，后者会覆盖前者 如果 var 声明和函数声明同名，函数声明会把 var 声明覆盖 // 函数预解析// 1.function fn() &#123; console.log(a) // undefined&#125;fn()var a = 1// 2.var n = 45function fn5() &#123; console.log(n) // undefined n = 20 console.log(n) // 20 var n = 0 console.log(n) // 0&#125;fn5()console.log(n) // 45// 3.console.log(b) // 函数体var b = 23function b() &#123; console.log(b)&#125;console.log(b) // 23// b() // 报错// 4.console.log(c) // 函数体c() // 嘿嘿var c = function() &#123; comsole.log('哈哈')&#125;function c() &#123; console.log('嘿嘿')&#125;// 5.console.log(fn1) // 函数体fn1()function fn1() &#123; console.log('哈哈') // 哈哈&#125;console.log(fn2) // undefinedfn2() // 报错var fn2 = function() &#123; console.log('嘿嘿')&#125;// 对于函数表达式，函数的调用必须在表达式声明之后fn2() // 嘿嘿// 6.// 只有用 var 声明的变量才会预解析console.log(d) // 报错d = 5// 7.console.log(e)console.log(f) // 报错var e = f = 10console.log(f) // 10// 8.if ('a' in window) &#123; var a = 'abc'&#125;console.log(a) // abc 不要在一个作用域内重复的声明相同的变量和函数 递归函数 递归函数：函数内部直接或者间接的调用自己 递归的要求： 自己调用自己（直接或者间接） 要有结束条件（出口） 递归函数主要是化归思想，将一个复杂的问题简单化，主要用于解决数学中的一些问题居多。 把要解决的问题，归结为已经解决的问题上。 一定要考虑什么时候结束让函数结束，也就是停止递归（一定要有已知条件） 练习： // 1. 计算1-100之间所有数的和// 2. 计算斐波那契数列function fn(n) &#123; if (n == 1 || n == 2) &#123; return 1 &#125; return fn(n - 1) + fn(n - 2)&#125;console.log(fn(12)) 实现缓存 缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据 计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。 初级优化： 使用缓存的基本步骤： 如果要获取数据，先查询缓存，如果有就直接使用 如果没有，就进行计算，并且将计算后的结果放到缓存中，方便下次使用。 // 缓存var arr = []var fbi = function (n) &#123; count++ if (n === 1 || n === 2) &#123; return 1 &#125; if (arr[n]) &#123; return arr[n] &#125; else &#123; var temp = fbi(n - 1) + fbi(n - 2) arr[n] = temp // 存入缓存 return temp &#125;&#125; 缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。 闭包闭包的基本概念闭包（closure）是 JavaScript 语言的一个难点，也是 JavaScript 的一个特色，很多高级的应用都要依靠闭包来实现 闭包是函数和声明该函数的词法环境的组合 在JavaScript中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，产生闭包 *闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用 * 产生闭包的条件：有两个函数，是嵌套关系，内部函数引用了外部函数的变量，这样就会形成闭包 闭包的作用： 私有变量，保护数据安全 持久化维持数据 // 闭包的基本模型function outer ()&#123; var num = 10 // function inner () &#123; // num++ // console.log(num) // &#125; // return inner // 把inner函数给返回出去，让外部能够调用inner函数 // 上面的简写 return function () &#123; num++ console.log(num) &#125;&#125; 闭包的应用计数器需求：统计一个函数的调用次数 var count = 0function fn () &#123; count++ console.log('我被调用了，调用次数是' + count)&#125;fn()fn()fn()// 缺点：count是全局变量，不安全 使用闭包解决这个问题！！！！ function outer () &#123; var count = 0 // 私有变量, 将 count 保护起来了 function add () &#123; count++ console.log('当前count' + count) &#125; return add&#125;var result = outer()result() 【案例：银行存钱取钱】 缓存的私有化 缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据。 计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。 缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。 function outer () &#123; // 缓存 var arr = [] var fbi = function (n) &#123; if (n == 1 || n == 2) &#123; return 1 &#125; if (arr[n]) &#123; return arr[n] &#125; else &#123; var temp = fbi(n - 1) + fbi(n - 2) arr[n] = temp //存入缓存 return temp &#125; &#125; return fbi&#125;var fbi = outer()console.log(fbi(40)) 闭包存在的问题 正常情况下：函数在调用的时候，去开辟一块内存空间用来执行内部的代码，当函数调用结束的时候，要销毁开辟的空间，节省内存 闭包占用的内存是不会被释放的，因此，如果滥用闭包，会造成内存泄漏的问题。闭包很强大，但是只有在必须使用闭包的时候才使用 js的垃圾回收机制(了解) 内存：计算机中所有程序的运行都是在内存 中进行的，因此内存的性能对计算机的影响非常大，运行程序需要消耗内存，当程序结束时，内存会得到释放。 javascript 分配内存：当我们定义变量，javascript 自动分配内存存储数据。无论是值类型或者是引用类型，都需要存储在内存中。 垃圾回收：当代码执行结束，分配的内存已经不需要了，这时候需要将内存进行回收，在 javascript语言中，垃圾回收机器会帮我们回收不再需要使用的内存。 引用记数法清除引用记数垃圾收集：如果没有引用指向某个对象（或者是函数作用域），那么这个对象或者函数作用域就会被垃圾回收机制回收。 var o = &#123; name: 'zs'&#125;// 对象被 o 变量引用，引用记数 1var obj = o // 变量被 o 和 obj 引用，引用记数 2o = 1 // o 不在引用对象了，引用记数 1obj = null // obj 不在引用对象了，引用记数 0，可以被垃圾回收了 引用计数法无法解决循环引用导致的内存泄露 function fn () &#123; var obj1 = &#123;&#125; // 引用计数为 2 var obj2 = &#123;&#125; // 引用计数为 2 obj1.a = obj2 obj2.b = obj1&#125;fn() // 销毁fn调用开辟的空间， 但是由于引用计数考虑到两个对象都不是零引用的对象，就不能够被垃圾回收机制给回收掉 标记清除法清除使用引用计数法进行垃圾回收的时候，会出现循环引用导致内存泄漏的问题。因此现代的浏览器都采用标记清除法来进行垃圾回收。 这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象 Window）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。 从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。 闭包占用内存释放当闭包的功能不在需要使用了，将这个变量指向 null， 这样闭包占用的内存就可以被回收掉了 function outer () &#123; var count = 0 function fn () &#123; count++ console.log('执行次数' + count) &#125; return fn&#125;var result = outer()result()result = null // 当函数 fn 没有被变量引用了，那么函数 fn 就会被回收，函数 fn 一旦被回收，那么 outer调用形成的作用域也就得到了释放 正则表达式 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串（数据验证）、将匹配的子串替换（数据删除或替换）或者从某个串中取出符合某个条件的子串等（数据提取） 创建正则表达式 构造函数的方式 // RegExp(regular expression)var reg = new RegExp(/a/) // 匹配字母中有 a 正则字面量 var reg = /a/ 正则有 test 方法，作用是测试字符串是否符合正则表达式的规律，如果符合， 返回 true console.log(reg.test('abc')) // trueconsole.log(reg.test('def')) // false 元字符 正则表达式由一些普通字符和元字符组成，普通字符包括大小写字母、数字等，而元字符则具有特殊的含义 常见元字符\d 匹配一个数字字符。等价于 [0-9] \D 匹配一个非数字字符。等价于 [^0-9] \w 匹配包括下划线的任何单词字符。等价于[A-Za-z0-9_] \W 匹配任何非单词字符。等价于 [^A-Za-z0-9_] \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [\f\n\r\t\v] \S 匹配任何非空白字符。等价于 [^\f\n\r\t\v] \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， n 匹配字符 n。\n 匹配换行符。\\ 匹配 \，\( 则匹配 (。 . 匹配除换行符 \n 之外的任何单字符。要匹配包括 ‘\n’ 在内的任何字符，可用(.|\n) | 指明两项之间的一个选择。，优先级最低，| 的左右都是单独的整体 () 优先级最高，标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。使用 $0…$9 属性。要匹配这些字符，请使用 \( 和 \) 。每个()就是一个子匹配 ‘\1’和’$1’用来指定第一个子匹配 /f|boot/; // 匹配 `f` 和 `boot`/(f|b)oot/; // 匹配 `foot` 和 `boot` 空白字符 \f 匹配一个换页符 \n 匹配一个换行符 \r 匹配一个回车符 \t 匹配一个制表符 \v 匹配一个垂直制表符 字符类的元字符 [] 在正则表达式中表示 单个 字符的位置，[] 里面写这个位置可以出现的字符。 /[abc]/; // 匹配 a,b,c 任意一个字符 [^] 在中扩号中的 ^ 表示非的意思。 // ^ 在方括号表达式开头中使用，此时它表示不接受该字符集合/[^abc]/; // 匹配除了a，b，c以外的其他字符 [a-z] [1-9]表示范围 /[a-z]/; // 小写字母/[A-Z]/; // 大写字母/[0-9]/; // 数字/[a-zA-Z0-9]/; // 所有的小写字母和大写字母以及数字 边界类元字符 我们前面学习的正则只要有满足的条件的就会返回true，并不能做到精确的匹配。 ^ 匹配输入字符串的开始位置 $ 匹配输入字符串的结尾位置 /^chuan/; // 以chuan开头/chuan$/; // 以chuan结尾/^chuan$/; // 精确匹配 chuan//精确匹配chuan,表示必须是这个console.log(/^chuan$/.test("chuanchuan")); // fasle 以后表单校验要精确匹配 \b 匹配一个字边界，即字与空格间的位置。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。 Chapter：/\bCha/ : 匹配Chapter的开头三个字符/ter\b/ : 匹配Chapter的结尾三个字符 \B 表示非单词边界。位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt/\Bapt/ 量词类元字符 量词用来控制出现的次数，一般来说量词和边界会一起使用 * 匹配前面的子表达式零次或多次，等价于 {0,} + 匹配前面的子表达式一次或多次，等价于 {1,} ? 匹配前面的子表达式零次或一次，等价于 {0,1} 。当该字符紧跟在任何一个其他限制符 (*, +,?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串 {n} n 是一个非负整数。匹配确定的 n 次。 {n,} n 是一个非负整数。至少匹配 n 次。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 // &#123;&#125; 就近修饰单个字符console.log(/chuan&#123;2&#125;/.test("chuanchuan")); // falseconsole.log(/(chuan)&#123;2&#125;/.test("chuanchuan")); // trueconsole.log(/chuan&#123;2&#125;/.test("chuann")); // true 其他字符 g 全局标记，指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配 i 标记指定不区分大小写。表达式的结尾处 优先级从高到低的优先级顺序： \ 转义符 (), (?:) , (?=), [] 圆括号和方括号 *, + , ?, {n}, {n,}, {n,m} 限定符 ^, $, \任何元字符、任何字符 定位点和序列（即：位置和顺序） | 替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。 正则的使用字符串使用正则 replace() var str = " 123AD asadf asadfasf adf ";// 1. 替换掉字符串中的所有空白var str2 = str.replace(/\s/g, ""); // g: global, 全局搜索// 2. 将所有的ad替换成xxvar str2 = str.replace(/ad/g, "xx");// 3. 将所有的ad/AD替换成xxvar str2 = str.replace(/ad/gi, "xx"); // i： ignore 忽略大小写var str = "abc,efg,123,abc,123,a"// 4. 所有的逗号替换成句号var str2 = str.replace(/,/g , "。");var jsonStr = '[&#123;"name":"张三",score:80&#125;,&#123;"name":"张三",score:90&#125;,&#123;"name":"张三",score:81&#125;]';// 5. 把所有成绩都修改成100分var str2 = jsonStr.replace(/\d&#123;1,2&#125;/g, "100"); match() ==&gt; 匹配， 匹配符合正则表达式的字符 var str2 = "zs的手机号是18938383838, ls的手机号13989907890， ww的手机号是13848962389，zl的手机号是18970890908";// 需求： 匹配出来所有的手机号, 返回了一个数组var str3 = str2.match(/1[3-9]\d&#123;9&#125;/g);console.log(str3); 正则的方法 test() ==&gt; 测试字符串是否符合正则表达式的规律，符合，就返回true exec() ==&gt; 提取，提取字符串中符合正则表达式的字符，需要用括号分组， 如果没有进行分组，返回的是符合整个正则表达式的字符 var str = "今天是2018-10-16，我这里的需求是提取出年月日";// var reg = /\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;/; ==&gt; 符合整个正则表达式的字符var reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; // ==&gt; 有分组存在 ，默认组名为 undefinedvar reg2 = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/; // ?&lt;组名&gt; 添加组名var ret = reg.exec(str); // 提取出分组的内容以下标的形式存在返回的数组里面var ret2 = reg2.exec(str);console.log(ret);console.log(ret2);// index 代表 匹配到 ret 在 str 中的下标 实例 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 匹配所有小写字母 [-a-z] 或 [a-z-] 匹配所有小写字母和 - [A-Za-z0-9] 匹配任何大写字母小写字母和数字 \b([a-z]+)\1\b/gi 一个单词连续出现的位置。 将通用资源指示符 (URI) 分解为其组件 var str = "https://www.baidu.com:80/index.html";var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;arr = str.match(patt1);for (var i = 0; i &lt; arr.length ; i++) &#123; document.write(arr[i]); document.write("&lt;br&gt;");&#125;//https://www.baidu.com:80/index.html//https//www.baidu.com//:80///index.html]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery]]></title>
    <url>%2F2018%2Fjquery%2Fjquery%2F</url>
    <content type="text"><![CDATA[jQueryjQuery 基本介绍为什么要学 jQuery使用 JS 操作 DOM 的时候，会遇到以下的一些缺点： 获取元素的方法太少且长，麻烦 遍历伪数组很麻烦，通常要嵌套一大堆的 for 循环。注册的事件会覆盖 有兼容性问题 实现动画很麻烦 jQuery 初体验【让div显示与设置内容】 $(document).ready(function () &#123; $('#btn1').click(function () &#123; // 隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。 // show() 显示元素 $('div').show(200) &#125;) $('#btn2').click(function () &#123; // text() 设置文本内容 $('div').text('我是内容') &#125;) $('#btn3').click(function () &#123; // css(name, value); 设置样式 // name: 设置什么样式 // value ： 设置的值是多少 $('div').css('fontSize', 30) &#125;)&#125;) 使用 jQuery 的优点 获取元素的方式非常的简单，而且非常的丰富 jQuery 的隐式迭代特性，不再需要书写 for 循环语句 使用 jQuery 完全不用考虑兼容性问题 jQuery 提供了一系列动画相关的函数，使用非常方便 代码简单、粗暴 什么是 jQuery jQuery 是一个快速的、轻量的、功能丰富的 js 库 jQuery 的官网 http://jquery.com/ js 库：把一些常用到的方法写到一个单独的 js 文件，使用的时候直接去引用这 js 文件就可以了。（animate.js、common.js） 版本介绍官网下载地址：http://jquery.com/download/ jQuery 版本有很多，分为 1.x 2.x 3.x 大版本分类： 1.x 版本：能够兼容IE678浏览器（最终版本1.12.4）2.x 版本：不兼容IE678浏览器（最终版本2.2.4）3.x 版本：不兼容IE678，更加的精简（在国内不流行，因为国内使用 jQuery 的主要目的就是兼容IE678）,3.x 版本只是在原来的基础上增加了一些新的特性 关于压缩版和未压缩版 jquery.min.js：压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，采用了代码混淆，基本没有可阅读性 jquery.js：未压缩版本，适用于学习与开发环境，源码清晰，易阅读 入口函数入口函数的好处： 等待文档加载完成，不论代码是写在 body、head 中都可以正常去获取到元素 形成了一个沙箱，防止全局变量污染 两种写法： // 第一种写法$(document).ready(function () &#123;&#125;)// 第二种写法$(function () &#123;&#125;) 原生 JavaScript 的入口函数： window.onload = function () &#123;&#125; jQuery 入口函数与 js 入口函数的对比 JavaScript 的入口函数要等到页面中所有资源（包括图片、文件等外部资源）加载完成才开始执行。jQuery 的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。所以 jQuery 的入口函数要比 js 入口函数先执行 window.onload 存在覆盖问题；jq 的入口函数不存在覆盖问题 jQuery 使用步骤&lt;!-- 引包（引入js文件） --&gt;&lt;script src='jquery.js'&gt;&lt;/script&gt;&lt;script&gt; // 写上入口函数 $(document).ready(function () &#123;&#125;) // 或者 $(function () &#123; // 在入口函数内部实现功能 &#125;)&lt;/script&gt; jquery 中的 $ 符号$ 来源于 jQuery ， 是个函数（查看jQuery源码中最后几行代码） // jquery 和 $ 是等价的jQuery === $ // true 作用：根据参数的不同， 作用是不同的 参数是个函数 $(function(){}) 作用是入口函数 参数是个 dom 对象 $(document) 作用是 dom 转 jq 参数是选择器 $(&#39;body&#39;) 作用是获取元素 参数是个 html 字符串 $(&#39;&lt;a&gt;123&lt;/a&gt;&#39;) 作用是创建节点 jQuery 对象与 DOM 对象基本概念： DOM 对象：使用 JavaScript 中的方法获取页面中的元素返回的对象就是 Dom 对象 jQuery 对象：jquery 对象就是使用 jquery 的方法获取页面中的元素返回的对象 jQuery 对象其实就是 DOM 对象的包装集（包装了 DOM 对象的集合），是一个 伪数组 jQuery 对象与 DOM 对象的区别： DOM 对象与 jQuery 对象的方法不能混用。dom 对象不能使用 jq 对象的方法，jq 对象也不能使用 dom 对象的属性和方法 DOM 对象可以和 jQuery 对象可以相互转化 DOM 对象转换成 jQuery 对象：【联想记忆：花钱】 // 将 dom 对象作为参数传递到 $() 里面去， 那么这个整体就是个jq对象var $obj = $(domObj) jQuery 对象转换成 DOM 对象： // 通过 $() 来获取到的元素返回的对象就是jq对象var $li = $('li')// 第一种方法,通过下标取出（推荐使用）$li[0]// 第二种方法$li.get(0) 【练习：隔行变色案例】 选择器jQuery 选择器jQuery 选择器是 jQuery 为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery 选择器返回的是 jQuery 对象 jQuery 选择器有很多，基本兼容了 CSS1 到 CSS3 所有的选择器，并且 jQuery 还添加了很多更加复杂的选择器 css 选择器jQuery 完全兼容 css 选择器 名称 用法 描述 ID选择器 $(‘#id’) 获取指定 id 的元素 类选择器 $(‘.class’) 获取同一类 class 的元素 标签选择器 $(‘div’) 获取同一类标签的所有元素 并集选择器 $(‘div, p, li’) 使用逗号分隔，只要符合条件之一就可 交集选择器 $(‘div.redClass’) 获取 class 为 redClass 的 div 元素 子代选择器 $(‘ul&gt;li’) 使用 &gt; 号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(‘ul li’) 使用空格，代表后代选择器，获取 ul 下的所有 li 元素，包括孙子等 过滤选择器这类选择器都带冒号 : 名称 用法 描述 :eq(index) $(‘li:eq(2)’) 获取 li 元素中，选择索引号为 2 的元素，索引号 index 从 0 开始 :odd $(‘li:odd’) 获取 li 元素中，选择索引号为奇数的元素 :even $(‘li:even’) 获取 li 元素中，选择索引号为偶数的元素 :first $(‘li:first’) 获取 li 元素中的第一个 :last $(‘li:last’) 获取 li 元素中的最后一个 【案例：隔行变色】 筛选选择器(方法)筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器 主要是方法 名称 用法 描述 children(selector) $(‘ul’).children(‘li’) 获取当前元素的所有子元素中的 li 元素 find(selector) $(‘ul’).find(‘li’) 获取当前元素中的后代元素中的 li 元素 siblings(selector) $(‘#first’).siblings(‘li’) 查找兄弟节点，不包括自己本身 parent() $(‘#first’).parent() 查找父亲 parents() $(‘#first’).parents(‘’) 查找所有祖宗（参数 指定具体祖宗） eq(index) $(‘li’).eq(2) 相当于$(&#39;li:eq(2)&#39;)，index从 0 开始 next() $(‘li’).next() 找下一个兄弟 nextAll() $(‘li’).nextAll() 找后面所有的兄弟 prev() $(‘li’).prev() 找上一个兄弟 prevAll() $(‘li’).prevAll() 找前面所有的兄弟 【案例：下拉菜单】【案例：突出展示】【案例：手风琴】【案例：淘宝精品】 补充mouseover 与 mouseenter mouseover 和 mouseoverenter 都有鼠标经过的意思，但是在注册鼠标经过事件的时候，推荐使用mouseenter mouseenter 与 mouseover 的不同 mouseover 与 mouseout 是一对事件，当鼠标经过当前元素或者当前元素的子元素的时候，会触发【事件冒泡】。 mouseenter 与 mouseleave 是一对事件，只有当鼠标经过当前元素时，事件会触发，鼠标经过子元素，mousenter 事件是不会触发的 index 方法index() 方法返回的是当前元素在所有兄弟元素里面的索引 区分 jQuery 与 JavascriptJavaScript 是一门编程语言，jQuery 仅仅是用 JavaScript 实现的一个 JavaScript 库，目的是简化我们的开发 jQuery 样式操作css 操作功能：设置或者修改样式，操作的是 style 属性 设置单个样式 // name：需要设置的样式名称// value：对应的样式值css(name, value)// 使用案例$('#one').css('background', 'gray') // 将背景色修改为灰色 设置多个样式 // 参数是一个对象，对象中包含了需要设置的样式名和样式值css(obj)// 使用案例$('#one').css(&#123; background: 'gray', width: '400px', height: '200px'&#125;) 获取样式 // name: 需要获取的样式名称css(name)// 案例$('div').css('background-color') 注意： 设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值 获取操作的时候，如果是多个元素，那么只会返回第一个元素的值 class 操作 添加样式类 // 给所有的 div 添加 one 的样式$('div').addClass('one') 移除样式类 // 移除 div 中 one 类名$('div').removeClass('one') 判断是否有某个样式类 判断标准是： 只要有一个元素有指定的类名，就返回 true，所有的元素都没有该类名，就返回 false // 判断是否有 one 的样式类$('div').hasClass('one') 切换样式类 // 如果有，移除该类，如果没有，添加该类$('div').toggleClass('one') 【案例：tab栏切换案例.html】 jQuery 属性操作attr 操作设置单个属性 // 第一个参数：需要设置的属性名// 第二个参数：对应的属性值attr(name, value)// 用法举例$('img').attr('title', '哈哈') 设置多个属性 // 参数是一个对象，包含了需要设置的属性名和属性值$('img').attr(&#123; title: 'hello', alt: 'hello', style: 'opacity: .5'&#125;) 获取属性 // 传需要获取的属性名称，返回对应的属性值var oTitle = $('img').attr('title') 移除属性 // 参数：需要移除的属性名$('img').removeAttr('title') 【案例：美女相册.html】 prop 操作在jQuery1.6之后，对于 checked、selected、disabled 这类 boolean 类型的属性来说，不能用 attr 方法，只能用 prop 方法 // 设置属性$('input:checked').prop('checked', true)// 获取属性$('input:checked').prop('checked') // 返回 true 或者 false 【案例：表格全选案例.html】 jQuery 动画jquery 提供了三组基本动画，这些动画都是标准的、有规律的效果，jquery 还提供了自定义动画的功能 三组基本动画 显示 (show) 与隐藏 (hide) 与切换 (slideToggle) 上滑 (slideUp) 与下滑 (slideDown) 与切换 (slideToggle)，效果与卷帘门类似 淡入 (fadeIn) 与淡出 (fadeOut) 与切换 (fadeToggle) // show() 系列show([speed], [easing], [callback])// speed(可选)：动画的执行时间 // 1.如果不传，就没有动画效果。如果是 slide 和 fade 系列，会默认为 normal // 2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐) // 3.固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal// easing(可选)：动画效果，默认是 swing，秋千，提供了一个 linear 匀速的效果// callback(可选)：执行完动画后执行的回调函数// slide 系列，参数使用和show 是一样的，不传参数，默认有动画效果slideDown([speed], [easing], [callback])// fade 系列，参数使用和 show 是一样的，不传参数，默认有动画效果fadeIn([speed], [easing], [callback]) 【案例：下拉菜单动画版.html】【案例：京东轮播图(呼吸灯).html】 自定义动画animate：自定义动画（只支持数值型的动画） $(selector).animate(&#123; params &#125;, [speed], [easing], [callback])// &#123;params&#125;：要执行动画的 CSS 属性，带数字（必选），多个属性会同时执行// speed：执行动画时长（可选）// easing: 执行效果，默认为swing（缓动） linear（匀速）// callback：动画执行完后立即执行的回调函数（可选） 动画队列与停止动画在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行 // 有顺序的执行效果// 动画队列：// 像链式编程一样，通过 . 继续写动画，给元素添加了多个动画, 这多个动画会添加到元素的动画队列里面，按照顺序依次执行$(function () &#123; $('div') .animate(&#123; left: 800 &#125;, 1000) .animate(&#123; top: 300 &#125;, 1000) .animate(&#123; borderRadius: 50 &#125;, 1000) .slideUp(2000) .slideDown(2000)&#125;)// 好处：可以有顺序的执行动画效果// 坏处：bug 给元素不停的添加动画，元素就不停的运动 stop 方法 // 停止当前正在执行的动画，如果元素的动画队列里面有后续动画，后续动画会执行stop(clearQueue, jumpToEnd)// 第一个参数：可选，是否清除队列，true，表示清除掉，默认 false// 第二个参数：可选，是否跳转到当前正在执行的动画的最终效果，true，表示跳转， 默认false 【案例：手风琴特效】【案例：音乐导航】 jQuery 节点操作创建节点// $()// 括号内写 html 格式的字符串$('&lt;span&gt;这是一个span元素&lt;/span&gt;') 添加节点// appendA.append(B) // 把 B 添加到 A 里面去，B 作为 A 的最后一个子元素// appendToB.appendTo(A) // 作用同上，写法不同// prependA.prepend(B) // 把 B 添加到 A 里面去，B 作为 A 的第一个子元素// prependToB.prependTo(A) // 作用同上，写法不同// afterA.after(B) // 把 B 作为 A 的兄弟，添加在 A 的后面// beforeA.before(B) // 把 B 作为 A 的兄弟，添加在 A 的前面 【案例：城市选择案例】 清空节点与删除节点empty：清空指定节点的所有元素，自身保留(清理门户) $('div').empty() // 清空 div 的所有内容（推荐使用，会清除子元素上绑定的内容，源码）$('div').html('') // 使用 html 方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除 remove：删除节点，会把元素自身给删除掉 $('div').remove() // 删除 div 节点 克隆节点clone：克隆元素节点 $('div').clone() // 返回复制的 div 新元素，（默认不显示，需要配合 append 方法）// 新元素和原来的元素没有任何关系// clone(布尔类型参数)， 参数为true， 克隆元素的事件，默认值是false jQuery 特殊属性操作val()val 方法用于设置和获取表单元素的值，例如 input、textarea 的值 // 设置值$('#name').val('张三')// 获取值$('#name').val() 【案例：搜索框】 html() 与 text()html 方法相当于 innerHTML，text 方法相当于 innerText // 设置内容$('div').html('&lt;span&gt;这是一段内容&lt;/span&gt;')// 获取内容$('div').html()// 设置内容$('div').text('&lt;span&gt;这是一段内容&lt;/span&gt;')// 获取内容$('div').text() 区别：html 方法会识别 html 标签，text 方法会将内容直接当成字符串，并不会识别 html 标签 width() 与 height()设置或者获取 内容区域 的宽度和高度 // 带参数表示设置$('div').width(200)$('div').height(200)// 不带参数表示获取$('div').width()$('div').height() 获取 内容区域 + padding 的宽度和高度 $('div').innerWidth()$('div').innerHeight() 获取 内容区域 + padding + border 的宽度和高度 $('div').outerWidth()$('div').outerHeight() 获取 内容区域 + padding + border + margin 的宽度和高度 // 传入参数true$('div').outerWidth(true)$('div').outerHeight(true) 获取网页的可视区宽高 $(window).width()$(window).height() scrollTop 与 scrollLeft设置或者获取垂直滚动条的位置 // 传参表示设置，不传参表示获取$(window).scrollTop(2000)$(window).scrollLeft()// 实时的去获取到页面垂直卷曲的距离$(window).scroll(function () &#123; console.log($(window).scrollTop()) console.log($(window).scrollLeft())&#125;) 返回顶部固定写法 $goTop.click(function () &#123; $('html, body').animate( &#123; scrollTop: 0 &#125;, 1000 )&#125;) 【案例：固定菜单栏案例】【案例：小火箭返航案例】 offset 方法与 position 方法offset 方法获取元素距离 document 的位置，position 方法获取的是元素距离有定位的父元素的位置 // 获取元素距离 document 的位置，和父元素没有关系，返回值为对象：&#123;left:100, top:100&#125;$(selector).offset()// 获取相对于其最近的有定位的父元素的位置，返回值为对象$(selector).position() jQuery 事件机制JavaScript 中已经学习过了事件，但是 jQuery 对 JavaScript 事件进行了封装，增加并扩展了事件处理机制。jQuery 不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。 jQuery 事件发展历程(了解)简单事件绑定&gt;&gt; bind 事件绑定&gt;&gt; delegate 事件绑定 &gt;&gt;on 事件绑定(推荐) 简单方式事件注册 // jq 中简单方式注册相同的事件是不会被覆盖的$('div').click(function () &#123; alert('2')&#125;)$('div').click(null) // alert('2') 依然会执行 缺点：不能同时注册多个事件，无法解绑事件 bind 方式注册事件 // 第一个参数：事件类型，如果需要给元素注册多个事件，可以用空格隔开写上多个事件名// 第二个参数：事件处理函数$('p').bind('click mouseenter', function () &#123; // 事件响应方法&#125;) unbind 解绑事件（不用） $('div').unbind() // 不传参数解绑所有的事件$('div').unbind('click') // 解绑指定的事件 缺点：不支持动态事件绑定 delegate 注册委托事件 事件是注册给父元素的，由子元素去触发该事件 原理： 事件冒泡 优点：节省内存，支持动态绑定 // 第一个参数：要绑定事件的元素// 第二个参数：事件类型// 第三个参数：事件处理函数$('div').delegate('p', 'click', function () &#123; // 事件注册给了父元素 div，为所有的子元素 p 绑定事件， 由 p 去触发事件&#125;) undelegate 解绑事件（不用） $('div').undelegate() // 解绑所有的 delegate 事件$('div').undelegate( 'click' ) // 解绑所有的 click 事件 缺点：只能注册委托事件，因此注册时间需要记得方法太多了 on 注册事件(重点)jQuery 1.7 之后，jQuery 用 on 统一了所有事件的处理方法，强烈建议使用 on 注册简单事件 // 表示给 $('div') 绑定事件，并且由自己触发，不支持动态绑定$('div').on('click', function () &#123;&#125;) on 注册委托事件 // 表示给 $('div') 绑定代理事件，必须是它的内部元素 span 才能触发这个事件，支持动态绑定$('div').on('click', 'span', function () &#123;&#125;) on 注册事件的语法 // 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）// 第四个参数：handler，事件处理函数$(selector).on(events[,selector][,data],handler) off 解绑事件// 解绑匹配元素的所有事件，父元素子元素的所有事件都解绑了$('div').off()// 解绑匹配元素的所有 click 事件$('div').off('click')// 解绑子元素 p 的所有 click 事件, 父元素的click事件不会被解绑$('div').off('click', 'p') 触发事件// 点击 div 触发事件$('div').on('click', function () &#123; alert(2)&#125;)// 可由其他元素触发 div 的事件// 点击 btn 触发 div 的 click 事件$('#btn').on('click', function () &#123; // $('div').click() // 触发 div 的 click 事件 $('div').trigger('click') // trigger(type) 触发 div 的 click 事件&#125;) jQuery 事件对象jQuery 事件对象其实就是js事件对象的一个封装，处理了兼容性 // screenX 和 screenY 对应屏幕最左上角的值// clientX 和 clientY 距离页面左上角的位置（忽视滚动条）// pageX 和 pageY 距离页面最顶部的左上角的位置（会计算滚动条的距离）// event.keyCode 按下的键盘代码// event.data 存储绑定事件时传递的附加数据// event.stopPropagation() 阻止事件冒泡行为// event.preventDefault() 阻止浏览器默认行为// return false 既能阻止事件冒泡，又能阻止浏览器默认行为 注意：js 中的 return false 只能起到阻止浏览器的默认行为，jquery 中的 return false 既能阻止事件冒泡也能阻止浏览器的默认行为 【案例：钢琴版导航（加强)】 【案例：弹幕效果】 jQuery 特点隐式迭代基本概念隐式迭代：jQuery 在设置属性时会自动的遍历，因此我们不需要再遍历 jQuery 在执行设置性操作时，会给所有的元素都设置上相同的值 jQuery 在执行获取性操作时，只会返回第一个元素对应的值 如果想要给每一个元素都设置不同的值，需要手动进行遍历 jQuery 对象 each方法遍历 jQuery 对象集合，为每个匹配的元素执行一个函数 语法： $(selector).each(function (index, element) &#123; // index 表示当前元素在所有匹配元素中的索引号 // element 表示当前元素 // this 在函数内部，this指向了element&#125;)$('li').each(function (index, ele) &#123; // $(ele).css('backgroundColor', arr[index]) $(this).css('backgroundColor', arr[index])&#125;) 链式编程链式编程的原理：设置性操作会返回一个 jQuery 对象，因此可以继续调用 jQuery 的方法 设置操作的时候，可以使用链式编程 获取操作的时候，无法使用链式编程，（因为没有返回jq对象） 链式编程不要太长，因为代码可读性差 prevObject: 返回上一次找到的jq对象end() // 上一次返回的 jq 对象（封装了 prevObject 属性） 【案例：五角星评分案例.html】 多库共存jQuery 使用 $作为标示符，但是如果与其他框架中的 $ 冲突时，jQuery 可以释放 $ 符的控制权 // noConflict() // 返回 $ 的功能var c = $.noConflict() // 释放 $ 的控制权,并且把 $ 的能力给了 c jQuery 插件插件：其实就是个 js 库，依赖于 jquery，而且在 jquery 的基础上新增一些功能 使用插件1. 先引入jQuery文件2. 在引入插件（如果有用到css的话，需要引入css）3. 使用插件 常用插件的使用 jquery.color.js animate 只支持数值型的动画，色值型的不支持，这个插件就可以让animate 做色值型的动画 jquery.lazyload.js // 使用方法// html图片调用方法// 为图片加入样式 lazy 图片路径引用方法用 data-original// &lt;img class='lazy' data-original='img/1.jpg'&gt;// js出始化lazyload并设置图片显示方式$(function () &#123; $('img.lazy').lazyload(&#123; effect: 'fadeIn', placeholder: 'img/2.jpg', // 用图片提前占位,待图片加载时,占位图则会隐藏 effect: 'fadeIn', // 载入使用何种效果 threshold: 200, // 表示滚动条在离目标位置200的高度时开始加载图片,可以做到不让用户察觉 event: 'click' // 事件触发时才加载 &#125;)&#125;) 制作 jQuery 插件制作 jQuery 插件的核心思想：给 jQuery 的原型增加方法即可。 $.fn.pluginName = function () &#123;&#125; 制作基本的jQuery插件（jquery.bgc.js） 制作手风琴插件 jQuery 架构看源码学习推荐看 1.7.0 版本，源码比较清晰 jq 的基本架构沙箱 ，减少全局污染 ;(function (window, undefined) &#123; // console.log(undefined) var jQuery = function () &#123;&#125; // 往外暴露 window.jQuery = window.$ = jQuery&#125;)(window)var jq = new jQuery() // ==&gt; 得到一个jq的实例对象console.log(jq) 参数 window 的作用： 减少对 window 的搜索过程 有利于代码压缩 参数 undefined 的作用： 参数 undefined 的值是 undefined undefined 这个数据类型的值在ie678 中是可以被修改的，现在有 undefined 形参在这，在沙箱里面去使用 undefined 的时候，就不会去引用外面被修改的 undefined 的值 省去 new 操作// 省去 new 操作，得到一个jq的实例对象;(function (window, undefined) &#123; // jQuery 是 工厂函数， 里面干啥？ var jQuery = function (selector) &#123; // return new 构造函数 // 在 jq 里面，真正的构造函数是 init，而且 init 方法放在 jq 的原型上 // jQuery.fn.init ==&gt; 是从 jq 的原型上拿 init 方法 return new jQuery.fn.init(selector) // init 何种调用模式， 构造函数模式 &#125; jQuery.fn = jQuery.prototype = &#123; // 原型替换 constructor: jQuery, init: function (selector) &#123; // init 是真正的构造函数 // 获取元素 var ele = document.querySelectorAll(selector) // this ==&gt; init的实例对象 ;[].push.apply(this, ele) &#125;, css: function () &#123; console.log('css is ok') &#125; &#125; window.jQuery = window.$ = jQuery&#125;)(window)// 把 init 的构造函数的 prototype 改成 jquery 的原型// 目的： 让 init 的实例对象可以访问 jq 原型上的方法jQuery.fn.init.prototype = jQuery.fnvar $div = $('div') // init实例对象console.log($div)$div.css()]]></content>
      <categories>
        <category>框架</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery-fileupload]]></title>
    <url>%2F2018%2Fjquery%2Fjquery-fileupload%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[jquery-fileuploadgithub地址：https://github.com/blueimp/jQuery-File-Upload 中文文档：http://www.jq22.com/jquery-info230 引包&lt;!-- jquery-fileupload依赖与jquery --&gt;&lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- jquery ui小部件，上传插件依赖了jquery ui的小部件 --&gt;&lt;script src="js/vendor/jquery.ui.widget.js"&gt;&lt;/script&gt;&lt;!-- 如果上传图片需要跨域，那么需要引入这个js文件，如果不跨域，则不需要引入 --&gt;&lt;script src="js/jquery.iframe-transport.js"&gt;&lt;/script&gt;&lt;!-- jquery上传插件 --&gt;&lt;script src="js/jquery.fileupload.js"&gt;&lt;/script&gt; html结构&lt;!-- name指定图片上传时的name属性 --&gt;&lt;!-- data-url指定图片上传时的接口地址 --&gt;&lt;!-- multiple指定多文件上传 --&gt;&lt;input id="fileupload" type="file" name="files" data-url="server/php/" multiple&gt; multiple 上传多文件（实质上是发送多次单文件异步上传请求） js代码$('#fileupload').fileupload(&#123; dataType: 'json', // e：事件对象 // data：图片上传后的对象，通过data.result.picAddr 可以获取上传后的图片地址 done: function (e, data) &#123; console.log(data) &#125;&#125;)]]></content>
      <categories>
        <category>框架</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery 中 AJAX 的全局事件]]></title>
    <url>%2F2018%2Fjquery%2Fjquery%E4%B8%ADAJAX%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[jquery 中 AJAX 的全局事件 ajax 提供了6个全局函数，会被页面中所有的 ajax 请求触发，在不同时间点会触发不同的全局事件。 https://api.jquery.com/category/ajax/global-ajax-event-handlers/ 在页面中会有很多的ajax请求，但是这些ajax请求都有相同的消息机制，比如我们需要在ajax请求发送之前弹出了一个提示框，提示”正在读取数据….” 在ajax请求成功时显示”获取数据成功…”,在ajax结束后隐藏提示框。如果不使用全局事件，那么需要在每一个ajax的beforeSend、success、complete回调函数中都加上相同的代码。 jquery 的全局事件需要给 document 注册（固定写法） $(document).ajaxStart(function () &#123;&#125;) 全局事件的执行时机 ajaxStart： 在第一个 ajax 请求开始时触发 first start ajaxSend： 在一个ajax请求开始之前触发（在beforeSend回调函数之后）one start ajaxSuccess： 在一个ajax请求成功之后触发（在 success 回调函数之后触发）one success ajaxComplete： 在一个ajax请求完成时触发（在complete回调函数之后触发） one complete ajaxError： 在一个 ajax 请求失败时触发（在error回调函数之后触发） ajaxStop： 在所有的 ajax 请求完成之后触发 all complete 若$.ajax() global 参数设置为 false，则 ajax 全局事件不会被触发，global 参数默认为 true]]></content>
      <categories>
        <category>框架</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Api]]></title>
    <url>%2F2018%2Fjavascript%2Fwebapi%2F</url>
    <content type="text"><![CDATA[Web Api 基本概念API（Application Programming Interface,应用程序编程接口） API 是一些预先定义的方法，这些方法能够实现某些特定的功能 任何开发语言都会提供自己的API API的特征输入和输出(参数/返回值) 通俗的讲，API就是编程语言给我提供的一些 工具，通过这些工具，我们可以非常轻易的完成一些功能。 Web API : 是浏览器提供的 一套操作网页(web)的方法(API), 通过这套API我们可以非常轻松的操作页面的元素和浏览器的一些功能 *ECMAScript - JavaScript的核心 * ECMAScript是一套标准, 规范了语言的基本语法和数据类型 与具体实现无关 DOM - 文档对象模型 一套操作页面元素的API 通过DOM提供的API可以获取/操作网页上的元素 BOM - 浏览器对象模型 一套操作浏览器功能的API 通过BOM可以操作浏览器窗口, 比如刷新、控制浏览器跳转等 DOM 文档对象模型DOM 基本概念 DOM ( Document Object Model ) 文档对象模型，是W3C组织推荐的一套操作网页元素的API DOM又称为文档树模型，因为整个HTML文档是一个树形的结构 DOM中常见的概念 : 文档 document : 一个网页可以称为文档；（换句话说：操作页面，其实就是操作document） console.log(document)// DOM 会把整个网页当成一个对象，我们操作这个网页，只要操作这个document对象// DOM 会把网页中的所有的东西都当作对象 节点node : 网页中的所有内容都是节点 (标签、属性、文本) &lt;ul class="box"&gt; ul: 标签节点 class="box": 属性节点 &lt;!-- 这是一些测试 --&gt; 注释节点 &lt;li&gt;测试&lt;/li&gt; 测试:文本节点 &lt;li&gt;测试&lt;/li&gt; &lt;li&gt;测试&lt;/li&gt;&lt;/ul&gt; 元素 element : 网页中的标签节点 获取元素的方法 document.getElementById() // 通过id 获取元素// 参数 : 字符串类型的id// 返回值 : 一个元素（dom对象）var div = document.getElementById('div')console.dir(div) // 以对象的形式显示console.log(div) // 以内容的形式显示 ​ 关于console.log()和console.dir()的区别 ​ console.log() ：打印一个元素的时候，是以标签的形式进行展示的 ​ console.dir() ：打印一个元素的时候，是以对象的形式进行展示的 getElementsByClassName() // 通过类名获取元素// 参数：字符串类型的类名// 返回值：伪数组document.getElementsByClassName("class") getElementsByTagName() // 通过标签名获取元素// 参数：标签名字符串// 返回值：伪数组var ps = document.getElementsByTagName('p') getElementsByName() // 通过name属性值获取元素// 参数 : name值// 返回值 : 伪数组var ps = document.getElementsByName("aa") querySelector() // 根据css选择器获取元素 (重点)// 参数：是一个css选择器// 返回值：只会返回一个对象，如果有很多个，会返回第一个document.querySelector("#box") querySelectorAll() // 根据css选择器获取元素 (重点)// 参数：是一个css选择器// 返回值：伪数组document.querySelectorAll(".box") 注意事项 getElementById() 只能由 document 调用，如果通过其他元素调用会报错，其他方法可由已经获取到的dom对象调用 querySelector和 getElementById如果获取不到元素会返回 null；getElementsByClassName 、getElementsByTagName 、getElementsByName 、querySelectorAll 如果没有获取到元素也会返回一个伪数组，只不过伪数组长度为0 伪数组不是数组，不能使用属性的方法，但是可以跟数组一样进行遍历和使用下标进行操作；伪数组不能直接注册事件，需要遍历后拿到标签再注册事件 在DOM中, 获取元素操作需要写在html内容的后面，保证页面加载完成之后才能获取到内容 事件学习认识事件 事件：理解为浏览器的感知系统 , 触发 –&gt; 响应机制，javascript是基于事件驱动的 // 点击事件// 结构 : 事件源.onclick = function () &#123;..&#125; 事件三要素 : 事件源 + 事件名称 + 事件处理函数 事件源 : 给谁注册事件 ( 按钮 btn ) 事件名称 : 注册了什么事件 ( click事件 ) 事件处理函数 : 事件触发后要执行的代码(函数形式) 注意：事件处理函数并不会立马执行，而是当事件触发的时候才会执行（浏览器会自动调用） 注册事件的基本语法 : var box = document.getElementById('box')//on:当 click:点击 当按钮被点击的时候触发box.onclick = function() &#123; console.log('代码会在box被点击后执行')&#125; 两种按钮 &lt;button&gt;点亮&lt;/button&gt;&lt;input type="button" value="哈"&gt;都是可点击的普通按钮一个是文字显示在标签内容里, 而且还可以放其他标签一个是文字显示在vaue中 焦点事件 focus : 获得焦点 blur : 失去焦点 鼠标事件 click : 单击 dblclick ：双击 mouseover/mouseout : 进入/离开元素 mouseenter/mouseleave : 进入/离开元素 mousedown ：按下 mouseup ：抬起/释放 mousemove ：移动 键盘事件 keydown/keypress ：按下 keyup： 释放 事件中的this this 指向注册事件的事件源 var btn = document.getElementById('btn')btn.onclick = function() &#123; // 给 btn 注册的事件，因此 this 表示 btn this.value = '哈哈'&#125; 练习： &lt;!-- 1. 给多个按钮注册点击事件，点击的那个变成红色 --&gt;.red &#123; background: red&#125;&lt;button&gt;1&lt;/button&gt;&lt;button&gt;2&lt;/button&gt;&lt;script&gt; // 给多个按钮注册点击事件，点击的那个变成红色，其他的恢复默认 var btns = document.getElementsByTagName('button') for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].onclick = function () &#123; // console.log(i) // 点击按钮时打印 2 // btns[i].className = 'red' // 此时 i = 2，报错 for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].className = '' // 恢复默认样式 ，排他思想 &#125; this.className = 'red' // 给自己添加样式 &#125; &#125;&lt;/script&gt;// 2. 点击按钮，显示对应的图片 1-6&lt;input type="button" value="第一张" title="1"&gt;&lt;img id="img" src="images/1.jpg" alt=""&gt; 阻止浏览器默认行为 对于 a 标签来说，默认的行为就是进行页面跳转，如果不想让 a 标签进行跳转，可以在注册事件中使用return false &lt;a id="link" href="http://www.baidu.com"&gt;这是a&lt;/a&gt;&lt;script&gt; var link = document.getElementById('link') link.onclick = function() &#123; alert('呵呵') // 阻止页面跳转 return false &#125;&lt;/script&gt; e.preventDefault() 只会阻止浏览器的默认行为，并不会停止函数执行 return false后的代码不在执行 在jQuery中，return false在调用时会执行3个单独的操作： event.preventDefault() event.stopPropagation() 停止回调执行并在调用时立即返回 属性操作 在DOM中，页面标签的属性和DOM对象的属性是一一对应的，因此我们可以通过修改DOM对象的属性来修改标签的属性 普通标签属性 常见的属性有：src、title、src、href、class、id等 // 在 js 中 class 是关键字，因此对应的是 className 属性div.className = 'hg' // 修改类名会把原类名直接覆盖掉 表单属性操作 常见的表单属性有：disabled、type、value、checked、selected 对于disabled、checked、selected三个属性来说，比较特殊。在DOM对象中，这些属性是一个布尔类型的属性，值只有 true 或者 false !&gt; reset() 方法可把表单中的元素重置为它们的默认值 【案例：禁用文本框】 【案例：随机下拉框选中】 【案例：表格全选案例】 标签的自定义属性 我们之前讨论的属性，都是HTML规范中，标签本来就有的属性，对于标签自定义的一些属性，比较特殊 在html页面中，定义一个自定义属性 &lt;div id="box" aa="bb"&gt;&lt;/div&gt; 在对应的DOM对象中是不存在的，在DOM对象中只会存在固定的那些属性 var box = document.getElementById('box')console.log(box.aa) // undefined attribute 方法 attribute 系列方法用于设置标签的属性，不管是自定义的还是固有的属性 // 获取标签的属性box.getAttribute(属性名)// 设置标签的属性box.setAttribute(属性名, 属性值)// 移除标签的属性box.removeAttribute(属性名) 区别 : // &lt;div a="1" id="box"&gt;&lt;/div&gt;// 1. 直接给标签里只能添加固有的属性 title 等 标签+对象里都有显示// 2. 给标签添加自定义属性--标签上显示console.log(box.a) // undefined =&gt; 对象中不显示console.log(box.getAttribute('a')) // 1 =&gt;// 3. 给对象添加自定义属性 -- 标签中不显示box.b = 2console.log(box.b) // 2 =&gt; 对象中显示console.log(box.getAttribute('b')) // null// 4. Attribute方法box.setAttribute('c', 3) // 标签中显示console.dir(box)console.log(box.c) // undefined =&gt;对象中不显示console.log(box.getAttribute('c')) // 3console.log(box.attributes) // &#123;0: a, 1: id, 2: c, a: a, id: id, c: c, length: 3&#125;console.log(box.attributes.c) // c='3' tab 栏案例 (重点)[案例：获取当前元素的索引] (超级重要) // 方式1：// 存btns[i].setAttribute('index', i)// 取console.log(this.getAttribute('index'))// 方式2：// 存btns[i].index = i// 取console.log(this.index)// 区别在于: 第一个显示在标签内 第二个不显示在标签内 推荐第二种 【案例：tab栏切换】 标签的内容属性innerText 和 innerHTML 共同点 : 都是用来获取和设置标签的内容的 区别： innerHTML 能够识别标签，标签能够生效 innerText 只识别文本，标签会被转义 var div = document.getElementById('div')// 获取内容// 获取标签内容的时候，只会获取文本，标签扔掉了console.log(div.innerText) // 哈哈// 获取标签内容的时候，不管标签还是文本，都能获取到console.log(div.innerHTML) // &lt;h1&gt;哈哈&lt;/h1&gt;// 设置内容// 设置标签内容的时候，覆盖原来内容，对标签进行转义div.innerText = '&lt;h1&gt;嘿嘿&lt;/h1&gt;'// 设置内容的时候，覆盖原来内容，标签也能生效，浏览器能解析这个标签div.innerHTML = '&lt;h1&gt;嘿嘿&lt;/h1&gt;' 浏览器兼容性：指网页在各种浏览器上的显示效果不一致。或者是一些属性和方法在低版本的浏览器中不支持 innerText 是 IE 提出来的属性，因此低版本的火狐浏览器不支持这个属性。 火狐有一个 textContent 属性，效果跟 innerText 一样，但是IE678不支持这个属性 书写 innerText 的兼容性代码 function getInnerText (element) &#123; if (typeof element.innerText === "string") &#123; return element.innerText &#125; else &#123; return element.textContent &#125;&#125; 行内样式操作（style属性） 标签不仅可以通过class属性操作样式 (嵌套样式)，还可以通过style属性操作样式 (行内样式)。 同样的DOM对象可以通过className操作样式 (嵌套样式)，也可以通过style属性操作样 (行内样式)。 css : 嵌套样式 =&gt; js : 类名 div.className = ‘red’ css : 行内样式 =&gt; js : style对象 div.style.color = ‘red’ 样式属性 style 属性是一个对象，里面存储了所有行内样式的键值对 style 属性只能获取和设置行内样式，嵌套样式通过 style 获取不到 如果样式的名字带 - ，比如 background-color ，在 style 对象中使用backgroundColor =&gt; （因为 - 在js中不是一个合法的标识符） style 设置的样式是行内样式，优先级要高于通过 className 设置的样式 &lt;div style="color:red;background-color:blue;"&gt;哈哈&lt;/div&gt;var div = document.querySelector('div')// 获取样式console.log(div.style)console.log(div.style.color) // red// 设置样式div.style.width = '200px'div.style.height = '200px'div.style.fontSize = '100px'div.className = 'box' getComputedStyle 获取元素计算后的样式 语法： window.getComputedStyle( 获取的元素， 伪类) ​ 伪类 ==&gt; ::after ::before，如果写上了伪类，表示要获取元素的伪类的样式，如果不需要获取的话，该参数写 null ​ 返回值： 返回一个样式对象 &gt; var div = document.querySelector('div')&gt; // 获取元素自身的&gt; var ret = window.getComputedStyle(div, null).fontSize&gt; var ret1 = window.getComputedStyle(div, null).backgroundColor&gt; // 推荐：对于复合样式，需要获取什么样式，写具体的样式名，这样能更好的兼容更多浏览器&gt;&gt; // 获取伪类的&gt; var ret2 = window.getComputedStyle(div, '::after').width&gt; 关于 body 的样式操作var bd = document.querySelector('body')console.log(bd) // 通过 querySelector 获取 body 元素console.log(document.body) // 直接获取 body 元素document.documentElement // 可以获取 html 元素document.head // 直接获取 head 元素document.title // 获取的是 title 中的文本 【案例：开关灯案例】 【案例：随机背景颜色案例】 【案例：百度换肤】 关于 cssText (了解) 使用 cssText 可以设置 style 的属性值 &lt;div style="width: 100px; height: 100px"&gt;哈哈哈&lt;/div&gt;&lt;script&gt; // 优点：可以一次性设置多个值 // 缺点：会覆盖整个style属性且不利于阅读 var div = document.querySelector('div') div.style.cssText = 'background:red;color:yellow'&lt;/script&gt; 节点操作 (超级重要)节点属性 (了解)节点分类： ​ 元素节点、文本节点、属性节点、注释节点 节点常用的属性 childNodes : 获取所有的子节点 nodeType: 节点类型：元素节点 = 1 属性-2(过时) 注释-8 文本-3 nodeType链接-MDN nodeName: 节点名称 nodeValue: 节点值 节点查找 (重点)孩子节点&lt;ul &gt; &lt;!-- 下面是li --&gt; &lt;li&gt;导航1&lt;/li&gt; &lt;li&gt;导航2&lt;/li&gt; &lt;li&gt;导航3&lt;/li&gt; &lt;li&gt;导航4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var ul = document.querySelector('ul') // 获取ul所有的子节点（包括了元素节点和其他很多类型的节点，基本不常用） console.log(ul.childNodes) // 获取第一个子节点 (不常用) console.log(ul.firstChild) // 获取最后一个子节点 (不常用) console.log(ul.lastChild) // 获取所有的子元素，兼容性：IE678会把注释节点算上 console.log(ul.children) // 获取第一个子元素 有兼容性问题（IE678） console.log(ul.firstElementChild) // 获取最后一个子元素 有兼容性问题（IE678） console.log(ul.lastElementChild) // 获取第n个子元素 有兼容性问题（IE678） console.log(ul.children[n])&lt;/script&gt; 兄弟节点 nextSibling : 下一个兄弟节点 (基本不常用) nextElementSibling : 下一个兄弟元素（IE678不兼容） previousSibling : 上一个兄弟节点 (基本不常用) previousElementSibling : 上一个兄弟元素 有兼容性问题 可以封装一个兼容性方法 &lt;p&gt;导航1&lt;/p&gt;&lt;p class="p"&gt;导航2&lt;/p&gt;&lt;p&gt;导航3&lt;/p&gt;&lt;script&gt; var p2 = document.querySelector('.p') console.log(p2) console.log(p2.nextSibling) console.log(p2.nextElementSibling) console.log(p2.previousSibling) console.log(p2.previousElementSibling)&lt;/script&gt; 【案例1：表单校验】 父亲节点 parentNode : 父节点（没有兼容性问题） parentElement : 父元素 div.parentNode // 获取父节点 添加节点 (重点)appendChild()// 作用：在子元素的最后添加一个元素// 语法：parent.appendChild(newChild)// 父元素.appendChild(新子元素) 注意 : 如果 newChild 已经存在于DOM树中，则它会被从原始位置删除 insertBefore()// 作用：在某个子元素之前添加一个元素// 语法：parent.insertBefore(newChild, refChild) 必须要父节点来调用，newChild 为需要添加的那个节点，refChild 为添加到哪一个节点的前面 没有 insertAfter() // 将元素添加到最后div.appendChild(p) // (常用)div.insertBefore(p, null)// 将元素添加到 s1 之前(常用)div.insertBefore(p, s1)// 将元素添加到 s1 之后// 没有 insertAfterdiv.insertBefore(p, s1.nextElementSibling)// 将元素添加到最前div.insertBefore(p, div.children[0]) // (常用)div.insertBefore(p, div.firstElementChild) 克隆节点 (重点)// 语法：var newNode = 节点.cloneNode([isDeep])// isDeep参数：false / true // false：默认值：是浅复制，只会复制标签节点本身，不会复制节点的孩子 // true: 深度复制，会复制标签，还会复制标签的所有内容 克隆出来的节点跟原来的节点没有关系了，修改了也不会相互影响 如果克隆的节点带了id，我们需要给id重新设置一个值，不让id冲突 var newNode = div.cloneNode(true)console.log(newNode) 创建节点(3种方式) (重点)document.write（基本不用）可以生成新的节点，但是不推荐使用。如果页面已经加载完成了，再用document.write写内容的话，会把之前的页面给覆盖掉 原理：页面从上往下加载的时候，会开启一个文档流，当页面加载完，文档流就会关闭。document.write 的本意就是在文档流上写入内容。如果页面没加载完成，文档流还是开着的，document.write直接在这个文档流上写东西，如果页面加载完成了，还是用document.write写东西，会重新开启一个新的文档流，往新的文档流上写东西，旧的文档流就被新的文档流覆盖了。 window.onload = function () &#123; document.write('呵呵')&#125; innerHTML (偶尔用)innerHTML也可以创建节点 使用 innerHTML 创建节点时，如果原来有内容的话，会把原先的内容覆盖 慎用：很容易出现效率问题 div.innerHTML = '&lt;h1&gt;哈哈&lt;/h1&gt;' createElement (常用)// 语法：var element = document.createElement('tagName')// 返回：一个元素// 需要配合 appendChild 和 innerText 来使用var div = document.querySelector('div')var h1 = document.createElement('h1')console.log(h1)h1.style.background = 'red'h1.innerText = '哈'div.appendChild(h1) 删除节点 (重点)// 语法：parent.removeChild(child)// 解析：父元素.removeChild(子元素)// 功能：由父元素调用，删除里面的一个子元素div.removeChild(p)p.parentNode.removeChild(p) 【案例 : 节点操作-删除节点】 1. 使用 children 和 TagName =&gt; 需要配合 i--// 原因 :动态计算 , 每删除一个,都会重新分配一次下标2. 使用 querySelectorAll('li') =&gt; ok的// 原因 : 静态计算 [案例 : 许愿墙案例] 功能1 : 克隆10个tip, 并且随机分布功能2 : 点击提高层级功能3 : 点击x, 删除当前tip功能4 : 双击tip头部,删除当前tip 替换节点// 语法：// newChild 为用来替换 oldChild 的新节点parentNode.replaceChild(newChild, oldChild) 注意 : 如果 newChild 已经存在于DOM树中，则它会被从原始位置删除 节点操作综合案例【动态生成表格】 BOM BOM（Browser Object Model）：浏览器对象模型，提供了一套操作浏览器功能的工具 重点 ：定时器、 offset系列 window window 对象是一个全局对象，也可以说是 JavaScript 中的顶级对象 所有定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法 像 document、alert()、console.log() 这些都是 window 的属性，其实 BOM 中基本所有的属性和方法都是 window 的 window 对象下的属性和方法调用的时候可以省略 window .onload（掌握） window.onload 事件会在 窗体加载完成 后执行，通常我们称之为入口函数。 window.onload = function()&#123; //代码会在窗体加载完成后执行。 //窗体加载完成 包括文档树(DOM html)的加载、还有图片、文件的加载完成。&#125; 如果有图片加载，那么代码一定要写到window.onload里面，否则会出现图片没有加载完成，获取到的宽度和高度不对的情况。 浏览器会对页面的加载做优化，在加载图片的时候，图片的引入会延迟。 &lt;img src="./01.png" alt=""&gt;window.onload = function () &#123; var img = document.querySelector('img') console.log(img.width) console.log(img.height)&#125; .open() 与 .close() (了解) window.open() 打开一个窗口 // 语法：window.open(url, [name], [features])// 参数1：需要载入的 url 地址// 参数2：新窗口的名称或者 targt 属性 // _blank:如果指定为 _blank，表示在新的窗口打开// 参数3：窗口的属性，指定窗口的大小// 返回值：会返回刚刚创建的那个窗口，在 window.close() 时使用// 示例：var newWin = window.open('http://www.baidu.com', '_blank', 'width=300,height=300')// 参数配置：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open window.close() 关闭窗口 newWin.close() // newWin 是刚刚创建的那个窗口window.close() // 把当前窗口给关闭 延时器与定时器 (重点)setTimeout 延时器 可以在延迟一定时间后执行指定的代码 设置延时器 // 语法: setTimeOut(callback,time)// 参数1: 回调函数, 时间到了就会执行// 参数2: 延时的时间 毫秒为单位 1s = 1000毫秒// 返回 : 延时器的id,用于清除var timer = setTimeOut(function () &#123; //1秒后将执行一次&#125;, 1000) 清除延时器 // 语法 : clearTimeOut(timerId)// 参数 : 延时器id// 示例 :clearTimeOut(timer) // 清除上面定义的延时器 setInterval 定时器 setInterval 方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间间隔。 (每隔一段时间执行一段代码) 定时器除非清除，否则会一直执行下去。 设置定时器 // 语法 :var timerId = setInterval(func,dealy)// 参数1 ： 重复执行的函数// 参数2 : 每次间隔的毫秒数// 返回 : 定时器的id, 用于清除// 示例 :var timer = setInterval(function () &#123; // 1s 之后开始重复执行&#125;,1000) 清除定时器 // 语法 : clearInterval(intervalId)// 参数 : 定时器id// 示例 :clearInterval(timerId) // 清除上面的定时器 案例【短信验证码案例.html】 location 对象 location 对象也是 window 的一个属性 location 其实对应的就是浏览器中的地址栏 常用属性和方法 location.href : 控制地址栏的地址，实现页面跳转 document.onclick = function () &#123; location.href = 'http://www.baidu.com' // 点击页面跳转到百度首页&#125; [案例 : 注册成功，3秒后跳转] 页面跳转： location.href = &#39;url地址&#39; location.assign(&#39;url地址&#39;) location.replace(&#39;url地址&#39;) (不记录历史) location.reload() 让页面重新加载 document.onclick = function () &#123; location.reload() // 重新刷新&#125; location 的其他值 http://www.bbb.com:8080/index.html?id=666&amp;psd=123#xxx location.hash //哈希值 其实就是锚点 ==&gt; #xxx location.host //服务器 服务器名+端口号 =&gt; www.bbb.com:8080 location.hostname //服务器名 =&gt; www.bbb.com location.pathname //路径名 =&gt; index.html location.port //端口 =&gt; 8080 location.protocol //协议 =&gt; http location.search //参数 =&gt; ?id=666&amp;psd=123 其他对象 history 对象表示页面的历史 // 随便打开一个网页 可以演示// 后退：history.back()history.go(-1)// 前进：history.forward()history.go(1) screen 对象 console.log(screen.width) // 屏幕的宽度console.log(screen.height) // 屏幕的高度console.log(screen.availWidth) // 浏览器可占用的宽度console.log(screen.availHeight) // 浏览器可占用的高度 缓动动画缓动动画初体验动画公式 : var step = (target-current)/10current += step [案例演示 : ] 1. 三步走- 获取当前位置- 累加小碎步- 重复赋值回去2. 定时器 缺点 : 打开控制台, 查看盒子的结构行内样式left, 发现并没有跑到400px, 只能跑到396.4/395.5 原因 : offsetLeft获取值的时候, 只会获取整数 , (对小数部分会四舍五入,整数有时候往上取整,有时候往下取整); 可以在获取的offset地方打印查看 缓动动画 - 移动400位置动画公式 : var step = (target-current)/10 step = Math.ceil(step) // 往上取整current += step// 为什么往上取整 :// 1. 如果不取整，赋值为小数的话,下次取值还是会取个 整数回来，这就是之前的缺点// 2. 往上取整的额原因是：(400-395)/10 = 0.5 如果往下取整为0，那就不会走了，所以// 为了保证可以走，往上取整 取 1 步数 为 1 案例演示 注意点 : 1.查看位置 : left有时候为 395.5/ 396.42.打印: offsetLeft =&gt; 395 / 3963.step为整数 往上取整 缓动动画 - 回到0点位置动画公式 : var step = (target-current)/10 step = Math.floor(step) //往下取整 current += step// 为什么往下取整 :// 1. 如果不取整，赋值为小数的话,下次取值还是会取个整数回来，这就是之前的缺点// 2. 往上取整的额原因是 : (0-5)/10 = -0.5 如果往上取整为0 那就不会走了，所以// 为了保证可以走，往下取整 : 取 -1 步数 为 -1 案例演示注意点 : 1. 先把盒子 设置 left : 400px 位置; 回到0位置2. 查看位置 : left有时候为 4.53. 打印: offsetLeft =&gt; 54. step为整数 往下取整 缓动动画 - 封装函数function animate (element, target) &#123; if (element.timerId) &#123; clearInterval(element.timerId) &#125; element.timerId = setInterval(function () &#123; // 1. 获取当前位置 var current = element.offsetLeft // 2. 累加小碎步 var step = (target - current) / 10 // 往上取整 ? 为什么，因为 0.5 如果网下取整也是0 ，不会走 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step) current += step // 1 // 3. 重新赋值 element.style.left = current + 'px' //400 if (current == target) &#123; clearInterval(element.timerId) &#125; &#125;, 15)&#125; [案例 : 筋斗云] [案例：开机提示关闭] 事件对象事件对象的概述 在触发某个事件的时候，都会产生一个事件对象 Event，这个对象中包含所有与事件相关的一些信息，包括触发事件的元素，事件的类型以及其他与事件相关的信息 鼠标事件触发时，事件对象中会包含鼠标的位置信息。 键盘事件触发时，事件对象中会包含按下的键相关的信息。 获取事件对象现代浏览器获取 : (掌握) // 给一个形参即可btn.onclick = function (e) &#123; // e 就是事件对象，里面包含了事件触发时的一些信息 console.log(e)&#125; 低版本浏览器 (ie678): (了解) btn.onclick = function()&#123; // IE678 通过 window.event 获取事件对象 console.log(window.event)&#125; 兼容性 : btn.onclick = function(e)&#123; // 只要用到了事件对象，就要记得处理浏览器兼容性 // 低版本IE event 不存在为undefined e = e || window.event&#125; 事件对象的常用属性 事件对象中有很多很多的属性，但是很多属性并不常用。我们经常用到的是鼠标位置信息和键盘码相关的信息 鼠标位置信息 clientX 与 clientY ： 相对于浏览器可视区左上角的位置（不随滚动条滚动而改变） pageX 与 pageY ：相对于网页内容（文档document）左上角的位置 screenX 与 screenY ：相对于屏幕左上角的位置 offsetX 与 offsetY ：鼠标相对于事件源左上角的位置 document.onmousemove = function (e) &#123; console.log(e.clientX, e.clientY) console.log(e.pageX, e.pageY) console.log(e.screenX, e.screenY)&#125; [案例 : 拖拽案例] 键盘码// 键盘按下的那个键的键盘码e.keyCode 注册事件的两种方式on + 事件名称 onclick、onmouseover 这种 on+事件名称的方式注册事件几乎所有的浏览器都支持 // 注册事件box.onclick = function () &#123; // 事件处理程序&#125;// 移除事件box.onclick = null on+事件名称注册事件的缺点：同一个元素同一类型的事件，只能注册一个，如果注册了多个，会出现覆盖问题 addEventListener 现代浏览器支持的注册事件的新方式，这种方式注册的事件不会出现覆盖问题 addEventListener 的语法 // type：事件的类型：click mouseover 字符串类型，不带 on// fn：函数，每次点击，执行这个函数// useCapture: 可选，true：事件在捕获阶段执行，false: 事件在冒泡阶段执行(默认)element.addEventListener(type, fn, useCapture)btn.addEventListener('click', function () &#123; console.log('哈哈') &#125;) removeEventListen的语法 // type：事件的类型// fn：要移除的那个函数element.removeEventListener(type, fn)btn.removeEventListener('click', fn)// 注意 : 如果想让注册的事件能移除，不能用匿名函数 低版本浏览器兼容问题: (了解) IE678不支持addEventListener与removeEventListen两个方法，但是支持attachEvent与detachEvnet attachEvent的用法： // type: 事件类型，需要加上on// fn: 需要执行的那个事件attachEvent(type, fn)btn.attachEvent('onclick', function () &#123; alert('哈哈')&#125;) detachEvent的用法： detachEvent(type, fn) 兼容性封装（了解）// 添加事件function addEvent(element, type, fn) &#123; // 能力检测 if (element.addEventListener) &#123; element.addEventListener(type, fn) &#125; else if (element.attachEvent) &#123; element.attachEvent('on'+type, fn) &#125; else &#123; // 如果都不行，那就用on方式 element['on'+type] = fn &#125;&#125;// 移除事件function removeEvent(element, type, fn) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false) &#125;else if(element.detachEvent)&#123; element.detachEvent('on'+type, fn) &#125;else &#123; element['on'+type] = null &#125;&#125; 事件流事件冒泡当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为冒泡 说白了就是：当我们触发了子元素的某个事件后，父元素对应的事件也会触发 on 创建的事件默认为冒泡，无法修改 [案例 : 弹窗案例] 阻止事件冒泡 e.stopPropagation() box.onclick = function (e) &#123; e.stopPropagation()&#125;// 参数1：true =&gt; 捕获， false =&gt; 冒泡（默认）box.addEventListener('click', function()&#123;&#125;, 参数1) 阻止事件冒泡的兼容性封装 function stopPropagation(e) &#123; if (e &amp;&amp; e.stopPropagation) &#123; e.stopPropagation() // 标准浏览器 &#125; else &#123; window.event.cancelBubble = true // 兼容 IE &#125;&#125; 事件捕获事件冒泡是 ie 提出来的 路径 : 触发事件的目标元素(son) &gt; you &gt; father &gt; body &gt; document 事件捕获是火狐提出来的 路径 : document &gt; body &gt; father &gt;you &gt; 触发事件的目标元素 (son) 解析 : 事件的处理将从 DOM 层次的根开始，而不是从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递 // 当 addEventListener 第三个参数为 true 时，表示事件捕获arr[i].addEventListener('click', function () &#123; //&#125;, true) 事件流的三个阶段 事件的捕获阶段 事件的目标阶段（触发自己的事件） 事件的冒泡阶段 事件有三个阶段 : 捕获事件和冒泡事件都存在的话，首先发生的是捕获阶段，然后是目标阶段，最后才是冒泡阶段 addEventListener 第三个参数为是否捕获 如果为 true 时，表示该事件在捕获阶段发生 如果为 false 时，表示该事件在冒泡阶段发生 某一个事件只会执行一次 三大系列offset 系列 (重要) offset 系列用于用于获取元素自身的大小和位置，在webapi中有广泛应用offset 系列主要有：offsetHeight、offsetWidth、offsetParent、offsetLeft、offsetTop offsetHeight 与 offsetWidth 获取元素真实的高度和宽度 （内容大小 + border + padding）（关注盒子本身，不关注盒子内部内容） 获取到的是数值类型，方便计算 offsetHeight 与 offsetWidth 是只读属性，不能设置 style.height 与 style.width 只能获取和设置行内样式 不包括内边距、边框和外边距 获取到的是字符串类型，需要转换 offsetParent 获取离当前元素最近的定位父元素(absolute、relative)，如果没有，那就找body parentNode : 父节点（没有兼容性问题） parentElement : 父元素 offsetLeft 与 offsetTop 获取元素自身与 offsetParent 真实的距离 获取到的是数值类型，方便计算 只读属性，只能获取，不能设置 style.left 与 style.top 只能获取和设置行内样式 获取到的是字符串，需要转换 scroll 系列 (掌握1个) scroll 系列是用来获取盒子内容的大小和位置 scroll 系列主要有 : scrollWidth、scrollHeight、scrollLeft、scrollTop scrollWidth 与 scrollHeight scrollWidth 与 scrollHeight 是盒子内容的宽度和高度。与盒子大小无关，仅仅与盒子的内容有关系（padding + 内容） 如果内容没有溢出，scrollHeight 就是盒子高度 (scrollWidth同理) =&gt; 与clientHeight、clientWidth相同 如果内容超过盒子，scrollHieght 就是内容高度 (scrollWidth同理) scrollTop scrollTop 用于获取内容垂直滚动的像素数。如果没有滚动条，那么scrollTop值是0 内容超过盒子，盒子设置 overflow: scroll 就可出现滚动条 此属性是可读写的 scrollLeft scrollLeft 用于获取内容水平滚动的像素数 此属性是可读写的 浏览器切忌这种出现水平滚动条，用户体验极差，避免 scrollX 与 scrollY scrollY：文档在垂直方向已滚动的像素值pageYOffset 属性是 scrollY 属性的别名为了跨浏览器兼容，请使用 window.pageYOffset 代替 window.scrollY onscroll 事件 对于有滚动条的盒子，可以使用 onscroll 注册滚动事件，每滚动一像素，就会触发该事件 var div = doucment.getElementById('div')div.onscroll = function () &#123; console.log(div.scrollLeft) console.log(div.scrollTop)&#125; 场景 : 获取页面被卷去的高度和宽度 通常来说，scroll 家族用的最多的地方就是用来获取页面 被卷去的高度，非常的常用 对于老式的浏览器，需要获取 html 或者 body 的 scrollTop 对于现在浏览器，使用 window.pageYOffset 进行获取 页面被卷去的高度和宽度的兼容性封装 // 给整个页面注册滚动事件document.onscroll = function () &#123; var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0 console.log(scrollLeft,scrollTop)&#125; [案例 : 固定导航案例] client 家族 clien t家族用于获取盒子可视区的大小 (内容 + padding) client 家族有 clientWidth、clientHeight、clientLeft、clientTop clientWidth、clientHeight 可视区宽高 clientTop 与 clientLeft 完全没有用，他们就是borderTop与borderLeft onresize 事件：onresize 事件会在窗口被调整大小的时候发生。 window.onresize = function()&#123; // 事件处理程序&#125; 场景 : client 系列一般用来获取页面的可视区宽高 低版本浏览器 : 获取的html 和 body 高版本的浏览器 : window.innerWidth (掌握)（只读属性） // 因为求的是窗口大小所以用 windowwindow.onresize = function () &#123; var W = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth console.log(W) var H = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight console.log(H)&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>webapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime 插件、快捷键]]></title>
    <url>%2F2018%2Ftool%2FSublime%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[sublime 插件、快捷键 插件 Sublime Tutor ：键盘快捷方式教程Help &gt; Sublime Tutor AlignTab ：自定义快捷键 快捷键 Ctrl + X 如果已经选中文本，则剪切该文本。如果未选中任何文本，则剪切光标所在行 Ctrl + Z 撤消 Ctrl + Shift + V 缩进粘贴 Ctrl + Shift + Z 或 Ctrl + Y 恢复 Ctrl + L Select line - Repeat to select next lines Ctrl + D Select word - Repeat select others occurrences Ctrl + Shift + D 如果已经选中文本，则复制该文本。如果未选中任何文本，则复制光标所在行 Ctrl + Enter Insert line after Ctrl + Shift + Enter Insert line before Alt + F3 选择所有相同单词的实例 Tab 或 Ctrl + ] 缩进 Shift + Tab 或 Ctrl + [ 取消缩进 Ctrl + Shift + K Delete Line Ctrl + KK Delete from cursor to end of line Ctrl + K + Backspace Delete from cursor to start of line Alt + Shift + W 使用标签包裹选中部分 Ctrl + ← 移动光标至上一个词 Ctrl + → 移动光标至下一个词 Ctrl + Shift + ↓ Move line/selection down Ctrl + Shift + ↑ Move line/selection up Home 移动光标至行首 End 移动光标至行尾 Ctrl + Home 移动光标至文档开头 Ctrl + End 移动光标至文档结尾 Ctrl + M 跳转到左/右圆括号、方括号、大括号 Ctrl + Shift + M 选择括号内的内容 Ctrl + R 跳转到定义 Ctrl + / Comment/un-comment current line Ctrl + Shift + / Block comment current selection Ctrl + N 新建标签 Ctrl + PgUp 向左切换标签 Ctrl + PgDn 向右切换标签 Ctrl + W 关闭标签 Ctrl + Shift + T 重新打开标签 Shift + 鼠标右键 竖向选择 Ctrl + Shift + &#39; 选择与光标关联的开始和结束标签 Ctrl + Shift + A 选择容器内内容 Ctrl + Shift + ; 移除与你的光标相关的父标签(清除标记) Ctrl + Shift + Y 计算数学表达式 Alt + ↓&amp;↑ 以0.1的步长改变数字 Alt + Shift + ↓&amp;↑ 以10的步长改变数字 Ctrl + ↓&amp;↑ 以1的步长改变数字 Ctrl+K+U Ctrl+K+L 改变大小写 http://sublime.emptystack.net/ issues1. “Error: 404 Not FoundSorry, the requested URL ‘http://127.0.0.1:51004/view/29&#39; caused an error:‘buffer_id(29) is not valid (closed or unsupported file format)’NOTE: If you run multiple instances of Sublime Text, you may want to adjust the server_port option in order to get this plugin work again.” Quick Fix 1: Remove Strikethrough Extension Sublime Text &gt; Preferences &gt; Package Settings &gt; OmniMarkupPreviewer &gt; Settings - Userpaste the following to remove the strikeout package. &#123; "renderer_options-MarkdownRenderer": &#123; "extensions": ["tables", "fenced_code", "codehilite"] &#125;&#125; Quick Fix 2: Fix the Strikethrough Extension (if you need it) Find the python-markdown sublime package. /Packages/OmniMarkupPreviewer/OmniMarkupLib/Renderers/libs/mdx_strikeout.py Replace the makeExtension() method with the following: def makeExtension(*args, **kwargs): return StrikeoutExtension(*args, **kwargs)Save, quit and reload Sublime Text.]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法]]></title>
    <url>%2F2018%2Ftool%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown语法Markdown基本语法待… Markdown使用技巧换行 方法1：连续两个以上空格+回车 方法2：使用html语言换行标签：&lt;br&gt; 居中 使用align属性 使用&lt;center&gt;标签（HTML5 不支持） 首行缩进两个字符 &amp;nbsp; 不换行空格，全称No-Break Space &amp;ensp; 半角的空格，全称是En Space &amp;emsp; 全角的空格，全称是Em Space，占据的宽度正好是1个中文宽度 字体 *斜体*或_斜体_ **粗体** ***加粗斜体*** ~~删除线~~ 字号与颜色：使用内嵌HTML &lt;font color=#0099ff size=3 face="黑体"&gt;color=#0099ff size=3 face="黑体"&lt;/font&gt; 效果：color=#0099ff size=3 face=”黑体” 背景色使用内嵌 HTML 借助 table，tr，td 等表格标签的 bgcolor 属性 &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果：背景色是：orange 分割线在一行中用三个以上的星号 * 、减号 - 、底线 _ 来建立一个分隔线，中间用空格隔开，行内不能有其他东西。（除第一个符号的左侧最多添加三个空格外三个相同符号两侧可以添加任意多个空格） 链接文字 行内式：[文字](url &quot;title&quot;) 参考式：[文字][1] [1]:url &quot;title&quot; 自动链接：&lt;url&gt;，将链接用&lt;&gt;包起来，Markdown 会自动把它转成链接。 图片： 行内式：![alt_text](url &quot;title&quot;) alt_text：图片的 alt 标签，用来描述图片的关键词，可以不写。最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，可以方便搜索引擎根据 alt_text 里面的关键词搜索到图片。 url：可以是图片的本地地址或者是网址。”title”：鼠标悬置于图片上会出现的标题文字，可以不写。 参考式：同上 使用 img 标签：&lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;，&lt;div align=center&gt;&lt;/div&gt; 实现居中 折叠按钮&lt;details&gt; &lt;summary&gt; 点击展开 &lt;/summary&gt; &lt;!-- 内部展示内容 --&gt;&lt;/details&gt; 点击展开 设置小三角样式： summary::-webkit-details-marker &#123; color: #42b983;&#125; Markdown 编辑器typora]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2018%2Flinux%2Flinux%2F</url>
    <content type="text"><![CDATA[宝塔面板 linux 目录表/ 根目录 /bin 、 /usr/bin 可执行二进制文件目录，如常用的命令 ls cat 等 /boot 放置系统启动时用到的一些文件，如内核文件 /dev 存放系统下的设备文件，访问该目录下的文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom/mnt /etc 系统配置文件，重要的配置文件有 文件大小表示方式 单位 英文 字节 B (Byte) 千 K (KibiByte) 兆 M (MebiByte) 千兆 G (GigaByte) 太 T (TeraByte) 拍 P (PetaByte) 艾 E (ExaByte) 泽 Z (ZettaByte) 尧 Y (YottaByte) linux 常用命令 命令 作用 ls list 查看当前文件夹下的内容 pwd print work directory 查看当前所在文件夹 cd[目录名] change directory 切换文件夹 touch[文件名] touch 如果文件不存在，新建文件如果文件已经存在，修改文件的末次修改日期 mkdir[目录名] make directory 创建目录 rm[文件名] remove 删除指定的文件名 clear 清屏 ls 常用选项 -a 显示所有目录和文件，包括隐藏文件 $ ls -a. .. .xxx.txt# 以.开头的文件/文件夹为隐藏文件/文件夹# . 代表当前目录# .. 代表上一级目录# 蓝色为目录，白色为文件 -l 以列表方式显示文件的详细信息 -h 配合-l 以人性化的方式显示文件大小 选项可以合写，无顺序 $ ls -alh ls 通配符 * 代表任意个数个字符 ？代表任意一个字符 [] 表示可以匹配字符组中的任意一个 [abc] 匹配a、b、c 中的任意一个 [a-f] 匹配 a-f 任意一个字符 cd 常用选项 cd/cd ~ 切换到当前用户的主目录 cd .. 切换到上一级目录 cd - 在最近两次工作目录间切换 mkdir -p 可以递归创建目录 $ madir -p a/b/c 同一目录下文件夹名称不能和文件名同名 rm 删除时直接删除，不放入回收站 -f 强制删除，忽略不存在的文件，无需提示 -r 递归的删除目录下的内容，或用于删除文件夹 终端命令格式$ command [-options][paramete] command : 命令名，相应功能的英文单词或单词缩写-options： 选项paramete ：参数 查阅帮助信息$ command --help$ man command# man 是manual缩写,手册# 使用man 时的操作键# 空格 显示手册的下一屏# enter 一次滚动手册页的一行# b 回滚一屏# f 前滚一屏# q 退出# /word 搜索word字符串 终端技巧 自动补全 在敲出 文件/目录/命令的前几个字母后，按下 tab 键 如果输入没有歧义，系统会自动补全 如果输入有歧义，再按一下 tab 键，系统会提示可能存在的命令 曾经使用过的命令 按上下键可在曾经使用过的命令间切换，Ctrl+c 退出选择 文件和目录常用命令拷贝和移动文件 tree [目录名]： 以树状图列出文件目录结构 -d 只显示目录，不显示文件 cp 源文件 目标文件： copy 复制文件或者目录 $ cp ~/Documemt/readme.txt ./readme.txt# 将 ~/Documemt/ 目录下的 readme.txt 文件复制到./目录下并以readme.txt命名# 如果不修改文件名，只需要写目标路径$ cp ~/Documemt/readme.txt ./ -i ：覆盖文件前提示 y 覆盖 n 不覆盖 -r ：若给出的源文件是目录文件，将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 mv 源文件 目标文件：move 移动文件或目录/ 文件或目录重命名 $ mv ~/Documemt/readme.txt ./# 将 ~/Documemt/ 目录下的 readme.txt 文件移动到./目录下$ mv readme.txt demo.txt# 将readme.txt文件名修改为demo.txt -i ：覆盖文件前提示 y 覆盖 n 不覆盖 查看文件内容 cat 文件名： concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能，会一次显示所有内容，适合内容较少的文本文件 -b：对非空输出行编号 -n：对输出的所有行编号 linux 中还有一个 nl 命令和 cat -b 的效果等价 more 文件名：分屏显示文件内容 ，按空格显示下一屏，适合查看内容较多的文本 # 使用 more 时的操作键 和 man 相同# 空格 显示手册的下一屏# enter 一次滚动手册页的一行# b 回滚一屏# f 前滚一屏# q 退出# /word 搜索word字符串 grep 搜索文本 文件名： 搜索文本文件内容，输出包含该文本的行 linux 中的文本搜索工具，允许对文本文件进行模式查找（正则表达式），如果搜索文本中间有空格可以使用引号包裹 -n 显示匹配行和行号 -v 显示不包含匹配文本的所有行（相当于求反） -i 忽略大小写 ^a 行首，搜索以 a 开头的行 ke$ 行尾，搜索以 ke 结束的行 其他 echo 文字内容 ：会在终端中显示参数指定的文本，通常会和重定向联合使用 重定向 &gt; 和 &gt;&gt;： linux 允许将命令执行结果重定向到一个文件，将本应显示在终端上的内容输出/追加到指定文件中，保存命令输出结果 &gt; 表示输出，会覆盖文件原有的内容 &gt;&gt; 表示追加，会将文件追加到已有文件的末尾 # 创建 a 文件并将 “hello world”输出到 a 文件中 ，与touch区别$ echo hello world &gt; a# 将命令 “ls -lh” 的结果输出到 a 文件中$ ls -lh &gt; a 管道 | linux 允许将一个命令的输出通过管道作为另一个命令的输入，另一个命令对第一个命令的输出进行二次处理 可以理解为现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，左端塞东西（写），右端取东西（读） # more：分屏显示内容# 分屏显示命令 “ls -lha” 的输出结果$ ls -lha ~ | more# grep：在命令执行结果的基础上查询指定文本# 查找 “ls -lha ~” 的结果中包含Do的行并显示$ ls -lha ~ | grep Do 远程管理命令关机/重启shutdown 选项 时间 `-r` 重新启动 不指定选项和参数，默认表示一分钟之后关闭电脑 远程维护服务器时，最好不要关闭系统，而应该重新启动系统 # 常用命令示例# 重新启动电脑，now 表示现在$ shutdown -r now# 系统在今天20:00 关机$ shutdown 20:00# 系统十分钟后自动关机$ shutdown +10# 取消关机计划$ shutdown -c 查看或配置网卡信息ifconfig: configure a network interface 查看/配置计算机当前的网卡配置信息 # 查看网卡配置信息$ ifconfig# 查看网卡对应的IP地址$ ifconfig | grep inet 在 linux 中物理网卡通常以 ensxx 表示 127.0.0.1 本地环回/环回地址，一般用来测试本机网卡是否正常 ping ip地址： ping 检测到目标 ip 地址连接是否正常 ping 127.0.0.1 检查本地网卡是否工作正常 远程登录和复制文件 ssh 用户名@ip ：secure shell 关机/重新启动 scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径：secure copy 远程复制文件 SSH ：SSH 客户端是一种使用 Secure Shell (SSH) 协议连接到远程计算机的软件协议 数据传输是加密的，可以防止远程管理过程中的信息泄露，也能防止 DNS 欺骗和 IP 欺骗 数据传输是压缩的，可以提高传输速度 有关 ssh 配置信息都保存在用户家目录下的 .ssh目录下 域名和端口号域名：由一串用点分割的名字组成，例如 www.baidu.com ，是 IP 地址的别名，方便记忆 端口号：通过 IP 地址可以找到网络上的计算机，通过端口号可以找到计算机上运行的程序 SSH 服务器默认端口号为 22，Web 服务器为 80，HTTPS 为 443，FTP 服务器为 21，如果没有指定端口号，使用默认端口号 SSH 基本使用$ ssh [-p port] user@remote# user 远程服务器上的用户名，如果不指定默认当前用户# remote 远程机器的地址，可以是IP/域名，或者别名# port 是SSH server 监听的端口，如果不指定，默认22# 使用 exit 退出当前用户登录# ssh 在 linux 或 Unix 系统下可直接使用，win下需要安装软件 putty xshell scp 基本使用# 从远程服务器拷贝文件$ scp user@remote ip:文件名或路径 文件名或路径# -r 复制目录# -P 指定端口是要用大写的 P# 上传文件到服务器$ scp 文件名或路径 user@remote ip:文件名或路径 scp 命令只能在 Linux 或 Unix 下使用 在 win 系统中需安装 filezilla 使用 FTP 进行文件传输 FileZilla 传输文件时，使用的是 FTP 服务而不是 SSH 服务，因此端口号应该为 21 ssh 高级 免密码登陆 配置公钥：执行 ssh-keygen 即可生成 ssh 钥匙，一路回车即可 ​ id_rsa.pub 公钥 、 id_rsa 私钥 上传公钥到服务器：执行 ssh-copy-id -p port user@remote，公钥保存在服务器 .ssh 目录下 ​ authorized_keys 本地使用私钥对数据进行加密/解密，服务器使用公钥对数据进行加密/解密 非对称加密算法 使用公钥加密的数据，需要使用私钥解密 使用公私钥加密的数据，需要使用公钥解密 配置别名 ~/.ssh/config Host vultr HostName ip地址 User root port 22 直接使用 ssh vultr 即可实现登陆，scp 同样适用 用户和权限的相关命令用户和权限的基本概念 用户管理包括 用户 和 组 管理 在 linux 中可以指定每一个用户针对不同的文件或目录不同的权限 对文件/目录的权限包括 权限 英文 缩写 数字代号 读 red r 4 写 write w 2 执行 excute x 1 无 - 0 组：实际工作中，可以预先对组设置好权限，然后将不同的用户添加到不同的组中（简化了用户权限设置） # ls -l 扩展$ ls -l-rw-rw-r-- 1 用户名 组名 大小 时间 名称drwxrwxr-x 2 - rw- rw- r– 1 用户名 组名 d rwx rwx r-x 2 文件/目录 当前用户权限 当前组所对应的权限 其他用户权限 硬链接数 硬链接数：表示有多少种方式可以访问到当前目录/文件，文件的硬链接数通常为 1，目录的硬链接数取决于该目录有多少个子目录。 修改文件/目录权限 chomd$ chmod +/-rwx 文件名|目录# + 增加权限 - 删除权限# 直接修改文件/目录的读、写、执行权限，但不能精确到 拥有者/组/其他$ chmod +x 文件名 // 增加文件可执行权限$ chmod -r 目录 // 删除目录可读权限# 目录的可读权限：读取目录内容（如果没有此权限，可cd，不能ls）# 目录的可写权限：修改目录内容# 目录的可执行权限：对目录执行终端命令（如果没有此权限，甚至无法 cd 到目录） chmod 高级用法 超级用户 root 账户用于系统的维护和管理，对操作系统的所有资源具有所有访问权限 不推荐直接使用 root 账户登录系统 在 linux 安装过程中，系统会自动创建一个标准用户账号 sudo su 是 substitute user 缩写，表示使用另一个用户身份 sudo 命令用来以其他身份来执行命令，预设身份为 root 用户使用 sudo 时，需先输入密码，之后有五分钟的有效期，超过期限去重新输入密码 组管理groupadd 组名 ：添加组 groupdel 组名 ：删除组 cat /etc/group ：确认组信息 chgrp 组名 文件/目录名 ：修改文件/目录的所属组 -R 递归修改 创建组/删除组的终端命令都需要通过 sudo 来执行 组信息保存在 /etc/group 文件中 /etc 目录是专门用来保存 系统配置信息的目录 用户管理创建用户/设置密码/删除用户 useradd -m -g 组 新建用户名 ：添加新用户 ​-m 自动建立用户家目录 ​-g 指定用户所在的组，否则会建立一个和用户名同名的组 passwd 用户名：设置用户密码 ​如果是普通用户，直接用 passwd 可以修改自己的账户密码 userdel -r 用户名：删除用户 ​-r 选项自动删除用户家目录 cat /etc/passwd | grep 用户名：确认用户信息 ​新建用户后，用户信息保存在 /etc/passwd 文件中 创建用户/删除用户/修改其他用户密码 的命令都需要通过 sudo 执行 用户信息保存在 /etc/passwd 文件中 查看用户信息 id [用户名]：查看用户 UID 和 GID 信息 who ：查看当前所有登陆的用户列表 $ who用户名 时间 (:0) # :0 表示当前电脑用户名 时间 (172.16.xx.xx) whoami ：查看当前登录用户的账户名 passwd 文件 由六个分号组成七个信息 用户名 密码（x，表示加密的密码） UID（用户标识） GID（组标识） 用户全名 家目录 登录使用的 shell，就是登陆之后使用的终端，ubuntu 默认使用 dash usermod 用来设置用户的主组/附加组 和登录 shell 主组：在用户新建时指定，在 etc/passwd 的第四列 GID 对应的组 附加组：在 etc/group 中最后一列表示该组的用户列表，用于指定用户的附加权限 设置用户的附加组之后，需要重新登录才能生效 # 修改用户的主组$ usermod -g 组 用户名# 修改用户的附加组$ usermod -G 组 用户名# 修改用户登录shell$ usermod -s /bin/bash 默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，使用以下命令将用户添加到 sudo 附加组中 usermod -G sudo 用户名 which /etc/passwd 是用于保存用户信息的文件 /usr/bin/passwd 是用于修改用户密码的程序 # which 可用于查看执行命令所在的位置$ which ls# /bin/ls$ which useradd# /usr/sbin/useradd cd 这个命令是内置在系统内核中的，没有独立文件，因此用 which 无法找到 bin 和 sbin /bin (binary) 是二进制执行文件目录，主要用于具体应用 /sbin (system binary) 是系统管理员专用的二进制文件目录，主要用于系统管理 /usr/bin (user commands for applications) 后期安装的一些软件 /usr/sbin (super user commands for applications) 超级用户的一些管理程序 bin 存储普通可执行文件，sbin 存储跟系统管理相关的可执行文件 切换用户su - 用户名：切换用户，并且切换目录 ​- 可以切换到用户家目录，否则保持位置不变 exit： 退出当前登录用户 su 不接用户名，可以切换到 roo，不推荐，不安全 exit 示意图： 修改文件权限chowm 修改拥有者 chgrp 修改组 chmod 修改权限 # 修改文件/目录的拥有者$ chown 用户名 文件名/目录名# 递归修改文件/目录的组$ chgrp -R 组名 文件名/目录名# 递归修改文件权限# 755 三个数字分别代表 用户 u /组 g /其他用户 o 的权限$ chmod -R 755 文件名/目录名 r –&gt; 4 w –&gt; 2 x –&gt; 1 无权限 –&gt; 0 ，想要什么权限直接将数字相加 系统信息相关命令 查询服务器上当前系统日期和时间 / 磁盘空间占用情况 / 程序执行情况 时间和日期date ：查看系统时间 cal ：calendar 查看日历， -y 选项可以查看一年的日历 磁盘和空间目录df -h ：disk free 显示磁盘剩余空间 -h 以人性化的方式显示文件大小 du -h [目录名] ：disk usage 显示目录占用空间情况，不指定目录默认表示当前目录 -h 以人性化的方式显示文件大小 进程信息PID 进程代号 ps au : process status 查看进程的详细状况，默认只显示当前用户通过终端启动的程序 ​ps 选项(没有减号) ​a 显示终端上的所有进程，包括其他用户的进程 ​u 显示进程的详细状态 ​x 显示不是通过终端启动的进程 top : 动态显示运行中的进程并且排序 ，输入 q 退出 kill [-9] 进程代号 : 终止指定代号的进程，-9 表示强行终止 其他命令查找文件find [路径] -name “*.txt” : 查找指定路径下扩展名为.txt 的文件，包括子目录 ​ 如果省略路径，表示在当前文件夹下查找 软连接ln -s 被链接的源文件 链接文件 ：建立文件的软链接，类似于 Windows 下的快捷方式 注意： 如果没有 -s 选项建立的是一个硬链接文件（两个文件占用相同大小的磁盘空间，几乎不用） 源文件要使用绝对路径，可以方便移动链接文件后，仍然能够正常使用 文件软硬链接示意图 在 linux 中文件名和文件的数据是分开存储的 在 linux 中，只有文件的硬链接数为 0 文件才会被删除 在日常工作中几乎不会建立文件的硬链接 打包和解包tar 是 Linux 中常用的备份工具，此命令可以把一系列文件打包到一个大文件中，也可以把一个打包的大文件恢复成一系列文件 # 打包文件tar -cvf 打包文件.tar 被打包的文件/路径 (多个文件一次写在后面，用空格隔开)# 解包文件tar -xvf 打包文件.tar c 生成档案文件，创建打包文件 x 解开档案文件 v 列出归档接档的详细过程 f 指定档案文件名称， f 选项必须放在最后 压缩和解压缩gzip tar 和 gzip 命令结合使用实现文件打包和压缩 tar 只负责打包，但不压缩 用 gzip 压缩 tar 打包后的文件，扩展名为 xxx.tar.gz tar 命令中 -z 选项可以调用 gzip # 压缩文件tar -zcvf 打包文件.tar.gz 被压缩文件/路径# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径# -C 解压到指定路径，（路径必须存在）tar -zxvf 打包文件.tar.gz -C 目标路径 bzip2 tar 和 bzip2 命令结合使用实现文件打包和压缩（用法同 gzip） tar 只负责打包，但不压缩 用 bzip2 压缩 tar 打包后的文件，扩展名为 xxx.tar.bz2 tar 命令中 -j 选项可以调用 bzip2 # 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩文件/路径# 解压缩文件tar -jxvf 打包文件.tar.bz2# 解压缩到指定路径# -C 解压到指定路径，（路径必须存在）tar -jxvf 打包文件.tar.bz2 -C 目标路径 软件安装apt : Advanced Packaging Tool ，linux 下安装包管理工具，可以方便的安装/卸载/更新软件包 # 安装软件sudo apt install 软件包# 卸载软件sudo apt remove 如软件名# 更新已安装的包sudo apt upgrade neofetch screenfetch sudo -i 为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。提示输入密码时该密码为当前账户的密码。没有时间限制。执行该命令后提示符变为“#”而不是“$”。想退回普通账户时可以执行“exit”或“logout” 。su 切换到某某用户模式，提示输入密码时该密码为切换后账户的密码，用法为“su 账户名称”。如果后面不加账户时系统默认为 root 账户，密码也为超级账户的密码。没有时间限制。sudo su 运行 sudo 命令给 su 命令提权，运行 su 命令。sudo -i 运行结果 PWD=/rootsudo su 运行结果 PWD=/home/用户名（当前用户主目录） sudo : 暂时切换到超级用户模式以执行超级用户权限，提示输入密码时该密码为当前用户的密码，而不是超级账户的密码。不过有时间限制，Ubuntu 默认为一次时长 15 分钟。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 版本控制系统]]></title>
    <url>%2F2018%2Ftool%2Fgit%2F</url>
    <content type="text"><![CDATA[版本控制系统为什么要有版本控制系统在开发过程中，经常需要对一个文件进行修改甚至删除，但是我们又希望能够保存这个文件的历史记录，如果通过备份，那么管理起来会非常的复杂 什么是版本控制系统 版本控制系统（Version Control System）:是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。 版本控制系统的分类参考文章：关于版本控制的介绍 本地版本控制系统 本地版本控制系统就是在一台机器上，记录版本的不同变化，保证内容不会丢失 如果多人开发，每个人都在不同的系统和电脑上开发，没办法协同工作。 集中式版本控制系統 svn 是集中式的版本控制系统，集中式版本控制系统都有一个单一的集中管理的服务器（中央服务器），保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 需要一个中央服务器来管理代码的的版本和备份 所有的用户电脑都是从中央服务器获取代码或者是将本地的代码提交到中央服务器 依赖与网络环境，如果连不上中央服务器，就无法提交和获取代码。 分布式版本控制系统 git 是分布式的版本控制系统。分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份 需要一台服务器作为代码仓库 每个用户电脑都是一个服务器（代码仓库），并且和代码仓库是镜像的，用户修改和获取代码都是提交到自己的服务器当中。 不需要网络就可以进行工作。 当连接网络时，用户可以选择将自己的服务器与代码仓库进行同步。 Git git 官方中文文档 Git 核心概念 WorkSpace：工作区，即从仓库中checkout出来的，需要通过Git进行版本控制的目录和文件，可以简单的理解为在电脑里真实看到的文件； Stage(Index)：暂存区，或者叫做待提交更新区；在提交进入Repository之前，可以把所有的更新放在暂存区, 用 git add 的文件都在这里； Repository(Remote/Local)：仓库，一个存放在远端／本地的版本库，用 git commit 提交的文件就到Local Repository,用 git push 提交的文件就到Remote Repository； .git：存放Git管理信息的目录，初始化仓库的时候会自动创建。 Git 初始设置设置用户名和邮箱# 用户名使用英文# --global 全局设置git config --global user.name 'your_name'git config --global user.email 'your_email@example.com'# 查看账号信息git config --list# 重置信息git config --unset -- user.name 全局设置会在~/.gitconfig中以如下形式输出设置文件，可以直接编辑这个文件来修改设置 [user]name = your_nameemail = your_email@example.com 每个仓库的 Git 配置文件都放在 .git/config 文件中，可以直接修改此文件$ cat .git/config 查看配置文件 # 解决中文变成数字加百分号，也可以在设置中将编码修改为 utf-8git config --global core.quotepath false 设置 SSH KeyGitHub 上连接已有仓库时的认证，是通过使用了 SSH 的公开密钥认证方式进行的。现在我们来创建公开密钥认证所需的 SSH Key，并将其添加至 GitHub 运行下面的命令 ssh-keygen -t rsa -C "your_email@example.com"Generating public/private rsa key pair.Enter file in which to save the key(/Users/your_user_directory/.ssh/id_rsa):按回车键Enter passphrase (empty for no passphrase):输入密码Enter same passphrase again:再次输入密码 输入密码后会出现以下结果 Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa.Your public key has been saved in /Users/your_user_directory/.ssh/id_rsa.pub.The key fingerprint is:SHA256:hbn1zPihlVDe/Y2FvzzZU8l+AOSlVRlaOmro/nTQDGg cui3155@gmail.com(fingerprint值+your_email@example.com)The key's randomart image is:+---[RSA 2048]----+| o o++|...| . . . +|| ... |+----[SHA256]-----+ id_rsa 文件是私有密钥，id_rsa.pub 是公开密钥 添加公开密钥在 GitHub 中添加公开密钥，今后就可以用私有密钥进行认证了点击右上角的账户设定按钮（Account Settings），选择 SSH Keys 菜单。点击 AddSSH Key 之后，在 Title 中输入适当的密钥名称。Key 部分请粘贴 id_rsa.pub 文件里的内容 id_rsa.pub 的内容可以用如下方法查看 cat ~/.ssh/id_rsa.pubssh-rsa公开密钥的内容your_email@example.com 完成以上设置后，就可以用手中的私人密钥与 GitHub 进行认证和通信了 ssh -T git@github.comThe authenticity of host 'github.com (192.30.255.113)' can't be established.RSA key fingerprint is (fingerprint值).Are you sure you want to continue connecting (yes/no)?输入yesWarning: Permanently added 'github.com,192.30.255.113' (RSA) to the list of known hosts.Enter passphrase for key '/c/Users/C.DESKTOP-3S4APJ4/.ssh/id_rsa': 出现如下结果即为成功 Hi cuilongjin! You've successfully authenticated, but GitHub does not provide shell access. 提高命令输出的可读性将 color.ui 设置为 auto 可以让命令的输出拥有更高的可读性 git config --global color.ui true ~/.gitconfig 中会增加下面一行 [color]ui = true 这样一来，各种命令的输出就会变得更容易分辨。 文件名大小写问题git 默认对文件名大小写不敏感 # 设置 git 大小写敏感git config core.ignorecase false# 或者先删除文件在添加进去 设置头像通过 Gravatar 服务 配置别名# 配置 st 别名表示 statusgit config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branchgit config --global alias.unstage 'reset HEAD'git config --global alias.last 'log -1'git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit" 搭建 Git 服务器搭建Git服务器 配置多用户根据不同邮箱生成对应的私钥公钥 ssh-keygen -t rsa -C email 将公钥上传到对应的用户账号中 在 .ssh 目录创建 config 文件，配置私钥对应的服务器，每个账号单独配置一个 Host，每个 Host 要取一个别名，每个 Host 主要配置 HostName 和 IdentityFile 两个属性即可 # 配置用户1Host githubHostName github.comIdentityFile ~/.ssh/id_rsa_githubUser cuilongjin# 配置用户2Host gitlabHostName git.gitlab.netIdentityFile ~/.ssh/id_rsa_gitlabUser cuilongjin Host 的名字可以任意，不过这个会影响 git 相关命令，例如： Host mygithub 这样定义的话，命令如下 git clone git@mygithub:cuilongjin/cuilongjin.git 即 git@ 后面紧跟的名字改为 mygithub 执行 ssh -T git@github、ssh -T git@gitlab 测试是否成功 配置局部 git 用户名和邮箱，如果没有局部配置，默认用全局配置 git config user.name "Your name"git config user.email "your_email@gmail.com" 或者直接找到 .git/config 文件，添加 [user]name = Your nameemail = your_email@gmail.com Git 基本操作git initmkdir projectcd projectgit init 如果初始化成功，执行了 git init 命令的目录下就会生成 .git 目录。这个 .git 目录里存储着管理当前目录内容所需的仓库数据。 mkdir project 命令创建 project 空文件夹 pwd 命令用于显示当前目录 git add# 将指定文件夹添加到暂存区（目录中的所有文件，包括新增/修改/删除的文件）--not-all 忽略删除的git add 目录名# 将 指定文件 添加到暂存区 （文件可以是新增/修改/删除的）git add README.md# 将当前目录下所有的js文件添加到暂存区（文件可以是新增/修改的，不包括删除的）git add *.js# 添加当前目录及子目录下件 （文件可以是新增/修改/删除的）git add .# 添加当前仓库下所有的文件 （文件可以是新增/修改/删除的）git add -Agit add --all git commit# 将文件从暂存区提交到仓库git commit -m '提交说明'# 如果是一个已经暂存过的文件，可以快速提交，如果是未追踪的文件，那么命令将不生效。git commit -a -m '提交说明'# 修改最近的一次提交说明， 如果提交说明不小心输错了，可以使用这个命令git commit --amend -m '提交说明' -m 参数后的 &#39;First commit&#39; 称作提交信息，是对这个提交的概述,如果想要记述得更加详细，请不加 -m ，直接执行 git commit 命令，执行后编辑器就会启动。在编辑器中记述提交信息的格式如下:​ 第一行：用一行文字简述提交的更改内容​ 第二行：空行​ 第三行以后：记述更改的原因和详细内容 git status# 建立 README.md 文件作为管理对象touch README.mdgit status# 简化日志输出格式git stauts -s (short) git status 命令可以让我们时刻掌握仓库当前的状态，但不能看到具体修改了什么内容，需要用 git diff 这个命令来查看具体修改内容。 git diff# 查看当前工作树和最新add之间（暂存区）的差别（difference）git diff# 如果尚未用 `git add` 命令向暂存区添加任何东西，则程序只会显示工作树与最新提交状态之间的差别# “+”号标出的是新添加的行，被删除的行则用“-”号标出#查看README.md文件的修改git diff -- README.md# 查看工作树和最新提交的差别git diff HEAD# 查看暂存区与仓库区的不同git diff --cached# 查看两个版本之间的不同git diff c265262 de4845b HEAD 是指向当前分支中最新一次提交的指针 git log# 显示当前版本之前的提交信息git logcommit 9f129bae19b2c82fb4e98cde5890e52a6c546922Author: cuilongjin &lt;cuilongjin@gmail.com&gt;Date: Sun Oct 8 22:08:39 2017 +0900 First commit# 只显示提交信息的第一行git log --pretty=oneline # 完整显示版本号git log --oneline # 只显示前7位版本号# 显示指定目录、文件的日志git log 目录名或文件名# 显示文件的改动（q键退出命令）git log -p 文件名# 显示所有曾经提交的版本（包括被删除的）git reflog git resetgit reset -h '查看帮助'--mixed 'reset HEAD and index'(默认)--soft 'reset only HEAD'--hard 'reset HEAD, index and working tree'--merge 'reset HEAD, index and working tree'--keep 'reset HEAD but keep local changes' HEAD 表示当前版本，上一个版本就是 HEAD^ ，上上一个版本就是 HEAD^^ ，当然往上100个版本写100个^比较容易数不过来，所以写成 HEAD~100 。 使用 commit_id 回退 , git reflog 用来记录你的每一次命令和 commit_id git reset --soft HEAD^git reset --hard commit_idgit reset HEAD [file] git checkout –filegit checkout -- README.md 把 README.md 文件在 工作区的修改全部撤销 ，用版本库里的版本替换工作区的版本 这里有两种情况： 一种是 README.md 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 一种是 README.md 已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态 总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态，可用于撤销文件修改或恢复误删文件 git remotegit remote add origin git@github.com:cuilongjin/git_test.git 添加后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库 # 查看远程库的信息git remote -vorigin git@github.com:cuilongjin/git_test.git (fetch)origin git@github.com:cuilongjin/git_test.git (push)# 查看指定远程库的详细信息git remote show &lt;远程库&gt; 上面显示了可以抓取和推送的 origin 的地址。如果没有推送权限，就看不到 push 的地址 # 删除已有的 GitHub 远程库git remote rm origin# 修改远程库名称git remote rename &lt;原远程库名&gt; &lt;新远程库名&gt; git pull# 获取远程仓库的更新，并且与本地的分支进行合并git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;# 如果远程分支是与当前分支合并，则冒号后面的部分可以省略git pull origin next 等同于 git fetch origin &amp;&amp; git merge origin/next# 远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支# 加上参数 -p 就会在本地删除远程已经删除的分支$ git pull -p# 等同于下面的命令$ git fetch --prune origin $ git fetch -p# 合并 pull 两个不同的项目出现 fatal: refusing to merge unrelated historiesgit pull origin master ----allow-unrelated-histories git pushgit push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 第一次推送分支时，加上 -u 参数，git 会把本地分支和远程分支关联起来，在以后的推送或者拉取时就可以简化命令git push -u origin master# 如果没有本地分支，表示删除远程分支git push origin :master# 等同于$ git push origin --delete master# 以强制覆盖的方式推送修改后的 repo （重新上传 repo）（不指定分支即所有分支）git push origin --force --all remote: error: GH007: Your push would publish a private email address.解决方法——http://github.com/settings/emails 把Keep my email address private这一项去掉勾选即可。 如果推送失败，则因为远程分支比你的本地更新，需要先用 git pull 拉取远程的新提交 git clonegit clone git@github.com:cuilongjin/仓库名.git [指定文件夹]# 默认远程主机为 origin ， -o 指定主机名git clone --o origin1 git@github.com:cuilongjin/仓库名.git Git 支持多种协议，包括 https，但通过 ssh 支持的原生 git 协议速度最快 从远程库 clone 时，默认情况下，只能看到本地的 master 分支要在 dev 分支上开发，就必须创建远程 origin 的 dev 分支到本地，于是用这个命令创建本地 dev 分支 git checkout -b dev origin/dev# 指定本地 dev 分支与远程 origin/dev 分支的链接git branch --set-upstream dev origin/dev 克隆指定分支 # git clone -b|--branch 分支名或tag名 仓库地址 git fetch# 将某个远程仓库的更新，全部取回本地。默认取回所有分支（branch）的更新git fetch &lt;远程仓库&gt;# 取回特定分支的更新git fetch &lt;远程仓库&gt; &lt;分支名&gt; git fetch 和 git pull 区别 git pull 获取远程仓库的更新，并且与本地的分支进行合并 git fetch 所取回的更新，在本地主机上要用 “远程仓库/分支名” 的形式读取，即不会与本地分支合并 git 忽视文件在仓库中，有些文件是不想被 git 管理的，比如数据的配置密码、写代码的一些思路等。git 可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 .class 文件 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件 在仓库的根目录创建一个.gitignore的文件，文件名是固定的 将不需要被 git 管理的文件路径添加到.gitignore中，把 .gitignore 也提交到 Git，Git 就会自动忽略这些文件 # 忽视 index.txt 文件index.txt# 忽视 .gitignore 文件.gitignore# 忽视 css 下的 index.css 文件css/index.css# 忽视 css 下的所有的 css 文件css/*.css# 忽视 css 下的所有文件css/*.*# 忽视 css 文件夹css GitHub 已经为我们准备了各种配置文件 https://github.com/github/gitignore 强制添加被 .gitignore 忽略的文件 # 强制添加被.gitignore忽略的文件git add -f &lt;file&gt;# 检查哪个规则忽略了此文件，以便修订规则git check-ignore -v &lt;file&gt;.gitignore:x:xxx.xx xxxxxx git branch在 git 中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git 中使用 HEAD 指向当前分支 git branch* master-r 参数查看远程分支-a 查看所有分支(远程分支会用红色表示出来) *（星号）表示当前所在的分支 git checkout -b 创建、切换分支 # 以 branch 为基础创建名为 feature-A 的分支git checkout -b feature-A &lt;branch&gt; 连续执行下面两条命令也能收到同样效果 # 创建 feature-A 分支git branch feature-A# 将当前分支切换为 feature-A 分支git checkout feature-A# 切换回上一个分支git checkout - git branch -d 删除分支 # 删除本地 feature-A 分支git branch -d feature-A# 强行删除本地 feature-A 分支git branch -D feature-A# 删除远程 feature-A 分支git push origin :feature-A或 git push origin --delete feature-A git branch -m 重命名分支 # 重命名本地分支git branch -m old_branch new_branch# 重命名远程分支# 重命名本地分支 -&gt; 删除远程分支 -&gt; 推送到远程分支 git merge合并分支 # 将 feature-A 合并到 master 上# 首先切换到 master 分支，然后执行git merge [--squash] [--no-ff] -m "描述" feature-A--squash # 只是将&lt;branch&gt;中的修改内容迁移过来，而不保留其中的commit历史--no-ff # 创建合并提交，为了在历史记录中明确记录下本次分支合并 git stash# 把当前工作现场“储藏”起来git stash# 查看存储的工作现场git stash list 恢复工作现场 # 恢复工作现场，stash 内容并不删除git stash apply# 删除 stash 内容git stash drop# 恢复的同时把 stash 内容也删了git stash pop 恢复指定的 stash，用命令：git stash apply stash@{0} 廖雪峰Git教程创建与合并分支 廖雪峰Git教程分支管理策略 廖雪峰Git教程Bug分支 git tag 创建标签 # 首先切换到需要打标签的分支上# 默认标签是打在最新提交的 commit 上的git tag v1.0# 对指定某一次提交打标签git tag v1.0 &lt;commit id&gt;# 创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字git tag -a v1.0 -m "version1.0 released" &lt;commit id&gt;# 通过 -s 用私钥签名一个标签(需配置gpg密钥对)git tag -s v1.0 -m "signed version1.0 released" &lt;commit id&gt; 查看标签 # 查看所有标签git tagv1.0# 查看所有标签信息git show# 查看 v1.0 标签信息git show v1.0commit id:xxxAuthor:xxxDate:xxx 推送标签到远程 # 推送 v1.0 标签到远程git push origin v1.0# 推送全部尚未推送的本地标签到远程git push origin --tags 删除标签 # 删除本地标签 v1.0git tag -d v1.0# 删除远程标签 v1.0git push origin :refs/tags/v1.0或 git push origin --delete tag v1.0 git 修改提交历史修改最后一条 commit git commit --amend 修改多条 commit git rebase -i HEAD~3 修改最近三次提交git rebase -i --root 修改所有提交 Commands p, pick = use commit: 直接使用commit 不做任何修改，其中p 是pick的缩写，以下雷同； r, reword = use commit, but edit the commit message: 使用commit，但是会更改commit 信息； e, edit = use commit, but stop for amending :使用commit，但是遇到此命令时会停止合并； s, squash = use commit, but meld into previous commit: 使用commit,但是会合并到前一个commit中； f, fixup = like “squash”, but discard this commit’s log message：和squash类似，但是会抛弃commit的log信息 x, exec = run command (the rest of the line) using shell：使用shell运行命令 d, drop = remove commit：丢弃commit https://www.jianshu.com/p/67f20d19605a othergit add .的时候遇到warning: LF will be replaced by CRLF in ……`git config core.autocrlfgit config --global core.autocrlf false# true：添加文件到git仓库时，git将其视为文本文件。他将把crlf变成lf# false：line-endings将不做转换操作。文本文件保持原来的样子# input：把crlf转成lf，当有人Check代码时还是lf方式。因此在window操作系统下，不要使用这个设置# CRLF (carriagereturnlinefeed)：表示句尾使用回车换行两个字符(即Windows编程时使用"\r\n"换行)# LF(line feed)：表示句尾只使用换行(Unix Style)# CR：表示只使用回车 Git 永久删除文件(包括历史记录)https://help.github.com/articles/removing-sensitive-data-from-a-repository/ # 在仓库的根目录执行git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch 文件路径' --prune-empty --tag-name-filter cat -- --all# 文件路径相对于git仓库根目录# 删除文件夹 添加 -r 命令# 以强制覆盖的方式推送修改后的 repo （不指定分支即所有分支）（重新上传 repo）git push origin --force --all# 强制推送 tagsgit push origin --force --tags# 清理和回收空间rm -rf .git/refs/original/git reflog expire --expire=now --allgit gc --prune=nowgit gc --aggressive --prune=now 重新绑定，而不是合并创建的旧（受污染）存储库历史记录中的任何分支 git 修改已提交的某一次的邮箱和用户信息 git filter-branch -f --env-filter \"GIT_AUTHOR_NAME='Newname'; GIT_AUTHOR_EMAIL='newemail'; \GIT_COMMITTER_NAME='committed-name'; GIT_COMMITTER_EMAIL='committed-email';" HEAD fork 的项目( A )与原项目 (B) 保持同步# 将 A 克隆到本地做中转# 添加 B 远程仓库地址并拉取git remote add update &lt;B 远程仓库地址&gt;git fetch update master:updated# 合并并解决冲突git merge updated# 也可以直接合并远程分支git merge update/master 远程分支删除以后，本地显示仍然存在的解决办法# 显示所有分支：git branch -a# 命令查看远程分支和本地分支的对应关系git remote show origin# 会看到refs/remotes/origin/&lt;branch&gt; stale (use 'git remote prune' to remove)# 执行下面命令同步删除git remote prune origin或者git fetch -p]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 基础]]></title>
    <url>%2F2018%2Fjavascript%2Fjavascript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JavaScript 基础书写位置 第一种 : 写在script标签中 &lt;script&gt; alert('Hello World!')&lt;/script&gt; 第二种 : 引入一个 js 文件 &lt;script src="main.js"&gt;&lt;/script&gt; 注意： script 可以放在很多地方，但是我们一般规范写在 body 的最后面； 使用 src 引入的标签不能再在标签内写 js 代码 (写了不会执行) !&gt; 通过 src 请求到的 js 文件，会被解析到 script 标签内，并且覆盖原 script 标签内的 js 代码 !&gt; script 标签的 src 属性可以写任何路径或文件，并不仅仅只能写 js 文件 注释 注释代码不会被执行，仅仅起到一个提示的作用。注释可以对复杂的代码进行解释，方便后期的维护和开发。 单行注释 : // 这是单行注释， 单行注释只能写一行代码// 快捷键： ctrl + / 多行注释 : /* 这是多行注释，在多行注释中可以 换行 快捷键 ctrl + shift + / 不可嵌套*/ 输出语句 (5 种) alert : 警告框 // alert会弹出一个警告框alert('hello world') confirm : 确认框 // confirm弹出一个确定框confirm('我帅吗？') prompt : 输入框 // prompt:弹出一个输入框，可以输入值prompt('请输入你的真是年龄') document.write : 网页中写入内容 // 可以识别标签document.write('hello world')document.write('&lt;h1&gt;hello world&lt;/h1&gt;')document.write(Date()) // 输出当前时间 console.log：控制台输出 // F12打开控制台，在console中可以看到打印的信息console.log('hello word') 变量// var 声明变量var ageage = 12 // 先声明,后赋值var age = 12 // 同时声明+赋值var age, name, sex // 直接声明变量,可一次声明多个，用逗号隔开height = 100 // 不声明变量，直接赋值(不会报错，但是不推荐)console.log(height) // 不声明变量，也不赋值变量，直接使用（会报错）vfunction add(num1, num2) &#123; return num1 + num2 // 把两个数字加起来&#125;/*var student = &#123; name:'小明'&#125;*/ 变量命名要求（变量是[标识符][1]的一种） 以字母、下划线或美元符号（$）开头 由字母、下划线、美元符号（$）和数字组成 标识符区分大小写 标识符不能使用关键字和保留字 如果重新声明 JavaScript 变量，该变量的值不会丢失 var car=&#39;yellow&#39;; var car car 的值依然是 ‘yellow’ 关键字 (有特殊意义的一些单词)break do instanceof typeof case else new var in catch finally return void continue for switch while try debugger function this with default if throw delete 保留字abstract enum int short boolean export interface static extends long super Char final native Class synchronized package throws Const goto private transient degubber implements volatile double import public byte float protected 交换两个变量的值 使用临时变量 (必须掌握) var temp = aa = bb = temp 不使用临时变量 a = a + bb = a - ba = a - b 基本数据类型Number 浮点数 var num = 3.1416 // 3.1416var num = 3.12e2 // 312var num = 3.12e-1 // 0.312 整数 var num = 10 // 10var num = 070 // 56 (八进制)var num = 0xa // 10 (十六进制) 特殊值 NaN Infinity var num = 1 / 0 // Infinity (无穷大) 通过 isNaN(num) 可以判断是否是一个数字，返回 false 的时候，表示是一个数字 浮点数精度丢失问题 // 在进行浮点数运算的时候，可能会出现精度丢失的问题0.1 + 0.2 = 0.300000000000000040.2 + 0.2 = 0.4// 尽量少用浮点数进行运算，不要让浮点数进行比较// 解决办法 : 根据小数点后面的位数量 乘以对应的整数0.1 + 0.2 ==&gt; (0.1*10+0.2*10) / 10 = 0.3 String只要是在单引号或双引号内的就是 String 类型 var name1 = 'hello'var name2 = 'july'var name3 = '3.1416'// 使用索引位置来访问字符串中的每个字符,字符串的索引从 0 开始var character = name1[3] // l// 内置属性 length 来计算字符串的长度console.log(name1.length) // 5 若在字符串中使用引号，字符串中的引号不要与字符串的引号相同，或在字符串添加转义字符 \ 字符串可以是对象 var x = 'john'var y = new String('john')typeof x // Stringtypeof y // Object Boolean布尔型，只有 true 和 false 两个值，且是小写 true : 1、2、1.1、-1、&#39;0&#39;、&#39;1&#39;、[]、Infinity、-Infinity、… false : 0、&#39;&#39;、null、NaN、undefined 所有非 0 数都是 true，0 是 false var sex = trueif (sex) &#123; document.write('男')&#125; else &#123; document.write('女')&#125; 真值： 在 JavaScript 中，Truthy（真值）指的是在布尔值上下文中，转换后的值为真的值。所有值都是真值，除非它们被定义为 假值（即除 false、0、&quot;&quot;、null、undefined 和 NaN 以外皆为真值） Arrayvar car = new Array()cat[0] = 'yellow'cat[1] = 'red'cat[2] = 'blue'// 或var cat = ['yellow', 'red', 'blue'] 关键词 new 用于声明新变量的类型 Object由花括号分隔，属性和方法的容器；对象的属性以名称和值对的形式 (name : value) 来定义；多个属性由逗号分隔。对象的方法定义了一个函数，并作为对象的属性存储。对象方法通过添加 () 调用 var cat = new Object()cat.name = 'kitty'cat.age = '2'cat.eat = function() &#123;&#125;// 或var cat = &#123; name: 'kitty', age: 2, eat: function() &#123;&#125;&#125; 对象属性有两种访问方式： name = cat.namename = cat['name'] 对象方法的访问： eat = cat.eat() // 输出函数执行结果eat = cat.eat // 输出函数表达式 Null只有一个值：null，表示对象不存在 var cat = null // 将cat的值清空 str.match()方法匹配不到返回 null 通过 document.querySelector、getElementById() 获取不到元素返回 null Undefined只有一个值：undefined 已声明未赋值的变量 var aconsole.log(a) // undefined 没有明确返回值的变量 // 获取对象不存在的属性var obj = &#123; a: 1, b: 2 &#125;console.log(obj.c) // undefined// 数组下标不存在var arr = ['zs', 'ls', 'ww']// 0 1 2 下标从零开始，长度为3arr[5] // undefined// 函数没有返回值function getSum(a, b) &#123; console.log(a + b)&#125;// getSum(20, 30) // 50var result = getSum(20, 30)console.log(result) // undefined// 函数参数没有传入function f(i) &#123; console.log(i)&#125;f() // undefined typeof 操作符 是一个操作符而不是函数，圆括号可以使用，但不是必需的 var numtypeof num // undefinedtypeof num1 // undefined// 对未初始化和未声明的变量执行 typeof 操作符都返回 undefined 值var num = 1typeof num // numbervar num = '1'typeof num // stringvar flag = truetypeof flag // bolleantypeof true // booleantypeof null // object ==&gt; null 被认为是一个空的对象引用var cat = &#123; name: 'kitty' &#125;typeof cat // object 数据类型转换转换成字符串 调用 toString() 方法 （显式转换） var a = 1var result = a.toString()console.log(typeof result) // stringconsole.log(typeof a) // number null 、undefined 没有 toString() 方法 调用 String() 构造函数（显式转换） var str1 = String(a)console.log(typeof str1) // string 直接和字符串做加法运算(推荐方法) （隐式因式转换） // 任意数据类型的变量和字符串做加法运算结果都是字符串var str2 = a + ''console.log(typeof str2) // stringvar b = trueconsole.log(typeof (b + '')) // string 转换成数值 Number(a) var num1 = Number('123')var num2 = Number('123c')console.log(typeof num1) // numberconsole.log(typeof num2) // NaN// 如果字符串不能转换成合法数字，转换结果为 NaN 使用 parseInt() var num2 = parseInt('12.3')console.log(typeof num2) // numberconsole.log(num2) // 12 只保留整数var num3 = parseInt('15xyz')var num4 = parseInt('15x6yz')console.log(typeof num3) // numberconsole.log(num3) // 15console.log(num4) // 15// 如果字符串里有非法的数字，会逐个转换，直到遇到无法转化的字符串为止 使用 parseFloat() 完成 var num3 = parseFloat('12.34')console.log(typeof num3) // numberconsole.log(num3) // 12.34 可以保留小数位 让字符串和数字做除了加法以外的运算（隐式转换） var d = '345'var num4 = +d // 前面加 + （正）号也可以转换// num4 = d - 0// numb4 = d * 1// num4 = d / 1console.log(typeof num4) // numberconsole.log(num4) // 345 补充 parseInt() 函数解析一个字符串参数，指定该字符串为指定基数的进制值，并返回一个 10 进制的整数，如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN 参考 parseInt // 语法parseInt(string, radix)// string 要被解析的值，如果参数不是一个字符串，则将其转换为字符串// radix 基数,表示进制，介于 2 和 36 之间的整数，参数 radix 的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数// 返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN。parseInt('123', 5) // 将 '123' 看作 5 进制数，返回十进制数 38 [(1, 2, 3)].map(parseInt) // [1, NaN, NaN]// [1, 2, 3].map(parseInt(item, index)) parseFloat() 函数解析一个字符串参数并返回一个浮点数，如果给定值不能被转换成数值，则会返回 NaN。 // 语法parseFloat(value)// value 需要被解析成为浮点数的值parseFloat('3.14') // 3.14 转换成布尔值 使用 Boolean() 完成 var a = 45var result1 = Boolean(a)console.log(result1) // true// 对于数字类型来说：一般的数字都转换成为true，0、NaN 会被转换成为falsevar str = 'hello'// var str = ''// var str = ' 'var result2 = Boolean(str)console.log(result2) // true// 字符串中只有空的字符串会被转换成为 falsevar result3 = Boolean(undefined)console.log(result3) // falsevar result4 = Boolean(null)console.log(result4) // falsevar b = falsevar result5 = Boolean(b)console.log(result5) // false 0, NaN, 空字符串，undefined, null, false 会被转换成为 false 使用 !! console.log(typeof !!a) // booleanconsole.log(!!a) // true 自动转换 if ('') &#123; console.log('哈哈')&#125; 变量转换表 Value Boolean Number String undefined false NaN “undefined” null false 0 “null” true true 1 “true” false false 0 “false” “” false 0 “” “123” true 123 “123” “1a” true NaN “1a” 0 false 0 “0” 1 true 1 “1” Infinity true Infinity “Infinity” NaN false NaN “NaN” {} true NaN “[object Object]” 操作符算数操作符 + 、- 、* 、/ 、% var num = 5 + 6 // 11var num = 5 % 2 // 1 取余数var num = 5 % -2 // 1var num = -5 % 2 // -1 只与左边值的符号有关var num = '5' + 6 + 7 // "567" 数字与字符串相加，返回字符串var num = 5 + 6 + '7' // "117"var num = '' + 5 + 6 + '7' // "567" 字符串 + 数字得到字符串var num = '' + 5 + 6 + 7 // "567"var num = 5 + true // 6 返回数值，false 转成 0，true 转成 1var num = '1' + true // "1true" 字符串与布尔值相加,布尔值转化成字符串 赋值操作符 a = a + 1 即 a++, a = a - 1 即 a-- &gt; a = a + 5 可简写成 a += 5，类似的还有 a -= 5、a *= 5、a /= 5、x %= y 赋值运算符左边不能是常量或表达式 var age = 10var num = age++ // num = 10 age = 11 (先将变量中的值取出做赋值操作,再自身+1)var age = 10var num = ++age // num = 11 age = 11 (先自身+1,然后再将+1后的结果赋值)var num = 5console.log(num++) // 5console.log(++num) // 7var x = 3var y = x++ + ++x + x * 10 // x = 3// y = 3 + ++x + x * 10 // x = 4// y = 3 + 5 + x * 10 // x = 5// y = 58 关系操作符 &gt; 、&lt; 、&gt;= 、&lt;= == 相等 、！= 不相等 、=== 全等 、！=== 不全等 in instanceof var result = 6 &gt; 4alert(result) // true 输出Boolean类型 运算符的结果类型为 Boolean &gt; 、&lt; 、&gt;= 、&lt;= 、== 相等、!= 不相等 （字面量比较） 在比较前先执行类型转换 如果有一个操作数是布尔值，则在比较相等性前先将其转换为数值—false 转换为 0，true 转换为 1 如果一个操作数是字符串，另一个操作数是数值，则在比较相等性前将字符串转换为数值 如果两个值都是字符串，则按照字符串的字符编码进行逐位比较 如果一个操作数是对象，另一个不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则比较 如果两个操作数都是对象，则比较它们是否指向同一个对象 null 和 undefined 是相等的 在比较相等性之前，不能将 null 和 undefined 转换为其他任何值 如果有一个操作符是 NaN，则相等操作符返回 false，不相等操作符返回 true；即使两个操作数都是 NaN，也一样 === 全等、！=== 不全等两个操作数在未经转换的情况下相等返回 true，不相等返回 false 0 == false // true1 == true // true2 == true // falsefalse == "0" // true'' == 0 // true'4' == 4 // truenull == undefined // trueundefined == 0 // falsenull == 0 // false"NaN" == NaN // false5 == NaN // falseNaN == NaN // falseNaN != NaN // true[] != [] // true[] == [] // false[] == ![] // true&#123;&#125; == &#123;&#125; // false1 == [] // false1 == [1] // true-0 === 0 // true"4" === 4 // falseundefined === null // false in 判断对象是否能够访问到该属性 instanceof 判断一个对象是否是另一个对象的实例 逻辑操作符 ！ 非、&amp;&amp; 与、|| 或 ! 对 Boolean 值取反 var flag = truealert(!flag) // falsealert(!0) // truealert(![]) // falsealert(!“”) // truealert(!![]) // truealert(!!1) // true &amp;&amp; 如果第一个值转换成 boolean 值之后为 true， 则输出第二个值；如果第一个值转换成 boolean 值之后为 false，则输出第一个值，且第二个值不在执行。（取第一个为 false 的值，如果都为 true ，则输出最后一个值。） var result = true &amp;&amp; 3 // 3var result = 1 &amp;&amp; 3 // 3var result = [] &amp;&amp; '' // ""var result = false &amp;&amp; 3 // falsevar result = '' &amp;&amp; 3 // ""var result = null &amp;&amp; true // nullvar num = 0var result = '' &amp;&amp; num++ // "" num = 0 &amp;&amp; 使用場景 function animate (fn) &#123; fn &amp;&amp; fn()&#125;// 不传参数不会报错animate() || 如果第一个值转换成 boolean 值之后为 true， 则输出第一个值，且第二个值不在执行；如果第一个值转换成 boolean 值之后为 false，则输出第二个值，以此类推，（取第一个为 true 的值，如果都为 false ，则输出最后一个值。） var result = true || 3 // truevar result = 1 || 3 // 1var result = [] || '' // []var result = false || 0 // 0var result = '' || 3 // 3var result = num || true // truevar num = 0var result = 3 || num++ // 3 num=0 || 使用场景 // 1.兼容性问题：var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop// 2. 函数的参数默认值function sum(n) &#123; n = n || 10 // 给形参 n 设置默认值 console.log(n + 10)&#125;sum() 操作符的优先级从高到低如下： () 优先级最高 一元运算符 ++ – ! 算数运算符 先 * / % 后 + - 关系运算符 &gt; &gt;= &lt; &lt;= 相等运算符 == != === !== 逻辑运算符 先 &amp;&amp; 后 || 赋值运算符 = 判断语句if 语句 单独的 if 语句 // 语法if (条件) &#123; // 只有当条件为 true 时,执行代码&#125; // else部分没有执行语句则 省略var age = 10if (age &gt;= 18) &#123; console.log('可以访问该网站')&#125; if..else 语句 // 语法if (条件) &#123; // 当条件为 true 时执行的代码&#125; else &#123; // 当条件不为 true 时执行的代码&#125;var age = 10if (age &gt;= 18) &#123; console.log('可以玩吃鸡')&#125; else &#123; console.log('不可以玩吃鸡')&#125; if..else if ..else 语句 if (条件1) &#123; // 当条件1为 true 时执行的代码&#125; else if (条件2) &#123; // 当条件2 为true 时执行的代码&#125; else &#123; // 当条件1和 条件2 都不为true 时执行的代码&#125; 三元运算符条件 ? 表达式1 : 表达式21. 如果 `条件` 的值为true，会返回表达式1的值2. 如果`条件`的值为false，会返回表达式2的值// 求两个数的最大值var max = n1 &gt; n2 ? n1 : n2 switch 语句 if..else 适用于范围的判断，switch..case 适用于具体的值的判断 // 语法switch (变量) &#123; case 值1: 语句1 break case 值2: 语句2 break … default: 默认语句 break&#125; 注意 :break 可以省略，如果省略，代码会继续执行下一个 caseswitch 语句在比较值时使用的是 全等 操作符, 因此不会发生类型转换（例如，字符串’10’ 不等于数值 10） 循环语句while 循环 基本语法 : // 当循环条件为true时，执行循环体，// 当循环条件为false时，结束循环。while (循环条件) &#123; // 循环体：需要循环执行的语句&#125; 代码示例: // 计算1-100之间所有数的和 (讲)// 初始化变量var i = 1var sum = 0while (i &lt;= 100) &#123; // 判断条件 sum += i // 循环体 i++ // 自增，修改循环条件（不能省略）&#125;console.log(sum) do..while 循环 do..while 循环和 while 循环非常像，二者经常可以相互替代，但是 do..while 的特点是不管条件成不成立，都会执行一次。 基础语法 : do &#123; // 循环体&#125; while (条件) 代码示例 : // 初始化变量var i = 1var sum = 0do &#123; sum += i // 循环体 i++ // 自增&#125; while (i &lt;= 100) // 循环条件 for 循环 for 循环语法： // 1. for循环使用分号分隔// 2. for循环有2个分号，两个分号不能少for (初始化语句; 判断语句; 自增语句) &#123; // 循环体&#125; 执行顺序：1243 —- 243 —–243(直到循环条件变成 false) 初始化语句 判断语句 自增或者自减 循环体 for 循环代码示例： // 打印1-5之间所有数for (var i = 1; i &lt;= 5; i++) &#123; console.log(i)&#125;console.log(i) // 6 即便循环已经结束了，我们依然可以访问 i 的值 思考 1： // 1 求1-100之间所有数的和、平均值// 2 求1-100之间所有数的乘积// 3 计算1-100之间能3整除的数的和 思考 2： // 1 计算1-100之间不能被7整除的数的和// 2 求1-100之间所有偶数的和// 3 同时求1-100之间所有偶数和奇数的和 思考 3（双重 for 循环）： // 1 网页打印5*5方形★阵 document.write()// 2 网页打印直角三角形// 3 网页打印9*9乘法表 for ..in 循环详见遍历对象 break 和 continue break: 结束/中止循环（可以用在 switch 语句和循环语句中） 立即跳出当前整个循环，即循环结束，开始执行循环后面的内容（直接跳传出大括号） continue: 结束本次循环，进行下一次循环 （只能用在循环语句中） 立即跳出当前循环，继续下一次循环（跳到 i++的地方） 在一个循环里，continue 和 break 后面不能在写任何语句，因为永远无法执行到 思考 1 : // 输出结果是什么？ 1 2 3 4 6for (var i = 1; i &lt;= 10; i++) &#123; if (i == 5) &#123; continue &#125; if (i == 7) &#123; break &#125; console.log(i)&#125; 总结 : 循环有很多种，但是以后用得最多的是 for 循环 当不明确循环次数的时候，可以使用 while 循环 当无论如何都要执行一次代码的时候，可以使用 do..while 循环 循环可以相互替代 Array 数组 将多个元素，按一定顺序排列放到一个集合中 ， 那么这个集合我们就称之为数组 可以存放任意类型的数据（一般一个数组只存放一种类型） 特点 : 用逗号隔开，有顺序，有长度，数组长度可以动态调整 用途 : 存储大量的数据 // 为什么要有数组?// 1. 我们知道,一个变量能够存储一个值, 当我们想要存储多个值的时候, 就可以使用数组。比如存储一个班级里面所有学生的名;// 2. 使用数组可以对多个相同类型的值统一的管理,存储起来方便,操作的时候,也会很方便 创建数组 通过 构造函数 创建数组 var arr = new Array() // 创建了一个空数组var arr = new Array(4) // 创建了一个数组，长度为4,里面全是空值var arr = new Array('4') // 创建了一个数组，长度为1,内容为字符串 "4"var arr = new Array(2, 3) // 创建了一个数组，里面存放了2个数字 通过 数组字面量 创建数组 var arr1 = [] // 创建一个空数组var arr2 = [4] // 创建了一个数组，长度为1,内容为数字 4var arr2 = [2, 3] // 创建一个包含2个数值的数组，多个数组项以逗号隔开var arr3 = ['2', 'b'] // 创建一个包含两个字符串的数组 数组的长度与下标 数组的长度 : 跟字符串一样,数组有一个 length 属性,, 指数组中存放的元素的个数 var arr = [] // 空数组 长度为 0var arr = [1, 3, 5]arr.length // 长度就是3arr.length = 0 // 设置length属性改变数组中元素的个数 数组的下标（又称索引） : 因为数组有序的，有序的就应该有自己的序号，而这个序号就是每个元素对应的下标，下标从 0 开始 , 到 arr.length-1 结束 // 数组取值，如果下标不存在，则返回 undefinedvar arr = ['zs', 'ls', 'ww']arr[0] // zsarr[2] // wwarr[5] // undefined// 数组的赋值// 格式：数组名[下标] = 值// 如果下标有对应的值，会把原来的值覆盖，如果下标不存在，会给数组新增一个元素。var arr = ['red', 'green', 'blue']arr[0] = 'yellow' // 把red替换成了yellowarr[3] = 'pink' // 给数组新增加了一个pink的值// 如果下标有跨度,中间全是empty 不合法// 在数组末尾添加新的元素arr[arr.length] = 值arr.push(值) 数组的遍历 遍历 : 对数组的每一个元素都访问一次就叫遍历 数组遍历的基本语法： for (var i = 0; i &lt; arr.length; i++) &#123; // 数组遍历的固定结构&#125; 冒泡排序// 将数组中的数从小到大排列var arr = [1, 4, 6, 7, 9, 3, 5, 8]// var arr = [1,2,3,4,5,6,7,8]var numi = 0var numj = 0for (var j = 0; j &lt; arr.length - 1; j++) &#123; numj += 1 var flag = true for (var i = 0; i &lt; arr.length - 1 - j; i++) &#123; // document.write("(" + arr[i] + "," + arr[i + 1] + ")") numi += 1 // 两两比较，如果前面的大于后面的，交换位置 if (arr[i] &gt; arr[i + 1]) &#123; flag = false var temp temp = arr[i] arr[i] = arr[i + 1] arr[i + 1] = temp // document.write("交换了") &#125; &#125; // document.write("，arr=（" + arr + "）") // document.write("&lt;br&gt;") // 如果一趟下来，一次交换都没有做，说明就已经排好序，就不需要继续比 if (flag) &#123; break &#125; // console.log(arr)&#125;console.log(arr)console.log(numi)console.log(numj) 函数 把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数 函数的作用就是封装一段代码，只需要声明一次，就可以被多次调用 提高代码的复用率，提高可维护性 函数三要素包括：函数名、参数、返回值 函数的声明与调用// 函数声明function 函数名() &#123; // 函数体&#125;// 函数表达式var 函数名 = function() &#123; //函数体&#125;// 函数调用函数名() 特点： 函数声明的时候，函数体并不会执行，函数体只有在调用的时候才会执行 可多次调用 练习： // 1. 封装一个打招呼的函数// 2. 封装一个函数，计算两个数的和// 3. 封装一个函数，计算1-100之间所有数的和 函数的参数(arguments) 形参 ( 形式参数 ) : 在函数声明时, 设置的参数。作用是占位置 。 实参 ( 实际参数 ) : 在函数调用时传入的参数。 作用 : 函数调用时，会把实参的值赋值给形参，这样形参就有了值，在函数体里，可以直接使用形参! 语法 : // 带参数的函数声明function 函数名 (形参1, 形参2, 形参...)&#123; // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3)// 在声明函数的时候，碰到不确定的值的时候，就可以定义成形参 如果实参的个数大于形参的个数，多余的实参会被 保存到函数的 arguments 对象里，arguments 对象里保存了所有的实参，arguments 是一个伪数组（可以像数组一样使用） 如果实参的个数小于形参的个数，不够的参数会用 undefined 来补充 // 实参个数大于形参个数function getSum(a, b) &#123; // return a + b // 3 // 任意多个数相加, 并没有调用形参，即可以省略不写 console.log(arguments) var sum = 0 for (var i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i] &#125; return sum&#125;var result = getSum(1, 2, 5)console.log(result) // 8// 实参个数小于形参个数function getSum1(a, b, c, d) &#123; console.log(d) // undefined return a + b + c + d&#125;var result1 = getSum1(1, 2, 5)console.log(result1) // NaN 函数的返回值 当函数执行完的时候，我们期望函数给我一些反馈（比如计算的结果），这个时候可以让函数返回一些东西。也就是返回值。函数通过 return 返回一个返回值 返回值语法： // 声明一个带返回值的函数function 函数名 (形参1, 形参2, 形参...) &#123; // 函数体 return 返回值&#125;// 可以通过变量来接收这个返回值var 变量 = 函数名(实参1, 实参2, 实参3) 函数返回值注意事项： return 语句代表一个函数的结束，后面不能再有语句（语句不会执行） 函数可以没有返回值，函数如果没有 return，那么返回结果是 undefined 函数的参数可以有多个，但是返回值只能有 1 个 return 在函数包含判断语句时，可以用来直接停掉一个函数的执行 练习： // 1. 求两个数的最大值,并且返回。// 2. 求三个数的最大值,并且返回。// 3. 求一个数组的最大值和最小值，并且返回。 函数内部调用函数 在函数内部是可以继续调用别的函数的。 // 求阶乘function getJc(n) &#123; var sum = 1 for (var i = 1; i &lt;= n; i++) &#123; sum *= i &#125; return sum&#125;var result = getJc(5)console.log(result)// 求阶乘和function getJcSum(n) &#123; var sum1 = 0 for (var j = 1; j &lt;= n; j++) &#123; sum1 += getJc(j) &#125; return sum1&#125;var result1 = getJcSum(5)console.log(result1) 函数是一种数据类型(function)函数可以作为参数 通常，我们把作为参数传递的函数叫做回调函数 function fn1(fn) &#123; fn()&#125;fn1(function() &#123; console.log('哈哈')&#125;) 函数可以作为返回值 在 js 高级中，闭包会使用到 function fn1() &#123; return function() &#123; console.log('呵呵') &#125;&#125;fn1()() // 呵呵 匿名函数与自执行函数自执行函数函数可以自执行 ;(function fn() &#123; console.log('我可以自己执行哦')&#125;)() 匿名函数 匿名函数：没有名字的函数 // 匿名自调用函数 ,用完一次就没了;(function() &#123; console.log('哈哈')&#125;)() 匿名函数如何使用： 1. 将匿名函数赋值给一个变量，这样就可以通过变量进行调用2. 自执行（匿名函数自执行） 匿名函数自执行的作用：防止全局变量污染。 函数的断点调试 跳到下个断点, 如果后面没有断点了,那么代码直接执行完 单步调试 : 下一步 没有断点的话,函数就直接跳过 单步调试 : 进入函数 单步调试 : 跳出函数 单步调试 : 下一步 不管有没有断点,都会一步一步的走,纯碎的下一步 让所有的断点失效 自动根据错误断点 函数的重载如果多个函数的函数名相同，但是参数或返回值不同，这些函数是不同的函数 参数不同指 1. 参数的个数不同 2. 参数的数据类型不同 js 中不允许函数的重载，即在 js 中，只要函数名一样，就是同一个函数，如果两个函数名相同，后边的会覆盖前边的 对象 对象 : 是一组无序的键（key）值（value）对的集合，有对应的属性和方法 特点 : 1. 声明的变量 = &#123;&#125;2. 键值对出现3. 逗号隔开4. 属性可以是任意类型 // 数组多个元素之间使用,隔开// 对象中多个键值对之间也用逗号隔开,键值对的格式： 键:值var obj = &#123; name: '张三', age: 18, sex: '男', hobby: '上网'&#125; this 的基本概念创建对象-1 (2 种方式 单创) 单纯的创建一个对象 对象字面量 字面量 : 直接量，通过看数值，直接看出来类型的 var p = &#123;&#125;var p = &#123; name: 'zs', age: 18, sayHi: function() &#123; console.log(this.name) &#125;&#125; 通过 Object 构造函数创建var p = new Object() // 创建一个空的对象var p = new Object(&#123; name: 'xx' &#125;) 设置对象的属性 // 设置对象的属性 语法 对象名.属性 = 值// 如果对象有这个属性，修改这个属性// 如果对象没有这个属性，添加这个属性var obj = new Object()obj.name = 'zs'obj.age = 18obj.gender = '男'// 添加方法obj.sayHi = function() &#123; console.log('大家好,我是' + obj.name)&#125; 创建对象-2 (2 种方式 批量) 批量创建对象 在实际开发中，经常需要创建多个相同类型的对象，比如游戏中的怪物，班级的学生等。 使用工厂函数创建对象// 定义一个函数，用于创建学生对象// 工厂函数：function createStudent(name, age, sex) &#123; // 创建空对象 var stu = &#123;&#125; // 设置对象属性 stu.name = name stu.age = age stu.sex = sex stu.sayHi = function() &#123; console.log('大家好,我是' + this.name) &#125; // 返回对象 return stu&#125;var stu1 = createStudent('zs', 18, '男')stu1.sayHi() 优点：可以同时创建多个对象 缺点：创建出来的没有具体的类型，都是 object 类型的 自定义构造函数:triangular_flag_on_post: 工厂函数的缺点 就是无法确定对象的具体类型 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与 new 运算符一起使用在创建对象的语句中。 function Teacher(name, age) &#123; // 构造函数内部的this指向的是新创建的那个对象 this.name = name this.age = age&#125;var tea = new Teacher('zs', 18)console.log(tea) 构造函数首字母要大写（推荐做法） 构造函数要和 new 一起使用才有意义 构造函数的作用是用于实例化一个对象，即给对象添加属性和方法 new 在执行时会做四件事情 1. new 会创建一个新的空对象，类型是Teacher2. new 会让 this 指向这个新的对象3. 执行构造函数 目的：给这个新对象加属性和方法4. new 会返回这个新对象构造函数的作用(实例化对象)：给创建出来的对象增加属性和方法 查看一个对象的类型(类型识别)typeof // 只能查看基本数据类型的类型instanceof // 判断对象的具体类型constructor.name // 获取对象的具体类型 适用于任何类型的检测Object.prototype.toString.call('str') // '[object String]' 适用于任何类型的检测 typeof 用于查看基本数据的数据类型， number string boolean undefined null 比较特殊，结果是 object 如果查看复杂数据类型，返回的都是 object 类型 函数的结果是 function // typeof 判断// 简单类型typeof 12 // 'number'typeof 'abc' // 'string'typeof true // 'boolean'typeof undefined // 'underfined'typeof null // 'object'// 复杂类型 (引用类型)typeof function() &#123;&#125; // 'function'typeof [] // 'object'typeof &#123;&#125; // 'object' instanceof 判断 // 语法object instanceof constructor 用来检测 constructor.prototype是否存在于参数 object 的原型链中 不能用于类型识别 // instanceof 判断var simpleStr = 'This is a simple string'var myString = new String()var newStr = new String('String created with constructor')var myObj = &#123;&#125;var myNonObj = Object.create(null)var myArr = []var myFn = function() &#123;&#125;simpleStr instanceof String // 返回 false, 检查原型链会找到 undefinedmyString instanceof String // 返回 truenewStr instanceof String // 返回 truemyString instanceof Object // 返回 truemyObj instanceof Object // 返回 true, 尽管原型没有定义;(&#123;&#125; instanceof Object) // 返回 true, 同上myNonObj instanceof Object // 返回 false, 一种创建对象的方法，这种方法创建的对象不myArr instanceof Array // truemyArr instanceof Object // truemyFn instanceof Object // truemyFn instanceof Function // true constructor.name Undefined/Null 没有 constructor 属性 var myArr = []var myFn = function() &#123;&#125;var myObj = &#123;&#125;// 原型的构造函数myArr.constructor.name // ArraymyFn.constructor.name // ObjectmyObj.constructor.name // Function// 自定义构造函数function Teacher(name, age) &#123; this.name = name this.age = age&#125;var tea = new Teacher('zs', 18)tea.constructor.name // Teacher Object.prototype.toString 适用于任何类型的检测，不能识别自定义对象类型 Object.prototype.toString.call('str') // '[object String]' 操作对象的属性. 语法 —– 对象名.属性名 ( 看似变量，不是字符串 ) [] 语法 —- 对象名 属性字符串 ，也叫关联数组的方式 // 获取对象属性的语法： // 对象.属性：对象的属性 // 1. 如果有这个属性，直接返回属性值 // 2. 如果没有这个属性，返回undefined // 3. 如果是方法，可以调用// 设置对象的属性的语法 // 对象.属性 = 值 // 1. 如果对象有这个属性，修改这个属性 // 2. 如果对象没有这个属性，添加这个属性var obj = &#123; name: 'zs'&#125;console.log(obj.name) // okconsole.log(obj[name]) // Xconsole.log(obj.'name') // Xobj.age = 18 // 增加 age 属性为 18obj.name = 'ls' // 修改name属性为 lsvar key = 'name'console.log(obj.key) // Xconsole.log(obj[key]) // okconsole.log(obj['name']) // ok 二者的区别：当属性名是一个字符串存储在变量中的时候，只能使用关联数组的方式。 应用场景 : 遍历对象 删除对象属性 // 删除对象属性delete obj.name // 删除obj的name属性console.log(delete obj.name) // 如果删除成功，返回true，删除失败，返回false// var 声明的全局变量不能被删除var num = 12str = 'hello'console.log(delete window.num) // false 删除失败console.log(delete window.str) // true 删除成功console.log(num) // 12console.log(str) // 报错 str is not undefined 遍历对象通过 for..in 循环语法可以遍历一个对象 // 遍历对象for (var key in obj) &#123; // 键 console.log(key) // 值 console.log(obj[key]) console.log(key + '==' + obj[key])&#125;// 判断一个属性是否是对象的一个属性// console.log("name" in obj) 返回布尔值if ('name' in obj) &#123; console.log('是')&#125;// 获取对象里的所有属性// 结构: Object.keys(对象) 返回一个包含所有属性的数组var keys = Object.keys(obj) 原始类型与引用类型 原始类型（简单数据类型/值类型） Number String Boolean Undefined Null 引用类型（复杂数据类型） Object Array function 自定义的对象 var num1 = 123var num2 = num1num2 = 456console.log(num1) // 123var obj1 = &#123; a: 1 &#125;var obj2 = obj1 // obj1和obj2，均指向了同一个对象obj2.a = 3 // 对obj2的任何操作console.log(obj1.a) // 3 同时也会影响到 obj1 原始数据类型和引用数据类型，主要是根据内存存储方式来区分的 原始类型储存在栈（Stack）中，存的是值本身（值类型），进行赋值的时候，赋值的是值本身 引用类型储存在堆（Heap）中，并非储存变量真实数值而是引用（也叫地址），进行赋值的时候，赋值的是地址，而不是数据本身 // 1.// a -&gt; xfunction fn(a, b) &#123; // 相当于 // var a = 10 // var b = 20 // 函数的参数 其实就是函数内部的局部变量 a = a + 1 b = b + 1 console.log(a) // 11 console.log(b) // 21&#125;var x = 10var y = 20fn(x, y)console.log(x) // 10console.log(y) // 20// 2.var p = &#123; name: 'zs', age: 18&#125;function fn(person) &#123; person.name = 'ls' console.log(person.name) // ls&#125;fn(p)console.log(p.name) // ls// 3.function Person(name, age, salary) &#123; this.name = name this.age = age this.salary = salary&#125;function f1(person) &#123; person.name = 'ls' console.log(person.name) // ls&#125;var p = new Person('zs', 18, 1000) // 创建一个新对象console.log(p.name) // zsf1(p)console.log(p.name) // ls// 4.function Person(name, age, salary) &#123; this.name = name this.age = age this.salary = salary&#125;function f1(person) &#123; person.name = 'ls' // person 指向新的对象 person = &#123; name: 'ww' &#125; console.log(person.name) // ww&#125;var p = new Person('zs', 18, 1000) // 创建一个新对象console.log(p.name) // zsf1(p)console.log(p.name) // ls object.valueOf()返回值为该对象的原始值，如果对象没有原始值，则 valueOf 将返回对象本身 对象 返回值 Array 返回数组对象本身 Boolean 布尔值 Date 存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC Function 函数本身 Number 数字值 Object 对象本身 （这是默认情况） String 字符串值 Math 和 Error 对象没有 valueOf 方法 内置对象 JS 内置对象就是指 Javascript 自带的一些对象，供开发者使用，这些对象提供了一些常用的的功能。 常见的内置对象有 Math、String、Array、Date 等 跳转到定义ctrl+左键 火狐开发者网站 MDN W3School 网站 如何学习一个方法？ 方法的功能 参数的意义和类型 返回值意义和类型 demo 进行测试 Math 对象 属性 PI Math.PI 最大值/最小值 Math.max()Math.min() 取整 Math.ceil() // 向上取整Math.floor() // 向下取整Math.round() // 四舍五入，如果是.5，则取更大的那个数 (-1.5 -&gt; -1) 随机数 Math.random() // 返回一个[0,1)之间的数，能取到0，取不到1// [0~N]随机数 parseInt(Math.random * (N+1))// [4~9] ==&gt; [0~5]+4 绝对值 Math.abs() // 求绝对值 次幂和平方 Math.pow(num, power) // 求 num 的 power 次方Math.sqrt(num) // 对 num 开平方 练习 // 随机生成一个 rgb 颜色?function randomRGB() &#123; var colorA = parseInt(Math.random() * 256) var colorB = parseInt(Math.random() * 256) var colorC = parseInt(Math.random() * 256) return 'rgb(' + colorA + ',' + colorB + ',' + colorC + ')'&#125; Date 对象 Date 对象用来处理日期和时间 创建一个日期对象 // 不传参数：创建一个当前时间的对象var date = new Date()// 日期格式字符串：创建一个指定时间的日期对象// '-' 在 safari 下不识别，推荐用 /var date = new Date('2018/12/02')var date = new Date('2018/12/02 00:02:05')// 日期以逗号分隔：注意月份从0开始var date = new Date(2018, 11, 2, 0, 2, 5) // 2018/12/02// 时间戳var date = new Date(1543680125000) 日期格式化(了解) date.toString() // 默认的日期格式 ，包括日期和时间date.toLocalString() // 本地风格的日期格式（兼容性）date.toDateString() // 只显示日期date.toLocalDateString()date.toTimeString() // 只显示时间date.toLocalTimeString() 获取日期的指定部分 getMilliseconds() // 获取毫秒值getSeconds() // 获取秒getMinutes() // 获取分钟getHours() // 获取小时getDay() // 获取星期，0-6 0：星期天getDate() // 获取日，即当月的第几天getMonth() // 返回月份，注意月份从0开始getFullYear() // 返回4位的年份 如 2018// 思考：// 封装一个函数，返回当前的时间，格式是：yyyy-MM-dd HH:mm:ss 时间戳 var date = +new Date() // 1970年01月01日00时00分00秒起至现在的总毫秒数// 思考// 如何统计一段代码的执行时间？ Array 对象 数组对象在 javascript 中非常的常用 数组转换 // 语法：arr.join(separator)// 作用：将数组的值拼接成字符串var arr = [1, 2, 3, 4, 5]arr.join() // 不传参数，默认用逗号进行拼接，返回拼接好的字符串arr.join('')arr.join('-') // 用 - 进行拼接 数组的增删操作 arr.push() // 从后面添加一个或多个元素，逗号隔开，返回新数组的 lengtharr.pop() // 从数组的后面删除元素，返回删除的那个元素arr.unshift() // 从数组的前面的添加元素，返回新数组的 lengtharr.shift() // 从数组的最前面删除元素，返回删除的那个元素arr.push(arr1) // 把 arr1 当成一个整体放到 arr 里// 练习1var arr = ['刘备']// 添加数据后变成：['赵云','马超','刘备','关羽','张飞']// 删除数据后变成：['关羽','张飞']// 练习2var arr = ['赵云', '马超', '刘备', '关羽', '张飞']// 把数组的最后一个元素变成数组的第一个元素// 把数组的第一个元素变成数组的最后一个元素 数组的翻转与排序 arr.reverse() // 翻转数组arr.sort() // 数组的排序，按照首字符依次比较// sort 方法可以传递一个函数作为参数，这个参数用来控制数组如何进行排序arr.sort(function(a, b) &#123; // 参数为 true 时，即返回值 &gt; 0 时，交换位置 // return a - b // 从小到大排序 return b - a // 从大到小排序&#125;) // 思考：// 将[3, 6, 1, 5, 10, 2,11]从小到大排列// 将字符串数组按照字符长度从小到大排列 a.sort(function (a, b) &#123;return a.length - b.length&#125;)// 将学生数组按照年龄从小到大排列 数组的拼接与截取 // concat：数组合并，返回一个新数组，原数组不受影响var newArr = arr.concat(arr2) // 把 arr 和 arr2 中的所有元素放到 newArr 里// slice: 数组切分，复制数组的一部分到一个新数组，并返回这个新数组，原数组不受影响// slice(begin, end) 包含 begin，不包含 end， begin 和 end 为下标// slice(begin) 只有一个参数时，为开始参数，截取到末尾// slice() 没有参数，全部截取// 可以为负数，会将字符串的长度与对应的负数相加，结果作为参数，-1 表示从后数第一个var newArr = arr.slice(begin, end)// splice: 删除或者增加数组元素，修改原数组，返回删除的内容（数组形式）// start: 开始位置 deletedCount: 删除的个数（如果不删除为 0）items: 替换的内容, 可为多个arr.splice(start) // 删除原数组 start 位置之后的项（包含 start），返回删除的内容arr.splice(start, deletedCount, [items]) // items 将作为 arr 的一项// 练习：var arr = ['赵云', '马超', '刘备', '关羽', '张飞']// 截取['刘备','关羽']// 在马超后面增加马腾arr.splice(2, 0, '马腾')// 删除关羽 数组查找元素 // indexOf 方法返回数组中某个元素第一次出现的位置，如果找不到，返回 -1// 可以用来判断元素是否在数组中// fromIndex 表示从 fromIndex 下标开始查找arr.indexOf('zs', [fromIndex])// lastIndexOf() 从后面开始查找数组中元素出现位置,即查找某元素最后一次出现的位置// 如果找不到，返回 -1arr.lastIndexOf('zs', [fromIndex]) 清空数组 // 1. arr.splice(0,arr.length) // 删除数组中所有的元素// 2．arr.length = 0 // 直接修改数组的长度// 3．arr = [] // 将数组赋值为一个空数组，推荐 数组综合练习 var arr = ['c', 'a', 'z', 'a', 'x', 'a', 'a', 'z', 'c', 'x', 'a', 'x']// 1. 找到数组中第一个a出现的位置// 2. 找到数组中最后一个a出现的位置// 3. 找到数组中每一个a出现的位置// 4. 数组去重，返回一个新数组// 5. 获取数组中每个元素出现的次数 !&gt; 补充数组对象方法 forEach() // 语法arr.forEach(function(item, index, arr) &#123;&#125;, thisArg)// item 必需。数组中正在处理的当前元素// index 可选。数组中正在处理的当前元素的索引// arr 可选。当前数组// thisArg 可选。当执行回调函数时用作this的值var arr = ['zs', 'ls', 'ww']arr.forEach(function(item, index, arr) &#123; console.log(item) console.log(this)&#125;)// 返回值: undefined// 不支持 return 操作输出，return 只用于控制循环是否跳出当前循环 arr.map() // 语法var newArr = arr.map(function(item, index) &#123; // item 必需。数组中正在处理的当前元素 // index 可选。数组中正在处理的当前元素的索引 // arr 可选。当前数组 // 使用 return 操作输出，会循环数组每一项，并返回新的每一项组成的数组 return item * 2&#125;)// 不修改原数组// 返回一个新数组，新数组的每一项乘以 2 arr.filter() // 语法var newArr = arr.filter(function(item, index) &#123; // 参数同 map // 使用 return 操作输出，会循环数组每一项，并返回判断为 true 的每一项组成的数组 return item &gt; 2 &amp;&amp; item &lt; 5 // return 后是判断条件&#125;)// 不修改原数组// 返回一个新数组，新数组每一项满足 2 &lt; item &lt; 5 arr.some() // 语法var newArr = arr.some(function(item, index) &#123; // 参数同 map // 返回布尔值，只要有一项满足条件就返回 true，否则返回 false return item &gt; 2 // return 后是判断条件&#125;)// 不修改原数组 arr.every() // 语法var newArr = arr.every(function(item, index) &#123; // 参数同 map // 返回布尔值，只有所有项都满足条件才返回 true，否则返回f alse return item &gt; 2 // return 后是判断条件&#125;)// 不修改原数组 arr.includes() 判断数组是否含有某值，输出 true 或 false var new1 = arr.includes(5)console.log(new1) 必须完全匹配才会返回 flase（实用性不如正则） arr.find() // 语法var newArr = arr.find(function(item, index) &#123; // 参数同 map // 使用 return 操作输出，会循环数组每一项，当遍历循环到判断到一个为 true 则跳出循环，输出当前数组元素 return item &gt; 2 // return 后是判断条件&#125;)// 不修改原数组// 返回一个数组元素，如果全不满足返回 undefined arr.findIndex() // 语法var newArr = arr.find(function(item, index) &#123; // 参数同 map // 使用 return 操作输出，会循环数组每一项，当遍历循环到判断到一个为 true 则跳出循环，输出当前数组元素的下标 return item &gt; 2 // return 后是判断条件&#125;)// 不修改原数组// 返回一个数组元素的下标，如果全不满足返回 -1 arr.reduce() // 语法var new1 = arr.reduce(function(pre, next, index) &#123; // pre 第一次为数组第一项，之后为上一操作的结果 // next 数组的下一项 // index next项的序列 // arr 可选。当前数组 // 使用 return 操作输出 return pre + next // 返回数组每一项的和&#125;)// 不修改原数组 // 扁平化数组var arr2 = [[1, 2, 3], [4, 5], [6, 7]]var new2 = arr2.reduce(function(pre, next, index) &#123; return pre.concat(next) // 前数组拼接后数组 .concat()&#125;) // 对象数组叠加计算var arr3 = [&#123; price: 1, count: 1 &#125;, &#123; price: 2, count: 2 &#125;, &#123; price: 3, count: 3 &#125;]var new3 = arr3.reduce(function(pre, next, index) &#123; return pre + next.price * next.count // 当需要操作第一项的时候，利用 reduce(callbreak()&#123;&#125;,往数组第一项前添加一项，如:0)&#125;, 0) // 在原数组第一项添加为 0，不改变原数组 基本包装类型 简单数据类型是没有方法的。为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String/Number/Boolean 基本包装类型：把基本类型包装成复杂类型 var str = 'abc'var result = str.indexOf('a')// 发生了三件事情// 1. 把简单类型转换成复杂类型：var s = new String(str)// 2. 调用包装类型的 indexOf 方法：var result = s.indexOf('a')// 3. 销毁刚刚创建的复杂类型 Number 对象 Number 对象是数字的包装类型，数字可以直接使用这些方法 num.toFixed(2) ：返回保留 2 位小数的新数的字符串格式num.toString() ：转换成字符串并返回 Boolean 对象 Boolean 对象是布尔类型的包装类型 toString() // 转换成字符串并返回 undefined 和 null 没有包装类型，所以调用 toString 方法会报错 String 对象 字符串可以看成是一个字符数组（伪数组）。因此字符串也有长度，也可以进行遍历。String 对象很多方法的名字和 Array 的一样。 操作字符串的方法不会改变原来的字符串，需要新字符串去接收 查找指定字符串 str.indexOf(‘‘) // 获取某个字符串第一次出现的位置，如果没有，返回-1str.lastIndexOf(’’) // 从后面开始查找第一次出现的位置。如果没有，返回-1str.search(regexp) // 查找并输出索引位置,找不到输出-1str.match(regexp) // 输出匹配到的第一个字符，匹配不到返回 nullstr.match(regexp/g) // 全部输出str.startsWith(str1) // 判断 str 字符串是否以 str1 字符串开头，若符合返回 true // 等价于判断 str.indexOf(str1) === 0str.endsWith(str1) // 判断 str 字符串是否以 str1 字符串结尾，若符合返回 true str.indexOf(str1) === str.length - str1.length 去除空白 str.trim() // 去除字符串两边的空格，内部空格不会去除 大小写转换 str.toUpperCase() // 全部转换成大写字母str.toLowerCase() // 全部转换成小写字母 字符串拼接与截取 // 字符串拼接 可以用 concat，用法与数组一样，但是字符串拼串我们一般都用 +str.slice(start, end) // 从 start 开始，end 结束，并且取不到 end，没有 end 则截取到末尾// 可以为负数，会将字符串的长度与对应的负数相加，结果作为参数，-1 表示从后数第一个，一次为 -2、-3...str.slice(-3) // 截取字符串后三位// str.slice() 与 str.slice(0) 等价 截取全部str.substring(start, end) // 以两个参数中较小一个作为起始位置，较大的参数作为结束位置// 负参数会被直接转换为 0// str.substring() 与 str.substring(0) 等价 截取全部str.substr(start, length) // 从 start 开始，截取 length 个字符，没有 length 则截取到末尾// 第一个参数为负参数时，会将第一个参数与字符串长度相加后的结果作为第一个参数，// 第二个参数为负数时，会被转化为 0 ，即截取长度为 0 字符串切割 // 将字符串分割成数组（很常用）str.split()// 功能和数组的 join 正好相反var str = 'zs,ls,ww'var arr = str.split(',') 字符串替换 str.replace(searchValue, replaceValue)// 参数：searchValue: 需要替换的值 replaceValue: 用来替换的值 默认只替换第一个str.replace(/searchValue/g, replaceValue) // 全部替换str.replace(/ /g, '') // 将全部空格去掉 访问 str[i]str.charAt(i)// i 均为下标 练习 1. 截取字符串’我爱中华人民共和国’，中的’中华’2. ’abcoefoxyozzopp’查找字符串中所有o出现的位置3. 把字符串中所有的o替换成!4. 把一个字符串中所有的空格全部去掉5. 统计一个字符串中每个字符出现的次数]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 模块化编程]]></title>
    <url>%2F2018%2Fjavascript%2Fjs%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Javascript模块化编程 最初Javascript不是一种模块化编程语言(es6开始支持)。为了能够尽可能的实现js的模块化，我们会把代码写成这样: // 1. 最原始:封装函数写法 function fn1()&#123; // code &#125; function fn2()&#123; // code &#125;// 上面的函数fn1()和fn2()，组成一个模块。使用的时候，直接调用就行了。// 这种做法的缺点很明显："污染"了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。 // 2. 对象写法// 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。 var module1 = &#123; _count : 0, fn1 : function ()&#123; //code &#125;, fn2 : function ()&#123; //code &#125; &#125;;// 上面的函数fn1()和fn2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。// module1.fn1();// 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。// module1._count = 666; Javascript 模块的基本写法 // 3.立即执行函数(自调用函数)写法 (沙箱模式)// 使用"立即执行函数"，可以达到不暴露私有成员的目的。var module1 = (function()&#123; var _count = 0; //一般私有的变量:申明变量名时,以_开头 function fn1()&#123; //code &#125; function fn2()&#123; //code &#125; return &#123; fn1 : fn1, fn2 : fn2 &#125;;&#125;)();// 使用上面的写法，外部代码无法读取内部的_count变量。// console.info(module1._count); //undefined ##模块化的标准 让模块拥有更好的通用性！ AMD : Async Module Definition 异步模块定义 依赖前置： 在一开始就将所有的依赖项全部加载 CMD : Common Module Definition 通用模块定义 依赖延迟： 在需要的时候才去加载依赖项 区别: AMD是异步的, CMD是同步的 ###CMD (Common Module Definition) 同步加载模块 // module add.jsmodule.exports = function add (a, b) &#123; return a + b; &#125;// main.jsvar &#123;add&#125; = require('./add'); // 此处是同步加载console.log('1 + 2 = ' + add(1,2);// 同步加载这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"状态。 AMD (Asynchronous Module Definition) 异步加载模块 require.js 库实现了AMD规范 // module add.jsdefine(function () &#123; return &#123; add: function (a, b) &#123; return a + b; &#125; &#125;;&#125;);// main.js// 第一个参数是要请求的模块,第二个参数是依赖模块请求完成的回调函数require(['add'], function (add) &#123; console.log('1 + 2 = ' + add(1,2);&#125;); 学习使用 require.jsjs 文件加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；由于js文件之间存在依赖关系，因此必须严格保证加载顺序，依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 require.js 的诞生，就是为了解决这两个问题： （1）实现js文件的异步加载，避免网页失去响应； （2）管理模块之间的依赖性，便于代码的编写和维护。 ###require.js 的下载和引入 使用 require.js 的第一步，是先去官方网站下载最新版本。 中文网 http://www.requirejs.cn &lt;!-- 引入方式: --&gt;&lt;script src="js/require.js"&gt;&lt;/script&gt; 加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样： &lt;!-- async 属性表明这个文件需要异步加载，避免网页失去响应 --&gt;&lt;!-- IE不支持这个属性，只支持 defer，所以把 defer 也写上 --&gt;&lt;script src="js/require.js" defer async="true" &gt;&lt;/script&gt; 加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了： &lt;!-- data-main 属性的作用是，指定网页程序的主模块。在上例中，就是 js 目录下面的 main.js，这个文件会第一个被 require.js 加载。由于 require.js 默认的文件后缀名是 js ，所以可以把 main.js 简写成 main。--&gt;&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; ###主模块的写法 main.js，我把它称为”主模块”，意思是整个网页的入口代码。所有代码都从这儿开始运行。 下面就来看，怎么写main.js。 如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。 // main.jsalert("加载成功！"); 但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。 // main.js require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC)&#123; // some code here &#125;);// require.js 要求，每个模块是一个单独的js文件。// require() 函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是['moduleA', 'moduleB', 'moduleC']，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。// require() 异步加载 moduleA，moduleB 和 moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 每个 AMD 模块的写法 require.js 加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。 具体来说，就是模块必须采用特定的 define() 函数来定义。 如果一个模块不依赖其他模块，那么可以直接定义在 define() 函数之中。 // 假定现在有一个math.js文件，它定义了一个 math 模块。那么，math.js 就要这样写：// math.jsdefine(function () &#123; var add = function (x, y) &#123; return x + y; &#125;; return &#123; add: add &#125;;&#125;); 加载方法如下： // main.jsrequire(['math'], function (math)&#123; alert(math.add(1,1));&#125;); 如果这个模块还依赖其他模块，那么 define() 函数的第一个参数，必须是一个数组，指明该模块的依赖性。 // 当require() 函数加载上面这个模块的时候，就会先加载 myLib.js 文件。define(['myLib'], function (myLib) &#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;;&#125;); 模块加载的配置// 上面代码中主模块的依赖模块是['moduleA', 'moduleB', 'moduleC']。默认情况下，require.js 假定这三个模块与main.js 在同一个目录，文件名分别为 moduleA.js，moduleB.js 和 moduleC.js，然后自动加载。// 使用 require.config() 方法，我们可以对模块的加载行为进行自定义。require.config() 写在主模块（main.js）的头部。参数就是一个对象，这个对象的 paths 属性指定各个模块的加载路径。require.config(&#123; paths: &#123; "moduleA": "moduleA.min", "moduleB": "moduleB.min", "moduleC": "moduleC.min" &#125;&#125;); // 上面的代码给出了三个模块的文件名，路径默认与 main.js 在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。require.config(&#123; paths: &#123; // 注意:路径相对的是 main 的路径, 不需要写后缀名,require 会自动加 "moduleA": "lib/moduleA.min", "moduleB": "lib/moduleB.min", "moduleC": "lib/moduleC.min" &#125;&#125;);// 另一种则是直接改变基目录（baseUrl）。require.config(&#123; baseUrl: "js/lib", paths: &#123; "moduleA": "moduleA.min", "moduleB": "moduleB.min", "moduleC": "moduleC.min" &#125;&#125;);// 如果某个模块在另一台主机上，也可以直接指定它的网址，比如：require.config(&#123; paths: &#123; "jquery": "https://code.jquery.com/jquery-3.3.1.min" &#125;&#125;); ###加载非规范的模块 理论上，require.js 加载的模块，必须是按照AMD规范、用 define() 函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？ 回答是可以的 这样的模块在用require()加载之前，要先用 require.config() 方法，定义它们的一些特征 // require.config() 接受一个配置对象，这个对象除了有前面说过的 paths 属性之外，还有一个 shim 属性，专门用来配置不兼容的模块。具体来说，每个模块要定义：（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。// 加入有一个demo.js文件,没有按照AMD规范定义, 那么应该如果使用呢?// 1. 在 paths 中先配置一下这个 demo.js 的路径// 2. 在 shim 中配置这个文件的依赖项和导出项// demo.jsfunction animate()&#123; $('.box').stop(true).fadeIn(1000).fadeOut(1000).slideDown(1000).hide(1000); console.log('动画执行了');&#125;// main.jsrequire.config(&#123; paths: &#123; 'jquery': 'https://code.jquery.com/jquery-3.3.1.min', 'demo': 'demo.js 相对 main.js 的路径' &#125;, shim: &#123; 'demo': &#123; deps: ['jquery'], // 注意: 这里导出项要写的是demo.js中的那些内容 // 这里要导出 animate 函数 exports: 'animate' &#125; &#125;&#125;);require(['demo'],function(demo)&#123; console.log(demo); demo(); // 会执行demo.js 文件中 animate 函数&#125;)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fixed定位脱离Viewport的bug]]></title>
    <url>%2F2018%2Fhtml%E4%B8%8Ecss%2FFixed%E5%AE%9A%E4%BD%8D%E8%84%B1%E7%A6%BBViewport%E7%9A%84bug%2F</url>
    <content type="text"><![CDATA[Fixed 定位脱离 Viewport 的 bug&lt;style&gt; .outer &#123; overflow: hidden; width: 300px; height: 300px; background: yellow; &#125; .mid &#123; margin: 20px; width: 200px; height: 200px; transform: translate(0, 0); background: greenyellow; &#125; .inner &#123; position: fixed; top: 0; left: 0; width: 100px; height: 100px; background: pink; z-index: 1 &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="outer"&gt; &lt;div class="mid"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 对于声明 transfrom 值非 none 元素，其子元素中若存在 position: fixed 将以声明 transform 的最近祖先作为基准而定位，这是因为 transfrom 值非 none 的元素定义了一个局部坐标系统，导致 postion: fixed 以此坐标系统计算布局。]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>html&amp;css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-z-index 堆叠顺序]]></title>
    <url>%2F2018%2Fhtml%E4%B8%8Ecss%2Fcss-z-index%2F</url>
    <content type="text"><![CDATA[9.3.2 堆叠顺序（z-index）在使用定位布局时，可能会出现盒子重叠的情况。加了定位的盒子，默认后来者居上， 后面的盒子会压住前面的盒子。 应用 z-index 层叠等级属性可以调整盒子的堆叠顺序。 z-index 的特性如下： 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面无单位。 只应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 层叠水平仅在直接父级层叠上下文中进行比较，即层叠上下文 A 中的子元素的层叠水平不会和另一个层叠上下文中的子元素进行比较 层叠上下文（stacking context）：创建层叠上下文的元素自己会成为一个参考对象。 层叠水平（stacking level） 层叠顺序（stacking order） 满足下面规则的元素将会构造出一个 Stacking Context 结构： html 根元素默认会创建层叠上下文 position不为static且z-index不是 auto 的元素 display为flex且z-index不是 auto 的元素 opacity不等于 1 transform不等于 none &lt;html&gt; &lt;div class="me"&gt; &lt;div class="you"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/html&gt;&lt;style&gt; .me &#123; width: 100px; height: 100px; &#125; .you &#123; width: 100px; height: 100px; left: 50px; position: relative; z-index: -1; &#125;&lt;/style&gt; you 在这里和 me 做比较，比较开始，首先 you 寻找参考对象，上一层 me 是吗？显然不是，因为 me 没有触发上面任一条件创建层叠上下文，所以继续往上寻找，找到 html。对于 me，也直接往上找到 html，所以这个例子里 me 和 you 是在以 html 为参考对象进行比较，换句话说就是在 html 创建的层叠上下文环境中进行比较！然后按照七阶图，负值 index 在 block 元素之下！所以 me 在 you 之上。 然后我们修改下 me，加个z-index:0; 按照之前的思路演算一遍，you 的参考对象变成 me 了！而 me 仍然是 html，然后 me 和 html 再做比较，me 参考对象是 html，html 的参考对象是 html，OK，在同一上下文了，me 明显高于 html，所以 you 高于 me。 参考链接 北风吹雪：不起眼的 z-index 却能牵扯出这么大的学问 张鑫旭:深入理解 CSS 中的层叠上下文和层叠顺序]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>html&amp;css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础]]></title>
    <url>%2F2018%2Fhtml%E4%B8%8Ecss%2Fcss%2F</url>
    <content type="text"><![CDATA[CSS层叠样式表1.CSS初识 概念： CSS(Cascading Style Sheets) ，通常称为CSS样式表或层叠样式表（级联样式表） 作用： 主要用于设置 HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。 CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。 2. 引入CSS样式表（书写位置）2.1 行内式（内联样式） 概念： 称行内样式、行间样式. 是通过标签的style属性来设置元素的样式 其基本语法格式如下： &lt;标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"&gt; 内容 &lt;/标签名&gt; 实际上任何HTML标签都拥有style属性，用来设置行内式。 案例： &lt;div style="color: red; font-size: 12px;"&gt;青春不常在，抓紧谈恋爱&lt;/div&gt; 注意： style其实就是标签的属性 样式属性和值中间是 : 多组属性值之间用 ; 隔开。 只能控制当前的标签和以及嵌套在其中的子标签，造成代码冗余 缺点： 没有实现样式和结构相分离 2.2 内部样式表（内嵌样式表） 概念： 称内嵌式 是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义 其基本语法格式如下： &lt;style&gt; div &#123; color: red; font-size: 12px; &#125;&lt;/style&gt; 注意： style标签一般位于head标签中 type=”text/css” 在html5中可以省略 只能控制当前的页面 缺点： 没有彻底分离 2.3 外部样式表（外链式） 概念： 称链入式 是将所有的样式放在一个或多个以 .CSS 为扩展名的外部样式表文件中， 通过link标签将外部样式表文件链接到HTML文档中 其基本语法格式如下： &lt;head&gt; &lt;link rel="stylesheet" type="text/css" href="css文件路径"&gt;&lt;/head&gt; 注意： link 是个单标签 link标签需要放在head头部标签中，并且指定link标签的三个属性 属性 作用 rel 定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 type 定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。我们都可以省略 href 定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。 2.4 三种样式表总结（位置） 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内部样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多） 3. CSS样式规则 选择器用于指定CSS样式作用的HTML标签，花括号内是对该对象设置的具体样式。 属性和属性值以“键值对”的形式出现。 属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。 属性和属性值之间用英文 : 连接。 多个“键值对”之间用英文 ; 进行区分。 4. CSS 选择器（重点）4.1 CSS 基础选择器4.1.1 标签选择器 概念： 标签选择器（元素选择器）是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。 语法： 标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125; 4.1.2 类选择器类选择器使用 .（英文点号）进行标识，后面紧跟类名. 语法： 类名选择器 .类名 &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125; 标签 &lt;p class=&apos;类名&apos;&gt;&lt;/p&gt; 优点： 可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签 注意 可以使用字母，数字，- ，_ 必须以字母开头，区分大小写，不要纯数字、中文等命名 一个class可以出现多次，一个元素可以有多个class，各个类名中间用空格隔开 4.1.3 id 选择器id 选择器使用 # 进行标识，后面紧跟id名 其基本语法格式如下： id选择器 #id名 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125; 注意 必须以字母开头 区分大小写 只可出现一次 4.1.4 通配符选择器通配符选择器用 * 号表示，选择所有的标签。 其基本语法格式如下： &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 * &#123; margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/&#125; 注意： 会匹配页面所有的元素，降低页面响应速度，不建议随便使用 4.2 CSS 复合选择器4.2.1 后代选择器（重点） 后代选择器又称为包含选择器（标签有直接或间接嵌套关系，可隔代选择） 中间用 空格 连接 语法： 父级 子级&#123;属性:属性值;属性:属性值;&#125;.class h3&#123;color:red;font-size:16px;&#125; 4.2.2 子元素(子代)选择器 子元素选择器只能选择作为某元素子元素(亲儿子)的元素（直接嵌套，不能隔代）。 其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接 语法： .class &gt; h3&#123;color:red;font-size:14px;&#125; 白话： 比如: .demo &gt; h3 &#123;color: red;&#125; 说明 h3 一定是 demo 亲儿子 demo 元素包含着h3 4.2.3 交集选择器 由两个选择器构成，找到的标签必须满足：既有标签一的特点，也有标签二的特点。 两个选择器之间 不能有空格，如h3.special。 记忆技巧： 交集选择器 是 并且的意思。 即…又…的意思 比如: p.one 选择的是类名为 .one 的 p 标签 用的相对来说比较少，不太建议使用。 4.2.4 并集选择器（重点） 并集选择器（CSS选择器分组）是各个选择器通过,连接而成的，通常用于集体声明。 任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。 比如 .one, p , #test &#123;color: #F00;&#125;表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色通常用于集体声明 4.2.5 伪类选择器伪类选择器实质上是让设计师可以根据元素特定的状态，设置不同的视觉效果。具体有:link、:visited、:hover、:active、:focus、:focus-within、:target、:root和:checked。 a:link 用于设置链接初始状态时的样式 a:visited 用于设置链接被点击过后的样式 设置font-size不起作用 a:hover 用于设置鼠标悬停在链接上方时，链接的样式 a:active 用于设置鼠标按键按下，但未释放时，链接的样式 :first-child li:first-child 选择属于其父元素的第一个子元素(不一定是li元素) :last-child li:last-child 选择属于其父元素的最后一个子元素 :nth-child(2) li:nth-child(2) 选择属于其父元素的第二个子元素 :nth-child(even) li:nth-child(even) 选择属于其父元素的偶数项的子元素 :nth-child(3n+1) li:nth-child(3n+1) 选择属于其父元素的正向3n+1项(n从0开始)的子元素 nth-last-child(3n+1) li:nth-last-child(-n+5) 选择属于其父元素的反向-n+5项(n从0开始)的子元素(即选择最后五个li元素) :only-child li:only-child 选择属于其父元素的唯一子元素的每个 &lt;li&gt; 元素 :only-of-type li:only-of-type 选择属于其父元素唯一 &lt;li&gt; 元素的每个 &lt;li&gt; 元素 :first-of-type li:first-of-type 选择属于其父元素的第一个&lt;li&gt; 元素 :last-of-type li:last-of-type 选择属于其父元素的最后一个 &lt;li&gt; 元素 :nth-of-type(2) li:nth-of-type(2) 选择属于其父元素的第二个 &lt;li&gt; 元素 :enabled input:enabled 选择每个启用的 &lt;input&gt; 元素 :disabled input:disabled 选择每个禁用的 input&gt; 元素 :checked input:checked 选择每个被选中的 &lt;input&gt; 元素 :focus 用于设置元素处于focus状态下的样式。 :focus-within 用于设置当子元素处于focus状态时，该元素的样式。 :empty p:empty 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点） :target #news:target 选择当前活动的 #news 元素 :root 选择文档的根元素 :not(p) li:not(:last-of-type) 选择最后一个li之外其他所有li :placeholder-shown 用于设置元素placeholder显示时的样式 伪元素 ::selection ::selection 选择被用户选取的元素部分 ::first-letter p::first-letter 选择每个 &lt;p&gt; 元素的首字母。 ::first-line p::first-line 选择每个 &lt;p&gt; 元素的首行 ::placeholder input::placeholder 选择input内部的占位符，给其设置样式 ::before div::before 在每个 &lt;div&gt; 元素的内容之前插入内容 ::after div::after 在每个 &lt;div&gt; 元素的内容之后插入内容 属性选择器 [attribute] [disabled] 选择带有disabled 属性所有元素。 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素。 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 [attribute|=value] [lang|=en] 选择 lang 属性值以 “en” 开头后续以-分隔的所有元素。 :lang(language) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 &lt;p&gt; 元素 [attribute^=value] a[src^=”https”] 选择其 src 属性值以 “https” 开头的每个 &lt;a&gt; 元素 [attribute$=value] a[src$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素 [attribute*=value] a[src*=”abc”] 选择其 src 属性中包含 “abc” 子串的每个 &lt;a&gt; 元素 #nav == [id=nav] 选择 id=nav 的所有元素 li:last-child 是选择li元素的父元素下的最后一个子元素，不一定是 li li:last-of-type 是选择li元素的父元素的最后一个 li 元素 li:not(:last-of-type) 选择最后一个li之外其他所有li ::before ::after 必须指定 content 属性，否则无效；生成的伪元素默认是行内样式；生成的伪元素无法被找到，更不能被 hover 等；一般用来清除浮动(只有::after可以)或添加小图标 关于单冒号和双冒号问题： 关于:before与::before的区别:before是css2中伪元素的写法，但是呢，在css3中严格规定，伪类采用单冒号，伪元素需要使用双冒号。为了兼容旧的代码，当浏览器碰到了:before之后，会自动的转换成::before。如果需要兼容老的浏览器，比如IE678，推荐使用:before如果不需要兼容老的浏览器，比如移动端，推荐使用::before 链接伪类注意 写的时候，他们的顺序尽量不要颠倒 按照 lvha 的顺序。否则可能引起错误。 记忆法 love hate 爱上了讨厌 lv *包包 非常 *hao 因为叫链接伪类，所以都是 利用交集选择器 a:link a:hover 因为a链接浏览器具有默认样式，所以我们实际工作中都需要给链接单独指定样式。 实际工作开发中，我们很少写全四个状态，一般我们写法如下： a &#123; /* a是标签选择器 所有的链接 */ font-weight: 700; font-size: 16px; color: gray;&#125;a:hover &#123; /* :hover 是链接伪类选择器 鼠标经过 */ color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */&#125; 5. CSS属性5.1 font:字体5.1.1 font-size:大小 作用： font-size属性用于设置字号 p &#123; font-size:20px;&#125; 谷歌浏览器默认的文字大小为16px，最小为12px。 em、百分比 相对父元素大小 设置body默认字体大小为100%，其他文字大小以此为基础设置百分比值 5.1.2 font-family:字体 作用： font-family属性用于设置哪一种字体。 p&#123; font-family:&quot;微软雅黑&quot;;&#125; 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。 如果字体名中包含空格、#、$ 等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: “Times New Roman”;。 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。 p&#123;font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;&#125; CSS Unicode字体 为什么使用 Unicode字体 在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。 xp 系统不支持 类似微软雅黑的中文。 解决： 方案一： 你可以使用英文来替代。 比如font-family:&quot;Microsoft Yahei&quot;。 方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。 &gt; font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;; 表示设置字体为“微软雅黑”。&gt; 字体名称 英文名称 Unicode 编码 宋体 SimSun \5B8B\4F53 新宋体 NSimSun \65B0\5B8B\4F53 黑体 SimHei \9ED1\4F53 微软雅黑 Microsoft YaHei \5FAE\8F6F\96C5\9ED1 楷体_GB2312 KaiTi_GB2312 \6977\4F53_GB2312 隶书 LiSu \96B6\4E66 幼园 YouYuan \5E7C\5706 华文细黑 STXihei \534E\6587\7EC6\9ED1 细明体 MingLiU \7EC6\660E\4F53 新细明体 PMingLiU \65B0\7EC6\660E\4F53 5.1.3 font-weight:字体粗细 在html中如何将字体加粗我们可以用标签来实现 使用 b 和 strong 标签是文本加粗。 可以使用CSS 来实现，但是CSS 是没有语义的。 属性值 描述 normal 默认值（不加粗的） bold 定义粗体（加粗的） 100~900 400 等同于 normal，而 700 等同于 bold 我们重点记住这句话 5.1.4 font-style:字体风格 在html中如何将字体倾斜我们可以用标签来实现 字体倾斜除了用 i 和 em 标签， 可以使用CSS 来实现，但是CSS 是没有语义的 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： 属性 作用 normal 默认值，浏览器会显示标准的字体样式 font-style: normal; italic 浏览器会显示斜体的字体样式。 5.1.5 line-height:文字行高 作用： 设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。 使用行高实现单行文字垂直居中 单位： line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 技巧： 一般情况下，行距比字号大7.8像素左右就可以了。line-height: 24px; 文字垂直居中就设置行高等于他外部元素的高度 line-height 不要代替 height ，height 不写 line-height 会把盒子撑起来，不建议这样， height该写也得写 行高测量 行高和高度的三种关系 如果 行高 等 高度 文字会 垂直居中 如果行高 大于 高度 文字会 偏下 如果行高小于高度 文字会 偏上 300%、3em、3 之间区别 300% 先计算后继承 3 先继承后计算 3em 5.1.6 font: 综合设置字体样式 (重点)font属性用于对字体样式进行综合设置 基本语法格式如下： font: [&lt;font-style&gt;||&lt;font-weight&gt;]?&lt;font-size&gt;[/&lt;line-height&gt;]?&lt;font-family&gt;(必不可少，否则无效)font:italic bold 20px/2 arial,serif;//表示font-style:italic font-weight:bold font-size:20px line-height:2 font-family:arial,serif 注意： 使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。 其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。 line-height 值如果不写，浏览器会默认添加 normal 5.2 text 属性5.2.1 color:文本颜色 作用： color属性用于定义文本的颜色， 其取值方式有如下3种： 表示表示 属性值 预定义的颜色值 red，green，blue等等 十六进制 #FF0000，#FF6600，#29D794 RGB代码 rgb(255,0,0)或rgb(100%,0%,0%)rgba(255,0,0,1)1表示不透明，0表示全透明全透明也可以用color：transparent 注意 我们实际工作中， 用 16进制的写法是最多的，而且我们更喜欢简写方式比如 #f00 代表红色 5.2.2 text-align:文本水平对齐方式 作用： text-align 属性用于设置当前这个标签内部的 内容（可以是文字 、行内标签、行内块标签）的水平对齐方式 其可用属性值如下： 属性 解释 left 左对齐（默认值） right 右对齐 center 居中对齐 justify 两端对齐 注意： 是让盒子里面的 内容水平居中 ， 而不是让盒子居中对齐 5.2.3 text-indent:首行缩进 作用： text-indent 属性用于设置首行文本的缩进， 属性值 其属性值可为不同单位的数值、em字符宽度的倍数、或相对于父元素宽度的百分比%，允许使用负值（设置成很大的负值可以用来隐藏文字） 建议使用em作为设置单位。 可以继承 1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度 p &#123; /*行间距*/ line-height: 25px; /*首行缩进2个字 em 1个em 就是1个字的大小*/ text-indent: 2em; &#125; 5.2.4 text-decoration 文本的装饰text-decoration 通常我们用于给链接修改装饰效果 值 描述 none 默认。定义标准的文本。 取消下划线（最常用） underline 定义文本下的一条线。下划线 也是我们链接自带的（常用） overline 定义文本上的一条线。（不用） line-through 定义穿过文本的一条线。（不常用） 多个属性值写在同一个text-decoration里会叠加 多个属性值写在不同的text-decoration里，属性不会累加，优先级高的会完全取代优先级低的 5.2.5 CSS外观属性总结 属性 表示 注意点 color 颜色 我们通常用 十六进制 比如 而且是简写形式 #fff line-height 行高 控制行与行之间的距离 text-align 水平对齐 可以设定文字水平的对齐方式 text-indent 首行缩进 通常我们用于段落首行缩进2个字的距离 text-indent: 2em; text-decoration 文本修饰 记住 添加 下划线 underline 取消下划线 none 5.3 背景(background)属性color/* 背景颜色 */background-color: 颜色值; 默认的值是 transparent 透明的 inherit 继承/* 半透明背景 */background: rgba(0, 0, 0, 0.3); /* 只作用于盒子背景颜色，不会影响文本和背景图片 */ /* 最后一个参数是 alpha 透明度 取值范围 0~1 之间 */ /* 0.3 的 0 可以省略 */ /* C3 属性，低于 ie9 的版本不支持 */ opacity 属性 设置整个标签的透明度，取值范围 0~1之间 image/* 背景图片 */background-image: none(默认) url(图片地址) url("demo1.png"), url("demo2.png"); /* demo1 在 demo2 上层 */ 在background-color上层 推荐背景图片 url 加引号 多个背景图片，使用逗号隔开 img 和背景图片的区别： img 直接可以显示在页面，不需要设置宽高，但是背景图片必须要给盒子设置宽高才能显示，背景图片撑不开容器 img 上面写不了内容（除非后期使用定位），而背景图片完全可以 在实际工作中：img 一般用来做产品图片展示（经常更新），而背景图片一般用来做背景或者一些很少更新的小 icon img &#123; width: 200px; /* 插入图片更改大小 width 和 height */ height: 200px; margin-top: 30px; /* 插入图片更改位置 可以用 margin 或 padding 盒模型 */ margin-left: 50px; /* 插入的图片也是一个盒子 */&#125;div &#123; width: 400px; height: 400px; border: 1px solid purple; background: #fff url('images/sun.jpg') no-repeat; background-position: 30px 50px; /* 背景图片更改位置用 */&#125; repeat/* 背景平铺 */background-repeat:repeat：背景图像在纵向和横向上平铺（默认的）no-repeat：背景图像不平铺（常用）repeat-x：背景图像在横向上平铺repeat-y：背景图像在纵向平铺space：中间有空白，保证显示每个图片完整round：通过缩放保证每个图片显示完整，有可能图片会被拉伸 position/* 背景位置 */background-position: length：百分数 | 由浮点数字和单位标识符组成的长度值 position：top | center | bottom | left | center | right 方位名词 注意： 必须先指定 background-image 属性 x 轴向右为正方向，y 轴向下为正方向，z 轴向屏幕外是正方向 如果 position 后面是精确坐标， 那么第一个是 x ，第二的一定是 y 如果指定的两个值是精确单位和方位名字混合使用，则第一个值是 x 坐标，第二个值是 y 坐标 如果指定两个值都是方位名字，则两个值前后顺序无关，比如 left top 和 top left 效果一致 如果只指定了一个方位名词，另一个值默认居中对齐。如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中 可设置像素值或百分比（百分比对应容器百分比位置，50% 50% 等价于 center center 即居中） right 10px top 20px 表示距离右边10px 距离上边 20px attachment/* 背景附着就是解释背景是滚动的还是固定的 */background-attachment: scroll：背景图像是随对象内容滚动 fixed：背景图像固定 inherit size 跟 width 或者 height 属性是一致的，其实就是设置背景图片的宽高 设置百分比则是相对于容器的百分比，而不是图片，50% 不是将图片缩小一半 特殊值：cover 和 contain 图片等比缩放恰好覆盖整个元素 cover 某一边正好100%，另一边等于或者大于元素对应方向的长度 contain 某一边正好100%，另一边等于或者小于元素对应方向的长度 origin/* 设置背景零点参考的盒模型即设置（0.0）坐标位置 */background-origin: padding-box（默认值） | border-box | content-box clip/* 设置背景裁剪参考的盒模型 */background-clip: border-box （默认值）背景区域：border + padding + content padding-box 背景区域：padding + content content-box 背景区域：content text (需要加 -webkit- 前缀) 背景区域 ：文字 背景属性简写!&gt; background: bg-image || bg-position/bg-size || repeat-style || bg-attachment || bg-origin|| bg-clip(origin 和 clip 只设置一个值时则他俩为同一个值) || bg-color 多重背景：background 设置背景的时候，可以设置多个背景图片，使用逗号隔开。注意颜色只能设置一次，并且颜色通常都是在最后面进行设置。 background 是一个合写的属性，如果在 background 之前设置了background相关的样式，会被覆盖掉 5.4 display 属性（重点）属性值：​ none 此元素不会被显示，不占空间，后续元素会补充上去（visibility：hidden 不显示，但空间保留）​ block 显示为块级元素​ inline 显示为内联元素​ inline-block 显示为行内块 5.4.1 块级元素(block)display:block; 常见的块元素有 &lt;h1&gt;~&lt;h6&gt; 、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt; 、dl、 dt 、dd、 header 、 footer 、aside、 nav 、 article 、 section …等，其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点 （1）独占一行 （2）高度，宽度、外边距以及内边距都可以控制。 （3）继承父元素的宽度，高度不继承 （4）是一个容器及盒子，里面可以放行内或者块级元素。 注意： 只有文字才能组成段落 因此 p 里面不能放块级元素，特别是 p 不能放div 同理还有这些标签 h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。 5.4.2 行内元素(inline)display:inline; 常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、lable 、&lt;span&gt; 等，其中 &lt;span&gt; 标签最典型的行内元素。有的地方也成内联元素 行内元素的特点： （1）相邻行内元素在一行上，一行可以显示多个。 （2）高、宽直接设置是无效的。 （3）默认宽度就是它本身内容的宽度。 （4）不可设置竖直方向的marging和padding,但是可以设置水平方向的margin和padding （5）行内元素只能容纳文本或则其他行内元素。 注意： &lt;a&gt; 不能直接嵌套 &lt;a&gt; 特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。 5.4.3 行内块元素（inline-block）display: inline-block; 在行内元素中有几个特殊的标签——&lt;img&gt;、&lt;input&gt;、&lt;td&gt;、textarea ，select ，button，可以对它们设置宽高和对齐属性，这些元素把它们称为行内块元素。 行内块元素的特点： （1）和相邻行内元素（行内块）在一行上。一行可以显示多个，超出范围会整块换行（2）默认宽度就是它本身内容的宽度。（3）高度，行高、外边距以及内边距都可以控制。（4）可以设置垂直居中 {vertical-align：middle；} 5.5 盒子阴影 box-shadow (CSS3) 语法: box-shadow:水平阴影 垂直阴影 模糊距离（虚实） 阴影尺寸（影子大小） 阴影颜色 内/外阴影； 前两个属性是必须写的，其余的可以省略。 水平阴影、垂直阴影、阴影尺寸可为负值，模糊距离不能为负 外阴影 (outset) 是默认的 但是不能写 想要内阴影可以写 inset div &#123; width: 200px; height: 200px; border: 10px solid red; /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4); */ /* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色 内/外阴影； */ box-shadow: 0 15px 30px rgba(0, 0, 0, .4);&#125; 颜色如果没设置则为border或文字颜色，阴影不占空间，内外阴影可以叠加，中间用逗号隔开 6. CSS 三大特性目标： 理解 能说出css样式冲突采取的原则 能说出哪些常见的样式会有继承 应用 能写出CSS优先级的算法 能会计算常见选择器的叠加值 6.1 CSS层叠性 概念： 所谓层叠性是指多种CSS样式的叠加。 是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 原则： 样式冲突，遵循的原则是就近原则。 同一标签同一属性，后面的会覆盖前面的 样式不冲突，不会层叠 CSS层叠性最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。 6.2 CSS继承性 概念： 子标签会继承父标签的某些样式，如文本颜色和字号。 想要设置一个可继承的属性，只需将它应用于父元素即可。 简单的理解就是： 子承父业。 注意： 恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。 子元素可以继承父元素的样式（text-，font-，line- 这些元素开头的可以继承，以及color属性） a标签不会继承color， text-decoration none 属性值不会继承，其他属性值会继承 h标签会继承的父元素的font-size，但是具体的值是继承下来的font-size的值* 2 6.3 CSS优先级（重点） 概念： 定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时， 选择器相同，则执行层叠性 选择器不同，就会出现优先级的问题。 !important &gt; style &gt; id &gt; 类/伪类 &gt; 标签 &gt; * &gt; 继承 1). 权重计算公式关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性） 标签选择器 计算权重公式 继承或者 * 0,0,0,0 每个元素（标签选择器），伪元素选择器 0,0,0,1 每个类，伪类，属性选择器 0,0,1,0 每个ID 0,1,0,0 每个行内样式 style=”” 1,0,0,0 每个!important 重要的 ∞ 无穷大 值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性） div { color: pink!important; } 2). 权重叠加我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。 就是一个简单的加法计算 div ul li ——&gt; 0,0,0,3 .nav ul li ——&gt; 0,0,1,2 a:hover —–—&gt; 0,0,1,1 .nav a ——&gt; 0,0,1,1 注意： 数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。 3). 继承的权重是0这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。 1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。2） 如果没有选中，那么权重是0，因为继承的权重为0.（!important也无效） 7. 盒子模型（CSS重点）css学习三大重点： css 盒子模型 、 浮动 、 定位 主题思路： 目标： 理解： 能说出盒子模型有哪四部分组成 能说出内边距的作用以及对盒子的影响 能说出padding设置不同数值个数分别代表的意思 能说出块级盒子居中对齐需要的2个条件 能说出外边距合并的解决方法 应用： 能利用边框复合写法给元素添加边框 能计算盒子的实际大小 能利用盒子模型布局模块案例 7.1 盒子模型（Box Model） 所谓盒子模型： 就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 总结: 盒子模型有元素的内容（）、边框（border）、内边距（padding）、和外边距（margin）组成。 盒子里面的文字和图片等元素是 内容区域 盒子的厚度 我们成为 盒子的边框 盒子内容与边框的距离是内边距（类似单元格的 cellpadding) 盒子与盒子之间的距离是外边距（类似单元格的 cellspacing） css中设置的宽高默认是内容部分 7.2 盒子边框（border）​ 语法： border : border-width || border-style || border-color || none 属性 作用 border-width 定义边框粗细，单位是px border-style 边框的样式 border-color 边框颜色 边框的样式： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 7.2.1 盒子边框写法总结表很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。 上边框 下边框 左边框 右边框 border-top-style:样式; border-bottom-style:样式; border-left-style:样式; border-right-style:样式; border-top-width:宽度; border- bottom-width:宽度; border-left-width:宽度; border-right-width:宽度; border-top-color:颜色; border- bottom-color:颜色; border-left-color:颜色; border-right-color:颜色; border-top:宽度 样式 颜色; border-bottom:宽度 样式 颜色; border-left:宽度 样式 颜色; border-right:宽度 样式 颜色; 7.2.2 表格的细线边框 通过表格的cellspacing=&quot;0&quot;,将单元格与单元格之间的距离设置为0， 但是两个单元格之间的边框会出现重叠，从而使边框变粗 通过css属性： table&#123; border-collapse:collapse; &#125; collapse 单词是合并的意思 border-collapse:collapse; 表示相邻边框合并在一起。 &lt;style&gt; table &#123; width: 500px; height: 300px; border: 1px solid red; &#125; td &#123; border: 1px solid red; text-align: center; &#125; table, td &#123; border-collapse: collapse; /*合并相邻边框*/ &#125;&lt;/style&gt; 7.2.3 圆角边框(CSS3) 语法： border-radius:length; /*圆角的半径*/ 其中每一个值可以为数值或百分比的形式。 四个值的顺序是：左上、右上、右下、左下，依旧是顺时针旋转。每个角又有水平半径垂直半径，前四个代表水平，后四个代表垂直，中间用/隔开 技巧： border-radius: 50%; /*让一个正方形 变成圆圈 */border-top-left-radius：10px; /*单独设置一个角*/ 7.3 内边距（padding）7.3.1 内边距padding属性用于设置内边距。 是指 边框与内容之间的距离。 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 当我们给盒子指定padding值之后， 发生了2件事情： 内容和边框 有了距离，添加了内边距。 盒子会变大。 如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。 注意： 后面跟几个数值表示的意思是不一样的。 值的个数 表达意思 1个值 padding：上下左右内边距; 2个值 padding: 上下内边距 左右内边距 ； 3个值 padding：上内边距 左右内边距 下内边距； 4个值 padding: 上内边距 右内边距 下内边距 左内边距 ； 7.3.2 内盒尺寸计算（元素实际大小） 宽度 Element Height = content height + padding + border （Height为内容高度） 高度 Element Width = content width + padding + border （Width为内容宽度） 盒子的实际的大小 = 内容的宽度和高度 + 内边距 + 边框 会撑大原来的盒子 box-sizing: content-box（为默认，宽高不包含padding和border）box-sizing: border-box; 此时宽高包含border在内 7.4 外边距（margin）7.4.1 外边距margin 属性用于设置外边距。 margin 就是控制盒子和盒子之间的距离，可以为负值 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin值的简写 （复合写法）代表意思 跟 padding 完全相同。 行内元素设置 margin-top/bottom 无效 7.4.2 块级盒子水平居中 可以让一个块级盒子实现水平居中必须： 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为auto， 实际工作中常用这种方式进行网页布局，示例代码如下： .header&#123; width:960px; margin:0 auto;&#125; 常见的写法，以下下三种都可以。 margin-left: auto; margin-right: auto; margin: auto; margin: 0 auto; 7.4.3 文字居中和盒子居中区别 盒子内的文字水平居中是 text-align: center, 而且还可以让 行内元素和行内块居中对齐 块级盒子水平居中 左右margin 改为 auto text-align: center; /* 文字 行内元素 行内块元素水平居中 */margin: 10px auto; /* 块级盒子水平居中 左右margin 改为 auto 就阔以了 上下margin都可以 */ 7.4.4 外边距合并（塌陷）使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。 (1). 相邻块元素垂直外边距的合并 当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和而是取两个值中的较大者，这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 解决方案：尽量只给一个盒子添加margin值。 (2). 嵌套块元素垂直外边距的合并（塌陷） 对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，父元素的上外边距会与子元素的上外边距发生合并（父元素会跟着下来），合并后的外边距为两者中的较大者 解决方案： 可以为父元素定义上边框。 可以为父元素定义上内边距 可以为父元素添加overflow:hidden。 还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。 7.4.5 清除元素的默认内外边距(重要)为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除 代码： * &#123; padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */&#125; 注意： 行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。 8. CSS 浮动(float)目标 记忆 能够说出 CSS 的布局的三种机制 理解 能够说出普通流在布局中的特点 能够说出我们为什么用浮动 能够说出我们为什么要清除浮动 应用 能够利用浮动完成导航栏案例 能够清除浮动 8.1 浮动8.1.1 CSS 布局的三种机制CSS 提供了 3 种机制来设置盒子的摆放位置，分别是普通流（标准流）、浮动和定位，其中： 普通流（标准流） 块级元素会独占一行，从上向下顺序排列； 常用元素：div、hr、p、h1~h6、ul、ol、dl 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行； 常用元素：span、a、i、em等 浮动 让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。 定位 将盒子定在浏览器的某一个位置——CSS 离不开定位，特别是后面的 js 特效。 8.1.2 为什么需要浮动？思考题： 我们首先要思考以下2个布局中最常见的问题？ 如何让多个盒子(div)水平排列成一行？ 如何实现盒子的左右对齐？ 虽然我们前面学过行内块（inline-block） 但是他却有自己的缺陷： 它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题。 它不能实现以上第二个问题，盒子左右对齐 pink老师一句话总结他们 因为一些网页布局要求，标准流不能满足我们的需要了，因此我们需要浮动来完成网页布局。 8.1.3 什么是浮动(float)概念：元素的浮动是指设置了浮动属性的元素会 脱离标准普通流的控制 移动到指定位置。 作用 让多个盒子(div)水平排列成一行，使得浮动成为布局的重要手段。 可以实现盒子的左右对齐等等.. 浮动最早是用来控制图片，实现文字环绕图片的效果。 语法在 CSS 中，通过 float 属性定义浮动，语法如下： 选择器 &#123; float: 属性值; &#125; 属性值 描述 none 元素不浮动（默认值） left 元素向左浮动 right 元素向右浮动 特点 float 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下，遮挡起来了 原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。 元素不在受标准流显示模式的限制,块级元素不再继承父元素的宽度，行内元素可以直接设置宽高 浮动的元素互相贴靠一起的，中间没有空白，但是如果父级宽度装不下这些浮动的盒子， 多出的盒子会掉下来（掉下来的位置会根据上一个浮动盒子的高度决定, 会以上一个盒子的底边线为基准线水平移动，如果在移动的过程里面被挡住了，那么就会卡在这里地方） 左浮从左往右排，右浮从右往左排 文字和img标签不会和浮动元素重叠 margin的auto值对于脱标元素没有作用 实际重要的导航栏中，我们不会直接用链接a 而是用 li 包含链接(li+a)的做法。 li+a 语义更清晰，一看这就是有条理的列表型内容。 如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名 8.2 清除浮动 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响 准确地说，所谓的清除浮动，是清除浮动后造成的影响 清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 8.2.1 清除浮动的方法在CSS中，clear属性用于清除浮动 语法： 选择器&#123;clear:属性值;&#125; clear 清除 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 但是我们实际工作中， 几乎只用 clear: both; 1).额外标签法(隔墙法)是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt; 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 2).父级添加overflow属性方法可以给父级添加: overflow为 hidden| auto| scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 3).使用after伪元素清除浮动::after 方式为空元素额外标签法的升级版，好处是不用单独加标签了 使用方法： .clearfix::after&#123; content: ""; display: block; height: 0; clear: both; visibility: hidden;&#125; /*content: ""; display: block; clear: both; 这三个必须写*/ .clearfix&#123; *zoom: 1;&#125; /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 8.2.2 清除浮动总结 父级没高度 子盒子浮动了 影响下面布局了，我们就应该清除浮动了。 清除浮动的方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差。 父级overflow:hidden; 书写简单 溢出隐藏 父级after伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 9. 定位(position)定位也是用来布局的，它有两部分组成： 定位 = 定位模式 + 边偏移 9.1 边偏移通过 top、bottom、left 和 right 属性定义元素的边偏移： 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。 9.2 定位模式 (position)在 CSS 中，通过 position 属性定义元素的定位模式，语法如下： 选择器 &#123; position: 属性值; &#125; 定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 9.2.1 静态定位(static) - 了解 静态定位是元素的默认定位方式，无定位的意思。它相当于 border 里面的none， 不要定位的时候用。 静态定位 按照标准流特性摆放位置，它没有边偏移。 静态定位在布局时我们几乎不用的 9.2.2 相对定位(relative) - 重要 相对定位是元素相对于它原来在标准流中的位置来说的。（自恋型） 原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。 9.2.3 绝对定位(absolute) - 重要 依据最近的已经定位的父级元素（默认父元素的padding部分）来进行定位（拼爹型） 不保留原来的位置，完全是脱标的。 因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。 定位口诀 —— 子绝父相—— 子级是绝对定位，父级要用相对定位。 子元素的 0 点为 margin-box 右上角，父元素的 0 点为 padding-box 右上角 9.2.4 固定定位(fixed) - 重要 完全脱标 —— 完全不占位置； 只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置； 跟父元素没有任何关系；单独使用的 不随滚动条滚动。 9.3 定位(position)的扩展9.3.1 绝对定位的盒子居中 注意：绝对定位/固定定位的盒子不能通过设置 margin: auto 设置水平居中。 在使用绝对定位时要想实现水平居中，可以按照如下方法（垂直居中同理）： left: 50%;：让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;：让盒子向左移动自身宽度的一半。 居中还可以这样：{margin: auto; left: 0; right: 0; top: 0; bottom: 0;} 9.3.2 堆叠顺序（z-index）在使用定位布局时，可能会出现盒子重叠的情况。加了定位的盒子，默认后来者居上， 后面的盒子会压住前面的盒子。 应用 z-index 层叠等级属性可以调整盒子的堆叠顺序。 z-index 的特性如下： 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位。 兄弟元素间相互比较（若A在B上面，B的子元素不管怎么设置都不可能覆盖A） 注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 9.3.3 定位改变display属性 前面我们讲过，display 是显示模式， 可以改变显示模式有以下方式: 可以用inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性转换为行内块。 所以说， 一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。 同时注意： 浮动元素、绝对定位(固定定位）元素不再有外边距合并（塌陷）的问题。 9.4 定位小结 定位模式 是否脱标占有位置 移动位置基准 模式转换（行内块） 使用情况 静态static 不脱标，正常模式 正常模式 不能 几乎不用 相对定位relative 不脱标，占有位置 相对自身位置移动 不能 基本单独使用 绝对定位absolute 完全脱标，不占有位置 相对于定位父级移动位置 能 要和定位父级元素搭配使用 固定定位fixed 完全脱标，不占有位置 相对于浏览器移动位置 能 单独使用，不需要父级 10. CSS书写规范空格规范【强制】 选择器 与 { 之间必须包含空格。 示例： .selector &#123;&#125; 【强制】 属性名与之后的 : 之间不允许包含空格， : 与 属性值之间必须包含空格。 示例： font-size: 12px; 选择器规范【强制】 并集选择器，每个选择器声明必须独占一行。 示例： /* good */.post,.page,.comment &#123; line-height: 1.5;&#125;/* bad */.post, .page, .comment &#123; line-height: 1.5;&#125; 【建议】 一般情况下，选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 示例： /* good */#username input &#123;&#125;.comment .avatar &#123;&#125;/* bad */.page .header .login input &#123;&#125;.comment div * &#123;&#125; 属性规范【强制】 属性定义必须另起一行。以分号结尾 示例： /* good */.selector &#123; margin: 0; padding: 0;&#125;/* bad */.selector &#123; margin: 0; padding: 0; &#125; 11. CSS补充知识11.1 元素的显示与隐藏 目的 让一个元素在页面中消失或者显示出来 场景 类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ 11.1.1 display 显示（重点） display 设置或检索对象是否及如何显示。 display: none; /*隐藏对象*/display: block; /*除了转换为块级元素之外，同时还有显示元素的意思。*/ 特点： 隐藏之后，不再保留位置。 实际开发场景： 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 11.1.2 visibility 可见性 (了解) 设置或检索是否显示对象。 visibility: visible; /*对象可视*/visibility: hidden; /*对象隐藏*/ 特点： 隐藏之后，继续保留原有位置。（停职留薪） 11.1.3 overflow 溢出(重点) 检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 属性值 描述 visible 不剪切内容也不添加滚动条（默认） hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条，包括上下和左右 auto 超出自动显示滚动条，不超出不显示滚动条 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。 11.1.4 显示与隐藏总结 属性 区别 用途 display 隐藏对象，不保留位置 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 隐藏对象，保留位置 使用较少 overflow 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 11.2 鼠标样式 cursor 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 属性值 描述 default 小白 默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 url() 图片 none 鼠标消失 help 问号 zoom-in 放大镜 zoom-out 缩小镜 11.3 轮廓线 outline 是绘制于元素周围的一条线，位于border的外围，不占空间，不影响元素布局，可起到突出元素的作用。如input输入框 outline: outline-color ||outline-style || outline-width; 四个边不能单独设置 但是我们都不关心可以设置多少，我们平时都是去掉的。 最直接的写法是 ： outline: 0; 或者 outline: none; &lt;input type="text" style="outline: 0;"/&gt; 11.4 防止拖拽文本域 resize实际开发中，我们文本域右下角是不可以拖拽： &lt;textarea style="resize: none;"&gt;&lt;/textarea&gt; 11.5 vertical-align (了解不推荐使用)行内、行内块、表单元格 垂直方向的对齐方式: vertical-align vertical-align:baseline | sub | super | top(对齐line) | text-top(对齐文字) | middle | bottom | text-bottom | &lt;percentage&gt;(参照line-height向上) | &lt;length&gt;(参照baseline向上);baseline: 当前元素的基线和父元素的基线对齐;middle: 当前元素的中线和父元素的基线加上x高度的一半对齐; 注意： vertical-align 不影响块级元素中的内容对齐，它只针对于行内元素或者行内块元素， 但是由于操作非常复杂,我们工作中基本不使用 去除图片底侧空白缝隙 原因： 图片或者表单等行内块元素，他的基线会和父级盒子的基线对齐。就是图片底侧会有一个空白缝隙。 解决方法： 给img vertical-align:middle等等。 让图片不要和基线对齐。 给img 添加 display：block; 转换为块级元素就不会存在问题了。推荐使用 文字溢出省略号显示white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 white-space: normal; /* 默认处理方式 */ nowrap; /* 强制在同一行内显示所有文本，直到文本结束或者遭遇 br 标签才换行 */ text-overflow设置或检索是否使用一个省略标记（…）标示对象内文本的溢出 text-overflow: clip; 不显示省略标记(...)，而是简单的裁切 ellipsis; 当对象内文本溢出时显示省略标记(...) 注意：一定要首先强制一行内显示，再次和 overflow 属性搭配使用 总结/* 强制一行内显示文本 */white-space: nowrap;/* 强制最多三行显示文本 */display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;/* 超出的部分隐藏 */overflow: hidden;/* 文字用省略号替代超出的部分 */text-overflow: ellipsis; 换行方式浏览器默认情况下，如果一个单词很长，导致一行中剩下的空间已经放不下时，浏览器会把这个单词挪到下一行去 word-wrap: break-word 标明是否允许浏览器在单词内进行断句，他会首先尝试挪到下一行，看看下一行的宽度够不够，不够的话就进行单词内的断句。 word-break 属性规定自动换行的处理方法 word-break: normal|break-all|keep-allnormal：使用浏览器默认的换行规则break-all：允许在单词内换行，它不会尝试把长单词挪到下一行，而是直接进行单词内的断句keep-all：只能在半角空格或连字符处换行 white-space：normal | pre | nowrap | pre-wrap | pre-line normal：连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 nowrap：和 normal 一样，连续的空白符会被合并。但换行符无效，除非手动添加换行标签pre：所有空白符都会被保留。不会自动换行，原样输出pre-wrap：保留空白符序列，但是正常地进行换行pre-line：合并空白符序列，但是保留换行符 pre 标签换行pre &#123; white-space: pre-wrap;&#125; 11.7 CSS精灵技术（sprite) 重点CSS精灵技术（也称CSS Sprites、CSS雪碧）。 CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），通过background属性精确定位到精灵图中的某个小图。 11.8 滑动门各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： &lt;li&gt; &lt;a href="#"&gt; &lt;span&gt;导航栏内容&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; css样式 * &#123; padding:0; margin:0;&#125;body&#123; background: url(images/wx.jpg) repeat-x;&#125;li &#123; padding-left: 16px; height: 33px; float: left; line-height: 33px; margin:0 10px; background: url(./images/to.png) no-repeat left ;&#125;a &#123; padding-right: 16px; height: 33px; display: inline-block; color:#fff; background: url(./images/to.png) no-repeat right ; text-decoration: none;&#125;li:hover,li:hover a &#123; background-image:url(./images/ao.png);&#125; 总结： a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 12. CSS三角形div &#123; width: 0; /*宽度高度为0*/ height: 0; line-height:0; /*照顾兼容性 低版本的浏览器，加上 font-size: 0; line-height: 0;*/ font-size: 0; border-top: 10px solid red; border-right: 10px solid green; border-bottom: 10px solid blue; border-left: 10px solid #000;&#125;]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html 基础]]></title>
    <url>%2F2018%2Fhtml%E4%B8%8Ecss%2Fhtml%2F</url>
    <content type="text"><![CDATA[HTML认识 WEB认识网页!&gt; 网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及 Flash 等 浏览器浏览器是网页显示、运行的平台，常用的浏览器有 IE、火狐（Firefox）、谷歌（Chrome）、Safari 和 Opera 等。我们平时称为五大浏览器 常见浏览器内核浏览器内核，英文叫做：Rendering Engine，中文翻译很多，排版引擎、解释引擎、渲染引擎，现在流行称为浏览器内核，负责读取网页内容，整理讯息，计算网页的显示方式并显示页面 因为浏览器太多啦， 但是现在主要流行的就是下面几个： 浏览器 内核 备注 IE Trident IE、猎豹安全、360 极速浏览器、百度浏览器 firefox Gecko 可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友 flash、神一样的对手 chrome Safari webkit 从 Safari 推出之时起，它的渲染引擎就是 Webkit，一提到 webkit，首先想到的便是 chrome，可以说，chrome 将 Webkit 内核 深入人心，殊不知，Webkit 的鼻祖其实是 Safari chrome Chromium/Blink 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用 Blink 内核。二次开发 Opera blink 现在跟随 chrome 用 blink 内核 拓展阅读： 移动端的浏览器内核主要说的是系统内置浏览器的内核 Android 手机而言，使用率最高的就是 Webkit 内核，大部分国产浏览器宣称的自己的内核，基本上也是属于 webkit 二次开发 iOS 以及 WP7 平台上，由于系统原因，系统大部分自带浏览器内核，一般是 Safari 或者 IE 内核 Trident 的 Web 标准（重点）Web 标准是由 W3C 组织和其他标准化组织制定的一系列标准的集合 W3C 万维网联盟是国际最著名的标准化组织。1994 年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献 w3c 就类似于现实世界中的联合国。 Web 标准的好处遵循 web 标准可以让不同我们写的页面更标准更统一外，还有许多优点： 让 Web 的发展前景更广阔 内容能被更广泛的设备访问 更容易被搜寻引擎搜索 降低网站流量费用 使网站更易于维护 提高页面浏览速度 Web 标准构成构成： 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 标准 说明 结构 结构用于对网页元素进行整理和分类，咱们主要学的是 HTML。 表现 表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是 CSS 行为 行为是指网页模型的定义及交互的编写，咱们主要学的是 Javascript 理想状态我们的源码： .HTML .css .js web 标准小结 web 标准有三层结构，分别是结构（html）、表现（css）和行为（javascript） 理想状态下，他们三层都是独立的， 放到不同的文件里面 深度阅读：五大主流浏览器内核的源起以及国内各大浏览器内核总结 HTML 初识超文本标记语言 HTML 指的是超文本标记语言 (Hyper Text Markup Language)是用来描述网页的一种语言。 HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) 所谓超文本，有 2 层含义： 因为它可以加入图片、声音、动画、多媒体等内容（超越文本限制） 不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本）。 HTML 骨架标签标签： 在 HTML 页面中，带有 &lt; &gt; 符号的元素被称为 HTML 标签， HTML 骨架格式（一个 html 的基本格式）： &lt;!-- HTML 标签：页面中最大的标签，我们称为根标签 --&gt;&lt;html&gt; &lt;!--文档的头部，注意在 head 标签中我们必须要设置的标签是 title --&gt; &lt;head&gt; &lt;!-- 文档的标题，让页面拥有一个属于自己的网页标题 --&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;!-- 文档的主体包含文档的所有内容，页面内容基本都是放到 body 里面的 --&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; HTML 标签名、类名、标签属性和大部分属性值统一用小写 HTML 标签分类分类： 双标签 &lt;标签名&gt; 内容 &lt;/标签名&gt; 比如 &lt;body&gt; 我是文字 &lt;/body&gt; 该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。 和开始标签相比，结束标签只是在前面加了一个关闭符“/”。 我们以后接触的基本都是双标签 单标签 &lt;标签名&gt; 比如&lt;br&gt; 里面不需要包含内容， 只有一个开始标签不需要关闭。 HTML 标签关系主要针对于双标签 的相互关系分为两种： 请大家务必熟悉记住这种标签关系，因为后面我们标签嵌套特别多，很容易弄混他们的关系。 嵌套关系 &lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; 2.并列关系 &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 书写规范： 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个 tab 键的身位（一个 tab 是 4 个或 2 个空格）。如果是并列关系，最好上下对齐。 代码开发工具（书写代码） Dreamweaver SublimeText WebStorm HBuilder VScode sublime 有非常多的优点， 最开心的就是非常轻量级，打开速度超快，后面更高的功能，后面再接触。 sublime 生成 html 骨架小技巧 双击打开软件 新建文件（ctrl+n） 保存（ctrl+s）,保存为：文件名.html （ 注意 后缀名必须是 .html ) 放大缩小代码 按住 ctrl 在 滚动鼠标滚轮 或者 ctrl+ 加号 键 和 ctrl + 减号键 生成页面骨架结构 html: 5 按下 tab 键 或者 ! 按下 tab 键 在浏览器中预览页面 右键在 浏览器中打开 文档类型&lt;!DOCTYPE&gt;用法： &lt;!DOCTYPE html&gt; 作用： 声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 就是告诉浏览器按照HTML5 规范解析页面. 团队约定： HTML 文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明 页面语言 lang&lt;html lang="en"&gt; &lt;!-- 指定html 语言种类 --&gt;&lt;/html&gt; 最常见的 2 个： en定义语言为英语 zh-CN定义语言为中文 &lt;html lang=&quot;zh-CN&quot;&gt; 指定该 html 标签内容所用的语言为中文 团队约定： 考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值 @拓展阅读： 简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理 Html 的程序对页面语言内容来做一些对应的处理或者事情。比如可以 告诉搜索引擎做精确的识别 让语法检查程序做语言识别 帮助翻译工具做识别 帮助网页阅读程序做识别等等 字符集&lt;meta charset="UTF-8" /&gt; 字符集(Character set)是多个字符的集合。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。 utf-8 是目前最常用的字符集编码方式，常用的字符集编码方式还有 gbk 和 gb2312。 gb2312 简单中文 包括 6763 个汉字 GUO BIAO BIG5 繁体中文 港澳台等用 GBK 包含全部中文字符 是 GB2312 的扩展，加入对繁体字的支持，兼容 GB2312 这句话是告诉浏览器当前 html 文档使用 UTF-8 进行的字符编码。 团队约定： 一般情况下统一使用 “UTF-8” 编码, 请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。 HTML 标签的语义化白话： 所谓标签语义化，就是指标签的含义。 根据标签的语义，在合适的地方给一个最为合理的标签，让结构更清晰。 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化（SEO） 语义是否良好： 当我们去掉 CSS 之后，网页结构依然组织有序，并且有良好的可读性。( 裸奔起来一样好看 ) 遵循的原则：先确定语义的 HTML ，再选合适的 CSS。所以，我们接下来学习 html 标签，要根据语义去记忆。 HTML 网页中任何元素的实现都要依靠 HTML 标签。 HTML 常用标签首先 HTML 和 CSS 是两种完全不同的语言，我们学的是结构，就只写 HTML 标签，认识标签就可以了。 不会再给结构标签指定样式了。 HTML 标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。 排版标签排版标签主要和 css 搭配使用，显示网页结构的标签，是网页布局最常用的标签。 标题标签 h (熟记)单词缩写： head 头部. 标题 title 文档标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML 提供了 6 个等级的标题，即 标题标签语义： 作为标题使用，并且依据重要性递减 其基本语法格式如下： &lt;h1&gt;标题文本&lt;/h1&gt;&lt;h2&gt;标题文本&lt;/h2&gt;&lt;h3&gt;标题文本&lt;/h3&gt;&lt;h4&gt;标题文本&lt;/h4&gt;&lt;h5&gt;标题文本&lt;/h5&gt;&lt;h6&gt;标题文本&lt;/h6&gt; 显示效果如下： 小结 : 加了标题的文字会变的加粗，字号也会依次变大 一行是只能放一个标题的 段落标签 p ( 熟记)单词缩写： paragraph 段落 [ˈpærəgræf] 无须记这个单词 作用语义： 可以把 HTML 文档分割为若干段落 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 &lt;p&gt;文本内容&lt;/p&gt; 是 HTML 文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签 hr(认识)单词缩写： horizontal 横线 [ˌhɔrəˈzɑntl] 同上 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： &lt;hr&gt; &lt;!-- 是单标签 --&gt; 换行标签 br (熟记)单词缩写： break 打断 ,换行 在 HTML 中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 &lt;br&gt; div 和 span 标签(重点)div span 是没有语义的 是我们网页布局主要的 2 个盒子 想必你听过 css+div div 就是 division 的缩写 分割， 分区的意思 其实有很多 div 来组合网页 span 跨度，跨距；范围 语法格式： &lt;div&gt;这是头部&lt;/div&gt;&lt;span&gt;今日价格&lt;/span&gt; 只不过他们有区别，现在我们主要记住使用方法和特点就好了 div 标签 用来布局的，一行只能放一个 div span 标签 用来布局的，一行上可以放好多个 span 后面后面讲显示模式的时候，会告诉大家 排版标签总结 标签名 定义 说明 &lt;hx&gt;&lt;/hx&gt; 标题标签 作为标题使用，并且依据重要性递减 &lt;p&gt;&lt;/p&gt; 段落标签 可以把 HTML 文档分割为若干段落 &lt;hr /&gt; 水平线标签 没啥可说的，就是一条线 &lt;br /&gt; 换行标签 &lt;div&gt;&lt;/div&gt; div 标签 用来布局的，但是现在一行只能放一个 div &lt;span&gt;&lt;/span&gt; span 标签 用来布局的，一行上可以放好多个 span 文本格式化标签(熟记)在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到 HTML 中的文本格式化标签，使文字以特殊的方式显示。 &lt;strong&gt;&lt;/strong&gt; 加粗强调 &lt;i&gt;&lt;/i&gt; 倾斜 标签属性使用 HTML 制作网页时，如果想让 HTML 标签提供更多的信息，可以使用 HTML 标签的属性加以设置。其基本语法格式如下： &lt;标签名 属性1="属性值1" 属性2="属性值2" …&gt; 内容 &lt;/标签名&gt;&lt;手机 颜色="红色" 大小="5寸"&gt; &lt;/手机&gt; 图片标签 img单词缩写： image 图像 要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签&lt;img&gt;以及和他相关的属性。（它是一个单身狗） 语法如下： &lt;img src="图像URL"&gt; 该语法中 src 属性用于指定图像文件的路径和文件名，他是 img 标签的必需属性。 src 图像的路径 alt 图像不能显示时的替换文本 title 鼠标悬停时显示的文本 width 设置图像的宽度 height 设置图像的高度 注意: 标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 采取 键值对 的格式 key=”value” 的格式 比如: &lt;!-- 正常的 --&gt;&lt;img src="cz.jpg" width="300" height="300"&gt;&lt;!-- 带有边框的 --&gt;&lt;img src="cz.jpg" width="300" height="300" border="3"&gt;&lt;!-- 有提示文本的 --&gt;&lt;img src="cz.jpg" width="300" height="300" border="3" title="这是个小蒲公英"&gt;&lt;!-- 有替换文本的 --&gt;&lt;img src="cz.jpg" width="300" height="300" border="3" alt="图片不存在"&gt; 重点掌握点： 请说出 图像标签哪个属性是必须要写的？ 请说出 图像标签中 alt 和 title 属性区别？ 链接标签单词缩写： anchor 的缩写 [ˈæŋkə(r)] 。基本解释 锚, 铁锚 的 在 HTML 中创建超链接非常简单，只需用标签把文字包括起来就好。 语法格式： &lt;a href="跳转目标" target="目标窗口的弹出方式"&gt;文本或图像&lt;/a&gt;&lt;a href="mailto:邮箱"&gt;文本或图像&lt;/a&gt; 属性 作用 href 用于指定链接目标的 url 地址，（必须属性）当为标签应用 href 属性时，它就具有了超链接的功能 target 用于指定链接页面的打开方式，其取值有_self、_blank、inner，其中_self 为默认值，__blank 为在新窗口中打开，inner 在内部打开。 注意： 在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。图片链接： &lt;a href=&quot; &quot;&gt;&lt;img src=&quot; &quot;&gt;&lt;/a&gt; style 属性：text-decoration:none 链接没有下划线 # 链接到文档顶部（什么都不写也会返回到页面顶端） 跳转某一页面某一锚点&lt;a href=&quot;index.html#锚点&quot;&gt;&lt;/a&gt; 空连接 javascript:void(null) 链接 css： &lt;link rel=&quot;stylesheet&quot; href=&quot;mycss.css&quot; /&gt; 链接 js： &lt;script type=&quot;text/javascript&quot; src=&quot;myscripts.js&quot;&gt;&lt;/script&gt; 注释标签在 HTML 中还有一种特殊的标签——注释标签。如果需要在 HTML 文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。 简单解释： 注释内容不会显示在浏览器窗口中，但是作为 HTML 文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 语法格式： &lt;!-- 注释语句 --&gt;快捷键是： ctrl + / 或者 ctrl +shift + / 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行 表格标签 table目标： 理解： 能说出表格用来做什么的 表格的基本结构组成 应用： 能够熟练写出 n 行 n 列的表格 能简单的合并单元格 表格作用： 表格现在还是较为常用的一种标签，但不是用来布局，而是显示、展示表格式数据。 因为它可以让数据显示的非常的规整，可读性非常好。 特别是后台展示数据的时候表格运用是否熟练就显得很重要，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然 div 布局也可以做到，但是总没有表格来得方便。 创建表格在 HTML 网页中，要想创建表格，就需要使用表格相关的标签。 创建表格的基本语法： &lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; table 用于定义一个表格标签。 tr 标签 用于定义表格中的行，必须嵌套在 table 标签中。 td 用于定义表格中的单元格，必须嵌套在 &lt;tr&gt;&lt;/tr&gt; 标签中。 字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。 总结： 表格的主要目的是用来显示特殊数据的 一个完整的表格有表格标签（table），行标签（tr），单元格标签（td）组成，没有列的标签 &lt;tr&gt;&lt;/tr&gt; 中只能嵌套 &lt;td&gt;&lt;/td&gt; 类的单元格 &lt;td&gt;&lt;/td&gt; 标签，他就像一个容器，可以容纳所有的元素 表格属性表格有部分属性我们不常用，这里重点记住 cellspacing 、 cellpadding。 border 设置表格的边框 border=&quot;1px dashed #ccc&quot; dashed 虚线 cellspacing 设置单元格与单元格边框之间的空白距离 cellpadding 设置单元格内容与单元格边框之间的空白距离 width 设置表格宽度 height 设置表格高度 align 设置表格水平对齐方式 （left center right） 写在 table 标签中控制表格位置 写在 tr 标签中控制表格内文本位置 表头单元格标签 th 作用： 一般表头单元格位于表格的第一行或第一列，并且文本加粗居中 语法： 只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 th 也是一个单元格 只不过和普通的 td 单元格不一样，它会让自己里面的文字居中且加粗 表格标题 caption定义和用法 &lt;table&gt; &lt;caption&gt; &lt;h2&gt; 我是表格标题 &lt;/h2&gt; &lt;/caption&gt;&lt;/table&gt; 注意： caption 元素定义表格标题，通常这个标题会被居中且显示于表格之上。 caption 标签必须紧随 table 标签之后。 这个标签只存在表格里面才有意义。 caption 没有加粗效果，一般用 h 标签实现加粗 合并单元格(难点)合并单元格 2 种方式： 跨行合并（向下合并）：rowspan=”合并单元格的个数” 跨列合并（向右合并）：colspan=”合并单元格的个数” 合并后需删除多余的单元格 总结表格 标签名 定义 说明 &lt;table&gt;&lt;/table&gt; 表格标签 就是一个四方的盒子 &lt;tr&gt;&lt;/tr&gt; 表格行标签 行标签要再 table 标签内部才有意义 &lt;td&gt;&lt;/td&gt; 单元格标签 单元格标签是个容器级元素，可以放任何东西 &lt;th&gt;&lt;/th&gt; 表头单元格标签 它还是一个单元格，但是里面的文字会居中且加粗 &lt;caption&gt;&lt;/caption&gt; 表格标题标签 表格的标题，跟着表格一起走，和表格居中对齐 clospan 和 rowspan 合并属性 用来合并单元格的 表格提供了 HTML 中定义表格式数据的方法。 表格中由行中的单元格组成。 表格中没有列元素，列的个数取决于行的单元格个数。 表格不要纠结于外观，那是 CSS 的作用。 表格的学习要求： 能手写表格结构，并且能简单合并单元格。 拓展阅读@表格划分结构（了解） 对于比较复杂的表格，表格的结构也就相对的复杂了，所以又将表格分割成三个部分：题头、正文和脚注。而这三部分分别用:thead, tbody, tfoot 来标注， 这样更好的分清表格结构 &lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。用来放标题之类的东西。&lt;thead&gt; 内部必须拥有&lt;tr&gt; 标签！ &lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。放数据本体 。 &lt;tfoot&gt;&lt;/tfoot&gt; 放表格的脚注之类。 以上标签都是放到 table 标签中。 列表标签 特点：用来布局 无序列表 ul无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： &lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 注意： 1. &lt;ul&gt;&lt;/ul&gt; 中只能嵌套&lt;li&gt;&lt;/li&gt; ，直接在&lt;ul&gt;&lt;/ul&gt; 标签中输入其他标签或者文字的做法是不被允许的2. &lt;li&gt;与&lt;/li&gt; 之间相当于一个容器，可以容纳所有元素3. HTML5 已不支持 &lt;ul&gt; 属性，用css ul &#123; list-style-type: disc; 圆点列表&#125;ul &#123; list-style-type: circle; 圆圈列表&#125;ul &#123; list-style-type: square; 正方形列表&#125;ul &#123; list-style-image: url(&apos;&apos;); 指定列表项标记的图像&#125;ul li &#123; background-image: url(/img.jpg);&#125; 有序列表 ol （了解）有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： &lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt; 所有特性基本与 ul 一致。 但是实际中比 无序列表 用的少很多。 ol start 属性 定义有序列表起始序号 ol type 属性 定义序号类型 “A” 大写字母列表 “a” 小写字母列表 “I” 罗马字母列表 “i” 小写罗马字母列表 ol css 属性 list-style-type 指定列表项标记的类型 {list-style-type:upper-roman;} 大写罗马字体 {list-style-type:lower-alpha;} 小写字母 自定义列表（理解）定义列表常用于对术语或名词进行解释和描述，自定义列表的列表项前没有任何项目符号。其基本语法如下： &lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 列表总结 标签名 定义 说明 &lt;ul&gt;&lt;/ul&gt; 无序标签 里面只能包含 li 没有顺序，我们以后布局中最常用的列表 &lt;ol&gt;&lt;/ol&gt; 有序标签 里面只能包含 li 有顺序， 使用情况较少 &lt;dl&gt;&lt;/dl&gt; 自定义列表 里面有 2 个兄弟， dt 和 dd 我们现在还没有学布局，现在只要保证 2 个点： 学会什么时候用无序列表， 学会什么时候用自定义列表 无序列表和自定义列表代码怎么写？ 具体的我们刚才看的布局，等我们学了 css 在来全面布局。 表单标签语法: &lt;form action="url地址" method="提交方式" name="表单名称"&gt; 各种表单控件&lt;/form&gt; 常用属性： 属性 属性值 作用 action url 地址 用于指定接收并处理表单数据的服务器程序的 url 地址。 method get/post 用于设置表单数据的提交方式，其取值为 get 或 post。 name 名称 用于指定表单的名称，以区分同一个页面中的多个表单。 作用 表单目的是为了收集用户信息。 在 HTML 中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域 3 个部分构成。 常用标签： &lt;form&gt; 定义供用户输入的表单&lt;input&gt; 定义输入域&lt;textarea&gt; 定义文本域 (一个多行的输入控件)&lt;label&gt; 定义了 input 元素的标签，一般为输入标题&lt;fieldset&gt; 定义了一组相关的表单元素，并使用外框包含起来&lt;legend&gt; 定义了 fieldset 元素的标题select&gt; 定义了下拉选项列表&lt;optgroup&gt; 定义选项组&lt;option&gt; 定义下拉列表中的选项 selected 预选&lt;button&gt; 定义一个点击按钮&lt;datalist&gt; 指定一个预先定义的输入控件选项列表&lt;output&gt; 定义一个计算结果 注意: 每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form 表单域。 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域：他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的 url 地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input 标签 语法： &lt;input type="属性值" value="你好"&gt; type 属性设置不同的属性值用来指定不同的控件类型 除了 type 属性还有别的属性 type 属性 text 单行文本输入框 password 密码输入框 radio 单选按钮 checkbox 复选框 button 普通按钮 submit 提交按钮 reset 重置按钮 image 图片按钮 ，添加 src 属性引入图片 file 上传文件 value 属性值&lt;!-- input 框在用户未输入时的默认值 --&gt;用户名:&lt;input type="text" name="username" value="请输入用户名"&gt; input placeholder 属性与 value 属性区别 placeholder 属性提供一种提示，描述输入域所期待的值，提示会在输入字段为空时显示，并会在字段获得焦点时消失。属性适用于以下类型的 input 标签：text、search、url、telephone、email 以及 password value 属性为 input 元素设定值，对于不同的输入类型，value 属性的用法也不同 type=&quot;button&quot;, &quot;reset&quot;, &quot;submit&quot; - 定义按钮上的显示的文本 type=&quot;text&quot;, &quot;password&quot;, &quot;hidden&quot; - 定义输入字段的初始值 type=&quot;checkbox&quot;, &quot;radio&quot;, &quot;image&quot; - 定义与输入相关联的值 &lt;input type=&quot;checkbox&quot;&gt; 和 &lt;input type=&quot;radio&quot;&gt; 中必须设置 value 属性。value 属性无法与 &lt;input type=&quot;file&quot;&gt; 一同使用。 name 属性用户名:&lt;input type="text" name="username"&gt; name 表单的名字， 这样，后台可以通过这个 name 属性找到这个表单项。 页面中的表单项很多，name 主要作用就是用于区别不同的表单项。 name 属性后面的值，是我们自己定义的。 radio 如果是一组，我们必须给他们命名相同的名字 name ，这样就可以多个选其中的一个啦 &lt;input type="radio" name="sex" /&gt; 男&lt;input type="radio" name="sex" /&gt; 女 checked 属性 表示默认选中状态。 较常见于 单选按钮和复选按钮。 性 别:&lt;input type="radio" name="sex" value="男" checked="checked" /&gt;男&lt;input type="radio" name="sex" value="女" /&gt;女 上面这个，表示就默认选中了 男 这个单选按钮 label 标签(理解)作用： 用于绑定一个表单元素, 当点击 label 标签的时候, 被绑定的表单元素就会获得输入焦点 如何绑定元素呢？ 第一种用法就是用 label 直接包括 input 表单 &lt;label&gt; 用户名： &lt;input type="radio" name="usename" value="请输入用户名"&gt;&lt;/label&gt; 适合单个表单选择 第二种用法 for 属性规定 label 与哪个表单元素绑定 &lt;label for="sex"&gt;男&lt;/label&gt;&lt;input type="radio" name="sex" id="sex"&gt; textarea 控件(文本域) 语法： &lt;textarea&gt; 文本内容&lt;/textarea&gt; 作用： 通过 textarea 控件可以轻松地创建多行文本输入框 cols=”每行中的字符数” rows=”显示的行数” 我们实际开发不用 文本框和文本域区别 表单 名称 区别 默认值显示 用于场景 input type=”text” 文本框 只能显示一行文本 单标签，通过 value 显示默认值 用户名、昵称、密码等 textarea 文本域 可以显示多行文本 双标签，默认值写到标签中间 留言板 select 标签语法： &lt;select multiple="multiple"&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option selected&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt; 中至少包含一对 option 在 option 中定义 selected =” selected “时，当前项即为默认选中项，不写默认第一项。 multiple 属性可以选多个 HTML5 新的表单属性HTML5 的 form 和 input 标签添加了几个新属性. form 新属性：autocomplete novalidate input 新属性：autocompleteautofocusformormactionformenctypeformmethodformnovalidateormtargetheight 与 widthlistmin 与 maxmultiplepattern (regexp)placeholderrequiredstep H5 新增标签：六大结构标签&lt;header&gt;网站的头部&lt;/header&gt;&lt;footer&gt;网站的底部&lt;/footer&gt;&lt;nav&gt;导航&lt;/nav&gt;&lt;aside&gt;侧边栏&lt;/aside&gt;&lt;article&gt;文章页&lt;/article&gt;&lt;section&gt;区块&lt;/section&gt; 路径(重点、难点)实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们 目录文件夹： 就是普通文件夹，里面只不过存放了我们做页面所需要的 相关素材，比如 html 文件， 图片 等等 页面中的图片会非常多， 通常我们再新建一个文件夹专门用于存放图像文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： 相对路径和绝对路径 相对路径以引用文件的网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径 同一级路径 只需输入图像文件的名称即可 下一级路径 / 上一级路径 ../ 相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的，而 我们所说的 上一级 下一级 同一级 简单说，就是 图片 位于 HTML 页面的位置 绝对路径绝对路径以 Web 站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。 “D:\web\img\logo.gif”，或完整的网络地址，例如 “http://www.itcast.cn/images/logo.gif&quot; 注意： 绝对路径用的较少，我们理解下就可以了 锚点定位通过创建锚点链接，用户能够快速定位到目标内容 创建锚点链接分为两步： 1. 使用相应的id名标注跳转目标的位置。 (找目标)&lt;h3 id=&quot;two&quot;&gt;第2集&lt;/h3&gt;2. 使用 &lt;a href=&quot;#id名&quot;&gt;链接文本&lt;/a&gt; 创建链接文本（被点击的）&lt;a href=&quot;#two&quot;&gt;&lt;/a&gt; 延伸base 标签描述了基本的链接地址/链接目标，该标签作为 HTML 文档中所有的链接标签的默认链接(包括 &lt;a&gt;、&lt;img&gt;、&lt;link&gt;、&lt;form&gt;标签中的 URL) 语法： &lt;head&gt; &lt;base href="" target="_blank"&gt;&lt;/head&gt; 总结： base 可以设置整体链接的打开状态 base 写到 &lt;head&gt; &lt;/head&gt; 之间 把所有的连接 都默认添加 target=&quot;_blank&quot; &lt;pre&gt; 标签可定义预格式化的文本。 被包围在 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。 &lt;pre&gt; 此例演示如何使用 pre 标签 对空行和 空格 进行控制&lt;/pre&gt; 所谓的预格式化文本就是 ，按照我们预先写好的文字格式来显示页面， 保留空格和换行等。 有了这个标签，里面的文字，会按照我们书写的模式显示，不需要段落和换行标签了。但是，比较少用，因为不好整体控制。 meta 标签 &lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词 每 30 秒中刷新当前页面: &lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt; 特殊字符 （理解） 显示结果 描述 实体名称 实体编号 空格 &amp;nbsp; &amp;#160; &lt; 小于号 &amp;lt; &amp;#60; &gt; 大于号 &amp;gt; &amp;#62; &amp; 和号 &amp;amp; &amp;#38; &quot; 引号 &amp;quot; &amp;#34; &#39; 撇号 &amp;apos;(IE 不支持) &amp;#39; ￠ 分 &amp;cent; &amp;#162; £ 镑 &amp;pound; &amp;#163; ¥ 人民币 &amp;yen; &amp;#165; € 欧元 &amp;euro; &amp;#8364; § 小节 &amp;sect; &amp;#167; © 版权 &amp;copy; &amp;#169; ® 注册商标 &amp;reg; &amp;#174; ™ 商标 &amp;trade; &amp;#8482; × 乘号 &amp;times; &amp;#215; ÷ 除号 &amp;divide; &amp;#247; 总结： 是以运算符&amp;开头,以分号运算符;结尾。 他们不是标签，而是符号。 HTML 中不能使用小于号 “”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 html5 发展之路 什么是 XHTMLXHTML 是更严格更纯净的 HTML 代码。 XHTML 指可扩展超文本标签语言（EXtensible HyperText Markup Language）。 XHTML 的目标是取代 HTML。 XHTML 与 HTML 4.01 几乎是相同的。 XHTML 是更严格更纯净的 HTML 版本。 XHTML 是作为一种 XML 应用被重新定义的 HTML。 XHTML 是一个 W3C 标准。 查文档经常查阅文档是一个非常好的学习习惯。 W3C : http://www.w3school.com.cn/ MDN: https://developer.mozilla.org/zh-CN/]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>html&amp;css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github 搭建博客教程及进阶设置]]></title>
    <url>%2F2017%2Ftool%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 文档 配置环境安装 Node作用：用来生成静态页面的 到Node.js 官网下载相应平台的最新版本，一路安装即可。 安装 Git作用：把本地的 hexo 内容提交到 github 上去。Git 官网下载 申请 GitHub作用：是用来做博客的远程创库、域名、服务器之类的。 github 账号注册，github 配置 安装 HEXO执行如下命令安装 hexo： npm install hexo-cli -g 初始化命令： hexo init 文件夹的目录如下： ├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml 网站配置文件 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 其中，description 主要用于 SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author 参数用于主题显示文章的作者 生成静态页面 将 md 文件放到 source/_posts 文件夹下执行命令： hexo g/generate # 生成静态页面至 public 目录# -w/--watch 参数监视文件变动 安装本地服务 npm install hexo-server --save 启动本地服务，进行文章预览调试，命令： hexo server # 开启预览访问端口(默认端口4000，'ctrl + c'关闭server)# --debug 参数开启调试模式 -p/--port 参数重设端口 浏览器输入http://localhost:4000 预览 自定义 IP 服务器默认运行在 0.0.0.0，您可以覆盖默认的 IP 设置，如下： hexo server -i 192.168.1.1 配置 Github建立 Repository建立与你用户名对应的仓库，仓库名必须为your_user_name.github.io，固定写法 建立关联 打开站点配置文件_config.yml 翻到最下面，改成我这样子的，注意 : 后面要有空格 deploy: type: git repository: ssh://git@github.com/cuilongjin/cuilongjin.github.io.git branch: master 为了便于以后管理，可以创建备份分支，$ git checkout -b hexo创建 hexo 分支用于备份原始文件 所有的修改添加均在此分支下进行，并 push 到远程 hexo 分支 执行如下命令 npm install hexo-deployer-git --save 然后，执行配置命令： hexo deploy # 将 .deploy 目录部署到 GitHub 然后再浏览器中输入http://your_user_name.github.io/就行了 部署步骤每次部署的步骤，可按以下三步来进行。 hexo cleanhexo generatehexo deploy 写作执行下列命令来创建一篇新文章 hexo new [layout] &lt;title&gt; 在文章中插入指定大小的图片 &#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; Bootstrap Callout 使用方式 &#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default、primary、success、info、warning、danger 主题NexT v5.1.x NexT v6.0.0 next 主题个性化配置 下载 NexT 主题cd your-hexo-sitegit submodule add git@github.com:cuilongjin/hexo-theme-next.git themes/next 启用主题打开站点配置文件 _config.yml ， 找到 theme 字段，并将其值更改为 next NexT 主题的目录架构 ├── .github #github信息├── languages #多语言| ├── _en.yml #默认语言| └── zh-CN.yml #简体中文| └── zh-TW.yml #繁体中文├── layout #布局，根目录下的*.swig文件是对主页，分页，存档等的控制| ├── _custom #可以自定义的模板，覆盖原有模板| | ├── head.swig #文首样式| | ├── header.swig #头部样式| | ├── sidebar.swig #侧边栏样式| ├── _macro #可以自定义的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl自定义局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── js #javascript源代码| └── lib #引用库├── _config.yml #主题配置文件└── README.md #说明文件 在菜单上添加页面以添加 about 页面为例，在 hexo 目录下执行： hexo new page "about" 然后你会发现 source 里面多了个目录 about，里面有个 index.md。其实你也可以手动建立。 然后在主题配置文件 _config.yml 中找到 menu 一项，添加一行 About: /about 设置「阅读全文」在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!-- more --&gt; 手动进行截断，Hexo 提供的方式 推荐 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在主题配置文件 _config.yml ，启用auto_excerpt auto_excerpt: enable: truelength: 150 默认截取的长度为 150 字符，可以根据需要自行设定 建议使用 &lt;!-- more --&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。 添加 RSS在博客根目录下执行： npm install --save hexo-generator-feed 打开站点配置文件 _config.yml ，添加： # Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 打开主题配置文件 _config.yml ，添加： rss: /atom.yml 添加本地搜索安装 hexo-generator-search，执行以下命令： npm install hexo-generator-search --save 打开主题配置文件 _config.yml ，添加： local_search: enable: true 自定义样式themes\next\source\css\_custom\custom.styl 文件中添加自定义样式 修改头像样式.site-author-image &#123; border-radius: 50%;&#125; 更改主题背景// 背景图片相关body &#123; background-image: url(../images/background.jpg); height: 100%; width: 100%; background-repeat: repeat-x; background-attachment: fixed; background-size: cover;&#125; 图片放入 themes\next\source\images 中即可 改变背景色和透明度添加： .main-inner &#123; background: #fff; opacity: 0.9;&#125;// 文章内容的透明度.content-wrap &#123; opacity: 0.85;&#125;// 侧边框的透明度设置.sidebar &#123; opacity: 0.85;&#125;// 菜单栏的透明度设置.header-inner &#123; background: rgba(255, 255, 255, 0.85);&#125;// 搜索框的透明度设置.popup &#123; opacity: 0.9;&#125; 修改 local-search 加载图标在blog/themes/next/layout/_third-party/search/localsearch.swig中寻找： &lt;i class=&quot;fa fa-spinner fa-pulse fa-5x fa-fw&quot;&gt;&lt;/i&gt; 将其修改为： &lt;i class=&quot;fa fa-circle-o-notch fa-spin fa-5x fa-fw margin-bottom&quot;&gt;&lt;/i&gt; 修改文章内链接文本样式// 文章内链接文本样式.post-body p a &#123; color: #0593d3; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: 1px solid #fc6423; &#125;&#125; 自定义代码块样式code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight,pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125; 修改文章底部的那个带 # 号的标签编辑主题配置文件 _config.yml ，修改 tag_icon: tag 在每篇文章末尾统一添加”本文结束”标记打开 \themes\next\layout\_macro\post.swig 文件，在 post-body 之后， post-footer 之前添加如下代码： &lt;div&gt; &#123;% if not is_index and theme.passage_end_tag.enable %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;margin-top: 20px;"&gt;-------------本文结束-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件 _config.yml ，在末尾添加： # 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 添加顶部加载条cd themes/nextgit clone https://github.com/theme-next/theme-next-pace source/lib/pace 修改主题配置文件 _config.yml 将 pace: false 改为 pace: true 自定义颜色 /* 自定义进度条颜色 */.pace &#123; .pace-progress &#123; background: #1e92fb; // 进度条颜色 height: 3px; &#125; .pace-progress-inner &#123; box-shadow: 0 0 10px #1e92fb, 0 0 5px #1e92fb; // 阴影颜色 &#125; .pace-activity &#123; border-top-color: #1e92fb; // 上边框颜色 border-left-color: #1e92fb; // 左边框颜色 &#125;&#125; 添加评论系统Gitmen 评论GitHub 授权接入Gitment 是使用的 GitHub Issues 作为评论系统，在接入 Gitment 前，需要获得 GitHub 的授权，获得相应的客户端 id 和客户端私钥，以备站点使用。 OAuth application 注册接入 添加 Gitment 如果您使用的是 Hexo 框架的 Next 主题博客，想要添加 Gitment 的时候，记得将自己的 Next 主 题更新到最新版。 打开主题配置文件 _config.yml 修改如下： gitment: enable: true github_user: # MUST HAVE, Your Github ID github_repo: # MUST HAVE, The repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment 其中 lazy 的含义，是否懒加载相应评论框，如果为 true，文章底部评论是收起状态，提示显示 Gitment 评论按钮，单击展开评论框 LiveRe 评论注册LiveRe 打开主题配置文件 _config.yml 添加： # Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid Hypercomments 超级评论注册Hypercomments 打开主题配置文件 _config.yml 添加： # Hypercomments# hypercomments_id: your id valine 评论系统添加分享cd themes/nextgit clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton 打开主题配置文件 _config.yml ，加入： needmoreshare2: enable: true postbottom: enable: true float: enable: true SEO 优化添加站点地图（sitemap.xml）npm install hexo-generator-sitemap hexo-generator-baidu-sitemapnpm install hexo-generator-baidu-sitemap 在站点配置文件中添加如下代码: sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 配置成功后，会生成sitemap.xml和baidusitemap.xml，前者适合提交给谷歌搜素引擎，后者适合提交百度搜索引擎。 提交博客地址到搜索引擎如果你不主动提交你的博客地址给各大搜索引擎，那么即使你站内优化做得再好，搜索引擎根本都不知道你的博客的存在。 所以别忘记在你创建完博客的那一刻就去提交。如果你此刻还没有提交，现在就去吧。 Google https://www.google.com/webmasters/tools/submit-url 必应 https://www.bing.com/toolbox/webmaster/ Baidu https://ziyuan.baidu.com/linksubmit/index Google 站长工具 和 Google AnalysisGA 是用来统计访问信息的，站长工具是用来查看网站的查询和搜索数据 注册Google Analysis 编辑主题配置文件 _config.yml ， 修改字段 google_analytics， 值设置成你的 Google 跟踪 ID。跟踪 ID 通常是以 UA- 开头 Google 站长工具 提交 sitemap 添加蜘蛛协议 robots.txtrobots.txt，代码如下 # hexo robots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://cuilongjin.top/sitemap.xmlSitemap: https://cuilongjin.top/baidusitemap.xml 把robots.txt放在你的hexo站点的source文件下即可 给出站链接添加 nofollow标签设置忽略文件渲染打开站点配置文件 _config.yml ，修改 skip_render 参数的值 # 路径是相对source目录的# 不对文件进行渲染，保持文件原有内容skip_render: - "*.html" - "demo/**" // 排除 demo 整个目录 - README.md 再次使用 hexo d 命令部署博客的时候就不会在渲染这些文件了 添加 google adsense注册账号 https://www.google.com/adsense/start/ 获取代码 &lt;script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"&gt;&lt;/script&gt;&lt;script&gt; ;(adsbygoogle = window.adsbygoogle || []).push(&#123; google_ad_client: 'ca-pub-9068539038073295', enable_page_level_ads: true &#125;)&lt;/script&gt; 将网站关联到 AdSense 在主题配置文件中添加广告控制开关 # 添加 Google AdSensegoogle_adsense: true 主题文件夹下找到 /layout/_partial/head.swig 里添加代码： &#123;% if theme.google_adsense %&#125; &lt;script async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt; &lt;script&gt; (adsbygoogle = window.adsbygoogle || []).push(&#123; google_ad_client: &quot;ca-pub-9068539038073295&quot;, enable_page_level_ads: true &#125;) &lt;/script&gt;&#123;% endif %&#125; 重新部署网站 等待审核，审核成功会向你发送邮件 文章加密访问https://github.com/MikeCoder/hexo-blog-encrypt 安装 npm install hexo-blog-encrypt 在 站点配置文件 中启用该插件: # 文章加密 https://github.com/MikeCoder/hexo-blog-encryptencrypt: enable: true # 默认的提示和摘要内容 default_abstract: 这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你确实想看，请与我联系 default_message: 输入密码，查看文章 在需要加密的文章的头部添加上对应的字段，如 password, abstract, message password: 该博客加密使用的密码abstract: 该博客的摘要，会显示在博客的列表页message: 博客查看时，密码输入框上面的描述性文字 存在问题 字数统计功能字数会显得比实际值大 加密文章内代码复制失效 添加评分系统https://widgetpack.com 注册 获得 id，即为左上角的数字： 主题配置文件中修改 rating: enable: true id: 在侧栏找到 rating 的 setting：推荐将投票方式改为 ip 投票，因为这个平台提供的账号投票基本不面向国内。 添加萌萌哒看板娘https://blog.bill.moe/hexo-live2d-poster-girl/ 添加 Hitokoto 一言功能https://hitokoto.cn/api 安装 Hexo Adminnpm install hexo-adminhexo server 然后打开 localhost:4000/admin/ 设置登陆 admin 的用户名和密码，打开http://localhost:4000/admin/#/auth-setup 可以直接输入你想要的用户名和密码，把生成的文本复制到 hexo 根目录配置文件中_config.yml # hexo-admin authentificationadmin: username: username password_hash: $2a$10$L.XAIqIWgTc5S1zpvV3MEu7/rH34p4Is/nq824smv8EZ3lIPCp1su secret: my super secret phrase 主题更新命令： cd themes/nextgit submodule update 推荐你使用 Hexo 数据文件特性进行主题配置 目前，通过 pull 或下载新的 release 版本来更新 NexT 主题的体验并不平滑。当用户使用 git pull 更新 NexT 主题时经常需要解决冲突问题，而在手动下载 release 版本时也经常需要手动合并配置 现在来说，NexT 推荐用户存储部分配置在站点的 _config.yml 中，而另一部分在主题的 _config.yml 中。这一方式固然可用，但也有一些缺点 配置项被分裂为两部分 用户难以弄清何处存放配置选项 为了解决这一问题，NexT 将利用 Hexo 的数据文件特性。因为数据文件是在 Hexo 3 中被引入，所以你需要更新至 Hexo 3.0 以后的版本来使用这一特性。 如果你仍然希望使用 Hexo 2.x，你依旧可以按老的方式进行配置。NexT 仍然兼容 Hexo 2.x（但可能会出现错误）。 带来的好处 使用这一特性，你现在可以将你的全部配置置于同一位置 (source/_data/next.yml），并且不需要修改 next/_config.yml。如果在新的 release 中出现了任何新的选项，那么你只需要从 next/_config.yml 中将他们复制到 source/_data/next.yml 中并设置它们的值为你想要的选项。 如何使用这一特性 请确认你的 Hexo 版本为 3.0 或更高。 在你站点的 hexo/source/_data 目录创建一个 next.yml 文件（如果 _data 目录不存在，请创建之）。 复制你站点的 _config.yml 和主题的 _config.yml 中的 NexT 配置项到 hexo/source/_data/next.yml 中。 使用 --config source/_data/next.yml 参数来启动服务器，生成或部署。 例如：hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml 。 从 NexT v5.1.x 更新https://github.com/theme-next/hexo-theme-next/blob/master/docs/cn/UPDATE-FROM-5.1.X.md]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
</search>
