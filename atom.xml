<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>稻草人</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.clj.me/"/>
  <updated>2019-06-18T11:53:00.000Z</updated>
  <id>http://blog.clj.me/</id>
  
  <author>
    <name>稻草人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动端调试</title>
    <link href="http://blog.clj.me/2019/tool/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    <id>http://blog.clj.me/2019/tool/移动端调试/</id>
    <published>2019-06-18T11:52:00.000Z</published>
    <updated>2019-06-18T11:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些调试工具"><a href="#一些调试工具" class="headerlink" title="一些调试工具"></a>一些调试工具</h2><ol><li><p>直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法 100% 还原手机的真实情况</p></li><li><p>chrome <a href="https://developer.chrome.com/devtools/docs/remote-debugging" target="_blank" rel="noopener">远程调试功能</a></p><p>需要连接数据线，其次是设置比较繁琐，而且还限制了 android 手机。对于 IOS 的调试则可能要使用 Safari 的另一套工具</p></li><li><p><a href="https://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener">weinre</a>：远程调试，在 PC 上生成一个像 chrome 开发工具一样的调试器，需要手动引入 js</p></li><li><p>Eruda、vConsole：在移动端页面上生成一个调试器，调试信息会挡住操作元素，查看复杂数据结构的 log 不方便，需要手动引入 js</p></li><li><p>安装各种虚拟机sdk，在电脑上进行手机调试。能比较真实模拟手机，但是安装繁琐，操作不方便，无法模拟真实的手势操作</p></li></ol><h2 id="Eruda"><a href="#Eruda" class="headerlink" title="Eruda"></a>Eruda</h2><p><a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">https://github.com/liriliri/eruda</a></p><p>Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。</p><ol><li>按钮拖拽，面板透明度大小设置。</li><li>Console面板：捕获Console日志，支持log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括%c自定义样式输出；支持按日志类型及正则表达式过滤；支持快捷命令加载underscore、jQuery库；支持JavaScript脚本执行。</li><li>Elements面板：查看标签内容及属性；查看应用在Dom上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看Dom上绑定的各类事件。</li><li>Network面板：捕获请求，查看发送数据、返回头、返回内容等信息。</li><li>Resources面板：查看并清除localStorage、sessionStorage及cookie；查看页面加载脚本及样式文件；查看页面加载图片。</li><li>Sources面板：查看页面源码；格式化html，css，js代码及json数据。</li><li>Info面板：输出URL及User Agent；支持自定义输出内容。</li><li>Snippets面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。</li></ol><p>使用</p><p>通过 CDN 使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/eruda/1.5.2/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 npm 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eruda --save</span><br></pre></td></tr></table></figure><p>在页面中加载脚本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/eruda/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Js文件对于移动端来说略重（gzip后大概100kb）。建议通过url参数来控制是否加载调试器，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> src = <span class="string">'node_modules/eruda/eruda.min.js'</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/eruda=true/</span>.test(<span class="built_in">window</span>.location) &amp;&amp; localStorage.getItem(<span class="string">'active-eruda'</span>) != <span class="string">'true'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt src="'</span> + src + <span class="string">'"&gt;&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt&gt;eruda.init();&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>初始化时可以传入配置：</p><ul><li>container：用于插件初始化的 Dom 元素，如果不设置，默认创建 div 作为容器直接置于 html 根结点下面</li><li>tool：指定要初始化哪些面板，默认加载所有</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el)</span><br><span class="line"></span><br><span class="line">eruda.init(&#123;</span><br><span class="line">  container: el,</span><br><span class="line">  tool: [<span class="string">'console'</span>, <span class="string">'elements'</span>],</span><br><span class="line">  useShadowDom: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vConsole"><a href="#vConsole" class="headerlink" title="vConsole"></a>vConsole</h2><p><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">https://github.com/Tencent/vConsole</a></p><p>一个轻量、可拓展、针对手机网页的前端开发者调试面板。</p><p>特性</p><ul><li>查看 console 日志</li><li>查看网络请求</li><li>查看页面 element 结构</li><li>查看 Cookies、localStorage 和 SessionStorage</li><li>手动执行 JS 命令行</li><li>自定义插件</li></ul><p><a href="https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md" target="_blank" rel="noopener">使用说明</a></p><p>下载 vConsole 的<a href="https://github.com/Tencent/vConsole/releases/latest" target="_blank" rel="noopener">最新版本</a>。（不要直接下载 dev 分支下的 <code>dist/vconsole.min.js</code>）</p><p>或者使用 npm 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure><p>引入 <code>dist/vconsole.min.js</code> 到项目中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/vconsole.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vConsole = <span class="keyword">new</span> VConsole()</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'Hello world'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="weinre"><a href="#weinre" class="headerlink" title="weinre"></a>weinre</h2><p><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html" target="_blank" rel="noopener">http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html</a></p><ol><li>Element： 查看/修改dom，查看/修改 dom CSS</li><li>Resources：查看/修改 localStorage, sessionStorage</li><li>Network：查看网络请求</li><li>Timeline：</li><li>Console：查看控制台输出</li></ol><p>不能做 JS 调试</p><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install -g weinre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 weinre 服务</span></span><br><span class="line">weinre --boundHost 192.168.3.44 --httpPort 8888</span><br><span class="line"></span><br><span class="line">启动调试客户端</span><br><span class="line">在浏览器中打开 <span class="string">'http://192.168.3.44:8888'</span> 即可启动调试客户端</span><br><span class="line"></span><br><span class="line">在需要调试的页面中添加如下</span><br><span class="line">&lt;script src=<span class="string">"http://192.168.3.44:8888/target/target-script-min.js#anonymous"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="spy-debugger"><a href="#spy-debugger" class="headerlink" title="spy-debugger"></a>spy-debugger</h2><p><a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="noopener">https://github.com/wuchangming/spy-debugger</a></p><p>微信调试，各种 WebView 样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP/HTTPS，无需USB连接设备</p><p>spy-debugger 集成了<code>weinre</code>，简化了<code>weinre</code>需要给每个调试的页面添加 js 代码。原理是拦截所有 html 页面请求注入<code>weinre</code>所需要的 js 代码。让页面调试更加方便</p><p>1、页面调试＋抓包<br>2、操作简单，无需USB连接设备<br>3、<strong>支持HTTPS</strong><br>4、<code>spy-debugger</code>内部集成了<a href="http://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener"><code>weinre</code></a>、<a href="https://github.com/wuchangming/node-mitmproxy" target="_blank" rel="noopener"><code>node-mitmproxy</code></a>、<a href="https://github.com/alibaba/anyproxy" target="_blank" rel="noopener"><code>AnyProxy</code></a>。5、自动忽略原生 App 发起的 https 请求，只拦截 webview 发起的 https 请求。对使用了 SSL pinning 技术的原生App 不造成任何影响。<br>6、可以配合其它代理工具一起使用(默认使用AnyProxy) <a href="https://github.com/wuchangming/spy-debugger#%E8%AE%BE%E7%BD%AE%E5%A4%96%E9%83%A8%E4%BB%A3%E7%90%86%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8anyproxy" target="_blank" rel="noopener">(设置外部代理)</a></p><p>基本使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install spy-debugger -g</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">spy-debugger</span><br><span class="line"><span class="comment">#设置手机的HTTP代理</span></span><br><span class="line">代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)</span><br><span class="line"><span class="comment"># 手机安装证书</span></span><br><span class="line">手机浏览器访问 http://s.xxx</span><br><span class="line">设置-&gt;通用-&gt;描述文件与设备管理-&gt;找到node-mitmproxy CA（安装）</span><br><span class="line">设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到node-mitmproxy CA（打开）</span><br></pre></td></tr></table></figure><p>自定义选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义端口</span></span><br><span class="line">spy-debugger -p 8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置页面内容为可编辑模式</span></span><br><span class="line">spy-debugger -w <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否只拦截浏览器发起的https请求(默认： true)</span></span><br><span class="line">spy-debugger -b <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许weinre监控iframe加载的页面(默认： false)</span></span><br><span class="line">spy-debugger -i <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 HTTP 缓存(默认： false)</span></span><br><span class="line">spy-debugger -c <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="m-console"><a href="#m-console" class="headerlink" title="m-console"></a>m-console</h2><p><a href="https://github.com/fwon/m-console" target="_blank" rel="noopener">https://github.com/fwon/m-console</a></p><p>手机远程调试工具，手机通过代理连接上PC后，可以在PC版浏览器打印log和错误日志</p><p>需要手动给每个调试的页面添加 js 代码</p><h2 id="DebugGap-VIDE"><a href="#DebugGap-VIDE" class="headerlink" title="DebugGap-VIDE"></a>DebugGap-VIDE</h2><p><a href="https://www.debuggap.com/debug_webview.html" target="_blank" rel="noopener">https://www.debuggap.com/debug_webview.html</a></p><h2 id="Mobile-Debug"><a href="#Mobile-Debug" class="headerlink" title="Mobile Debug"></a>Mobile Debug</h2><p><a href="https://www.mobiledebug.com/" target="_blank" rel="noopener">https://www.mobiledebug.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些调试工具&quot;&gt;&lt;a href=&quot;#一些调试工具&quot; class=&quot;headerlink&quot; title=&quot;一些调试工具&quot;&gt;&lt;/a&gt;一些调试工具&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法
      
    
    </summary>
    
      <category term="工具" scheme="http://blog.clj.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="移动端调试" scheme="http://blog.clj.me/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://blog.clj.me/2019/tool/docker/"/>
    <id>http://blog.clj.me/2019/tool/docker/</id>
    <published>2019-06-18T11:52:00.000Z</published>
    <updated>2019-06-18T11:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-dcoker"><a href="#安装-dcoker" class="headerlink" title="安装 dcoker"></a>安装 dcoker</h2><p>安装</p><p>ubuntu 16.04 (LTS)安装docker</p><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p>镜像仓库方式安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置镜像仓库</span></span><br><span class="line"><span class="comment"># 更新 apt 软件包索引：</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># 安装软件包，以允许 apt 通过 HTTPS 使用镜像仓库：</span></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">     apt-transport-https \</span><br><span class="line">     ca-certificates \</span><br><span class="line">     curl \</span><br><span class="line">     software-properties-common</span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥：</span></span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 验证密钥指纹是否为 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。</span></span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p>设置 stable 镜像仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ amd64：</span><br><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure><p>安装 DOCKER CE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><p>验证是否正确安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令将下载一个测试镜像并在容器中运行它。容器运行时，它将输出一条参考消息并退出。</p><p>升级 DOCKER CE</p><p>如需升级 Docker CE，首先运行 <code>sudo apt-get update</code>，然后按照顺序执行操作，并选择您要安装的新版本</p><p>卸载 Docker CE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure><p>主机上的镜像、容器、存储卷、或定制配置文件不会自动删除。如需删除所有镜像、容器和存储卷，请运行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><p>将 Docker 配置为在启动时启动</p><h2 id="使用-docker-安装-ubuntu-镜像"><a href="#使用-docker-安装-ubuntu-镜像" class="headerlink" title="使用 docker 安装 ubuntu 镜像"></a>使用 docker 安装 ubuntu 镜像</h2><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">docker search ubuntu <span class="comment"># 查找 Ubuntu 镜像</span></span><br><span class="line">docker pull ubuntu <span class="comment"># 安装 Ubuntu 镜像</span></span><br><span class="line">docker images <span class="comment">#查看 docker 镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并运行 docker 容器</span></span><br><span class="line">docker run -it -d --name ubuntu_test -p 8088:80 ubuntu</span><br><span class="line"><span class="comment"># --name 自定义容器名，-p 指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回 id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 docker 容器  启动一个bash交互终端</span></span><br><span class="line">docker run -it 容器名:容器tag /bin/bash</span><br><span class="line"></span><br><span class="line">docker start container_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有启动的容器(查看所有容器加 -a)</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 id 查看容器信息</span></span><br><span class="line">docker inspect id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker(或者把容器id改为容器名，也可以进入)</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id或容器名 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi 删除镜像</span><br></pre></td></tr></table></figure><p>备份镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 制作 docker 镜像  1.0 为版本号</span></span><br><span class="line">docker commit 98 ubuntu_test:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像是否创建</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存镜像到docker账号中</span></span><br><span class="line"><span class="comment"># 登录进Docker注册中心</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送镜像</span></span><br><span class="line">docker tag a25ddfec4d2a arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line">docker push arunpyasi/container-backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包镜像并查看</span></span><br><span class="line">docker save -o ubuntu_test.tar ubuntu_test:1.0</span><br></pre></td></tr></table></figure><p>恢复容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从docker账号中拉取</span></span><br><span class="line">docker pull arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地</span></span><br><span class="line">docker load -i ~/container-backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用加载的镜像去运行Docker容器</span></span><br><span class="line">docker run -d -p 80:80 container-backup</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-dcoker&quot;&gt;&lt;a href=&quot;#安装-dcoker&quot; class=&quot;headerlink&quot; title=&quot;安装 dcoker&quot;&gt;&lt;/a&gt;安装 dcoker&lt;/h2&gt;&lt;p&gt;安装&lt;/p&gt;
&lt;p&gt;ubuntu 16.04 (LTS)安装docker&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="工具" scheme="http://blog.clj.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="http://blog.clj.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://blog.clj.me/2019/other/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.clj.me/2019/other/面试题/</id>
    <published>2019-03-21T10:30:00.000Z</published>
    <updated>2019-03-26T02:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><h3 id="http-相关"><a href="#http-相关" class="headerlink" title="http 相关"></a>http 相关</h3><h3 id="HTML-css-相关"><a href="#HTML-css-相关" class="headerlink" title="HTML css 相关"></a>HTML css 相关</h3><h3 id="js-相关"><a href="#js-相关" class="headerlink" title="js 相关"></a>js 相关</h3><h3 id="jquery-相关"><a href="#jquery-相关" class="headerlink" title="jquery 相关"></a>jquery 相关</h3><h3 id="工具类相关"><a href="#工具类相关" class="headerlink" title="工具类相关"></a>工具类相关</h3><p><a href="zh-cn/_Tool/webpack配置?id=webpack-和-gulp-区别">webpack 和 gulp 区别</a><br><a href></a><br><a href></a><br><a href></a><br><a href></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器相关&quot;&gt;&lt;a href=&quot;#浏览器相关&quot; class=&quot;headerlink&quot; title=&quot;浏览器相关&quot;&gt;&lt;/a&gt;浏览器相关&lt;/h3&gt;&lt;h3 id=&quot;http-相关&quot;&gt;&lt;a href=&quot;#http-相关&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="other" scheme="http://blog.clj.me/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="http://blog.clj.me/2019/tool/webpack%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.clj.me/2019/tool/webpack配置/</id>
    <published>2019-01-15T10:00:00.000Z</published>
    <updated>2019-03-21T10:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><ul><li><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack 官网</a></li><li><a href="https://webpack.docschina.org/" target="_blank" rel="noopener">webpack 中文网</a></li><li><a href="https://github.com/cuilongjin/webpack-config/" target="_blank" rel="noopener">webpack 配置文件</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webpack 是一个现代 JavaScript 应用程序的模块打包器（module bundler）</p><p>webpack 是一个模块化方案（预编译）</p><p>webpack 获取具有依赖关系的模块，并生成表示这些模块的静态资源</p><p>webpack 的两个特点：模块化、打包</p><p>四个核心概念：<strong>入口(entry)</strong>、<strong>输出(output)</strong>、<strong>加载器(loader)</strong>、<strong>插件(plugins)</strong></p><p>模块化方案：webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）<br>browserify 是与 webpack 相似的模块化打包工具</p><h3 id="webpack-起源"><a href="#webpack-起源" class="headerlink" title="webpack 起源"></a>webpack 起源</h3><ul><li>webpack 解决了现存模块打包器的两个痛点：<ul><li>Code Spliting - 代码分离</li><li>静态资源的模块化处理方案</li></ul></li></ul><h3 id="webpack-与模块"><a href="#webpack-与模块" class="headerlink" title="webpack 与模块"></a>webpack 与模块</h3><ul><li><p><a href="http://zhaoda.net/webpack-handbook/module-system.html" target="_blank" rel="noopener">前端模块系统的演进</a></p></li><li><p>在 webpack 看来：所有的<strong>静态资源都是模块</strong></p></li><li><p>webpack 模块能够识别以下等形式的模块之间的依赖：</p><ul><li><p>ES2015 <code>import</code> <code>export</code></p></li><li><p>CommonJS <code>require()</code> <code>module.exports</code></p></li><li><p>AMD <code>define</code> 和 <code>require</code></p></li><li><p>css/sass/less 文件中的 <code>@import</code></p></li><li><p>图片连接，比如：样式 <code>url(...)</code> 或 HTML <code>&lt;img src=...&gt;</code></p></li><li><p>字体等</p></li></ul></li></ul><ul><li>在webpack提供的模块化环境中<ul><li>想要加载一个JS文件，只需要 require(‘a.js’)</li><li>想要加载一个CSS文件，只需要 require(‘css/index.css’)</li><li>想要加载一个图片文件，只需要 require(‘images/a.png’)</li></ul></li></ul><ul><li><a href="http://www.jianshu.com/p/42e11515c10f#" target="_blank" rel="noopener">入门 Webpack，看这篇就够了</a></li></ul><h3 id="webpack-打包原理："><a href="#webpack-打包原理：" class="headerlink" title="webpack 打包原理："></a>webpack 打包原理：</h3><p>​        入口文件： main.js</p><p>​        webpack 从入口出发，递归分析项目中所有的依赖项（模块），使用loader来处理对应的模块最终，打包生成一个 bundle.js 文件。</p><p>​        如果配置了 webpack 中的 代码分离（Code Spliting），webpack 会根据 分离点 将这个模块生成一个独立的JS文件</p><p>​        还可以通过配置，将 CSS 、 图片、 字体 等文件，从 bundle.js 中抽离为独立的文件</p><h2 id="webpack-的基本使用"><a href="#webpack-的基本使用" class="headerlink" title="webpack 的基本使用"></a>webpack 的基本使用</h2><p>安装：<code>npm i -D webpack webpack-cli</code></p><p>webpack：是 webpack 工具的核心包</p><p>webpack-cli：提供了一些在终端中使用的命令</p><p>-D(–save-dev)：表示项目开发期间的依赖</p><p>webpack 的两种使用方式：命令行、配置文件（<code>webpack.config.js</code>）</p><h3 id="命令行使用说明"><a href="#命令行使用说明" class="headerlink" title="命令行使用说明"></a>命令行使用说明</h3><ul><li><code>package.json</code>中的<code>scripts</code>中可以存放一些 bash 命令，这些 bash 命令可以通过 <code>npm run 命令名称</code> 来执行</li><li>注意：npm 在执行 scripts 中的命令的时候，是在电脑系统后台默认开启一个 bash，将当前目录下的<code>./node_modules/.bin</code>这个文件夹临时加入了系统环境变量</li><li>使用方式：<code>npm run build</code></li><li>设置开发状态： <code>mode</code>  如果没有设置 mode 配置项，webpack 会默认提供开发环境(production)</li><li>在入口文件中可以使用 <code>import</code> 引入 js css less 等文件</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // webpack 是 webpack-cli 提供的命令</span><br><span class="line">  // src/js/main.js 为入口文件</span><br><span class="line">  // --output dist/bundle.js 为出口文件</span><br><span class="line">  // --mode development 生产环境</span><br><span class="line">  "build": "webpack"</span><br><span class="line">  "build1": "webpack src/js/main.js --output dist/bundle.js --mode development"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件方式（推荐）"><a href="#配置文件方式（推荐）" class="headerlink" title="配置文件方式（推荐）"></a>配置文件方式（推荐）</h3><p>项目<code>根目录</code>下创建一个 <code>webpack.config.js</code>文件，运行 <code>webpack</code> 命令时的默认配置文件</p><p>指定其他文件：<code>--config  webpack.XX.js</code></p><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;build&quot;: &quot;webpack&quot;</code></p><p>执行命令 : <code>npm run build</code></p><p>示例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置</span></span><br><span class="line"><span class="comment">// 注意 : 不要再这个文件中使用ES6的的模块化 import语法</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  entry: path.join(__dirname, <span class="string">'./src/js/main.js'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出口</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 出口目录</span></span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发模式</span></span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>安装：<code>npm i -D webpack-dev-server</code></p><p>作用：配合 webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率</p><p>注意：无法直接在终端中执行 <code>webpack-dev-server</code>，需要在 <code>package.json</code> 配置 <code>scripts</code> 后使用</p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>webpack-dev-server</code>将打包好的文件存储在内存中，提高编译和加载速度，效率更高（不会生成dist目录）</li><li>在内存中出口目录为项目根目录（命令行中的提示：<code>webpack output is served from /</code>）<ul><li>在<code>index.html</code>页面中引入文件不需要加<code>dist</code></li></ul></li></ul><h3 id="CLI-配置"><a href="#CLI-配置" class="headerlink" title="CLI 配置"></a>CLI 配置</h3><ul><li><code>--contentBase</code> ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的 index.html）<ul><li><code>--contentBase ./src</code>：当前目录下的 src 文件夹</li></ul></li><li><code>--open true</code> ：自动打开浏览器</li><li><code>--port 3000</code> ：指定端口号</li><li><code>--hot</code> ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载</li><li><code>--progress</code>：显示进度条</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --contentBase src --open --port 8888 --hot"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;dev&quot;: &quot;webpack-dev-server --hot&quot;</code></p><p>执行命令 : <code>npm run dev</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --hot 热更新写在命令行里，不然的话还要配其他插件麻烦</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'src'</span>),</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    port: <span class="number">3000</span></span><br><span class="line">    <span class="comment">// hot: true</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// plugins: [</span></span><br><span class="line">  <span class="comment">//   new webpack.HotModuleReplacementPlugin()</span></span><br><span class="line">  <span class="comment">// ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="html-webpack-plugin-插件"><a href="#html-webpack-plugin-插件" class="headerlink" title="html-webpack-plugin 插件"></a>html-webpack-plugin 插件</h2><ul><li>安装：<code>npm i -D html-webpack-plugin</code></li><li>作用：根据模板，在内存中自动生成 html 页面，并自动引入<code>bundle.js</code>、<code>css</code>等文件</li></ul><p>配置文件配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 html-webpack-plugin 插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 配置插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin 配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 模板页面路径</span></span><br><span class="line">      template: path.join(__dirname, <span class="string">'src/index.html'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包非js文件"><a href="#打包非js文件" class="headerlink" title="打包非js文件"></a>打包非js文件</h2><p>webpack 默认只能处理 js 文件，非 js(css、less、图片、字体等)处理不了，借助 loader 加载器</p><h3 id="处理-css-文件"><a href="#处理-css-文件" class="headerlink" title="处理 css 文件"></a>处理 css 文件</h3><p>在 <code>main.js</code>中引入css文件 <code>import &#39;../css/main.css&#39;</code></p><p>安装 : <code>npm i -D style-loader css-loader</code></p><p>在 <code>webpack.config.js</code> 中，添加个新的配置项 <code>module</code></p><p>在 <code>module</code> 中添加 <code>loader</code> 来处理 <code>css</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理 css</span></span><br><span class="line">      <span class="comment">// 注意点 use 执行loader 顺序 从右往左</span></span><br><span class="line">      <span class="comment">// css-loader: 读取css文件内容，将其转化为一个模块</span></span><br><span class="line">      <span class="comment">// style-loader: 拿到模块, 创建一个style标签，插入页面中</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-less-文件"><a href="#处理-less-文件" class="headerlink" title="处理 less 文件"></a>处理 less 文件</h3><p>在 <code>main.js</code>中引入 less 文件 <code>import &#39;../css/main.less&#39;</code></p><p>安装 : <code>npm i -D less-loader less style-loader css-loader</code></p><p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理 <code>less</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">//处理 css</span></span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h3><p>安装 : <code>npm i -D url-loader file-loader</code></p><p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">//  图片大小 &lt;= 10000 =&gt; 转化为base64</span></span><br><span class="line">              <span class="comment">//  图片大小 &gt;= 10000 =&gt; 不会转base64 内部调用 file-loader 加载图片</span></span><br><span class="line">              limit: <span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url-loader</strong> 默认会将图片转化为 base64 编码格式，目的：提高性能</p><p><strong>file-loader</strong> 在处理图片时，会对文件进行重命名</p><p>base64 编码格式的图片说明：</p><ul><li>精灵图：将一些小图片合并为一张图片，减少请求次数，提高性能</li><li>字体图标：直接将一些小的图片,合并到字体文件中，并且不会失真</li><li>base64：是一种编码格式,能够将图片、文字等常见的文件，转化为 base64 格式，这种字符串格式浏览器能够识别并且读取显示到页面中</li><li>base64 是一个字符串，也可以直接被内嵌到页面中，或者 css 中</li><li>注意：大图片不适合用 base64 处理，只有小的图标才适合 base64 处理</li></ul><h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><p>在 <strong>main.js</strong> 中引入 css 文件 <code>import &#39;../css/iconfont/iconfont.css&#39;</code></p><p>在 webpack.config.js 中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理字体图标</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(svg|woff|woff2|ttf|eot)$/</span>,</span><br><span class="line">        use: <span class="string">'url-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-ES6-语法"><a href="#处理-ES6-语法" class="headerlink" title="处理 ES6 语法"></a>处理 ES6 语法</h3><ol><li>现在的项目都是使用 ES6 开发的，但是这些新的 ES6 语法，并不是所有的浏览器都支持，所以就需要有一个工具，帮我们转成 es5 语法，这个就是：babel</li><li><a href="https://babeljs.io/" target="_blank" rel="noopener">babel</a></li><li>Babel is a JavaScript compiler. ==&gt; babel 是一个 JavaScript 编译器</li><li>webpack 只能处理 import / export 这个 es6 模块化语法，而其他的 js 新语法，应该使用 babel 来处理</li></ol><p>babel 的使用 :</p><ul><li>安装： <code>npm i -D babel-core babel-loader@7</code><ul><li>babel-core 是 babel 的核心包</li><li>babel-loader 加载 js 文件，并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js</li></ul></li></ul><ul><li>安装：<code>npm i -D babel-preset-env babel-preset-stage-2</code><ul><li>babel-preset-env：表示能够解析 es2015、es2016、es2017、es2018 这些标准的语法</li><li>babel-preset-stage-2：用来解析还没有被采纳为标准的语法</li><li><code>babel-polyfill与babel-plugin-transform-runtime</code> 也是做兼容处理的,以前都是用这个，兼容更早的</li></ul></li></ul><ul><li>配置 : 在 webpack.config.js 中添加一个 loader</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理 ES6 语法</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">        <span class="comment">// 设置忽略 node-modules 文件夹</span></span><br><span class="line">        exclude: <span class="regexp">/node-modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在项目根目录中创建 babel 的配置文件，叫：<code>.babelrc</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;,</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  -----------</span><br><span class="line">  // 暂时不用</span><br><span class="line">  // 如果未来某一天真的用到了polify</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;, &#123;</span><br><span class="line">      &quot;helpers&quot;: false,</span><br><span class="line">      &quot;polyfill&quot;: true,</span><br><span class="line">      &quot;regenerator&quot;: true,</span><br><span class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目打包上线"><a href="#项目打包上线" class="headerlink" title="项目打包上线"></a>项目打包上线</h2><p>执行 : <code>npm run build</code> 对项目进行打包，生成dist文件</p><p>模拟本地服务器 : 安装 : <code>npm i -g http-server</code></p><p>把dist文件里的内容放到服务器里即可，直接运行<code>http-server</code></p><h2 id="webpack-和-gulp-区别"><a href="#webpack-和-gulp-区别" class="headerlink" title="webpack 和 gulp 区别"></a>webpack 和 gulp 区别</h2><ol><li>Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给 gulp 配置不通的 task（通过Gulp 中的 gulp.task() 方法配置，比如启动 server、sass/less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程</li><li>Webpack 也称之为模块打包机 ，由此也可以看出 Webpack 更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块，最初 Webpack 本身就是为前端 JS 代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack 是通过 loader（加载器）和 plugins（插件）对资源进行处理的</li><li>gulp是构建工具，Webpack是 js 模块化的解决方案</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Webpack&quot;&gt;&lt;a href=&quot;#Webpack&quot; class=&quot;headerlink&quot; title=&quot;Webpack&quot;&gt;&lt;/a&gt;Webpack&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="工具" scheme="http://blog.clj.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Webpack" scheme="http://blog.clj.me/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="http://blog.clj.me/2019/vue/vuex/"/>
    <id>http://blog.clj.me/2019/vue/vuex/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-19T11:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="vuex-是什么"><a href="#vuex-是什么" class="headerlink" title="vuex 是什么?"></a>vuex 是什么?</h2><ul><li>状态管理工具</li><li>状态即数据，状态管理就是管理组件中的 data(数据)</li><li>Vuex 中的状态管理工具采用 <code>集中式</code> 统一管理项目中组件之间需要通讯的数据</li><li>最佳实践：只将组件之间共享的数据放在 vuex 中，而不是将所有的数据都放在 vuex 中，也就是如果数据只是在组件内部使用的，这个数据应该放在组件中，而不要放在 vuex</li><li>vuex 中的数据也是响应式的，如果一个组件中修改了 vuex 中的数据，另外一个使用的 vuex 数据的组件，就会自动更新</li><li>任何组件中都可以直接获取 vuex</li><li>前端状态该管理的思想最早是由 react 团队提出来的，就是 Flux(思想以及具体的实现)</li><li>前端状态管理工具 : Flux / Redux / Mobx / vuex 等等</li></ul><h2 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用?"></a>什么时候用?</h2><ul><li>项目体量很小，不需要使用 vuex，如果项目中组件通讯不复杂，也不需要使用 vuex</li><li>写项目的时候，发现组件通讯多，组件之间的关系复杂，项目已经无法继续开发了，此时就应该使用 vuex</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>安装 : <code>npm i vuex</code></li><li>导入 vuex</li><li>创建 vuex 示例</li></ul><h2 id="vuex-中的概念"><a href="#vuex-中的概念" class="headerlink" title="vuex 中的概念"></a>vuex 中的概念</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li><p>状态 , 状态即数据</p></li><li><p>状态是由 store 提供的</p></li><li><p>状态也是响应的</p></li><li><p>推荐通过 mutations 中提供的方法去修改数据，因为在严格模式下不允许在 mutation 外部修改 state下的数据，否则会报错</p><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3></li><li><p>作用：提供修改 state 的状态数据的方法</p></li><li><p>只要想改变 state 中的状态数据，就应该在 mutations 中提供一个方法来修改，接受 <code>state</code> 作为第一个参数（如果定义在模块中，则为模块的局部状态），<code>payload</code> 作为第二个参数（可选）</p></li><li><p>通过 <code>$store.commit(&#39;方法名&#39;)</code> 调用 mutations 中的方法</p></li><li><p>传参数的话，紧挨着方法名后面继续传就可以了，推荐传入一个对象（payload 即可）</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addTodo () &#123;</span><br><span class="line">    <span class="comment">// commit =&gt; 找 mutations</span></span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'addTodo'</span>, &#123;</span><br><span class="line">      todoName: <span class="keyword">this</span>.todoName</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  addTodo (state, playload) &#123;</span><br><span class="line">    state.list.push(playload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>提供异步修改 state 的状态数据的方法</p><p>处理函数总是接受 <code>context</code> 作为第一个参数，<code>payload</code>作为第二个参数（可选）</p><p>通过 <code>$store.dispatch(&#39;方法名&#39;)</code> 调用 actions 中的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addTodo () &#123;</span><br><span class="line">    <span class="comment">// 异步: 分发 dispatch  =&gt; actions</span></span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'addTodoAsync'</span>, &#123;</span><br><span class="line">      todoName: <span class="keyword">this</span>.todoName</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  addTodoAsync (context, playload) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">'addTodo'</span>, playload)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>可以认为是 store 的计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</p><p>getter 接受 state 作为其第一个参数，Getter 也可以接受其他 getter 作为第二个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：<code>store.getters.doneTodos</code></p><h2 id="vue-和-vuex-的配合使用"><a href="#vue-和-vuex-的配合使用" class="headerlink" title="vue 和 vuex 的配合使用"></a>vue 和 vuex 的配合使用</h2><ol><li>实例 vue 和实例 store</li><li>一定要把 store 挂在到 vue上</li><li>读取<ul><li>组件读取:<code></code></li><li>js读取: <code>this.$store.state.count</code></li><li>js操作: 在 mutations 里放一个方法，在方法里修改</li><li>js中触发这个方法 <code>this.​$store.commit(&#39;addCount&#39;, { num : 8})</code></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h1&gt;&lt;h2 id=&quot;vuex-是什么&quot;&gt;&lt;a href=&quot;#vuex-是什么&quot; class=&quot;headerlink&quot; title=&quot;v
      
    
    </summary>
    
      <category term="框架" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="vue" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/vue/"/>
    
    
      <category term="vue" scheme="http://blog.clj.me/tags/vue/"/>
    
      <category term="vuex" scheme="http://blog.clj.me/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://blog.clj.me/2019/vue/vue/"/>
    <id>http://blog.clj.me/2019/vue/vue/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-03-21T18:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><ul><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue 中文网</a></p></li><li><p><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">github 下载地址</a></p></li><li><p>Vue.js (读音 /vju:/ view)</p></li><li><p>渐进式 JavaScript 框架</p><ul><li><p>渐进式：小型项目使用 vue 就够了，随着页面的复杂程度提高，就要学习 vue-rouer 来管理更多的页面，再随着项目的数据越来越多，管理数据也变得麻烦起来了，就开始使用 vuex 来管理数据</p></li><li><p>框架 : 一整套的解决方案</p></li></ul></li></ul><h2 id="框架和库的区别-面试"><a href="#框架和库的区别-面试" class="headerlink" title="框架和库的区别 (面试)"></a>框架和库的区别 (面试)</h2><h3 id="库-Library-，代表-jquery"><a href="#库-Library-，代表-jquery" class="headerlink" title="库(Library) ，代表 : jquery"></a>库(Library) ，代表 : jquery</h3><ul><li>库就是一系列函数的集合，我们开发人员在使用库的时候，想要完成什么样的功能，就调用库中提供的某个方法</li></ul><p>比如：想要添加样式，就调用 jquery 中的 .css() / .addClass()</p><ul><li>库起到了一个辅助的作用，在使用库的是时候，是由开发人员说了算，也是由开发人员起主导作用</li></ul><h3 id="框架-Framework-，代表-vue"><a href="#框架-Framework-，代表-vue" class="headerlink" title="框架 (Framework)，代表 : vue"></a>框架 (Framework)，代表 : vue</h3><ul><li><p>在使用框架的时候，是由框架说了算，由框架起到了主导作用</p></li><li><p>框架是一套完整的解决方案，框架中制定了一套规则，使用框架的时候，只需要按照规则把代码放到合适的地方，然后框架会在合适的时机，主动调用开发人员的代码</p></li></ul><p>比如 : 想用vue组件里遍历就得使用 v-for，使用 for 不行</p><h3 id="主要区别：控制反转"><a href="#主要区别：控制反转" class="headerlink" title="主要区别：控制反转"></a>主要区别：控制反转</h3><blockquote><p>也就是 : 谁起到了主导作用</p></blockquote><ul><li><p>使用库的时候：开发人员起主导作用</p></li><li><p>使用框架的时候：框架起到了主导作用</p></li><li><p>从体量上看，框架一般比库大</p></li><li><p>会发现使用框架的时候，会受到很多限制</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/26078359?group_id=830801800406917120" target="_blank" rel="noopener">我们所说的前端框架与库的区别？</a></p></li></ul><h2 id="MVC-MVVM-面试"><a href="#MVC-MVVM-面试" class="headerlink" title="MVC + MVVM (面试)"></a>MVC + MVVM (面试)</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ol><li><p>MVC 是一种软件架构模式，也有人叫做设计模式</p></li><li><p>M : Model 数据模型 (专门用来操作数据，数据的 CRUD)</p></li><li><p>V : View 视图 (对于前端来说就是页面)</p></li><li><p>C : Controller 控制器 (是视图和数据模型沟通的桥梁，用于处理业务逻辑)</p></li></ol><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><blockquote><p>Vue 使用的是 MVVM 模式</p></blockquote><ul><li><p>MVVM ===&gt; M / V / VM</p></li><li><p>M : model 数据层</p></li><li><p>V : view 视图层</p></li><li><p>VM : ViewModel 视图模型</p></li><li><p>核心 : M &lt;===&gt; VM &lt;===&gt; V</p></li></ul><h3 id="MVVM-优势"><a href="#MVVM-优势" class="headerlink" title="MVVM 优势"></a>MVVM 优势</h3><ul><li><p>MVC 模式将应用程序划为三个部分，实现职责分离</p><ul><li><p>但是，在前端中，经常要通过 js 代码来进行一些逻辑操作，最终还要把这些逻辑操作展示页面中，也需要<code>频繁的操作DOM</code></p></li><li><p>比如 : ajax 请求、添加、修改、设置样式、动画</p></li></ul></li><li><p>MVVM 的思想通过 <code>数据双向绑定</code> 让数据自动的双向同步</p><ul><li><p>V (修改视图) –&gt; M</p></li><li><p>M (修改数据) –&gt; V</p></li></ul></li><li><p>采用的是 : <strong>数据驱动视图</strong>的思想，<strong>数据是核心</strong>。不要再想着怎么操作 DOM，而是想着如何操作数据</p></li></ul><h3 id="Vue-中的-MVVM"><a href="#Vue-中的-MVVM" class="headerlink" title="Vue 中的 MVVM"></a>Vue 中的 MVVM</h3><ul><li>注意 : 不推荐直接手动操作 DOM<blockquote><p>每个人操作 DOM 的方法不一样，会造成性能不一样<br>官网 : 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例</p></blockquote></li></ul><h2 id="Vue-基本使用"><a href="#Vue-基本使用" class="headerlink" title="Vue 基本使用"></a>Vue 基本使用</h2><ol><li><p>安装 : <code>npm i vue</code></p></li><li><p>导入 : <code>&lt;script src=&#39;./vue.js&#39;&gt;&lt;/script&gt;</code></p></li><li><p>实例化 vue</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 指定 vue 管理的边界，不能是 body 或 html 节点</span></span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 提供视图中 需要的数据</span></span><br><span class="line">  <span class="comment">// 视图可以直接使用 data 中的数据</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">'xxx'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul><li><p>vm 官网建议</p></li><li><p>Vue 构造函数首字母大写</p></li><li><p>参数是一个对象</p></li><li><p>id=’#app’, 其他也可以</p></li><li><p>边界外的无法使用 msg</p></li></ul><h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. &#123;&#123;&#125;&#125; : mustache 语法，小胡子语法，插值表达式</span><br><span class="line">2. 作用 : 使用`&#123;&#123;&#125;&#125;` 从`data`中获取数据，并展示在模板中</span><br><span class="line">3. 说明 : `&#123;&#123;&#125;&#125;` 中只能出现 js 表达式</span><br><span class="line">4. `&#123;&#123;&#125;&#125;` 语法不能作用在 HTML 元素的属性上</span><br></pre></td></tr></table></figure><ul><li>表达式 (有返回值的)<ul><li>基本的数据类型 <code>1 &#39;abc&#39; false [] {}</code></li><li>数据类型 和 运算符结合在一起<code>1+2 arr.join(&#39;-&#39;) true ? 123 : 321</code></li></ul></li><li>语句 <code>if语句 for语句</code></li></ul><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><h3 id="input-v-model"><a href="#input-v-model" class="headerlink" title="input + v-model"></a>input + v-model</h3><p> v-model 指令：数据双向绑定的指令</p><ul><li>作用：把 data 中的 num 值 和 input 上的值绑定到一起，一方的值发生了改变，另 一方也会跟着改变</li><li>注意：v-model 只能用在表单控件上（input checkbox 等）</li></ul><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"><span class="comment">// 参数1：要给哪个对象设置属性</span></span><br><span class="line"><span class="comment">// 参数2：给对象设置什么属性</span></span><br><span class="line"><span class="comment">// 参数3：属性的修饰符</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'赋值了'</span>, newVal)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'取值了'</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据双向绑定的原理"><a href="#数据双向绑定的原理" class="headerlink" title="数据双向绑定的原理"></a>数据双向绑定的原理</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">    <span class="comment">// 设置属性时会触发该函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'设置'</span>, newVal)</span><br><span class="line">    temp = newVal</span><br><span class="line">    input.value = newVal</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="comment">// 获取属性时会触发该函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'获取'</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">input.oninput = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this.value)</span></span><br><span class="line">  obj.name = <span class="keyword">this</span>.value</span><br><span class="line">  <span class="built_in">console</span>.log(obj.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><p>检测变化注意：受现代 JavaScript 的限制 (而且 <code>Object.observe</code> 也已经被废弃)，Vue <strong>不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 转换它，这样才能让它是响应的</p><p><strong>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性</strong>，可以使用 <code>Vue.set(object, key, value)</code> 方法将响应属性添加到嵌套的对象上，或者创建一个包含原对象属性和新属性的对象替换掉原对象</p><h3 id="列表渲染数组更新检测"><a href="#列表渲染数组更新检测" class="headerlink" title="列表渲染数组更新检测"></a>列表渲染数组更新检测</h3><p>数组的方法可以触发视图更新：方法如下：</p><p><code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code></p><p>替换数组</p><p>用一个含有相同元素的数组去替换原来的数组并不会导致 Vue 丢弃现有 DOM 并重新渲染整个列表</p><p>注意：由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p><ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>解决第一类问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure><p>解决第二类问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><h2 id="指令学习"><a href="#指令学习" class="headerlink" title="指令学习"></a>指令学习</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>指令：就是一个特殊的标记，起一个辅助作用，使 html 具备原来没有的功能</li><li>vue 中所有的指令都是以 <code>v-</code> 开头的，比如 : v-model v-bind v-if v-for 等等</li></ul><h3 id="v-model-常用"><a href="#v-model-常用" class="headerlink" title="v-model (常用)"></a>v-model (常用)</h3><blockquote><p>说明：用在<code>表单</code>元素中，用来实现<code>数据双向绑定</code> (input checkbox 等等)<br>作用：将 <code>数据</code> 和 <code>文本框的值</code> 绑定到一起，任何一方发生改变，都会引起对方的改变<br>注意：v-model 在不同类型的表单元素中作用不同<br><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 的初始值而总是将 Vue 实例的数据作为数据来源</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 文本输入框 绑定的是值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"num"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 多选框  绑定的选中状态 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"isChecked"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    num: <span class="number">0</span>,</span><br><span class="line">    isChecked: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-text-和-v-html"><a href="#v-text-和-v-html" class="headerlink" title="v-text 和 v-html"></a>v-text 和 v-html</h3><blockquote><p>说明 : 设置文本内容</p></blockquote><p>v-text :  相当于之前的 innerText</p><p>v-html :  相当于之前的 innerHTML，会解析 html 标签，（已经废弃三大括号的插值）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">"msg1"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-html</span>=<span class="string">"msg2"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg1: <span class="string">'&lt;a href="#"&gt;haha&lt;/a&gt;'</span>,</span><br><span class="line">    msg2: <span class="string">'&lt;a href="#"&gt;haha&lt;/a&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-bind-常用"><a href="#v-bind-常用" class="headerlink" title="v-bind (常用)"></a>v-bind (常用)</h3><blockquote><p>说明：动态绑定数据 (单向)<br>出现原因：在 HTML 属性中，无法使用插值表达式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"href"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-bind 可以直接省略 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"href"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v-bind：</span></span><br><span class="line"><span class="comment">// 说明：动态数据绑定 (单向)，因为html的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据, 需要使用 v-bind</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    href: <span class="string">'https://www.baidu.com'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="v-bind-和-v-model-的区别"><a href="#v-bind-和-v-model-的区别" class="headerlink" title="v-bind 和 v-model 的区别"></a>v-bind 和 v-model 的区别</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-model 数据双向绑定 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--场景：表单元素中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"isChecked1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  v-bind 数据动态绑定 (单向) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--场景：主要用在属性中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">:checked</span>=<span class="string">"isChecked2"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 操作样式 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1. 动态添加类，但不符合vue数据是核心的思想 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">"cls"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 2. class值是一个对象 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性名为类名 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性值为布尔值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">"&#123;red: isRed, fz: isFz&#125;"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 3. style --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">"&#123;backgroundColor: 'red', fontSize: fz + 'px'&#125;"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v-bind :</span></span><br><span class="line"><span class="comment">// 说明 : 动态数据绑定 (单向)，因为html的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据 , 需要使用 v-bind</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    href: <span class="string">'https://www.baidu.com'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其他操作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"['red', 'fz']"</span>&gt;</span>heheheh<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ===&gt; &lt;div class="red fz"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 多个样式对象写成数组的形式，如果有相同样式后面会覆盖前面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[&#123;red: true&#125;, 'fz']"</span>&gt;</span>hehehe<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ===&gt; &lt;div class="red fz"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><blockquote><p>注册事件/绑定事件</p></blockquote><ol><li><p>v-on:click 绑定了一个 click 事件</p></li><li><p>缩写 : @click=’fn’</p></li><li><p>函数写在 <code>methods</code> 里面</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"fn"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 简写 @ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn1"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传参 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn2(123)"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v-on 注册事件</span></span><br><span class="line"><span class="comment">// v-on:click =&gt; 绑定点击事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 事件函数写在 methods 中</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'haha'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn1 () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'haha'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2 (ref) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(ref)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>函数里面的 this 指的就是 vm 实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> === vm <span class="comment">// true</span></span><br><span class="line"><span class="keyword">this</span>.msg <span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">this</span>.msg = <span class="string">'XXX'</span> <span class="comment">// 修改数据</span></span><br></pre></td></tr></table></figure><ol start="5"><li>事件对象 $event</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定事件对象的时候, 没有添加小括号，此时，直接在方法中，通过参数 e 就可以获取到事件对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果绑定事件的地方,事件函数有()  @click='fn()' 则需要通过 $event 获取 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn1($event, 123)"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn1 (e, ref) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">      <span class="built_in">console</span>.log(ref)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>遍历数据，为数据中的每一项生成一个指令所在的标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1: 最常用 遍历数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in list1"</span>&gt;</span>&#123;&#123; item &#125;&#125; - &#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2: 遍历元素是对象的数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in list2"</span>&gt;</span>&#123;&#123; item.name &#125;&#125; - id:&#123;&#123; item.id &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3: 遍历对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- item 是 属性值，key 是属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, key) in obj"</span>&gt;</span>&#123;&#123; item &#125;&#125;-&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4: 生成10个h1 （item是1-10）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">"item in 10"</span>&gt;</span>我是h1 &#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="headerlink" title="v-if 和 v-show"></a>v-if 和 v-show</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">'isShow'</span>&gt;</span>我是h1 v-if<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">'isShow'</span>&gt;</span>我是h1 v-show<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-if 和 v-show 的异同点：</p><ul><li><p>相同点: 可以切换元素的显示与隐藏</p></li><li><p>不同点: 切换显示和隐藏的实现不同</p><ul><li>v-if：显示：创建节点；隐藏：删除节点</li><li>v-show：显示：display:block；隐藏： display:none</li></ul></li><li><p>使用场景 :</p><ul><li>v-if 因为要不断的创建和删除来切换显示与隐藏，所以性能不高</li><li>v-if：切换次数不频繁的时候</li><li>v-show：切换次数频繁的时候</li></ul></li></ul><h3 id="v-else-if-和-v-else"><a href="#v-else-if-和-v-else" class="headerlink" title="v-else-if 和 v-else"></a>v-else-if 和 v-else</h3><ul><li>v-else：两种情况的</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"num &gt; 40"</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>v-else-if：三种以上情况</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"num &gt;= 40"</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">"num &gt;= 30 &amp;&amp; num &lt; 40"</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>作用：告诉 vue 这个标签中的内容只需要解析一次，即便是数据再发送改变，这个标签中的内容也不会被更新</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>带 onece 的 &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>作用：告诉 vue 这段节点中没有指令或表达式，不需要解析，从而，提升性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span>带 v-pre &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><p>使用遮盖</p><ul><li><p>给要遮盖的元素添加一个 v-cloak 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用属性选择器，添加样式：<code>[v-cloak] { display: none }</code></p></li><li><p>vue 会在解析模板后将 v-cloak 指令从页面中移除，移除指令的时候，差值表达式已经变为对应的数据</p></li></ul><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符</p><p> Vue 为最常用的按键提供了别名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>全部的按键别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>写起来像一个方法，用起来像一个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fn () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：只有跟计算属性相关的数据发生了改变，计算属性才会重新计算<br>注意点:</p><ul><li><p>计算属性必须返回一个值</p></li><li><p>计算属性只能当属性用，不能当方法用</p></li><li><p>不能和 data 中的属性名重名</p></li></ul><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。它的工作方式类似于一个属性，所以你需要用 <code>v-bind</code> 来绑定动态值</p><p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升</p><ul><li><code>就地复用</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">  &#123;&#123;item.name&#125;&#125; <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据 --&gt;</span></span><br><span class="line">data: &#123;list: [&#123;id: 1, name: 'zs'&#125;, &#123;id: 2, name: 'ls'&#125;, &#123;id: 3, name: 'ww'&#125;]</span><br><span class="line"><span class="comment">&lt;!-- 演示  --&gt;</span></span><br><span class="line">vm.list.unshift(&#123;id:4, name:'zl'&#125;)</span><br></pre></td></tr></table></figure><ul><li>使用 key<ul><li>如果数组的元素是一个对象，使用对象里固定属性，一般情况下，对象里都有 id</li><li>如果数组的元素是一个简单类型，不是一个对象，就可以取索引作为 key</li></ul></li></ul><h2 id="异步-DOM-更新"><a href="#异步-DOM-更新" class="headerlink" title="异步 DOM 更新"></a>异步 DOM 更新</h2><ol><li>Vue 中采用了 <code>异步DOM更新</code> 的机制</li><li>数据发生改变后，vue 没有立即将数据的改变更新到视图中，而是等到数据不再变化的时候 一次性的将数据的改变更新到视图中</li></ol><p>为什么是异步 DOM 更新?</p><ul><li>性能的考虑</li><li>因为对于前端来说，修改数据进行 DOM 操作是常有的事情，如果频繁操作 DOM，会严重影响页面的加载性能</li><li>DOM 操作这是前端的性能的瓶颈</li><li>比如 : for (let i = 1; i &lt; 10000; i++&gt;) 如果同步 就要重新渲染 1000 次</li></ul><p>验证异步 DOM 更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过dom来获取count的值</span></span><br><span class="line"><span class="comment">// this.$el ==&gt; vue 边界元素</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.count = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>需求：在数据更新后，立即获取到更新后的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 更新后，会执行 this.$nextTick() 的回调函数，所以能拿到值</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="监听-watch"><a href="#监听-watch" class="headerlink" title="监听 watch"></a>监听 watch</h2><p>vue 中可以通过 watch 配置项来监听 vue 实例中数据的变化</p><ul><li>基本使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  num: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//  监听</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 监听 num 属性的数据变化</span></span><br><span class="line">  <span class="comment">// 作用: 只要 num 的值发生变化，这个方法就会被调用</span></span><br><span class="line">  <span class="comment">// 第一个参数: 新值</span></span><br><span class="line">  <span class="comment">// 第二个参数: 旧值</span></span><br><span class="line">  num (newVal, oldVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'新:'</span>, newVal)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'旧:'</span>, oldVal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>监听对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  msg: <span class="string">''</span>,</span><br><span class="line">  obj: &#123;</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 监听对象</span></span><br><span class="line">  obj (newVal) &#123;</span><br><span class="line">    <span class="comment">// 虽然 obj 中的属性值发生改变了，但 obj 引用的地址没有发生改变，所以不会触发事件</span></span><br><span class="line">    <span class="built_in">console</span>.log(newVal)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 监听对象的属性</span></span><br><span class="line">  <span class="comment">// 从对象的角度来监听的</span></span><br><span class="line">  obj: &#123;</span><br><span class="line">    <span class="comment">// 深度监听 监听对象里面的属性</span></span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面刚进入立即触发监听，以表达式的当前值触发回调</span></span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象里的属性值发生变化，调用 handler 方法</span></span><br><span class="line">    handler (newVal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.msg = <span class="string">`obj.age 值变化了，新值：<span class="subst">$&#123;newVal.age&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 从属性的角度来监听</span></span><br><span class="line">  <span class="string">'obj.age'</span> (newVal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.msg = <span class="string">`obj.age 值变化了，新值：<span class="subst">$&#123;newVal&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用案例：需求 : 监听文本框字符个数，并显示格式验证码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"val"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">'isTrue'</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  val: <span class="string">''</span>,</span><br><span class="line">  msg: <span class="string">'请输入 6-12 位'</span>,</span><br><span class="line">  isTrue: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  val (newVal) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^[0-9a-zA-z]&#123;6,12&#125;$/</span>.test(newVal)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.isTrue = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.isTrue = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><ul><li>所有的 vue 组件，都是 vue 实例，一个组件对应一个实例，并且接收相同的选项对象（一些根实例特有的选项除外）</li><li>实例生命周期也叫做：组件生命周期</li><li>声明周期图：<a href="/zh-cn/_vue/Vue实例生命周期图">01</a></li></ul><h3 id="生命周期介绍"><a href="#生命周期介绍" class="headerlink" title="生命周期介绍"></a>生命周期介绍</h3><p><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">vue 生命周期钩子函数</a></p><ul><li>简单说：一个组件（实例）从开始到最后消化所经历的各种状态，就是一个组件的生命周期</li><li>生命周期钩子函数的定义：从组件被创建，到组件挂在到页面上运行，再到页面关闭组件被销毁，这三个阶段总是伴随着组件的各种事件，这些事件，统称为组件的生命周期函数（简称 : 钩子函数）</li><li>开发人员可以通过 vue 提供的钩子函数，让我们写的代码参与到 vue 的生命周期里面来，让我们的代码在合适的阶段起到相应的作用</li></ul><p>注意：</p><ul><li>vue 在执行过程中会 <strong>自动调用</strong> <code>生命周期钩子函数</code>，我们只需要提供这些钩子函数即可</li><li>钩子函数的名称都是  vue 中规定好的</li></ul><p><a href="https://segmentfault.com/a/1190000008879966" target="_blank" rel="noopener">vue 实例生命周期 参考 1</a></p><p><a href="https://segmentfault.com/a/1190000008010666" target="_blank" rel="noopener">vue 实例生命周期 参考 2</a></p><h3 id="钩子函数-beforeCreate"><a href="#钩子函数-beforeCreate" class="headerlink" title="钩子函数 - beforeCreate"></a>钩子函数 - beforeCreate</h3><ul><li>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li><li>此时组件的选项还未挂载，因此无法访问 methods，data，computed 上的方法或数据</li><li>使用场景 : 几乎不用</li></ul><h3 id="钩子函数-created-掌握"><a href="#钩子函数-created-掌握" class="headerlink" title="钩子函数 - created (掌握)"></a>钩子函数 - created (掌握)</h3><ul><li>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见</li><li>可以调用 methods 中的方法、改变 data 中的数据，并且修改可以通过 vue 的响应式绑定体现在页面上、获取computed 中的计算属性等</li><li>使用场景：发送 ajax、本地存储获取数据</li></ul><h3 id="钩子函数-beforeMounted"><a href="#钩子函数-beforeMounted" class="headerlink" title="钩子函数 - beforeMounted()"></a>钩子函数 - beforeMounted()</h3><ul><li>在挂载开始之前被调用（挂载：DOM 渲染）</li></ul><h3 id="钩子函数-mounted-掌握"><a href="#钩子函数-mounted-掌握" class="headerlink" title="钩子函数 - mounted() (掌握)"></a>钩子函数 - mounted() (掌握)</h3><ul><li><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</li><li>这个周期可以获取 DOM</li><li>指令的生效在 mounted 周期之前</li><li>在这个周期内，对 data 的改变可以生效。但是要进下一轮的 DOM 更新，DOM 上的数据才会更新</li><li>使用场景：发送 ajax、操作 DOM</li></ul><h3 id="钩子函数-beforeUpdate"><a href="#钩子函数-beforeUpdate" class="headerlink" title="钩子函数 - beforeUpdate()"></a>钩子函数 - beforeUpdate()</h3><ul><li><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p></li><li><p>此处获取的数据是更新后的数据，但是获取页面中的 DOM 元素是更新之前的</p><blockquote><p>小提示 : 打印 this.$el ，打开小三角是之后的，是因为打印是有监听的功能，展示的是后面更改之后的</p></blockquote></li></ul><h3 id="钩子函数-updated"><a href="#钩子函数-updated" class="headerlink" title="钩子函数 - updated()"></a>钩子函数 - updated()</h3><ul><li>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</li><li>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作</li><li>应该避免在此期间更改状态。如果要相应状态改变，通常最好使用 <strong>计算属性</strong> 或 <strong>watcher</strong> 取而代之</li></ul><h3 id="钩子函数-beforeDestroy"><a href="#钩子函数-beforeDestroy" class="headerlink" title="钩子函数 - beforeDestroy()"></a>钩子函数 - beforeDestroy()</h3><ul><li>实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">this</span>.timerId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1111</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果当组件销毁了,还不清除定时器会出现性能问题</span></span><br><span class="line"> <span class="comment">// 在浏览器中可以尝试销毁 vm.$destroy()</span></span><br><span class="line"> <span class="comment">// 最后销毁</span></span><br><span class="line">beforeDestroy () &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="钩子函数-destroyed"><a href="#钩子函数-destroyed" class="headerlink" title="钩子函数 - destroyed()"></a>钩子函数 - destroyed()</h3><ul><li>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul><h2 id="使用接口的形式发送数据"><a href="#使用接口的形式发送数据" class="headerlink" title="使用接口的形式发送数据"></a>使用接口的形式发送数据</h2><h3 id="json-server-提供假数据接口"><a href="#json-server-提供假数据接口" class="headerlink" title="json-server 提供假数据接口"></a>json-server 提供假数据接口</h3><ul><li>作用：根据指定的 JSON 文件，提供假数据接口</li><li>地址：<a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">json-server</a></li><li>使用步骤</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 全局安装 json-server: <span class="string">`npm i -g json-server`</span></span><br><span class="line"><span class="number">2.</span> 准备一个json数据</span><br><span class="line"><span class="number">3.</span> 执行：<span class="string">`json-server data.json`</span></span><br><span class="line"></span><br><span class="line">data.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"todos"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">      <span class="string">"age"</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>REST API格式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 查询：GET</span><br><span class="line"><span class="number">2.</span> 添加：POST</span><br><span class="line"><span class="number">3.</span> 删除：DELETE</span><br><span class="line"><span class="number">4.</span> 更新：</span><br><span class="line">PUT：需要将对象里的所有属性提交</span><br><span class="line">  PATCH(打补丁)：只需要提交需要修改的属性</span><br></pre></td></tr></table></figure><ul><li>具体接口<ul><li>查询全部数据 <a href="http://localhost:3000/todos" target="_blank" rel="noopener">http://localhost:3000/todos</a><br>查询指定数据 <a href="http://localhost:3000/todos/2" target="_blank" rel="noopener">http://localhost:3000/todos/2</a></li><li>添加一个对象 <a href="http://localhost:3000/todos" target="_blank" rel="noopener">http://localhost:3000/todos</a><br>POST<br>id 会自动帮我们添加</li><li>更新数据 <a href="http://localhost:3000/todos/3" target="_blank" rel="noopener">http://localhost:3000/todos/3</a><br>PUT 或者 PATCH<br>PUT 需要提供该对象的所有数据<br>PATCH 只需要提供要修改的数据即可</li><li>删除数据<a href="http://localhost:3000/todos/3" target="_blank" rel="noopener">http://localhost:3000/todos/3</a><br>DELETE</li></ul></li><li>可以借助 <code>postman</code> 测试接口</li></ul><h3 id="axios-发送请求"><a href="#axios-发送请求" class="headerlink" title="axios 发送请求"></a>axios 发送请求</h3><ul><li><strong>作用</strong> : 一个专门用来发送 ajax 请求的库,  可以在浏览器或者node.js 中使用</li><li><strong>使用步骤</strong><ul><li>本地安装 axios : <code>npm i -g axios</code></li><li>导入 axios</li></ul></li><li><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios 使用说明</a></li><li><strong>GTE 方式发送请求</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">axios.get(<span class="string">'http://localhost:3000/todoList/1'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'获取到数据了：'</span>, res.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">axios.get(<span class="string">'http://localhost:3000/todoList'</span>,&#123;</span><br><span class="line">  params : &#123;</span><br><span class="line">    id : <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'获取到数据了：'</span>, res.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>POST 方式发送请求</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// post 请求</span></span><br><span class="line">axios</span><br><span class="line"><span class="comment">// 第一个参数：表示接口地址</span></span><br><span class="line"><span class="comment">// 第二个参数：表示接口需要的参数</span></span><br><span class="line">  .post(<span class="string">'http://localhost:3000/todoList'</span>, &#123;</span><br><span class="line">  name: <span class="string">'haha'</span>,</span><br><span class="line">  done: <span class="literal">true</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><strong>概念 :</strong></p><ul><li>vue 中的过滤器(filter)：<strong>数据格式化</strong>，让数据按照我们规定的格式输出</li><li>比如 : 对于日期来说，将日期格式化转化为 <code>年-月-日 小时:分:秒</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">显示：2019-01-11T10:11:19.566Z</span><br><span class="line">不是我们想要的</span><br><span class="line">我们想要的：2019-01-11 18-11-53</span><br></pre></td></tr></table></figure><p><strong>全局过滤器 和 局部过滤器</strong></p><ul><li>全局方式创建的过滤器，在任何一个 Vue 实例中都可以使用 (一般情况下，为了项目方便管理，都是一个 vue 实例)</li><li>局部创建的过滤器只能在当前 vue 实例中使用</li><li>全局过滤器应在 Vue 实例创建之前创建</li></ul><p><strong>注册全局过滤器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：过滤器的名字</span></span><br><span class="line"><span class="comment">// 第二个参数：是一个回调函数，只要使用过滤器的时候，这个回调函数就会执行，res =&gt; 原始数据</span></span><br><span class="line"><span class="comment">// 必须要有返回值：通过回调函数的返回值得到格式化后的数据</span></span><br><span class="line">Vue.filter(<span class="string">'date'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注册局部过滤器</strong></p><p>在 vm 的配置项里写一个 <code>filters</code>，对应的是一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  date (res) &#123;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>moment 插件</strong></p><ul><li><p><a href="http://momentjs.cn/" target="_blank" rel="noopener">moment</a></p></li><li><p>使用：<code>npm i moment</code></p></li><li><p>日期 =&gt; 指定格式<code>moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;)</code></p></li><li><p>时间戳 =&gt; 指定格式<code>moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;)</code></p></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'dataFilter'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> moment(res).format(<span class="string">'YYYY-MM-DD HH-mm-ss'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>使用过滤器</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- data: 原始数据  dataFilter: 过滤器名称  |：管道--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date | dataFilter &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局</span></span><br><span class="line">Vue.filter(<span class="string">'dataFilter'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> moment(res).format(<span class="string">'YYYY-MM-DD HH-mm-ss'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部</span></span><br><span class="line">filters: &#123;</span><br><span class="line">  date (res, format = <span class="string">'YYYY-MM-DD'</span>, arg) &#123;</span><br><span class="line">    <span class="keyword">return</span> moment(res).format(format)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数问题</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date | dateFilter('YYYY-MM-DD HH-mm-ss', 888) &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'dateFilter'</span>, (res, format = <span class="string">'YYYY-MM-DD'</span>, arg) =&gt; &#123;</span><br><span class="line">  <span class="comment">// res: 原始数据</span></span><br><span class="line">  <span class="comment">// format：dateFilter 中的第一个参数，等号后面为默认值</span></span><br><span class="line">  <span class="comment">// arg: dateFilter 中的第二个参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg) <span class="comment">// 888</span></span><br><span class="line">  <span class="keyword">return</span> moment(res).format(format)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote><p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常 <strong>可复用</strong> 的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p></blockquote><p><img src="components.png" alt="组件化图释"></p><ul><li>注册组件的两种方式：全局组件、局部组件</li><li>Vue实例中的配置项（如：methods、filters、watch、computed、directives、生命周期钩子函数）都可以在组件中使用</li></ul><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><ul><li>说明：全局组件在所有的 vue 实例中都可以使用</li><li>注意：<ul><li>注册全局组件应放在 vm 实例之前</li><li>模板只允许有一个根节点</li><li>组件中的 <code>data</code> 必须是函数，并且要返回一个对象</li><li>组件复用时如果 data 为对象，所有复用的组件的 data 指向同一片内存空间，一个组件被修改了会影响其他组件，这不是我们想要的</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册全局组件</span></span><br><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;A custom component!&lt;/p&gt;'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'注意：组件的data必须是一个函数！！！'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给组件指定返回值</span></span><br><span class="line"><span class="comment">// 组件名称为 One</span></span><br><span class="line"><span class="keyword">const</span> One = Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;A custom component!&lt;/p&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 可以简写为 ==&gt;</span></span><br><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;A custom component!&lt;/p&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用：以自定义元素的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><ul><li>局部组件是在某一个具体的vue实例（组件）中定义的，只能在当前 vue 实例（组件）中使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 局部组件</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// 子组件 com-a</span></span><br><span class="line">    <span class="string">'com-a'</span>: &#123;</span><br><span class="line">      template: <span class="string">`&lt;h1&gt;局部组件：&#123;&#123; num &#125;&#125;&lt;/h1&gt;`</span>,</span><br><span class="line">      data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          num: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><ul><li>组件是一个独立、封闭的个体</li><li>也就是说：组件中的数据默认情况下，只能在组件内部使用，无法直接在组件外部使用</li><li>可以将 vue 实例看做一个组件</li><li>对于组件之间需要相互使用彼此的情况，应该使用 <strong>组件通讯机制</strong> 来解决</li><li>组件通讯的三种情况 :<ul><li>父组件将数据传递给子组件(父 -&gt; 子)</li><li>子组件将数据传递给父组件 (子 =&gt; 父)</li><li>非父子组件(兄弟组件)</li></ul></li></ul><h4 id="父组件到子组件"><a href="#父组件到子组件" class="headerlink" title="父组件到子组件"></a>父组件到子组件</h4><ul><li>将要传递的数据，通过属性传递给子组件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">"pmsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子组件通过 <code>props</code> 配置项来指定要接收的数据，props 是一个数组<ul><li>在使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名代替</li><li>如果使用字符串模板，那么这个限制就不存在了</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'msg'</span>]</span><br></pre></td></tr></table></figure><ul><li>传递过来的 <code>props</code> 属性的用法与 <code>data</code> 属性的用法相同</li><li>子组件不能直接修改父组件传过来的数据，可以将父组件传过来的值保存在一个临时变量中<ul><li>如果 props 传过来的数据为引用类型，只要不是重新赋值，修改数据不会报错，但不推荐这样做</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一步：将你要传递的数据,作为属性传递给子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hello</span> <span class="attr">:num</span>=<span class="string">"pnum"</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二部：子组件通过 props 配置项来指定要接收的数据</span></span><br><span class="line">  props: [<span class="string">'num'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="子组件到父组件"><a href="#子组件到父组件" class="headerlink" title="子组件到父组件"></a>子组件到父组件</h4><ul><li>方式：父组件给子组件传递一个函数，由子组件调用这个函数</li><li>说明：借助 vue 中的自定义事件(v-on:cunstomFn=”fn”)</li><li><code>$emit()</code>：触发事件</li><li>第一步：父组件了里准备一个方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    pfn (num) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>第二步：把这个方法作为事件传递给子组件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello</span> @<span class="attr">fn</span>=<span class="string">"pfn"</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>第三步：子组件调用父组件传过来的方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;button @click='click'&gt;按钮&lt;/button&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">num</span>: <span class="number">5</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    click () &#123;</span><br><span class="line">      <span class="comment">// 第一个参数：表示要触发的自定义事件名称，也就是 @fn</span></span><br><span class="line">    <span class="comment">// 第二个参数：表示要传递给父组件的数据</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'fn'</span>, <span class="keyword">this</span>.num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="非父子组件通讯"><a href="#非父子组件通讯" class="headerlink" title="非父子组件通讯"></a>非父子组件通讯</h4><ul><li><p>是通过 <code>事件总线 (event bus 公交车) 机制</code> 来实现的</p></li><li><p>事件总线：实际上就是一个 <code>空 Vue 实例</code></p></li><li><p>可以实现任意两个组件之间的通讯而不管两个组件到底有什么样的层级关系</p></li><li><p><code>$emit()</code>：发送数据</p></li><li><p><code>$on()</code>：接收数据</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：实例化事件总线 bus</span></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发组件 A 中的事件</span></span><br><span class="line">bus.$emit(<span class="string">'id'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件 B 创建的钩子中监听事件</span></span><br><span class="line">bus.$on(<span class="string">'id'</span>, id =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例：组件A —&gt; 组件B</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com-a</span>&gt;</span><span class="tag">&lt;/<span class="name">com-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com-b</span>&gt;</span><span class="tag">&lt;/<span class="name">com-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：实例化事件总线 bus</span></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 A</span></span><br><span class="line">Vue.component(<span class="string">'com-a'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;h1 @click="click"&gt;组件A&lt;/h1&gt;`</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    click () &#123;</span><br><span class="line">      <span class="comment">// 第二部：发送数据</span></span><br><span class="line">      bus.$emit(<span class="string">'hello'</span>, <span class="string">'你好'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 B</span></span><br><span class="line">Vue.component(<span class="string">'com-b'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;h1&gt;组件B&lt;/h1&gt;`</span>,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">// 第三步：接收数据</span></span><br><span class="line">    bus.$on(<span class="string">'hello'</span>, res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'接收到数据'</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>[开关灯案例]</p><h3 id="单向数据流-组件与组件之间"><a href="#单向数据流-组件与组件之间" class="headerlink" title="单向数据流(组件与组件之间)"></a>单向数据流(组件与组件之间)</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<code>单向下行绑定</code>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>当 todo-head 中的 todoName 设置数据后回车添加到 todoList，todoList 的长度就会发生变化，然后就会根据(组件与组件之间的)单向数据流，把数据单向下流到子组件中<br>而且必须是通过 props 往下传递的才可以</p><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p> <code>vm.$refs</code> 一个对象，持有已注册过 ref 的所有子组件 ( HTML 元素)</p><ul><li>使用 :</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML元素 中，添加ref属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"div"</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在JS中通过 $refs.属性 来获取</span></span><br><span class="line"><span class="comment">// 在 mounted 函数中使用</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;h1&gt;组件A&lt;/h1&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">num</span>: <span class="number">100</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn () &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.div) <span class="comment">// div 标签</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child) <span class="comment">// child 组件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果获取的是一个子组件，那么通过 ref 就能获取到子组件中的 <code>data</code> 和 <code>methods</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child.num) <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child.fn) <span class="comment">// fn</span></span><br></pre></td></tr></table></figure><ul><li>一般在第三方的组件中， 可能会用到这个功能</li></ul><h2 id="单页面应用程序"><a href="#单页面应用程序" class="headerlink" title="单页面应用程序"></a>单页面应用程序</h2><p>SPA : <strong>Single Page Application</strong> 单页面应用程序</p><p>MPA : <strong>Multiple Page Application</strong> 多页面应用程序</p><ul><li>单页 web 应用，就是只有一个 web 页面的应用，是加载单个 HTML 页面，并在用户与应用程序交互时动态更新该页面的 web 应用程序</li></ul><ul><li>区别<ul><li>对于传统的多页面应用程序来说，每次请求服务器返回的都是一个完整的页面</li><li>对于单页应用程序来说，只有第一次会加载页面，以后的每次请求，仅仅是获取必要的数据，然后由页面中js解析获取的数据展示在页面中</li></ul></li></ul><ul><li>优势 :<ul><li>减少了请求体积，加快页面响应速度，降低了对服务器的压力</li><li>更好的用户体验，让用户在 web app 感受 native app 的流畅</li></ul></li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul><li><strong>路由</strong> : 是浏览器 URL 中的<code>哈希值</code>( # hash) 与 <code>展示视图内容</code> 之间的<code>对应规则</code><ul><li>在 web App 中，通过一个页面来展示和管理整个应用的功能。SPA 往往是功能复杂的应用，为了有效管理所有视图内容，前端路由应运而生。简单来说，路由就是一套映射规则(一对一的对应规则)，由开发人员制定规则。当 URL 中的哈希值( <code>#</code> hash) 发生改变后，路由会根据制定好的规则，展示对应的视图内容。</li></ul></li><li><strong>vue 中的路由</strong>；是 <strong>hash</strong> 和 <strong>component</strong> 的对应关系，一个哈希值对应一个组件</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装路由 : <code>npm i vue-router</code></p><p>引入路由</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue-router/dist/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>详细使用步骤</p><ul><li>实例路由对象并挂载到 vue 实例 上</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由实例 与 Vue 实例 关联到一起</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter()</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>入口 (#哈希值)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">方式1 : url地址为入口 输入url地址改变哈希值</span></span><br><span class="line"><span class="comment">router.html#/one</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方式2 : router-link+to</span></span><br><span class="line"><span class="comment">to 属性：实际上就是哈希值，将来要参与路由规则中进行与组件匹配</span></span><br><span class="line"><span class="comment">router-link 标签最终会转化为 a 标签，to 属性转化为 a 标签的 href 属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/two"</span>&gt;</span>Tow<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注册组件并设置返回值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置规则</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path : 路由路径</span></span><br><span class="line"><span class="comment">// component : 将来要展示的路由组件</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/one'</span>, <span class="attr">component</span>: One&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/two'</span>, <span class="attr">component</span>: Two&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>出口</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  出口：组件要展示的地方--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>示例 ：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 入口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可以直接通过url地址访问路由 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- to 属性：路由匹配路径</span></span><br><span class="line"><span class="comment">router-link 最终会转化为 a 标签</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/two"</span>&gt;</span>Tow<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 5. 出口 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 注册组件并设置返回值</span></span><br><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实例化路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 4. 配置路由规则，路由和实例一一对应</span></span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/one'</span>, <span class="attr">component</span>: One&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/two'</span>, <span class="attr">component</span>: Two&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 2. 将路由挂载到 vue 实例上，让 vue 和路由关联在一起</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>多出口情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 多个出口的形式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"two"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 配置路由规则，一个路由对应多个实例</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      <span class="comment">// conponents 为一个对象</span></span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="comment">// key 为出口的 name 属性值</span></span><br><span class="line">        <span class="comment">// value 为组件实例</span></span><br><span class="line">        one: One,</span><br><span class="line">        two: Two</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="入口菜单高亮处理"><a href="#入口菜单高亮处理" class="headerlink" title="入口菜单高亮处理"></a>入口菜单高亮处理</h3><p>点击导航会给链接添加两个类名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/one"</span> <span class="attr">class</span>=<span class="string">"router-link-exact-active router-link-active"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/two"</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改方式 1：直接修改类的内容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.router-link-exact-active</span>,</span><br><span class="line"><span class="selector-class">.router-link-active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰方式 2：给默认高亮类名设置别名，别名为已经定义好样式的类名 (推荐)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改默认高亮的a标签的类名</span></span><br><span class="line">  linkActiveClass: <span class="string">'red'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="精确匹配和模糊匹配"><a href="#精确匹配和模糊匹配" class="headerlink" title="精确匹配和模糊匹配"></a>精确匹配和模糊匹配</h3><ul><li>精确匹配：router-link-exact-active 类名 : 只有当浏览器地址栏中的哈希值 与 router-link 的 to 属性值完全匹配才会添加该类</li><li>模糊匹配：router-link-active 类名 : 只要浏览器地址栏中的哈希值包含 router-link 的 to 属性值就会添加该类名</li><li>解决办法：加个 exact</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span> <span class="attr">exact</span>&gt;</span></span><br><span class="line">  One</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：精确匹配和模糊匹配，只对添加类名这个机制有效，与路由的匹配规则无关</li></ul><h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>入口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 入口  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/detail/1"</span>&gt;</span>手机1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/detail/2"</span>&gt;</span>手机2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/detail/3"</span>&gt;</span>手机3<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>传参</p><p><a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D" target="_blank" rel="noopener">动态路由匹配</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Detail = Vue.component(<span class="string">'detail'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">routes: [</span><br><span class="line">  <span class="comment">// 方式1：手动一个一个配置</span></span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/1'</span>, <span class="attr">component</span>: Detail&#125;,</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/2'</span>, <span class="attr">component</span>: Detail&#125;,</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/3'</span>, <span class="attr">component</span>: Detail&#125;，</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确的方式：把传过去的 1/2/3 当成参数</span></span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/:id?'</span>, <span class="attr">component</span>: Detail&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>?</code> 代表参数可传可不传，即可识别的路径包括：<code>detail</code>、<code>detail/1</code>、<code>detail2</code>、<code>detail3</code></p><p>获取参数的三种正确方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $route =&gt; 路由配置对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Detail = Vue.component(<span class="string">'detail'</span>, &#123;</span><br><span class="line">  <span class="comment">// 方式1：组件中直接读取</span></span><br><span class="line">  <span class="comment">// $route.path 为路由路径</span></span><br><span class="line">  <span class="comment">// $route.params.id 为路由参数</span></span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// 方式2：js直接读取</span></span><br><span class="line">    <span class="comment">// 打印只会打印一次，因为组件是复用的，每次进来钩子函数只会执行一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #/detail/2?name=zs</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route) <span class="comment">// 路由配置对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.path) <span class="comment">// #/detail/2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.params) <span class="comment">// &#123;id: "2"&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.query) <span class="comment">// &#123;name: 'zs'&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.params.id) <span class="comment">// 2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 方式3：监听路由的参数变化(因为不是 data 中的数据，不需要深度监听)</span></span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// to：新值</span></span><br><span class="line">    <span class="comment">// from：旧值</span></span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(to.params.id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://router.vuejs.org/zh/guide/essentials/navigation.html#%E7%BC%96%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%AF%BC%E8%88%AA" target="_blank" rel="noopener">编程式导航</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">'123'</span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">'/user'</span>) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象, path为路由的path属性值</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span> &#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由，name 为路由的 name 属性值</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 如果提供了 path，params 会被忽略</span></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'register'</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">'private'</span> &#125;&#125;) <span class="comment">// -&gt; /register?plan=private</span></span><br><span class="line"></span><br><span class="line">routes: [&#123; <span class="attr">path</span>: <span class="string">'/user/:id?'</span>, name=<span class="string">'user'</span>, <span class="attr">component</span>: User &#125;]</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><code>redirect</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 / 重定向到 /home</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/home'</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><h3 id="vue-是单文件组件"><a href="#vue-是单文件组件" class="headerlink" title="vue 是单文件组件"></a>vue 是单文件组件</h3><p>后缀为 .vue 的文件</p><p>单文件组件，无法直接在浏览器中使用，必须经过 webpack 这种打包工具处理后，才能在浏览器中使用</p><p>单文件组件的三个组成部分</p><ul><li>template (模板结构)</li><li>script 组件的代码逻辑</li><li>style 样式</li></ul><h3 id="脚手架介绍"><a href="#脚手架介绍" class="headerlink" title="脚手架介绍"></a>脚手架介绍</h3><p><strong>vue-cli</strong> 是 vue 的脚手架工具</p><p>因为 webpack 配置繁琐，阻止一批想用 vue 但是不会 webpack 的开发人员</p><p>vue-cli 提供了一条命令，我们直接通过这条命令就可以快速的生成一个 vue 项目 (<code>vue init XX</code>)，项目的基本结构、以及 webpack 配置项  <strong>全部配置</strong>  好了</p><p><a href="https://vue-loader.vuejs.org/zh/" target="_blank" rel="noopener">Vue Loader</a> 手动配置置 <code>webpack</code></p><p><a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">Vue CLI3</a></p><p><a href="https://vuejs-templates.github.io/webpack/" target="_blank" rel="noopener">Vue webpack 配置</a></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>安装：<code>npm i -g vue-cli</code></p><p>初始化 vue 项目：<code>vue init webpack 项目名称</code></p><p>进入到项目根目录运行项目：<code>npm run dev</code></p><p>项目安装过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">? Project name demo</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author</span><br><span class="line">? Vue build standalone  =&gt; 运行时+编译</span><br><span class="line">? Install vue-router? Yes</span><br><span class="line">? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard</span><br><span class="line">? <span class="built_in">Set</span> up unit tests No</span><br><span class="line">? Setup e2e tests <span class="keyword">with</span> Nightwatch? No</span><br></pre></td></tr></table></figure><h4 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a>项目目录介绍</h4><p><a href="https://vuejs-templates.github.io/webpack/structure.html" target="_blank" rel="noopener">https://vuejs-templates.github.io/webpack/structure.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build/                      # webpack config files</span><br><span class="line">├── config/index.js             # main project config</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.js                 # app entry file</span><br><span class="line">│   ├── App.vue                 # main app component</span><br><span class="line">│   ├── components/             # ui components</span><br><span class="line">│   └── assets/                 # module assets (processed by webpack)</span><br><span class="line">├── static/                     # pure static assets (directly copied)</span><br><span class="line">├── test/</span><br><span class="line">│   └── unit/                   # unit tests</span><br><span class="line">│   └── e2e/                    # e2e tests</span><br><span class="line">├── .babelrc                    # babel config</span><br><span class="line">├── .editorconfig               # settings for your editor</span><br><span class="line">├── .eslintrc.js                # eslint config</span><br><span class="line">├── .eslintignore               # eslint ignore rules</span><br><span class="line">├── .gitignore                  # sensible defaults for gitignore</span><br><span class="line">├── .postcssrc.js               # postcss config</span><br><span class="line">├── index.html                  # index.html template</span><br><span class="line">├── package.json                # build scripts and dependencies</span><br><span class="line">└── README.md                   # Default README file</span><br></pre></td></tr></table></figure><ul><li>build 和 config 不要动，都是一些配置好的，还有一些他们之间的约定</li><li>.gitkeep：static 为预留的文件夹，空文件夹默认不会上传到 github，添加这个文件让static文件夹被 git 上传</li><li><code>.editorconfig</code> 编译器配置，需要安装 vscode 插件：Editorconfig</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">charset = utf-8   utf-8 格式编码</span><br><span class="line">indent_style = space   空格和tab都可以缩进</span><br><span class="line">indent_size = 2    缩进为2个</span><br><span class="line">end_of_line = lf  回车换行</span><br><span class="line">insert_final_newline = true   结束最后一行+一个空白</span><br><span class="line">trim_trailing_whitespace = true   开头去除空白</span><br></pre></td></tr></table></figure><ul><li><code>eslint</code> 校验<ul><li>忽略文件中有这个 =&gt; /*.js =&gt; 意思是根目录下的.js 文件不校验,,但是发现根目录就没有.js 文件</li><li>/*  eslint-disable no-new */ eslint 忽略 no-new规则</li><li>/_ eslint-disable_/ 也可以</li><li>如果去掉,就会提示你 不要以 new 开头</li><li>可以前面给个变量 var vm = new Vue()</li><li>但是又提示没有用,还要打印一下,其实这个赋值是没有意义的</li><li>不要去掉.这是 eslint 的<code>不校验下一行代码</code></li><li><a href="https://standardjs.com/readme-zhcn.html" target="_blank" rel="noopener">standard 代码规范</a></li></ul></li><li>postcssrc 处理 less css 等</li><li>src<ul><li>assets 静态资源</li><li>components 组件</li><li>router 路由</li><li>App.vue 根组件 =&gt; 指定路由出口</li><li>脚手架之后，所有的组件都将渲染到 app.vue 中</li><li>vm 中的 #app 还是 index.html 中的 #app， app.vue 中的会覆盖前者<br>可以通过分别添加 title 属性验证一下</li><li><code>&lt;router-view/&gt;</code> 路由出口要写在 app.vue 组件模板中</li><li>main.js<ul><li>入口 js 文件</li><li>作用：创建 vue 实例，导入其他组件并挂在到 vue 实例上</li><li><code>Vue.config.productionTip = false</code> 不要打印提示</li></ul></li><li>route/index.js：路由<ul><li><code>@</code>：build/ webpack.base.config.js =&gt;  <code>&#39;@&#39;: resolve(&#39;src&#39;)</code></li><li>如果在一个模块化工程中使用它，必须要通过 <code>Vue.use()</code> 明确地安装路由功能</li><li><code>https://router.vuejs.org/zh/installation.html</code></li></ul></li></ul></li></ul><h3 id="两种编译模式"><a href="#两种编译模式" class="headerlink" title="两种编译模式"></a>两种编译模式</h3><p>完整版和运行时版</p><p><a href="https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A" target="_blank" rel="noopener">参考官网</a></p><p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码</p><p>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切</p><ul><li>使用 完整版 (包含编译器)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>只使用运行时</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查看编译模式：build =&gt; webpack.base.config.js =&gt;  <code>&#39;vue\$&#39;: &#39;vue/dist/vue.esm.js&#39;,</code></p><h3 id="手动配置路由"><a href="#手动配置路由" class="headerlink" title="手动配置路由"></a>手动配置路由</h3><p>安装路由 <code>npm i vue-router</code></p><p>准备工作：创建一个文件夹 router/router.js</p><p>具体配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* router.js */</span></span><br><span class="line"><span class="comment">// 引入路由</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'@/components/home/Home'</span>   (template + script + style)</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'@/components/login/Login'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把路由当成插件安装</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由，配置路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 路由规则</span></span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path : <span class="string">'/home'</span>,</span><br><span class="line">    component : Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path : <span class="string">'/login'</span>,</span><br><span class="line">    component : Login</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main.js 中绑定路由</span></span><br><span class="line">router</span><br><span class="line"></span><br><span class="line">在跟组件 App.vue 下配置出口</span><br><span class="line">&lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main.js */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 绑定路由</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置出口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编辑器配置插件"><a href="#编辑器配置插件" class="headerlink" title="编辑器配置插件"></a>编辑器配置插件</h3><ul><li><p><code>vetur</code>：vue 单文件组件的高亮</p></li><li><p>eslint</p><ul><li>关闭 <strong>eslint</strong>：打开 config/index.js，将26行 :  <code>dev.useEslint</code>设置为false，重启项目 ( npm run dev)</li></ul></li><li><p><code>Prettier</code>：格式化插件</p></li></ul><h2 id="TODOMVC-案例"><a href="#TODOMVC-案例" class="headerlink" title="TODOMVC 案例"></a>TODOMVC 案例</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><a href="http://todomvc.com/examples/vue/" target="_blank" rel="noopener">Vue-TodoMVC</a></li><li><a href="https://github.com/tastejs/todomvc-app-template" target="_blank" rel="noopener">下载模板地址</a> <code>git clone https://github.com/tastejs/todomvc-app-template.git</code></li><li>安装依赖包 : <code>npm i</code></li><li>安装 vue : <code>npm i vue</code></li><li>开始 <a href="https://github.com/cuilongjin/todomvc-app-template/tree/master" target="_blank" rel="noopener">https://github.com/cuilongjin/todomvc-app-template/tree/master</a></li></ol><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><ul><li>渲染任务列表：<code>&lt;label&gt;&lt;/label&gt;</code></li><li>任务完成 : <code>:class=&quot;{ completed : item.done }&quot;</code></li><li>多选框选中状态 : <code>v-model=&#39;item.done&#39;</code></li></ul><h3 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h3><ul><li>获取文本输入框的内容 (关键点)<ul><li>把 input 通过 v-model 双向数据绑定 == todoName</li><li>@keyup.enter 触发事件 addTodo =&gt; 拿到 todoName 的值</li><li>判断文本框不能为空</li><li>按回车添加任务</li></ul></li><li>对象{done: false, id: , name : todoName}<ul><li>获取数组里最后一个元素的 id+1</li><li>如果数组之前一个元素都没有 , id = 1</li></ul></li><li>将对象添加进数组</li><li>添加完，清除文本框内容</li></ul><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><ul><li>传索引<br><code>this.todoList.splice(index, 1)</code></li><li>传 id</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id  找到对应的元素索引</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="keyword">this</span>.todoList.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id)</span><br><span class="line"><span class="comment">// 根据索引删除</span></span><br><span class="line"><span class="keyword">this</span>.todoList.splice(index, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>传 id 过滤</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传过来一个 id, 过滤出来不等于这个 id 的元素，重新赋值给 todoList</span></span><br><span class="line"><span class="keyword">this</span>.todoList = <span class="keyword">this</span>.todoList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id !== id)</span><br></pre></td></tr></table></figure><h3 id="编辑任务"><a href="#编辑任务" class="headerlink" title="编辑任务"></a>编辑任务</h3><ul><li><p>显示<code>编辑框</code> ( editing : true) (难点)</p><ul><li>在 data 中添加一个 editId : -1</li><li>在 :class<br>editing: item.id === editId</li><li>双击 : 接收过来双击元素的id<br>this.editId = id</li><li>关键点 :<br>vue 中 data 中的数据一旦发生改变，当前页面的指令和表达式都会重新计算</li></ul></li><li><p>读取内容<br><code>&lt;input class=&quot;edit&quot; v-model=&quot;item.name&quot;&gt;</code></p></li><li><p>回车隐藏编辑框</p></li></ul><h3 id="底部的显示与隐藏"><a href="#底部的显示与隐藏" class="headerlink" title="底部的显示与隐藏"></a>底部的显示与隐藏</h3><ul><li>v-if/v-show</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件部分</span></span><br><span class="line">&lt;footer <span class="class"><span class="keyword">class</span></span>=<span class="string">"footer"</span> v-show=<span class="string">"isFooter()"</span>&gt;</span><br><span class="line"><span class="comment">// js</span></span><br><span class="line">  isFooter() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.todoList.length &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>因为 vue 中 data 的数据发送了改变，当前页面中的指令和表达式都会重新计算，所以只要文本框里的内容发生改变，todoName 也会发送改变，isFooter 会一直被调用，性能不好。我们需要的是数组列表的个数改变才会影响底部的变化，所以需要用到计算属性</p></li><li><p>计算属性</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span> <span class="attr">v-show</span>=<span class="string">"isFooter"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 计算属性 判断底部是否显示</span></span><br><span class="line">  <span class="comment">// 1. 计算属性只会跟着相关属性的值发生变化而变化</span></span><br><span class="line">  <span class="comment">// 2. 一定要有返回值</span></span><br><span class="line">  <span class="comment">// 3. 一定要写在 computed 里面</span></span><br><span class="line">  <span class="comment">// 4. 写起来像一个方法，用起来像一个属性</span></span><br><span class="line">  isFooter () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.todoList.length &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><ul><li>存储数据<ul><li>监听 list 数据的改变，只要 list 数据变了，就调用保存数据的方法</li><li>使用 vue 的 watch 监听 list 的数据改变</li><li>保存值，记得把对象转化为字符串(存的快省空间)</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 监听 todoList</span></span><br><span class="line">  todoList: &#123;</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    handler (newVal) &#123;</span><br><span class="line">   localStorage.setItem(<span class="string">'todoList'</span>, <span class="built_in">JSON</span>.stringify(newVal))</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 data 中可以初始值</span></span><br><span class="line"><span class="comment">// 设置一个默认值 空数组 []</span></span><br><span class="line">todoList: <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'todoList'</span>)) || []</span><br></pre></td></tr></table></figure><h3 id="使用钩子函数来完善数据存储"><a href="#使用钩子函数来完善数据存储" class="headerlink" title="使用钩子函数来完善数据存储"></a>使用钩子函数来完善数据存储</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">this</span>.todoList = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'todoList'</span>)) || []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取接口数据"><a href="#获取接口数据" class="headerlink" title="获取接口数据"></a>获取接口数据</h3><p><a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">json-server</a> 提供假数据接口</p><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a> 发送请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -g json-server</span><br><span class="line">npm i axios</span><br><span class="line">json-server data.json</span><br></pre></td></tr></table></figure><h3 id="组件化TODOMVC"><a href="#组件化TODOMVC" class="headerlink" title="组件化TODOMVC"></a>组件化TODOMVC</h3><p><a href="https://github.com/cuilongjin/todomvc-app-template/tree/zujianhua" target="_blank" rel="noopener">https://github.com/cuilongjin/todomvc-app-template/tree/zujianhua</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="框架" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="vue" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/vue/"/>
    
    
      <category term="vue" scheme="http://blog.clj.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="http://blog.clj.me/2019/vue/vue+elementui/"/>
    <id>http://blog.clj.me/2019/vue/vue+elementui/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-19T11:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p>组件抽离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 标签不要动，只需要把内容题出去后，添加 src 引入即可</span><br><span class="line">&lt;template src=&quot;./Roles.html&quot;&gt;&lt;/template&gt;</span><br><span class="line">&lt;script src=&quot;./Roles.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style src=&quot;./Roles.less&quot; lang=&quot;less&quot; scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>scoped</p><p>vue 组件之间的样式有自动复用的问题，给一个类设置样式，其他组件中相同类的元素也会被设置样式</p><p>解决：在 <code>style</code> 标签上添加 <code>scoped</code> 字段，设置样式只作用于当前组件</p><p> <code>&lt;style scoped&gt;&lt;/style&gt;</code></p><p>作用 1：让当前组件内的样式，只能在当前组件上起效果<br>作用 2：如果添加了 scoped，样式只会对本来就存在的标签/组件起效果，如果是动态添加的组件/标签，是无效的</p><p>动态添加的组件/标签，在 <code>.vue</code>文件里添加一个 style 标签，在标签里设置该样式属性，或者在选择器前添加<code>/deep/</code></p><p>vm.$nextTick( [callback] )：将回调延迟到下次 DOM 更新循环之后执行</p><p>如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise：<code>await this.$nextTick()</code></p><p>插槽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">通过 scope.row 获取当前行的数据</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面跳转</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'login'</span> &#125;)</span><br><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="element"><a href="#element" class="headerlink" title="element"></a>element</h2><p><code>span=&#39;1&#39;</code>：赋值 span 的是一个字符串 ‘1’</p><p><code>:span=&#39;1&#39;</code>：前面加一个<code>:</code> 意思是动态数据绑定，赋值 span 的是具体数据类型的数据，即数字  1</p><h3 id="时间日期选择器"><a href="#时间日期选择器" class="headerlink" title="时间日期选择器"></a>时间日期选择器</h3><p>日期选择器限制选择范围</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-date-picker</span> <span class="attr">v-model</span>=<span class="string">"options.endDate"</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">:picker-options</span>=<span class="string">"endDateOptions"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-date-picker</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">endDateOptions: &#123;</span><br><span class="line">  disabledDate: <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 限制结束时间范围为大于开始时间，并在一周内</span></span><br><span class="line">  <span class="keyword">return</span> time.getTime() &lt; <span class="keyword">this</span>.options.startDate || time.getTime() &gt; <span class="keyword">this</span>.options.startDate + <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tree-树形控件"><a href="#Tree-树形控件" class="headerlink" title="Tree 树形控件"></a>Tree 树形控件</h3><ul><li>Attributes</li></ul><p>show-checkbox：节点是否可被选择</p><p>default-expand-all：是否默认展开所有节点</p><p>node-key： 每个树节点用来作为唯一标识的属性，整棵树应该是唯一的</p><ul><li>方法</li></ul><p>this.$refs.tree.setCheckedKeys：通过 keys 设置目前勾选的节点，使用此方法必须设置 node-key 属性</p><p>this.$refs.tree.getCheckedKeys：若节点可被选择（即 show-checkbox 为 true），则返回目前被选中的节点的 key 所组成的数组</p><h3 id="NavMenu-导航菜单"><a href="#NavMenu-导航菜单" class="headerlink" title="NavMenu 导航菜单"></a>NavMenu 导航菜单</h3><h4 id="Menu-Attribute"><a href="#Menu-Attribute" class="headerlink" title="Menu Attribute"></a>Menu Attribute</h4><p>router：是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转</p><p>background-color：菜单的背景色（仅支持 hex 格式）#ffffff</p><p>text-color：菜单的文字颜色（仅支持 hex 格式）</p><p>active-text-color：当前激活菜单的文字颜色（仅支持 hex 格式）</p><p>default-active：当前激活菜单的 index</p><p>unique-opened：是否只保持一个子菜单的展开</p><h3 id="Table-表格"><a href="#Table-表格" class="headerlink" title="Table 表格"></a>Table 表格</h3><h4 id="Table-column-Attributes"><a href="#Table-column-Attributes" class="headerlink" title="Table-column Attributes"></a>Table-column Attributes</h4><ul><li>type：设置 <code>index</code> 则显示该行的索引（从 1 开始计算）；设置 <code>expand</code> 则显示为一个可展开的按钮；</li></ul><p>设置了 <code>selection</code> 则显示多选框</p><ul><li>自定义索引 <code>index</code>：如果设置了 <code>type=index</code>，可以通过传递 <code>index</code> 属性来自定义索引，属性传入数字时，将作为索引的起始值。传入方法是，它提供当前行的行号（从 <code>0</code> 开始）作为参数，返回值将作为索引展示。</li></ul><p><code>type=&quot;index&quot; :index=&quot;indexMethod&quot;</code>  <code>indexMethod(index) {return index}</code></p><h3 id="Radio-单选框"><a href="#Radio-单选框" class="headerlink" title="Radio 单选框"></a>Radio 单选框</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-radio v-model=&quot;radio&quot; label=&quot;1&quot;&gt;备选项&lt;/el-radio&gt;</span><br><span class="line">&lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;备选项&lt;/el-radio&gt;</span><br></pre></td></tr></table></figure><p>选中意味着变量的值为相应 <code>label</code> 属性的值，<code>label</code>可以是<code>String</code>、<code>Number</code>或<code>Boolean</code>。</p><h4 id="禁用状态"><a href="#禁用状态" class="headerlink" title="禁用状态"></a>禁用状态</h4><p>设置<code>disabled</code>属性<code>true</code>为禁用</p><h4 id="单选框组"><a href="#单选框组" class="headerlink" title="单选框组"></a>单选框组</h4><p>结合 el-radio-group 元素和子元素 el-radio 可以实现单选组，在 el-radio-group 中绑定 v-model，在 el-radio 中设置好 label 即可，无需再给每一个 el-radio 绑定变量，另外，还提供了 change 事件来响应变化，它会传入一个参数value</p><h4 id="Radio-Events"><a href="#Radio-Events" class="headerlink" title="Radio Events"></a>Radio Events</h4><p>change：绑定值变化时触发的事件  选中的 Radio label 值</p><h3 id="Cascader-级联选择器"><a href="#Cascader-级联选择器" class="headerlink" title="Cascader 级联选择器"></a>Cascader 级联选择器</h3><h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>options：可选项数据源，键名可通过 <code>props</code> 属性配置</p><p>props：配置选项，对象</p><p>​    value：指定选项的值为选项对象的某个属性值</p><p>​    label：指定选项标签为选项对象的某个属性值</p><p>​    children：指定选项的子选项为选项对象的某个属性值</p><h3 id="Upload-上传"><a href="#Upload-上传" class="headerlink" title="Upload 上传"></a>Upload 上传</h3><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><ul><li><p>action: 必选参数，上传的完整地址</p></li><li><p>multiple: 是否支持多选文件</p></li><li><p>:on-preview: 点击文件列表中已上传的文件时的钩子  function(file)</p></li><li><p>:on-remove: 文件列表移除文件时的钩子 function(file, fileList)</p></li><li><p>list-type: 文件列表的类型</p></li><li><p>:before-upload: 对文件校验 function(file)，若返回 false 或者返回 Promise 且被 reject，则停止上传</p></li><li><p>:on-success: 文件上传成功时的钩子  function(response, file, fileList)</p></li></ul><p>​    response：参数一， 接口的响应结；file：参数二， 文件对象；fileLIst：参数三，文件对象列表</p><p>​    自定义参数 <code>:on-success=&quot;(res, file, fileList) =&gt; UploadImg(1, res, file, fileList)&quot;</code></p><ul><li><p>headers: 设置上传的请求头部 object</p></li><li><p>:auto-upload=”false”：手动调用<code>this.$refs.upload.submit()</code>上传</p></li><li><p>on-progress: 文件上传时的钩子    function(event, file, fileList)</p></li></ul><h3 id="Steps-步骤条"><a href="#Steps-步骤条" class="headerlink" title="Steps 步骤条"></a>Steps 步骤条</h3><p>active    设置当前激活步骤    number</p><p>设置<code>active</code>属性，接受一个<code>Number</code>，表明步骤的 index，从 0 开始</p><h3 id="Tabs-标签页"><a href="#Tabs-标签页" class="headerlink" title="Tabs 标签页"></a>Tabs 标签页</h3><h4 id="Tabs-Attributes"><a href="#Tabs-Attributes" class="headerlink" title="Tabs Attributes"></a>Tabs Attributes</h4><p>value / v-model    绑定值，选中选项卡的 name       string    —    第一个选项卡的 name</p><p>tab-position    选项卡所在位置    string    top/right/bottom/left    top</p><h4 id="Tabs-Events"><a href="#Tabs-Events" class="headerlink" title="Tabs Events"></a>Tabs Events</h4><p>tab-click    tab 被选中时触发    被选中的标签 tab 实例</p><h3 id="element-中的-Events-和-Methods"><a href="#element-中的-Events-和-Methods" class="headerlink" title="element 中的 Events 和 Methods"></a>element 中的 Events 和 Methods</h3><p>// 假设有个el-box ,如果看文档,有个 Events 和 Methods<br><el-box></el-box></p><p>// Events<br>close</p><p>// Methdos<br>getData</p><p>// 使用<br>&lt;el-box ref=’box’ @close=’函数名自己写’&gt;</p><p>this.$refs.box.getData()</p><h3 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h3><p>打包 :  npm run build<br>把打好的包放到 http-server 里面</p><p>介绍 vendor : 里面放一些第三方包 vue/vue-router/element-ui 包等</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化 :"></a>优化 :</h4><ul><li><p>按需加载</p></li><li><p>首屏加载时间，是衡量一个网站性能快慢的很重要的一个指标</p></li><li><p>如何提高加载速度呢?</p></li></ul><p>只加载首屏中看到的内容，没有看到的内容都不加载，需要用到的时候，再去加载<br>进来减少首屏的请求次数</p><ul><li>vue 项目打包的时候，如何实现按需加载功能 ?</li></ul><p>vue 的异步组件(路由) 配合 webpack 代码分割的功能实现按需加载功能</p><p>路由懒加载：<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'Home.vue'</span></span><br><span class="line">==&gt;</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'Home.vue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个组件打包在一起</span></span><br><span class="line"><span class="keyword">const</span> Goods = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'goods' */</span> <span class="string">'Goods.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> GoodsAdd = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'goods' */</span> <span class="string">'GoodsAdd.vue'</span>)</span><br></pre></td></tr></table></figure><ul><li>CDN</li></ul><p>在 index.html 引入 CDN 提供的文件</p><p>在 webpack.base.conf.js中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  <span class="comment">// 键：表示 导入包语法 from 后面跟着的名称</span></span><br><span class="line">  <span class="comment">// 值：表示 script 引入JS文件时，在全局环境中的变量名称</span></span><br><span class="line">  vue: <span class="string">'Vue'</span>,</span><br><span class="line">  <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">  axios: <span class="string">'axios'</span>,</span><br><span class="line">  <span class="string">'element-ui'</span>: <span class="string">'ELEMENT'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 index.html 引入 css 文件就不需要在 main.js 中引入了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue&quot;&gt;&lt;a href=&quot;#vue&quot; class=&quot;headerlink&quot; title=&quot;vue&quot;&gt;&lt;/a&gt;vue&lt;/h2&gt;&lt;p&gt;组件抽离&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="框架" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="vue" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/vue/"/>
    
      <category term="element" scheme="http://blog.clj.me/categories/element/"/>
    
    
      <category term="vue" scheme="http://blog.clj.me/tags/vue/"/>
    
      <category term="element" scheme="http://blog.clj.me/tags/element/"/>
    
  </entry>
  
  <entry>
    <title>Vue 生命周期</title>
    <link href="http://blog.clj.me/2019/vue/vue-lifecycle/"/>
    <id>http://blog.clj.me/2019/vue/vue-lifecycle/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-13T12:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">生命周期</a></p><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p><p><img src="lifecycle.png" alt title=":no-zoom"></p><p><img src="Vue%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE.png" alt title=":no-zoom"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="框架" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="vue" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/vue/"/>
    
    
      <category term="vue" scheme="http://blog.clj.me/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://blog.clj.me/2019/javascript/promise/"/>
    <id>http://blog.clj.me/2019/javascript/promise/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-23T09:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul><li>Promise 是<code>异步编程</code>的一种解决方案，它允许你以一种同步的方式编写异步代码</li><li><code>promise</code>：承诺、保证</li><li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES6 - Promise</a></li><li>JS 是通过回调函数来实现异步编程的，当异步操作多了以后，就会产生回调嵌套回调的问题，这就是<code>回调地狱</code></li><li>Promise 方式：将异步操作以同步操作的方式表达出来，避免了层层嵌套的回调函数</li></ul><h2 id="封装一个-Promise"><a href="#封装一个-Promise" class="headerlink" title="封装一个 Promise"></a>封装一个 Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按序读取文件：a -&gt; b -&gt; c</span></span><br><span class="line"><span class="comment">// 按顺序读取 a b c 文件</span></span><br><span class="line"><span class="comment">// 以前</span></span><br><span class="line"><span class="comment">// 读取 a 文件</span></span><br><span class="line">fs.readFile(<span class="string">'./a'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 b 文件</span></span><br><span class="line">  fs.readFile(<span class="string">'./b'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 c 文件</span></span><br><span class="line">    fs.readFile(<span class="string">'./a'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise</span></span><br><span class="line"><span class="comment">// 封装</span></span><br><span class="line"><span class="comment">// Promise 是一个构造函数</span></span><br><span class="line"><span class="comment">// 通过 new 创建 Promise 的实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化 Promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve 表示成功，异步操作成功调用</span></span><br><span class="line">    <span class="comment">// reject  表示失败，异步操作失败调用</span></span><br><span class="line">    fs.readFile(path, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 读取错误，调用 reject()</span></span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取成功 调用 resolve</span></span><br><span class="line">      resolve(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 Promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">readFile(<span class="string">'a'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'a'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="promise-的三个状态"><a href="#promise-的三个状态" class="headerlink" title="promise 的三个状态"></a>promise 的三个状态</h2><ul><li><p>pending : 等待  (等待成功或者失败去调用)</p></li><li><p>resolved : 成功调用</p></li><li><p>rejected : 失败调用</p></li></ul><h2 id="then-和-catch"><a href="#then-和-catch" class="headerlink" title="then 和 catch"></a>then 和 catch</h2><ul><li>说明：获取异步操作的结果</li><li><code>then()</code> ：用于获取异步操作成功时的结果 -&gt; <em>resolve</em></li><li><code>catch()</code>：用于获取异步操作失败时的结果 -&gt; <em>reject</em></li><li>说明：<code>then()</code>方法可以有多个，按照先后顺序执行，通过回调函数返回值传递数据给下一个 then</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件a的内容为：'</span>, value)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 失败（比如：文件路径错误）</span></span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件读取失败：'</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------- 或者 -----------</span></span><br><span class="line">p.then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="all-和-race"><a href="#all-和-race" class="headerlink" title="all 和 race"></a>all 和 race</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有请求完成，才会执行后续代码</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  axios(<span class="string">'/a'</span>),</span><br><span class="line">  axios(<span class="string">'/b'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// res 是 all() 方法中所有异步操作的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有一个请求完成，就会继续执行后续代码</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  axios(<span class="string">'/a'</span>),</span><br><span class="line">  axios(<span class="string">'/b'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// res 是 race() 方法中先完成的异步操作的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><ul><li>异步编程终极方案</li></ul><ul><li>async / await 用同步编写代码的方式 处理异步操作的一个方案</li><li>async：修饰 (修饰一个内部有异步操作的函数)    格式 :  async + 函数 (里面有异步操作的函数)</li><li>await : 等待 (等上一个异步操作完成啊 , 修饰 一个结果是promise的)异步操作    格式 : await + 异步操作(结果promise对象)</li><li>async 和 await 是成对出现的，await 只能在 async 函数中使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 实例化 promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 操作错误 调用 =&gt;  reject  =&gt; catch</span></span><br><span class="line">        <span class="keyword">return</span> reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 操作成功  调用 =&gt; resolve =&gt; then</span></span><br><span class="line">      resolve(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 2. 返回 promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：使用 (async/await)</span></span><br><span class="line"><span class="comment">// async + 函数 (里面有异步操作的函数)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await + 异步操作(结果promise对象)</span></span><br><span class="line">  <span class="comment">// 读取a文件</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFile(<span class="string">'./data/a1.txt'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 b 文件</span></span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFile(<span class="string">'./data/b.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 c 文件</span></span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> readFile(<span class="string">'./data/c.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(b)</span><br><span class="line">    &#125;, a)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> sleep(<span class="number">1000</span>, <span class="string">'a'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res1)</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> sleep(<span class="number">5000</span>, <span class="string">'b'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> sleep(<span class="number">3000</span>, <span class="string">'c'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn()</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>, <span class="string">'a'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> sleep(<span class="number">5000</span>, <span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> sleep(<span class="number">3000</span>, <span class="string">'c'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.all([sleep(<span class="number">1000</span>, <span class="string">'a'</span>), sleep(<span class="number">5000</span>, <span class="string">'b'</span>)])</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.race([sleep(<span class="number">1000</span>, <span class="string">'a'</span>), sleep(<span class="number">5000</span>, <span class="string">'b'</span>)])</span><br><span class="line">p2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Promise 是&lt;code&gt;异步编程&lt;/code&gt;的一种解决方案，它允许你以一种同步的
      
    
    </summary>
    
      <category term="js" scheme="http://blog.clj.me/categories/js/"/>
    
    
      <category term="promise" scheme="http://blog.clj.me/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>nodejs</title>
    <link href="http://blog.clj.me/2018/javascript/nodejs/"/>
    <id>http://blog.clj.me/2018/javascript/nodejs/</id>
    <published>2018-12-29T10:00:00.000Z</published>
    <updated>2019-03-19T05:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nodejs基本介绍"><a href="#nodejs基本介绍" class="headerlink" title="nodejs基本介绍"></a>nodejs基本介绍</h1><h2 id="为什么要学习nodejs"><a href="#为什么要学习nodejs" class="headerlink" title="为什么要学习nodejs"></a>为什么要学习nodejs</h2><ol><li>降低编程语言切换的成本(nodejs实质上用的还是javascript)</li><li>NodeJS是前端项目的基础设施，前端项目中用到的大量工具 (大前端)</li><li>nodejs在处理高并发上有得天独厚的优势(利用nodejs做中间层)</li><li>对于前端工程师，面试时对于nodejs有一定的要求</li></ol><h2 id="node-js-是什么？"><a href="#node-js-是什么？" class="headerlink" title="node.js 是什么？"></a>node.js 是什么？</h2><p>node.js，也叫作node，或者nodejs，指的都是一个平台</p><ol><li><a href="https://nodejs.org/" target="_blank" rel="noopener">node.js官方网站</a></li><li><a href="http://nodejs.cn/" target="_blank" rel="noopener">node.js中文网</a></li><li><a href="https://cnodejs.org/" target="_blank" rel="noopener">node.js 中文社区</a></li></ol><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，nodejs 允许 javascript 代码运行在服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. nodejs不是一门新的编程语言，nodejs是在服务端运行javascript的运行环境</span><br><span class="line">2. 运行环境：写得程序想要运行必须要有对应的运行环境</span><br><span class="line">php代码必须要有apache服务器</span><br><span class="line">在web端，浏览器就是javascript的运行环境</span><br><span class="line">在node端，nodejs就是javascript的运行环境</span><br><span class="line">2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。</span><br><span class="line">3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎</span><br></pre></td></tr></table></figure><p><strong>nodejs的本质：不是一门新的编程语言，nodejs是javascript运行在服务端的运行环境，编程语言还是javascript</strong></p><h2 id="nodejs与浏览器的区别"><a href="#nodejs与浏览器的区别" class="headerlink" title="nodejs与浏览器的区别"></a>nodejs与浏览器的区别</h2><p>相同点：nodejs与浏览器都是js的运行环境，都能够解析js程序。对于ECMAScript语法来说，在nodejs和浏览器中都能运行</p><p>不同点：nodejs无法使用DOM和BOM的操作，浏览器无法执行nodejs中的文件操作等功能</p><p><img src="nodejs.png" alt></p><h2 id="nodejs可以干什么？"><a href="#nodejs可以干什么？" class="headerlink" title="nodejs可以干什么？"></a>nodejs可以干什么？</h2><ol><li>开发服务端程序</li><li>开发命令行工具（CLI），比如npm，webpack，gulp，less，sass等</li><li>开发桌面应用程序（借助 node-webkit、electron 等框架实现）</li></ol><h1 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h1><h2 id="nodejs版本"><a href="#nodejs版本" class="headerlink" title="nodejs版本"></a>nodejs版本</h2><p>下载地址</p><ul><li><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">当前版本</a></li><li><a href="https://nodejs.org/en/download/releases/" target="_blank" rel="noopener">历史版本</a></li></ul><p>官网术语解释</p><ul><li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li><li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入</li></ul><p>查看node版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h1 id="运行nodejs程序"><a href="#运行nodejs程序" class="headerlink" title="运行nodejs程序"></a>运行nodejs程序</h1><h2 id="方式一：使用node执行js文件"><a href="#方式一：使用node执行js文件" class="headerlink" title="方式一：使用node执行js文件"></a>方式一：使用node执行js文件</h2><ul><li>创建js文件 <code>helloworld.js</code></li></ul><ul><li>写nodejs的内容：<code>console.log(&#39;hello nodejs&#39;)</code></li><li>打开命令窗口 <code>cmd</code><ul><li>shift加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li></ul></li><li>执行命令：<code>node helloworld.js</code></li></ul><p>注意：在nodejs中是无法使用DOM和BOM的内容的，因此<code>document</code>， <code>window</code>等内容是无法使用的</p><h2 id="方式二：REPL介绍"><a href="#方式二：REPL介绍" class="headerlink" title="方式二：REPL介绍"></a>方式二：REPL介绍</h2><ol><li>REPL 全称: Read-Eval-Print-Loop（交互式解释器）<ul><li>R 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中</li><li>E 执行 - 执行输入的数据结构</li><li>P 打印 - 输出结果</li><li>L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出</li></ul></li><li>在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能）<ul><li>直接在控制台输入 <code>node</code> 命令进入 REPL 环境</li></ul></li><li>按两次 Control + C 退出REPL界面 或者 输入 <code>.exit</code> 退出 REPL 界面<ul><li>按住 control 键不要放开, 然后按两下 c 键</li></ul></li></ol><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>当要求系统运行一个<strong>程序</strong> 而没有告诉它程序所在的完整路径时</p><ol><li>首先在<strong>当前目录</strong>中查找和该字符串匹配的可执行文件</li><li>进入用户 path 环境变量查找</li><li>进入系统 path 环境变量查找</li></ol><p>配置环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找到环境变量：计算机 --右键--&gt; 属性 --&gt; 高级系统设置 --&gt; 高级 --&gt; 环境变量</span><br></pre></td></tr></table></figure><h1 id="global模块-全局变量"><a href="#global模块-全局变量" class="headerlink" title="global模块-全局变量"></a>global模块-全局变量</h1><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p><p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 <code>global</code>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p><p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p><p><strong>常用的 global 属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>: 用于打印日志</span><br><span class="line">setTimeout/clearTimeout: 设置清除延时器</span><br><span class="line">setInterval/clearInterval: 设置清除定时器</span><br><span class="line"></span><br><span class="line">__dirname: 当前文件的路径，不包括文件名</span><br><span class="line">__filename：当前文件的路径，包括文件名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与模块化相关的，模块化的时候会用到</span></span><br><span class="line"><span class="built_in">require</span></span><br><span class="line">exports</span><br><span class="line"><span class="built_in">module</span></span><br></pre></td></tr></table></figure><h1 id="fs-模块"><a href="#fs-模块" class="headerlink" title="fs 模块"></a>fs 模块</h1><blockquote><p>fs 模块是 nodejs 中最常用的一个模块，因此掌握fs模块非常的有必要，fs模块的方法非常多，用到了哪个查哪个即可。</p><p>文档地址：<a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html</a></p></blockquote><p>  在 nodejs 中，提供了 fs 模块，这是 node 的核心模块</p><p>  注意：</p><ol><li>除了 global 模块中的内容可以直接使用，其他模块都是需要加载的。</li><li>fs 模块不是全局的，不能直接使用。因此需要导入才能使用。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br></pre></td></tr></table></figure><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><blockquote><p>语法：fs.readFile(file[, options], callback)</p></blockquote><p>方式一：不传编码参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件路径</span></span><br><span class="line"><span class="comment">// 参数2：读取文件的回调函数</span></span><br><span class="line">  <span class="comment">// 参数1：错误对象，如果读取失败，err 会包含错误信息，如果读取成功，err 是 null</span></span><br><span class="line">  <span class="comment">// 参数2：读取成功后的数据（是一个Buffer对象）</span></span><br><span class="line">fs.readFile(<span class="string">'data.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString()) <span class="comment">// 将Buffer对象转换成字符串</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方式二：传编码参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件的路径</span></span><br><span class="line"><span class="comment">// 参数2：编码，如果设置了，返回一个字符串，如果没有设置，会返回一个buffer对象</span></span><br><span class="line"><span class="comment">// 参数3：回调函数</span></span><br><span class="line">fs.readFile(<span class="string">'data.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关于Buffer对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Buffer对象是Nodejs用于处理二进制数据的</span><br><span class="line">2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制</span><br><span class="line">3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象</span><br><span class="line">4. Buffer对象可以调用toString()方法转换成字符串</span><br></pre></td></tr></table></figure><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><blockquote><p>语法：fs.writeFile(file, data[, options], callback)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：文件路径(如果文件不存在，会自动创建)</span></span><br><span class="line"><span class="comment">// 参数2：写入的文件内容（注意：写入的内容会覆盖以前的内容）</span></span><br><span class="line"><span class="comment">// 参数3：写文件后的回调函数</span></span><br><span class="line">fs.writeFile(<span class="string">'2.txt'</span>, <span class="string">'hello world'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'写入文件失败'</span>, err)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'写入文件成功'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>写文件的时候，会把原来的内容给覆盖掉</li></ol><blockquote><p>语法：fs.appendFile(path, data[, options], callback)</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：追加的文件名(如果文件不存在，会自动创建)</span></span><br><span class="line"><span class="comment">// 参数2：追加的文件内容</span></span><br><span class="line"><span class="comment">// 参数3：追加文件后的回调函数</span></span><br><span class="line">fs.appendFile(<span class="string">'2.txt'</span>, <span class="string">'我是追加的内容'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'追加文件内容失败'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'追加文件内容成功'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>思考：如果没有appendFile，通过readFile与writeFile应该怎么实现？</p><h2 id="文件同步与异步的说明"><a href="#文件同步与异步的说明" class="headerlink" title="文件同步与异步的说明"></a>文件同步与异步的说明</h2><blockquote><p>fs中所有的文件操作，都提供了异步和同步两种方式</p></blockquote><p>异步方式：不会阻塞代码的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步方式</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">fs.readFile(<span class="string">'2.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取文件失败'</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'222'</span>)</span><br></pre></td></tr></table></figure><p>同步方式：会阻塞代码的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方式</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line"><span class="keyword">const</span> result = fs.readFileSync(<span class="string">"2.txt"</span>, <span class="string">"utf-8"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">222</span>);</span><br></pre></td></tr></table></figure><p>总结：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p><h2 id="其他api（了解）"><a href="#其他api（了解）" class="headerlink" title="其他api（了解）"></a>其他api（了解）</h2><p>方法有很多，但是用起来都非常的简单，学会查文档</p><p>文档：<a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html</a></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>fs.readFile(path,  callback)</code></td><td>读取文件内容（异步）</td></tr><tr><td><code>fs.readFileSync(path)</code></td><td>读取文件内容（同步）</td></tr><tr><td><code>fs.writeFile(path,  data,  callback)</code></td><td>写入文件内容（异步）</td></tr><tr><td><code>fs.writeFileSync(path,  data)</code></td><td>写入文件内容（同步）</td></tr><tr><td><code>fs.appendFile(path,  data,  callback)</code></td><td>追加文件内容（异步）</td></tr><tr><td><code>fs.appendFileSync(path,  data)</code></td><td>追加文件内容（同步）</td></tr><tr><td><code>fs.rename(oldPath,  newPath,  callback)</code></td><td>重命名文件（异步）</td></tr><tr><td><code>fs.renameSync(oldPath,  newPath)</code></td><td>重命名文件（同步）</td></tr><tr><td><code>fs.unlink(path,  callback)</code></td><td>删除文件（异步）</td></tr><tr><td><code>fs.unlinkSync(path)</code></td><td>删除文件（同步）</td></tr><tr><td><code>fs.mkdir(path,  mode,  callback)</code></td><td>创建文件夹（异步）</td></tr><tr><td><code>fs.mkdirSync(path,  mode)</code></td><td>创建文件夹（同步）</td></tr><tr><td><code>fs.rmdir(path,  callback)</code></td><td>删除文件夹（异步）</td></tr><tr><td><code>fs.rmdirSync(path)</code></td><td>删除文件夹（同步）</td></tr><tr><td><code>fs.readdir(path,  option,  callback)</code></td><td>读取文件夹内容（异步）</td></tr><tr><td><code>fs.readdirSync(path,  option)</code></td><td>读取文件夹内容（同步）</td></tr><tr><td><code>fs.stat(path,  callback)</code></td><td>查看文件状态（异步）</td></tr><tr><td><code>fs.statSync(path)</code></td><td>查看文件状态（同步）</td></tr></tbody></table><h1 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h1><h2 id="路径操作的问题"><a href="#路径操作的问题" class="headerlink" title="路径操作的问题"></a>路径操作的问题</h2><p>在读写文件的时候，文件路径可以写相对路径或者绝对路径</p><p>data.txt 是相对路径，读取当前目录下的 data.txt，相对路径相对的是指向node命令的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果node命令不是在当前目录下执行就会报错，在当前执行node命令的目录下查找data.txt，找不到</span></span><br><span class="line">fs.readFile(<span class="string">'data.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取文件失败'</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相对路径：相对于执行node命令的路径</p><p>推荐使用绝对路径：<code>__dirname</code>: 当前文件的目录，<code>__filename</code>: 当前文件的目录，包含文件名</p><h2 id="path模块的常用方法"><a href="#path模块的常用方法" class="headerlink" title="path模块的常用方法"></a>path模块的常用方法</h2><blockquote><p>关于路径，在linux系统中，路径分隔符使用的是<code>/</code>，但是在windows系统中，路径使用的<code>\</code></p></blockquote><p>在我们拼写路径的时候会带来很多的麻烦，经常会出现windows下写的代码，在linux操作系统下执行不了，path模块就是为了解决这个问题而存在的。</p><p>常用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">path.join() <span class="comment">// 拼接路径，返回拼接后的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// windows系统下</span></span><br><span class="line">path.join(<span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'gg'</span>, <span class="string">'index.html'</span>)</span><br><span class="line"><span class="string">'abc\def\gg\a.html'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// linux系统下</span></span><br><span class="line">path.join(<span class="string">'abc'</span>,<span class="string">'def'</span>,<span class="string">'gg'</span>, <span class="string">'index.html'</span>)</span><br><span class="line"><span class="string">'abc/def/gg/index.html'</span></span><br><span class="line"></span><br><span class="line">【优化读写文件的代码】</span><br><span class="line"></span><br><span class="line">其他方法:</span><br><span class="line">path.basename(path[, ext])返回文件的最后一部分</span><br><span class="line">path.dirname(path)返回路径的目录名</span><br><span class="line">path.extname(path)获取路径的扩展名(后缀名)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> temp = <span class="string">'abc\\def\\gg\\a.html'</span></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(temp)) <span class="comment">//a.html</span></span><br><span class="line"><span class="built_in">console</span>.log(path.dirname(temp)) <span class="comment">//abc\def\gg</span></span><br><span class="line"><span class="built_in">console</span>.log(path.extname(temp)) <span class="comment">//.html</span></span><br></pre></td></tr></table></figure><h2 id="path模块其他api（了解）"><a href="#path模块其他api（了解）" class="headerlink" title="path模块其他api（了解）"></a>path模块其他api（了解）</h2><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>path.basename(path[, ext])</code></td><td>返回文件的最后一部分</td></tr><tr><td><code>path.dirname(path)</code></td><td>返回路径的目录名</td></tr><tr><td><code>path.extname(path)</code></td><td>获取路径的扩展名</td></tr><tr><td><code>path.isAbsolute(path)</code></td><td>判断目录是否是绝对路径</td></tr><tr><td><code>path.join([...paths])</code></td><td>将所有的path片段拼接成一个规范的路径</td></tr><tr><td><code>path.normalize(path)</code></td><td>规范化路径</td></tr><tr><td><code>path.parse(path)</code></td><td>将一个路径解析成一个path对象</td></tr><tr><td><code>path.format(pathObj)</code></td><td>讲一个path对象解析成一个规范的路径</td></tr></tbody></table><h1 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h1><h2 id="创建服务器基本步骤"><a href="#创建服务器基本步骤" class="headerlink" title="创建服务器基本步骤"></a>创建服务器基本步骤</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入http模块，http模块是node的核心模块，作用是用来创建 http 服务器的</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 服务器处理请求</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我接收到请求了'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 启动服务器，监听某个端口</span></span><br><span class="line">server.listen(<span class="number">9999</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'服务器启动成功了, 请访问： http://localhost:9999'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>详细说明</p><ol><li>给服务器注册 request 事件，只要服务器接收到了客户端的请求，就会触发 request 事件</li><li>request事件有两个参数，req表示请求对象，可以获取所有与请求相关的信息，res是响应对象，可以获取所有与响应相关的信息</li><li>服务器监听的端口范围为：1-65535之间，推荐使用3000以上的端口，因为3000以下的端口一般留给系统使用</li></ol><h2 id="request-对象详解"><a href="#request-对象详解" class="headerlink" title="request 对象详解"></a>request 对象详解</h2><p>文档地址：<a href="http://nodejs.cn/api/http.html#http_message_headers" target="_blank" rel="noopener">http://nodejs.cn/api/http.html#http_message_headers</a></p><p>常见属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">headers: 所有的请求头信息</span><br><span class="line">method：请求的方式</span><br><span class="line">rawHeaders：所有的请求头信息（数组的方式）</span><br><span class="line">url：请求的地址（url地址的路径部分）</span><br><span class="line">请求 http:<span class="comment">//127.0.0.1:3000/index 获取到的是：/index</span></span><br><span class="line">请求 http:<span class="comment">//127.0.0.1:3000 获取到的是：/</span></span><br></pre></td></tr></table></figure><p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求</p><p>小结：request对象中，常用的就是 method 和 url 两个参数</p><h2 id="response-对象详解"><a href="#response-对象详解" class="headerlink" title="response 对象详解"></a>response 对象详解</h2><p>文档地址：<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse" target="_blank" rel="noopener">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p><p>常见的属性和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">res.write(data): 给浏览器发送响应体，可以调用多次，从而提供连续的响应体</span><br><span class="line">res.end()：通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成</span><br><span class="line">res.end(data)：结束请求，并且响应一段内容，相当于res.write(data) + res.end()</span><br><span class="line">res.statusCode: 响应的的状态码 <span class="number">200</span> <span class="number">404</span> <span class="number">500</span></span><br><span class="line">res.statusMessage: 响应的状态信息（不能有中文）， 如果不设置会根据statusCode自动设置</span><br><span class="line">res.setHeader(name, value)：设置响应头信息，比如<span class="string">'content-type'</span>，<span class="string">'text/html;charset=utf-8'</span></span><br><span class="line">res.writeHead(statusCode, statusMessage, options)：设置响应头，同时可以设置状态码和状态信息</span><br><span class="line">options 是对象，写响应头的键值对</span><br></pre></td></tr></table></figure><p><strong>注意：必须先设置响应头，才能设置响应主体。</strong></p><ul><li><p>注意：浏览器中输入的URL地址，仅仅是一个标识，可以不与服务器中的文件路径一致。也就是说：返回什么内容是由服务端的逻辑决定</p></li><li><p>路由 : url标示和对应文件/数据的一一对应关系</p></li></ul><h2 id="模拟Apache服务器"><a href="#模拟Apache服务器" class="headerlink" title="模拟Apache服务器"></a>模拟Apache服务器</h2><ul><li>根据 <code>req.url</code> 读取不同的页面内容，返回给浏览器</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求: 简单模仿apache服务器，浏览器发送127.0.0.1:8888/index.html</span></span><br><span class="line"><span class="comment">// 对应的返回www文件夹下面的index.html的内容</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> server = http.createServer()</span><br><span class="line"><span class="comment">// 监听请求</span></span><br><span class="line">server.on(<span class="string">'request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 根据不同请求输出不同响应数据</span></span><br><span class="line">  <span class="keyword">if</span> (req.url === <span class="string">'/'</span> || req.url === <span class="string">'/i'</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取www下面的index.html</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(__dirname, <span class="string">'www'</span>, <span class="string">'index.html'</span>)</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'文件读取失败'</span>)</span><br><span class="line">      <span class="comment">// 服务器响应文件</span></span><br><span class="line">      res.statusCode = <span class="number">200</span></span><br><span class="line">      res.statusMessage = <span class="string">'ok'</span></span><br><span class="line">      res.setHeader(<span class="string">'content-type'</span>, <span class="string">'text/html;charset=utf-8'</span>)</span><br><span class="line">      res.end(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url === <span class="string">'/l'</span>) &#123;</span><br><span class="line">    <span class="comment">// 读取list.html</span></span><br><span class="line">    <span class="keyword">let</span> filename = path.join(__dirname, <span class="string">'www'</span>, <span class="string">'list.html'</span>)</span><br><span class="line">    fs.readFile( filename, <span class="string">'utf-8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'文件读取失败'</span>)</span><br><span class="line">      <span class="comment">// 服务器响应文件</span></span><br><span class="line">      res.writeHead(<span class="number">200</span>, <span class="string">'OOOOOOK'</span>, &#123;</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">'text/html;charset=utf-8'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      res.end(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回浏览器, 未找到资源</span></span><br><span class="line">    res.writeHead(<span class="number">404</span>, <span class="string">'NOT FOUND'</span>, &#123;</span><br><span class="line">      <span class="string">'content-type'</span>: <span class="string">'text/html;charset=utf-8'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    res.end(<span class="string">'404 ,资源未找到'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 开启服务器</span></span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>, ()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'服务器开启了'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h2><ul><li>MIME(Multipurpose Internet Mail Extensions)多用途Internet邮件扩展类型 是一种表示文档性质和格式的标准化方式</li><li>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的MIME类型附加到响应对象的头部是非常重要的</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types" target="_blank" rel="noopener">MIME 类型</a></li></ul><h2 id="mime模块"><a href="#mime模块" class="headerlink" title="mime模块"></a>mime模块</h2><ul><li>作用：获取文件的MIME类型</li><li>安装：<code>npm i mime</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取路径对应的 MIME 类型</span></span><br><span class="line">mime.getType(<span class="string">'txt'</span>) <span class="comment">// 'text/plain'</span></span><br><span class="line"><span class="comment">// 根据 MIME 获取到文件后缀名</span></span><br><span class="line">mime.getExtension(<span class="string">'text/plain'</span>)  <span class="comment">// 'txt'</span></span><br></pre></td></tr></table></figure><h1 id="npm-Node-包管理工具"><a href="#npm-Node-包管理工具" class="headerlink" title="npm - Node 包管理工具"></a>npm - Node 包管理工具</h1><h2 id="npm-的基本概念"><a href="#npm-的基本概念" class="headerlink" title="npm 的基本概念"></a>npm 的基本概念</h2><ul><li>node package manager</li><li><a href="https://npmjs.com" target="_blank" rel="noopener">npm官网</a></li><li><a href="https://www.npmjs.com.cn/" target="_blank" rel="noopener">npm中文文档</a></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. npm 是node的包管理工具，</span><br><span class="line">2. 它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。</span><br><span class="line">3. 来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。</span><br><span class="line"></span><br><span class="line">npm 由三个独立的部分组成：</span><br><span class="line">    网站</span><br><span class="line">    注册表（registry）</span><br><span class="line">    命令行工具 (CLI)</span><br></pre></td></tr></table></figure><ul><li>作用：通过<code>npm</code>来快速安装开发中使用的包</li><li>npm不需要安装，只要安装了node，就自带了<code>npm</code></li></ul><h2 id="npm-基本使用"><a href="#npm-基本使用" class="headerlink" title="npm 基本使用"></a>npm 基本使用</h2><h3 id="初始化包"><a href="#初始化包" class="headerlink" title="初始化包"></a>初始化包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个命令用于初始化一个包，创建一个package.json文件，我们的项目都应该先执行npm init</span></span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 快速的初始化一个包， 不能是一个中文名</span></span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装指定的包名的最新版本到项目中</span></span><br><span class="line">npm install 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定包的指定版本</span></span><br><span class="line">npm install 包名@版本号</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简写</span></span><br><span class="line">npm i 包名</span><br></pre></td></tr></table></figure><h3 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载已经安装的包</span></span><br><span class="line">npm uninstall 包名</span><br></pre></td></tr></table></figure><h2 id="package-json-文件"><a href="#package-json-文件" class="headerlink" title="package.json 文件"></a>package.json 文件</h2><p>package.json文件，包（项目）描述文件，用来管理组织一个包（项目），它是一个纯JSON格式的</p><ul><li>作用：描述当前项目（包）的信息，描述当前包（项目）的依赖项</li><li>如何生成：<code>npm init</code>或者<code>npm init -y</code></li><li>作用<ul><li>作为一个标准的包，必须要有<code>package.json</code>文件进行描述</li><li>一个项目的node_modules目录通常都会很大，不用拷贝node_modules目录，可以通过package.json文件配合<code>npm install</code>直接安装项目所有的依赖项</li></ul></li><li>描述内容</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "name": "03-npm",  // 描述了包的名字，不能有中文</span><br><span class="line">  "version": "1.0.0",  // 描述了包的的版本信息， x.y.z  如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。</span><br><span class="line">  "description": "", // 包的描述信息</span><br><span class="line">  "main": "index.js", // 入口文件（模块化）</span><br><span class="line">  "scripts": &#123;  // 配置一些脚本，在vue的时候会用到，现在体会不到</span><br><span class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "keywords": [],  // 关键字（方便搜索）</span><br><span class="line">  "author": "",  // 作者的信息</span><br><span class="line">  "license": "ISC",  // 许可证，开源协议</span><br><span class="line">  "dependencies": &#123;   // 重要，项目的依赖， 方便代码的共享  通过 npm install</span><br><span class="line">    "bootstrap": "^3.3.7",</span><br><span class="line">    "jquery": "^3.3.1"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：一个合法的package.json，必须要有 name 和 version 两个属性</strong></p><h2 id="本地安装和全局安装"><a href="#本地安装和全局安装" class="headerlink" title="本地安装和全局安装"></a>本地安装和全局安装</h2><p>有两种方式用来安装 npm 包：本地安装和全局安装。选用哪种方式来安装，取决于你如何使用这个包。</p><ul><li>全局安装：如果你想将其作为一个命令行工具，那么你应该将其安装到全局。这种安装方式后可以让你在任何目录下使用这个命令。比如nrm, nodemon等命令</li><li>本地安装：如果你自己的模块依赖于某个包，并通过 Node.js 的 <code>require</code> 加载，那么你应该选择本地安装，这种方式也是 <code>npm install</code> 命令的默认行为</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装，会把 npm 包安装到C:\Users\用户名\AppData\Roaming\npm目录下，作为命令行工具使用</span></span><br><span class="line">npm install -g 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地安装，会把 npm 包安装到当前项目的node_modules文件中，作为项目的依赖</span></span><br><span class="line">npm install 包名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意： 如果网速慢的话，会导致下载失败。 再重新下载之前,建议使用以下命令,清除刚才下载的缓存.否则有可能一直无法下载成功</span></span><br><span class="line">npm cache clean -f</span><br></pre></td></tr></table></figure><h2 id="npm下载加速"><a href="#npm下载加速" class="headerlink" title="npm下载加速"></a>npm下载加速</h2><h3 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h3><ul><li>nrm：npm registry manager（npm仓库地址管理工具）</li><li>安装：<code>npm i -g nrm</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 带*表示当前正在使用的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看仓库地址列表</span></span><br><span class="line">nrm ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换仓库地址</span></span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure><h2 id="nodemon-自动重启"><a href="#nodemon-自动重启" class="headerlink" title="nodemon 自动重启"></a>nodemon 自动重启</h2><ul><li>作用：监听到 js 文件修改后，自动重启node程序</li><li>安装：<code>npm i -g nodemon</code></li><li>使用：<code>nodemon app.js</code> 运行node程序</li></ul><h1 id="hacknews案例"><a href="#hacknews案例" class="headerlink" title="hacknews案例"></a>hacknews案例</h1><ul><li><a href="https://news.ycombinator.com/" target="_blank" rel="noopener">Hacker News 示例</a></li><li>路由（route）：就是一套映射规则，根据url地址分配到对应的处理程序</li></ul><h2 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h2><ul><li>1 新闻列表页 - /index    get</li><li>2 新闻详情页 - /details  get</li><li>3 新闻添加页 - /submit   get</li><li>4 新闻添加请求 - /add    post</li></ul><h2 id="art-template-模板引擎"><a href="#art-template-模板引擎" class="headerlink" title="art-template 模板引擎"></a>art-template 模板引擎</h2><ul><li><a href="https://aui.github.io/art-template/zh-cn/docs/" target="_blank" rel="noopener">文档</a></li><li>安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install art-template</span><br></pre></td></tr></table></figure><ul><li>核心方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于模板路径渲染模板</span></span><br><span class="line"><span class="comment">// 参数1：文件的路径</span></span><br><span class="line"><span class="comment">// 参数2：数据</span></span><br><span class="line"><span class="comment">// 返回值：返回渲染后的内容</span></span><br><span class="line"><span class="comment">// template(filename, data)</span></span><br><span class="line"><span class="keyword">let</span> html = template(path.join(__dirname, <span class="string">'pages'</span>, <span class="string">'index.html'</span>), &#123;<span class="attr">name</span>: <span class="string">'大吉大利，今晚吃鸡'</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意点：文件的路径必须是绝对路径</strong>；会将整个html当做模板返回</p><h2 id="url-模块"><a href="#url-模块" class="headerlink" title="url 模块"></a>url 模块</h2><ul><li>说明：用于 URL 处理与解析</li><li>注意：通过 url 拿到的查询参数都是字符串格式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入url模块</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 URL 字符串并返回一个 URL 对象</span></span><br><span class="line"><span class="comment">// 第一个参数：表示要解析的URL字符串</span></span><br><span class="line"><span class="comment">// 第二个参数：是否将query属性（查询参数）解析为一个对象，如果为：true，则query是一个对象</span></span><br><span class="line"><span class="keyword">var</span> ret = url.parse(<span class="string">'http://localhost:3000/details?id=1&amp;name=jack'</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ret.query) <span class="comment">// &#123;id: '1', name: 'jack'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="querystring-模块"><a href="#querystring-模块" class="headerlink" title="querystring 模块"></a>querystring 模块</h2><ul><li>用于解析与格式化 URL 查询字符串</li><li>注意：只在专门处理查询字符串时使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo=bar&amp;abc=xyz&amp;abc=123</span></span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将查询参数转化为对象</span></span><br><span class="line"><span class="comment">// 第一个参数: 要解析的 URL 查询字符串</span></span><br><span class="line">querystring.parse(<span class="string">'foo=bar&amp;abc=xyz'</span>) <span class="comment">// &#123;foo: 'bar', abc: 'xyz'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="服务端重定向"><a href="#服务端重定向" class="headerlink" title="服务端重定向"></a>服务端重定向</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP 状态码说明</a></li><li><a href="http://shuai.be/archives/301-302-redirection/" target="_blank" rel="noopener">301 和 302</a></li><li>说明：服务端可以通过HTTP状态码让浏览器中的页面重定向</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.writeHead(<span class="number">302</span>, &#123;</span><br><span class="line">  <span class="string">'Location'</span>: <span class="string">'/'</span></span><br><span class="line">&#125;)</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure><h2 id="POST-请求参数的处理"><a href="#POST-请求参数的处理" class="headerlink" title="POST 请求参数的处理"></a>POST 请求参数的处理</h2><ul><li>说明：POST请求可以发送大量数据，没有大小限制</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受POST参数</span></span><br><span class="line"><span class="keyword">var</span> postData = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// data事件：用来接受客户端发送过来的POST请求数据</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">''</span></span><br><span class="line">req.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">  result += chunk</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// end事件：当POST数据接收完毕时，触发</span></span><br><span class="line">req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">  cosnole.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="模块化改造hackerNews"><a href="#模块化改造hackerNews" class="headerlink" title="模块化改造hackerNews"></a>模块化改造hackerNews</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nodejs基本介绍&quot;&gt;&lt;a href=&quot;#nodejs基本介绍&quot; class=&quot;headerlink&quot; title=&quot;nodejs基本介绍&quot;&gt;&lt;/a&gt;nodejs基本介绍&lt;/h1&gt;&lt;h2 id=&quot;为什么要学习nodejs&quot;&gt;&lt;a href=&quot;#为什么要学习nod
      
    
    </summary>
    
      <category term="js" scheme="http://blog.clj.me/categories/js/"/>
    
    
      <category term="nodejs" scheme="http://blog.clj.me/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>ES6（ECMAScript）</title>
    <link href="http://blog.clj.me/2018/javascript/ES6/"/>
    <id>http://blog.clj.me/2018/javascript/ES6/</id>
    <published>2018-12-29T10:00:00.000Z</published>
    <updated>2019-03-19T15:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6（ECMAScript）"><a href="#ES6（ECMAScript）" class="headerlink" title="ES6（ECMAScript）"></a>ES6（ECMAScript）</h1><p>ECMAScript 6.0（以下简称 ES6）是在 2015 年 6 月正式发布的标准。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言</p><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门 阮一峰</a></p><h2 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h2><blockquote><p>ES6 中提供了两个声明变量的关键字：const 和 let</p></blockquote><h3 id="let-的使用"><a href="#let-的使用" class="headerlink" title="let 的使用"></a>let 的使用</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code></p><ul><li>let声明的变量只有在当前作用域(块作用域)有效</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><ul><li>不存在变量提升</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// ReferenceError: b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>不允许重复声明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> <span class="comment">// SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><ul><li>不绑定全局作用域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>-</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 报错</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const-的使用"><a href="#const-的使用" class="headerlink" title="const 的使用"></a>const 的使用</h3><p><code>const</code>声明一个常量。常量：代码执行的过程中，不可以修改常量里面的值</p><ul><li>const 声明的量不可以改变</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span></span><br><span class="line">PI = <span class="number">3</span> <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><ul><li>const 声明的变量必须赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><ul><li>如果 const 声明了一个对象，仅仅保证地址不变，可以修改对象的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">'zs'</span>&#125;</span><br><span class="line">obj.age = <span class="number">18</span> <span class="comment">// 正确</span></span><br><span class="line">obj = &#123;&#125; <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><ul><li>其他用法和 let 一样</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只能在当前代码块中使用</span><br><span class="line">不会提升</span><br><span class="line">不能重复声明</span><br><span class="line">不绑定全局作用域</span><br></pre></td></tr></table></figure><h2 id="模板字符串-模板字面量"><a href="#模板字符串-模板字面量" class="headerlink" title="模板字符串(模板字面量)"></a>模板字符串(模板字面量)</h2><p>模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 通过``可以定义一个字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`hello world`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 模板字符串内部允许换行</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">  hello</span></span><br><span class="line"><span class="string">  world</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 模板字符串内部可以使用表达式</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">你好，我是<span class="subst">$&#123;name&#125;</span></span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 标准新增了一种新的函数：Arrow Function（箭头函数）</p><p>为什么叫 Arrow Function？因为它的定义用的就是一个箭头</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line"><span class="comment">// 语法： (参数列表) =&gt; &#123;函数体&#125;</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><ul><li>如果没有参数列表，使用()表示参数列表</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果只有一个参数，可以省略()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">n1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果有多个参数，需要使用 () 把参数列表括起来</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给参数指定默认值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">n = <span class="number">1</span></span>) =&gt;</span> <span class="built_in">console</span>.log(n)</span><br><span class="line">a() <span class="comment">// 1</span></span><br><span class="line">a(<span class="number">3</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>不存在 prototype 这个属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li><p>没有 arguments</p><p>箭头函数没有自己的 arguments 对象，箭头函数可以访问外围函数的 arguments 对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">1</span>, <span class="number">2</span>)()) <span class="comment">// [Arguments] &#123; '0': 1, '1': 2 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问箭头函数的参数</span></span><br><span class="line"><span class="comment">// Rest 参数接受函数的多余参数组成一个数组</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">a, b, ...Args</span>) =&gt;</span> <span class="built_in">console</span>.log(Args)</span><br><span class="line">a(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// [3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.length) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>Rest 参数和 arguments 对象的区别：</li></ul><p>rest 参数只包括那些没有给出名称的参数，arguments 包含所有参数</p><p>rest 参数之后不能再有其他参数，否则会报错</p><p>函数的 length 属性，不包括 rest 参数</p><p>arguments 对象不是真正的数组，而 rest 参数是数组实例，可以直接使用数组的方法</p><p>arguments 对象拥有一些自己额外的功能</p><h3 id="返回值详解"><a href="#返回值详解" class="headerlink" title="返回值详解"></a>返回值详解</h3><ul><li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">  <span class="keyword">return</span> n1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">n1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">  <span class="keyword">return</span> n1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果函数体只有一行一句，并且需要返回这个值，那么可以省略 {} 和 return</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2</span><br></pre></td></tr></table></figure><h3 id="箭头函数的注意点"><a href="#箭头函数的注意点" class="headerlink" title="箭头函数的注意点"></a>箭头函数的注意点</h3><ol><li>箭头函数内部没有 this，因此箭头函数内部的 this 指向了外部的 this</li><li>因为箭头函数没有 this，因此箭头函数不能作为构造函数</li><li>不能用 call()、apply()、bind() 这些方法改变 this 的指向</li></ol><p>【定义一个对象，定时器打招呼】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'大家好，我是'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.sayHi()</span><br></pre></td></tr></table></figure><h2 id="对象简化语法"><a href="#对象简化语法" class="headerlink" title="对象简化语法"></a>对象简化语法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当属性的 key 和变量的名相同时可以简写</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: name&#125; ==&gt; <span class="keyword">let</span> person = &#123;name&#125;</span><br><span class="line"></span><br><span class="line">声明函数</span><br><span class="line"><span class="keyword">let</span> cal = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 可以省略 `:function`</span></span><br><span class="line">  add()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><ul><li>ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">let</span> methodKey = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// foo: true</span></span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span>,</span><br><span class="line">  <span class="comment">// abc: 123</span></span><br><span class="line">  [methodKey]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="class-关键字"><a href="#class-关键字" class="headerlink" title="class 关键字"></a>class 关键字</h2><p>ES5 中通过 构造函数 + 原型 的方式来实现面向对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'jack'</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在原型中添加实例方法</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure><p>ES6 中出现了 class 关键字，用来实现面向对象。</p><p>class 仅仅是一个语法结构（语法糖），本质上还是通过构造函数+原型的方式来实现继承的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="comment">// 创建 Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类的构造函数</span></span><br><span class="line">  <span class="comment">// constructor 固定名称</span></span><br><span class="line">  <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加实例方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'tom'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure><p>继承：要实现至少需要两个class（子类 和 父类），子类继承自父类，继承后，子类就可以使用父类中的属性或方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类中的 say 方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// 子类中使用 constructor 必须手动调用 super</span></span><br><span class="line">    <span class="comment">// super 表示父类的构造函数</span></span><br><span class="line">    <span class="comment">// 先调用 super() 在使用 this</span></span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'ls'</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Chinese()</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line">c.say() <span class="comment">// 父类中的方法</span></span><br></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 对象解构</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b&#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取变量并赋值</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: p, <span class="attr">b</span>: q&#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(p, q) <span class="comment">// 10 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余数组赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b, ...rest &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;</span><br><span class="line"><span class="comment">// ;(&#123; a, b, ...rest &#125; = &#123; a: 10, b: 20, c: 30, d: 40 &#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest) <span class="comment">// 10 20 &#123;c: 30, d: 40&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123; a = <span class="number">1</span>, b = <span class="number">1</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值并提供默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">a</span>:aa = <span class="number">10</span>, <span class="attr">b</span>:bb = <span class="number">1</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa, bb) <span class="comment">// 10 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 数组解构</span></span><br><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余数组赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> [a, b, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest) <span class="comment">// 1 2 [3, 4]</span></span><br><span class="line"><span class="comment">// ==&gt; var a = arr[0]; var b = arr[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供默认值</span></span><br><span class="line"><span class="keyword">var</span> [c = <span class="number">2</span>, d = <span class="number">2</span>] = [<span class="number">10</span>]</span><br><span class="line"><span class="built_in">console</span>.log(c, d) <span class="comment">// 10 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略某些值</span></span><br><span class="line"><span class="keyword">var</span> [a = <span class="number">2</span>, , b = <span class="number">2</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 函数参数的解构赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">foo(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x = <span class="number">10</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 解构的特殊应用</span></span><br><span class="line"><span class="comment">// 交换变量</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">[a, b] = [b, a]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串解构</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'love'</span></span><br><span class="line"><span class="keyword">var</span> [a, b, c, d] = str</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// l o v e</span></span><br></pre></td></tr></table></figure><h2 id="数组扩展运算符"><a href="#数组扩展运算符" class="headerlink" title="数组扩展运算符"></a>数组扩展运算符</h2><p>扩展运算符（spread）是三个点（…）。作用：将一个数组转为用逗号分隔的参数序列</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr)</span><br><span class="line"><span class="comment">// 上面这句代码相当于：</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组深拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = [...arr]</span><br><span class="line"><span class="built_in">console</span>.log(arr === arr1) <span class="comment">// false, 说明arr1和arr指向不同数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个数组插入另一个数组字面量</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转数组</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'love'</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [...str]</span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [ 'l', 'o', 'v', 'e' ]</span></span><br></pre></td></tr></table></figure><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6（ECMAScript）&quot;&gt;&lt;a href=&quot;#ES6（ECMAScript）&quot; class=&quot;headerlink&quot; title=&quot;ES6（ECMAScript）&quot;&gt;&lt;/a&gt;ES6（ECMAScript）&lt;/h1&gt;&lt;p&gt;ECMAScript 6.0（以下简
      
    
    </summary>
    
      <category term="js" scheme="http://blog.clj.me/categories/js/"/>
    
    
      <category term="es6" scheme="http://blog.clj.me/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>防抖和节流</title>
    <link href="http://blog.clj.me/2018/other/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>http://blog.clj.me/2018/other/防抖和节流/</id>
    <published>2018-12-12T12:57:00.000Z</published>
    <updated>2018-11-19T13:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>防抖和节流都是为了解决<strong>短时间内大量触发某函数</strong>而导致的<strong>性能问题，</strong>比如触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象</p></blockquote><h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>在事件被触发n秒后再执行回调函数，如果在这n秒内又被触发，则重新计时</p><p>应用场景</p><ul><li><p>用户在输入框中连续输入一串字符后，只会在输入完后去执行最后一次的查询ajax请求，这样可以有效减少请求次数，节约请求资源</p></li><li><p>window 的 resize、scroll 事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次</p></li></ul><h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p>规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内事件被触发多次，只有一次能生效</p><p>应用场景</p><ul><li><p>鼠标连续不断地触发某事件（如点击），只在单位时间内只触发一次</p></li><li><p>在页面的无限加载场景下，需要用户在滚动页面时，每隔一段时间发一次 ajax 请求，而不是在用户停下滚动页面操作时才去请求数据</p></li><li><p>监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断</p></li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>防抖的作用是将多个连续的<code>debounced</code>调用合并为一次<code>func</code>调用。防抖是基于最近次 <code>debounced</code> 调用来重置 <code>waitTime</code>，如果<code>debounced</code>事件触发间隔小于 <code>waitTime</code>，<code>func</code>就不会执行；</p><p>节流的作用是限制<code>func</code>调用的频率（每<code>waitTime</code>调用一次）。是基于上次 <code>func</code> 调用来计算 <code>waitTime</code> 的，不管<code>func</code> 事件触发有多频繁，只要距离上次 <code>func</code> 调用超过了 <code>waitTime</code>，就一定会进行下次 <code>func</code> 调用。</p><p>– 原理：</p><p>防抖是 <code>debounced</code> 维护了一个计时器，规定在 <code>waitTime</code> 时间后触发 <code>func</code>，但是在 <code>waitTime</code> 时间内再次触发 <code>debounced</code> 的话，会清除当前的 timer 然后重新计时，这样一来，只有最后一次<code>debounced</code> 操作才能触发 <code>func</code>；</p><p>节流是通过判断是否到达一定时间 (<code>waitTime</code>) 来再次触发 <code>func</code> ， <code>func</code> 在 <code>waitTime</code> 时间内不能被再次触发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;防抖和节流都是为了解决&lt;strong&gt;短时间内大量触发某函数&lt;/strong&gt;而导致的&lt;strong&gt;性能问题，&lt;/strong&gt;比如触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="other" scheme="http://blog.clj.me/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>gulp 前端自动化环境</title>
    <link href="http://blog.clj.me/2018/tool/gulp%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
    <id>http://blog.clj.me/2018/tool/gulp前端自动化环境/</id>
    <published>2018-12-12T11:23:00.000Z</published>
    <updated>2019-06-10T15:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端自动化环境"><a href="#前端自动化环境" class="headerlink" title="前端自动化环境"></a>前端自动化环境</h1><p>实现一些简单的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 版本控制</span><br><span class="line">2. 编译SASS</span><br><span class="line">3. 检查JS</span><br><span class="line">4. 图片合并</span><br><span class="line">5. 压缩CSS</span><br><span class="line">6. 压缩JS</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这些都是每个Web项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。</p><p>构建工具： Gulp、Grunt、Webpack、…</p><h2 id="gulp-环境"><a href="#gulp-环境" class="headerlink" title="gulp 环境"></a>gulp 环境</h2><p>Gulp 是基于 Node.js 的，需要要安装 Node.js</p><h3 id="安装-4-0版本"><a href="#安装-4-0版本" class="headerlink" title="安装 # 4.0版本"></a>安装 # 4.0版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 node 环境</span></span><br><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装 gulp</span></span><br><span class="line">$ npm install -g gulp</span><br><span class="line">$ gulp -v  <span class="comment">#4.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到你的在项目根文件夹下，运行</span></span><br><span class="line">$ npm install gulp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 gulp 功能插件依赖包</span></span><br><span class="line">$ npm install gulp-less gulp-sass gulp-concat gulp-connect gulp-rename</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>新建 <code>gulpfile.js</code> 配置文件放在项目根目录下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gulp3.x 配置不能直接在 4.0 上使用</span></span><br><span class="line"><span class="comment">// gulp4.0 配置内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 gulp</span></span><br><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"><span class="comment">// 引入组件</span></span><br><span class="line"><span class="keyword">const</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>)</span><br><span class="line"><span class="keyword">const</span> fileinclude = <span class="built_in">require</span>(<span class="string">'gulp-file-include'</span>)</span><br><span class="line"><span class="keyword">const</span> connect = <span class="built_in">require</span>(<span class="string">'gulp-connect'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 serve</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  connect.server(&#123;</span><br><span class="line">    root: <span class="string">'./'</span>,</span><br><span class="line">    port: <span class="string">'8888'</span>,</span><br><span class="line">    <span class="comment">// 启用https</span></span><br><span class="line">    <span class="comment">// https: true,</span></span><br><span class="line">    livereload: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译 less</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileLess</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">  <span class="comment">// '!./**' 忽略文件</span></span><br><span class="line">    .src([<span class="string">'./less/*.less'</span>, <span class="string">'!./less/_*.less'</span>])</span><br><span class="line">    .pipe(less())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html 刷新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshHtml</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./*.html'</span>)</span><br><span class="line">    .pipe(connect.reload())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入外部 html 文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileHtml</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp</span><br><span class="line">    .src([<span class="string">'./*.html'</span>, <span class="string">'!./_*.html'</span>])</span><br><span class="line">    .pipe(</span><br><span class="line">      fileinclude(&#123;</span><br><span class="line">        prefix: <span class="string">'@@'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 html 中使用 `@@include('_header-aside.html')` 引入公共 html 结构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听文件变化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watch</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.watch([<span class="string">'./less'</span>], compileLess)</span><br><span class="line">  gulp.watch([<span class="string">'./image'</span>], compileImg)</span><br><span class="line">  gulp.watch([<span class="string">'./js'</span>], compileJs)</span><br><span class="line">  gulp.watch([<span class="string">'./*.html'</span>], compileHtml)</span><br><span class="line">  gulp.watch([<span class="string">'./public'</span>], refreshHtml)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认任务，执行 gulp 会自动执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, gulp.parallel(serve, watch))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制 lib 文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyLib</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./lib/**/*'</span>).pipe(gulp.dest(<span class="string">'./dest/lib'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 dest 文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> del([<span class="string">'./dest'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行-gulp-任务"><a href="#运行-gulp-任务" class="headerlink" title="运行 gulp 任务"></a>运行 gulp 任务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行定义的 default 任务</span></span><br><span class="line"><span class="comment"># $ gulp default</span></span><br><span class="line">$ gulp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独运行 sass 任务</span></span><br><span class="line">$ gulp less</span><br></pre></td></tr></table></figure><p><code>!./**</code> 忽略文件</p><p><code>gulp.parallel()</code> –并行运行任务</p><p><code>gulp.series()</code> –运行任务序列</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">其他 gulp 插件参考</span><br><span class="line">gulp-imagemin: 压缩图片</span><br><span class="line">gulp-minify-css: 压缩css</span><br><span class="line">gulp-uglify:      压缩js</span><br><span class="line">gulp-concat:    合并文件</span><br><span class="line">gulp-rename:  重命名文件</span><br><span class="line">gulp-htmlmin: 压缩html</span><br><span class="line">gulp-clean:      清空文件夹</span><br><span class="line">del:              删除文件</span><br></pre></td></tr></table></figure><p>gulp-connect 启动服务本机可以打开，局域网下手机打不开解决办法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connect.server(&#123;</span><br><span class="line">  host: <span class="string">'0.0.0.0'</span></span><br><span class="line">  或</span><br><span class="line">  host: <span class="string">'::'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在gulp 3.x 版本中报错会暂停监听需重新开启任务，4.0 修复了此问题</p><p><a href="https://www.tuicool.com/articles/nAzqiaN" target="_blank" rel="noopener">https://www.tuicool.com/articles/nAzqiaN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端自动化环境&quot;&gt;&lt;a href=&quot;#前端自动化环境&quot; class=&quot;headerlink&quot; title=&quot;前端自动化环境&quot;&gt;&lt;/a&gt;前端自动化环境&lt;/h1&gt;&lt;p&gt;实现一些简单的功能：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="工具" scheme="http://blog.clj.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="gulp" scheme="http://blog.clj.me/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>bootstrap 框架</title>
    <link href="http://blog.clj.me/2018/bootstrap/bootstrap/"/>
    <id>http://blog.clj.me/2018/bootstrap/bootstrap/</id>
    <published>2018-12-11T10:00:00.000Z</published>
    <updated>2019-04-17T10:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bootstrap-框架"><a href="#bootstrap-框架" class="headerlink" title="bootstrap 框架"></a>bootstrap 框架</h1><p>Bootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷</p><p><a href="http://www.bootcss.com/" target="_blank" rel="noopener">bootstrap 中文网</a></p><p>特点：</p><ul><li>组件简洁大方、代码规范精简、界面自定义性强</li><li>Bootstrap 是基于 HTML5 和 CSS3 开发的，它在 jQuery 的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分 jQuery 插件</li><li>Bootstrap 中包含了丰富的 Web 组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站</li></ul><p>优点：</p><ul><li>有自己的生态圈，不断的更新迭代</li><li>提供了一套简洁、直观、强悍的组件</li><li>标准化的 HTML+CSS 编码规范</li><li>让开发更简单，提高了开发效率</li><li>扩展性强，虽然界面组件样式已经定义好了，我们还可以自定义，修改默认样式</li></ul><p>版本：</p><ul><li>2.x.x 停止维护<ul><li>优点：兼容性好 IE678</li><li>缺点：代码不够简洁、功能不够完善</li></ul></li><li>3.x.x <strong>目前使用最多（H5C3 很多东西）</strong><ul><li>优点：稳定，偏向于开发响应式布局，移动设备优先的 WEB 项目</li><li>缺点：放弃了 IE67，对 IE8 支持但是界面效果不友好</li></ul></li><li>4.x.x 测试阶段</li></ul><h2 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h2><p>!&gt; 但凡看到 <code>role属性</code> <code>aria-*的属性</code> <code>class=&#39;sr-only&#39;的标签</code> 都可以直接删除，因为是给屏幕阅读器用的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>bootstrap基本模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 bootstrap 的核心样式文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"lib/bootstrap/css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- html5shiv 是用来解决 IE8 以下浏览器不支持 HTML5 语义化标签的问题 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- respond 是用来解决 IE8 以下浏览器不支持媒体查询的问题，注意：respond 不支持 file 协议打开 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 条件注释：IE浏览器专属 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src="html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src="respond.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">  &lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- bootstrap 依赖于 jquery，因此需要在 bootstrap 之前引入jquery文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/jquery/jquery-1.12.4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入 bootstrap 的核心js文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/bootstrap/js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h2><h3 id="normalize-css"><a href="#normalize-css" class="headerlink" title="normalize.css"></a>normalize.css</h3><p>Normalize.css 是一种 CSS reset 的替代方案。经过@necolas 和@jon_neal 花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样</p><p><a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">官网</a> <a href="https://github.com/necolas/normalize.css" target="_blank" rel="noopener">github 网址</a></p><p>normalize 的特点：</p><ul><li><strong>保护有用的浏览器默认样式</strong>而不是完全去掉它们</li><li><strong>一般化的样式</strong>：为大部分 HTML 元素提供</li><li><strong>修复浏览器自身的 bug</strong>并保证各浏览器的一致性</li><li><strong>优化 CSS 可用性</strong>：用一些小技巧</li></ul><p><code>Normalize.css</code> 支持包括手机浏览器在内的超多浏览器，同时对 HTML5 元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。</p><p><a href="http://www.cnblogs.com/webpush/p/4974063.html" target="_blank" rel="noopener">Normalize.css 与 CSS reset 区别</a></p><h3 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h3><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。默认带了 15px 的 padding 值</p><p><code>.container</code> 类用于固定宽度并支持响应式布局的容器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>.container-fluid</code> 类用于 100% 宽度，占据全部视口（viewport）的容器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container-fluid"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两种容器类不能互相嵌套</p><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h3><p>栅格系统，也叫网格系统，bootstrap 栅格系统把一个盒子分成 12 格</p><ul><li><p>栅格参数：<code>col-xx-yy</code></p><p>xx：<code>lg</code> 大屏(≥1200px)、<code>md</code> 中屏(≥992px)、<code>sm</code> 小屏(≥768px)、<code>xs</code> 超小屏(&lt;768px)</p><p>yy：取值范围为 1 - 12 表示占几格</p><p><code>col-xx-12</code>：可以省略不写</p></li><li><p>列偏移：<code>col-xx-offset-yy</code></p><p>xx ：lg、md、sm、xs</p><p>yy：取值范围为 1 - 12 表示往右偏移几格</p><p>列偏移：实际上是给当前元素增加了左侧的边距（margin）</p></li><li><p>多余列（column）的元素将作为一个整体单元被另起一行排列</p></li><li><p><code>.row</code>用于抵消 <code>.container</code>容器的 15px 的 padding 值，实际上是给元素添加了 margin: -15px</p></li><li><p>可以在<code>.row</code>中嵌套<code>column</code></p></li><li><p>列排序：<code>.col-md-push-*</code> 和 <code>.col-md-pull-*</code></p></li></ul><p>栅格系统常用类（总共 12 列）</p><table><thead><tr><th>类名</th><th>例子</th><th>解释</th></tr></thead><tbody><tr><td>.col-xs-xx</td><td>.col-xs-6</td><td>在超小屏幕（及以上）生效</td></tr><tr><td>.col-sm-xx</td><td>.col-sm-6</td><td>在小屏幕（及以上）生效</td></tr><tr><td>.col-md-xx</td><td>.col-md-6</td><td>在中屏幕（及以上）生效</td></tr><tr><td>.col-lg-xx</td><td>.col-lg-3</td><td>在大屏幕及生效，占 1/4</td></tr><tr><td>.col-lg-xx</td><td>.col-lg-4</td><td>在大屏幕及生效，占 1/3</td></tr><tr><td>.col-lg-xx</td><td>.col-lg-5</td><td>在大屏幕及生效，占 1/2</td></tr></tbody></table><p>【案例：列嵌套.html】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-4"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 栅格系统无处不在，只要父盒子有宽度，就可以使用栅格系统 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-6"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-6"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【案例：列偏移.html】</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 .col-md-offset-* 类可以将列向右侧偏移--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- col-lg-offset-3:在大屏下，这个div将向右侧偏移3个单位 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-6 col-lg-offset-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><p>标题：h1 到 h6 标签、<code>.h1</code> 到 <code>.h6</code> 类、 <code>&lt;small&gt;</code> 标签或 <code>.small</code> 类用来标记副标题</p><p>文本：<code>&lt;mark&gt;</code>标记、<code>&lt;del&gt;</code>删除、<code>&lt;s&gt;</code>无用文本、<code>&lt;ins&gt;</code>插入文本、<code>&lt;u&gt;</code>下划线文本、 <code>.small</code> 类或<code>&lt;small&gt;</code> 小号文本、<code>&lt;strong&gt;</code>着重</p><p>对齐：<code>text-left</code>、<code>text-center</code>、<code>text-right</code>、<code>text-justify</code>、<code>text-nowrap</code></p><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p><code>&lt;a&gt;</code>、<code>&lt;button&gt;</code> 或 <code>&lt;input&gt;</code></p><p>预定义样式：btn、btn-default、btn-primary(蓝)、btn-success(绿)、btn-info(浅蓝)、btn-warning(橙)、btn-danger(红)、btn-link(链接)</p><p>尺寸：btn-lg(大)、(默认)、btn-sm(小)、btn-xs(超小)<br>btn-block (块元素 100%宽度)</p><p>激活状态：active</p><p>禁用状态：button 元素 添加 <code>disabled</code> 属性、链接<code>&lt;a&gt;</code>元素添加 <code>.disabled</code> 类（建议通过 JavaScript 代码来禁止链接的原始功能）</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>响应式图片：<code>img-responsive</code></p><p>实质是为图片设置了 max-width: 100%;、 height: auto; 和 display: block; 属性</p><p>图片形状：<code>img-rounded</code>、<code>img-circle</code>、<code>img-thumbnail</code></p><h3 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h3><p>文本颜色：<code>text-muted</code>、<code>text-muted</code>、<code>text-primary</code>、<code>text-success</code>、<code>text-info</code>、<code>text-warning</code>、<code>text-danger</code></p><p>背景颜色：<code>bg-primary</code>、<code>bg-success</code>、<code>bg-info</code>、<code>bg-warning</code>、<code>bg-danger</code></p><p>关闭按钮：<code>&lt;button type=&quot;button&quot; class=&quot;close&quot;&gt;&lt;span&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;</code></p><p>三角符号：<code>&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</code></p><p>快速浮动：<code>pull-left</code>、<code>pull-right</code></p><p>让内容块居中：<code>&lt;div class=&quot;center-block&quot;&gt;...&lt;/div&gt;</code></p><p>清除浮动：<code>clearfix</code></p><p>显示隐藏内容：<code>show</code>、<code>hidden</code>、<code>invisible</code></p><h3 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">            超小屏 小屏幕 中等屏幕 大屏幕桌面</span><br><span class="line">.visible-xs-*可见   隐藏   隐藏  隐藏</span><br><span class="line">.visible-sm-*隐藏   可见   隐藏  隐藏</span><br><span class="line">.visible-md-*隐藏   隐藏   可见  隐藏</span><br><span class="line">.visible-lg-*隐藏   隐藏   隐藏  可见</span><br><span class="line"></span><br><span class="line">.hidden-xs  隐藏 可见  可见  可见</span><br><span class="line">.hidden-sm  可见 隐藏  可见  可见</span><br><span class="line">.hidden-md  可见 可见  隐藏  可见</span><br><span class="line">.hidden-lg    可见 可见  可见  隐藏</span><br></pre></td></tr></table></figure><p><code>*</code> -&gt; block inline inline-block</p><p>推荐使用 hidden 相关的属性</p><h2 id="bootstrap-validator-插件"><a href="#bootstrap-validator-插件" class="headerlink" title="bootstrap-validator 插件"></a>bootstrap-validator 插件</h2><p>基于 bootstrap 的前端校验插件</p><p><a href="http://bootstrapvalidator.votintsev.ru/api" target="_blank" rel="noopener">http://bootstrapvalidator.votintsev.ru/api</a></p><h3 id="引包"><a href="#引包" class="headerlink" title="引包"></a>引包</h3><p>引入 css 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"lib/bootstrap/css/bootstrap.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"lib/bootstrap-validator/css/bootstrapValidator.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>引入 js 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/jquery/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/bootstrap/js/bootstrap.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/bootstrap-validator/js/bootstrapValidator.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="初始化表单校验插件"><a href="#初始化表单校验插件" class="headerlink" title="初始化表单校验插件"></a>初始化表单校验插件</h3><p>bootstrap-validator 插件会在表单提交的时候进行校验，如果校验成功了，表单会继续提交，但是如果校验失败了，就会阻止表单的提交</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用表单校验插件</span></span><br><span class="line">$(formSelector).bootstrapValidator(&#123;</span><br><span class="line">  <span class="comment">// 1. 指定不校验的类型，默认为[':disabled', ':hidden', ':not(:visible)'],可以不设置</span></span><br><span class="line">  excluded: [], <span class="comment">// 全部校验</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 指定校验时的图标显示，默认是bootstrap风格</span></span><br><span class="line">  feedbackIcons: &#123;</span><br><span class="line">    valid: <span class="string">'glyphicon glyphicon-ok'</span>,</span><br><span class="line">    invalid: <span class="string">'glyphicon glyphicon-remove'</span>,</span><br><span class="line">    validating: <span class="string">'glyphicon glyphicon-refresh'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 指定校验字段</span></span><br><span class="line">  fields: &#123;</span><br><span class="line">    username: &#123;</span><br><span class="line">      <span class="comment">// 设置校验规则</span></span><br><span class="line">      validators: &#123;</span><br><span class="line">        <span class="comment">// 不能为空</span></span><br><span class="line">        notEmpty: &#123;</span><br><span class="line">          message: <span class="string">''</span></span><br><span class="line">        &#125;,</span><br><span class="line">        stringLength: &#123;</span><br><span class="line">          min: <span class="number">6</span>,</span><br><span class="line">          max: <span class="number">12</span>,</span><br><span class="line">          message: <span class="string">''</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 正则校验</span></span><br><span class="line">        regexp: &#123;</span><br><span class="line">          regexp: <span class="regexp">/^[a-zA-Z0-9_\.]+$/</span>,</span><br><span class="line">          message: <span class="string">'用户名由数字字母下划线和.组成'</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        callback: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    password: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="注册表单校验成功的事件"><a href="#注册表单校验成功的事件" class="headerlink" title="注册表单校验成功的事件"></a>注册表单校验成功的事件</h3><p>当表单校验成功时，会触发<code>success.form.bv</code>事件，此时会提交表单，通常我们需要禁止表单的自动提交，使用 ajax 进行表单的提交</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#form'</span>).on(<span class="string">'success.form.bv'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="comment">// 使用ajax提交逻辑</span></span><br><span class="line">  $.ajax(&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="获取-validator-实例-对象"><a href="#获取-validator-实例-对象" class="headerlink" title="获取 validator 实例(对象)"></a>获取 validator 实例(对象)</h3><p>当我们初始化好表单校验插件时，我们可以通过以下方法来获取表单校验的 validator 实例，通过 validator 实例调用一些方法来完成某些功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取表单校验实例</span></span><br><span class="line"><span class="keyword">var</span> validator = $(<span class="string">'#form'</span>).data(<span class="string">'bootstrapValidator'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用表单校验实例可以调用一些常用的方法</span></span><br><span class="line">validator.methodName(params)</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h4><p>重置表单中设置过校验的内容，将隐藏所有错误提示和图标</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置表单，隐藏所有的错误提示和图标 传入参数 true 会将内容也清空</span></span><br><span class="line">validator.resetForm()</span><br></pre></td></tr></table></figure><h4 id="更新字段的状态"><a href="#更新字段的状态" class="headerlink" title="更新字段的状态"></a>更新字段的状态</h4><p>BootstrapValidator 在用户输入内容的时候，会做校验，当调用 bootstrap 的插件的方法可以手动会改变字段值的状态</p><p><code>validator.updateStatus(field*, status*, validator)</code></p><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>field</code></td><td>String|jQuery</td><td>The field name or field element</td></tr><tr><td><code>status</code></td><td>String</td><td>Can be <code>NOT_VALIDATED</code>, <code>VALIDATING</code>, <code>INVALID</code> or <code>VALID</code></td></tr><tr><td><code>validator</code></td><td>String</td><td>The validator name. If <code>null</code>, the method updates validity result for all validators</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bootstrap-框架&quot;&gt;&lt;a href=&quot;#bootstrap-框架&quot; class=&quot;headerlink&quot; title=&quot;bootstrap 框架&quot;&gt;&lt;/a&gt;bootstrap 框架&lt;/h1&gt;&lt;p&gt;Bootstrap，来自 Twitter，是目前最受欢迎的前
      
    
    </summary>
    
      <category term="框架" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="bootstrap" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/bootstrap/"/>
    
    
      <category term="bootstrap" scheme="http://blog.clj.me/tags/bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>移动 web</title>
    <link href="http://blog.clj.me/2018/%E7%A7%BB%E5%8A%A8web/%E7%A7%BB%E5%8A%A8web/"/>
    <id>http://blog.clj.me/2018/移动web/移动web/</id>
    <published>2018-12-11T10:00:00.000Z</published>
    <updated>2018-12-19T13:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动web基础"><a href="#移动web基础" class="headerlink" title="移动web基础"></a>移动web基础</h1><h2 id="移动端开发现状"><a href="#移动端开发现状" class="headerlink" title="移动端开发现状"></a>移动端开发现状</h2><ul><li>移动web开发指的是需要适配移动设备的网页开发</li><li>移动web开发与pc端web开发没有本质的区别，使用的还是HTML/CSS/JavaScript的技术</li><li>移动web开发与pc端web开发的区别是什么？</li></ul><p>移动端的浏览器与pc端不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">谷歌浏览器 苹果浏览器、 UC浏览器 QQ浏览器 欧朋浏览器 百度手机浏览器  <span class="number">360</span>安全浏览器  搜狗浏览器  猎豹浏览器等</span><br><span class="line">国内的手机浏览器都是根据webkit内核修改过来的，国内没有自主研发的内核，国内的操作系统也是基于Android系统修改的。</span><br><span class="line"></span><br><span class="line">因此在移动端，css3属性只需要加webkit前缀即可。</span><br></pre></td></tr></table></figure><p>移动端设备尺寸不一样(尺寸非常多，碎片化很严重)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Android： <span class="number">320</span>*<span class="number">480</span> <span class="number">480</span>*<span class="number">800</span>  <span class="number">540</span>*<span class="number">960</span> <span class="number">720</span>*<span class="number">1280</span> <span class="number">1080</span>*<span class="number">1920</span> <span class="number">2</span>k屏 <span class="number">4</span>k屏</span><br><span class="line">iphpne：  <span class="number">640</span>*<span class="number">960</span> <span class="number">640</span>*<span class="number">1136</span> <span class="number">750</span>*<span class="number">1334</span> <span class="number">1242</span>*<span class="number">2208</span></span><br></pre></td></tr></table></figure><h2 id="移动端开发分类"><a href="#移动端开发分类" class="headerlink" title="移动端开发分类"></a>移动端开发分类</h2><ul><li>原生app（native app）</li><li>混合app（Hybrid app）</li><li>web应用（webApp）</li></ul><p><strong>原生app（native app）</strong></p><blockquote><p> 原生app是基于操作系统的开发，比如安卓，ios，windows phone,他们只能在各自的操作系统上运行。</p></blockquote><p>优点：</p><ol><li>可以访问操作系统，获取更多的资源（gps，摄像头，传感器，麦克风等）</li><li>速度快，性能高，用户体验好</li><li>可以离线使用</li></ol><p>缺点：</p><ol><li>开发成本高</li><li>需要安装和更新，更新与发布需要审核。</li></ol><p><strong>Web App</strong></p><blockquote><p> Web应用使用H5C3开发页面，为浏览器设计的基于web的应用，可以在各种智能设备的手机浏览器上运行。不需要安装即可运行。</p></blockquote><p>优点：</p><ol><li>支持设备广泛</li><li>开发成本低（使用）</li><li>可以随时上线与更新，无需审核</li></ol><p>缺点：</p><ol><li>用户体验极度依赖网速</li><li>要求联网</li><li>无法获取手机的资源（gps，摄像头）</li></ol><p><strong>混合app（Hybrid App）</strong></p><blockquote><p>Hybrid App是指介于web-app、native-app这两者之间的app,它虽然看上去是一个Native App，但只有一个UI WebView，里面访问的是一个Web App。（淘宝、京东、手机百度）</p></blockquote><p>Hybird App说白了就是使用了Native app的壳，里面其实还是HTML5页面。</p><p>优点：</p><ol><li>开发成本和难度更低，兼容多个平台</li><li>也可以访问手机的操作系统资源。</li><li>更新维护更方便</li></ol><p>缺点：</p><ol><li>用户体验相比原生app稍差。</li><li>性能依赖于网速</li></ol><p>总结：</p><p>三种开发各有优缺点，具体用什么需要根据实际情况而定，比如预算，app注重功能还是内容等。</p><p><img src="%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%88%86%E7%B1%BB.png" alt></p><h2 id="屏幕与分辨率"><a href="#屏幕与分辨率" class="headerlink" title="屏幕与分辨率"></a>屏幕与分辨率</h2><blockquote><p>移动设备与PC设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面。</p></blockquote><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>通常我们所指的屏幕<code>尺寸</code>，实际上指的是屏幕对角线的长度（一般用英寸来度量）</p><p><code>1英寸 = 2.54厘米</code></p><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>分辨率则一般用像素来度量，表示屏幕水平和垂直方向的像素数，例如1920*1080指的是屏幕垂直方向和水平方向分别有1920和1080个像素点而构成。</p><p><code>像素</code>：指计算机显示设备中的最小单位，即一个像素点的大小。每一个像素点可以理解为就是屏幕上的一个发光点。</p><h3 id="像素密度ppi-了解"><a href="#像素密度ppi-了解" class="headerlink" title="像素密度ppi(了解)"></a>像素密度ppi(了解)</h3><p><code>PPI（Pixels Per Inch）</code>表示屏幕每英寸的像素数</p><p>PPI值的越大说明单位尺寸里所能容纳的像素数量就越多，所能展现画面的品质也就越精细，反之就越粗糙。</p><p><strong>结论：当PPI 越大，展示的画质越精细。</strong></p><h2 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h2><blockquote><p>随着技术发展，设备不断更新，出现了不同PPI的屏幕共存的状态，给我们开发带来的问题</p></blockquote><p>做为用户是不会关心这些细节的，他们只是希望在不同PPI的设备上看到的图像内容差不多大小，所以这时我们需要一个新的单位，<code>这个新的单位能够保证图像内容在不同的PPI设备看上去大小应该差不多</code>，这就是独立像素，也叫（设备无关像素），在IOS设备上叫<code>PT</code>，Android设备上叫<code>DP</code>，在css中，叫<code>PX</code>。</p><p>获取设备的像素比</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.devicePixelRatio  <span class="comment">// 物理像素与独立像素的比值 DPR</span></span><br></pre></td></tr></table></figure><h2 id="2倍图与3倍图（重要）"><a href="#2倍图与3倍图（重要）" class="headerlink" title="2倍图与3倍图（重要）"></a>2倍图与3倍图（重要）</h2><blockquote><p>以后同学在工作的过程中，从UI那拿到的设计图通常都是640的设计图或者是750的设计图.</p></blockquote><p>把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度。</p><p><img src="2x.png" alt></p><p>设备像素比devicePixelRatio：即像素的压缩比例</p><p><strong>结论 ：在移动端为了在高清屏手机上显示得更加细腻，通常会使用更大的图片，比如2倍图或者3倍图。</strong></p><h2 id="视口viewport（重要）"><a href="#视口viewport（重要）" class="headerlink" title="视口viewport（重要）"></a>视口viewport（重要）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">问题：一个电脑上的网站，在手机端访问，效果是什么样的？</span><br><span class="line"></span><br><span class="line">iPhone5的设备宽度只有<span class="number">320</span>px，一张宽度为<span class="number">640</span>px的图片在手机端访问，显示的效果是什么？</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 在手机端，html的大小都是<span class="number">980</span>px，为什么？</span><br><span class="line">这主要是历史原因导致的，因为在移动设备刚流行的时候，网站大多都是pc端的，pc端的页面宽度一般都比较大，移动设备的宽度比较小，如果pc端页面直接在移动端显示的话，页面就会错乱。为了解决这个问题，移动端html的大小直接就定死成了<span class="number">980</span>px（因为早起的pc端网站版心就是<span class="number">980</span>px居多）。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 视口</span><br><span class="line">在pc端，html的大小默认是继承了浏览器的宽度，即浏览器多宽，html的大小就是多宽，但是在移动端，多出来了一个视口的概念（乔布斯）,视口说白了就是介于浏览器与html之间的一个东西，视口的宽度默认定死了<span class="number">980</span>px，因此html的宽度默认就是<span class="number">980</span>px，视口的特点是能够根据设备的宽度进行缩放。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 视口设置。</span><br><span class="line">对于现在的移动端页面来说，视口默认为<span class="number">980</span>px肯定不合适，因为设备宽度不够的话，视口会进行缩放，导致页面展示效果不好看。</span><br></pre></td></tr></table></figure><p><strong>视口参数设置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// width 设置视口的宽度</span></span><br><span class="line"><span class="comment">// width=device-width   设置视口宽度为设备的宽度（常用）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initial-scale 设置初始缩放比例</span></span><br><span class="line"><span class="comment">// initial-scale=1.0  表示不缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user-scalable 设置是否允许用户缩放</span></span><br><span class="line"><span class="comment">// user-scalable=no  不允许用户缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maximum-scale  设置允许的最大缩放比例</span></span><br><span class="line"><span class="comment">// maximum-scale=1.0  可以不设置，因为都禁止用户缩放了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// minimum-scale 设置允许最小缩放比</span></span><br><span class="line"><span class="comment">// minimum-scale=1.0  不设置，因为都禁用用户缩放了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标准写法：</span></span><br><span class="line"><span class="comment">// 快捷键：  meta:vp + tab键</span></span><br><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0"</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="移动端调试问题"><a href="#移动端调试问题" class="headerlink" title="移动端调试问题"></a>移动端调试问题</h2><ol><li>模拟器调试</li><li>真机调试：使用手机进行访问。</li></ol><p>手机设备五花八门，屏幕尺寸都大不一样，尤其是安卓端，给我们的页面预览带来了一些麻烦。在实际工作中，作为开发者不可能有足够的设备让我们去测试（<strong>除了测试部门</strong> ），即便有，效率也特别的低，因此开发者一般都是通过浏览器的手机模拟器来模拟不同的设备。</p><h1 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h1><p><strong>移动端的特点</strong></p><ul><li>手机端的兼容性问题比PC端小很多，因为手机端的浏览器版本比较新</li><li>手机端屏幕比较小，能够放的内容比较少。</li></ul><p>问题：布局的时候怎么解决屏幕大小不一致的问题？</p><ul><li>PC端，固定版心，让所有分辨率的电脑的版心都是一样的，比如京东</li><li>移动端：移动端无法设置版心，因为移动端的设备屏幕本身就小，设置版心不合适。因此移动端大多会采用流式布局（百分比布局）</li></ul><p><strong>流式布局</strong>，也叫百分比布局，是移动端开发中经常使用的布局方式之一。</p><p>流式布局的特征：</p><ul><li>宽度自适应，高度写死，并不是百分百还原设计图</li><li>图标都是固定死大小的，包括字体等也是固定死的。并不是所有的东西都是自适应的。</li><li>一些大的图片，设置宽度为百分比自适应即可，随着屏幕大小进行变化</li></ul><p><strong>流式布局无法做到所有设备都非常逼真的还原设计图，有些设备显示效果不是特别的好看。但是流式布局是移动端非常常用的一种布局方式，比较简单，需要掌握（携程、京东)</strong></p><p><strong>最后一天会学习rem布局，配合less非常的方便，并且能够实现完全的自适应，包括字体以及图标等</strong></p><p>经典的流式布局</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 左侧固定，右侧自适应</span><br><span class="line"><span class="number">2.</span> 右侧固定，左侧自适应</span><br><span class="line"><span class="number">3.</span> 两侧固定，中间自适应（圣杯布局，双飞翼布局）</span><br><span class="line"><span class="number">4.</span> 等分布局</span><br></pre></td></tr></table></figure><h1 id="touch-事件"><a href="#touch-事件" class="headerlink" title="touch 事件"></a>touch 事件</h1><p>移动端新增了4个与手指触摸相关的事件</p><ul><li><code>touchstart</code>: 手指放到屏幕上时触发</li><li><code>touchmove</code>: 手指在屏幕上滑动式触发（会触发多次）</li><li><code>touchend</code>: 手指离开屏幕时触发</li><li><code>touchcancel</code>: 系统取消touch事件的时候触发，比如电话</li></ul><p>每个触摸事件被触发后，会生成一个event对象，event对象中<code>changedTouches</code>会记录手指滑动的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.touches <span class="comment">// 当前屏幕上的手指</span></span><br><span class="line">e.targetTouches <span class="comment">// 当前dom元素上的手指。</span></span><br><span class="line">e.changedTouches <span class="comment">// 触摸时发生改变的手指(重点)(如手指离开屏幕)</span></span><br></pre></td></tr></table></figure><p>这些列表里的每次触摸由touch对象组成，touch对象里包含着触摸信息，主要属性如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e.changedTouches[0].clientX</span></span><br><span class="line">clientX / clientY <span class="comment">// 触摸点相对浏览器窗口的位置</span></span><br><span class="line">pageX / pageY     <span class="comment">// 触摸点相对于页面的位置</span></span><br></pre></td></tr></table></figure><p>!&gt; 使用 jquery 注册 touch 类事件时，获取手指使用 <code>e.originalEvent.touchs[0]</code> ，因为 jq 对事件对象进行了封装</p><p>【案例：jdm-滑动轮播图】</p><p>【案例：jdm-区域滚动】</p><h2 id="iscroll-插件使用"><a href="#iscroll-插件使用" class="headerlink" title="iscroll 插件使用"></a>iscroll 插件使用</h2><p><a href="https://github.com/cubiq/iscroll" target="_blank" rel="noopener">https://github.com/cubiq/iscroll</a></p><p><a href="http://www.mamicode.com/info-detail-331827.html" target="_blank" rel="noopener">iscroll参考文档</a></p><p><strong>注意</strong>：使用 iscroll 需要满足的条件</p><ol><li>父盒子嵌套了子盒子（一个）<ol><li>如果有多个子盒子，所以我们需要使用一个盒子把所有的子盒子包裹起来</li><li>如果有图片，我们需要保证图片加载完成，如果有浮动，需要清除浮动，为了保证子盒子的高度获取的是正确的</li></ol></li><li>子盒子大小一定要超过父盒子的大小</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用：box为父盒子</span></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">'.box'</span>)</span><br><span class="line"><span class="keyword">new</span> IScroll(box, &#123;</span><br><span class="line">    scrollX:<span class="literal">false</span>, <span class="comment">// 横向滚动</span></span><br><span class="line">    scrollY:<span class="literal">true</span> <span class="comment">// 纵向滚动</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h1 id="zepto-框架"><a href="#zepto-框架" class="headerlink" title="zepto 框架"></a>zepto 框架</h1><blockquote><p><strong>Zepto</strong>是一个轻量级的<strong>针对现代高级浏览器的JavaScript库， **它与jquery</strong>有着类似的api**。 如果你会用jquery，那么你也会用zepto。</p></blockquote><p><a href="https://github.com/madrobby/zepto" target="_blank" rel="noopener">github地址</a></p><p><a href="http://www.css88.com/doc/zeptojs_api/" target="_blank" rel="noopener">中文文档</a></p><h2 id="zepto-与-jquery-的区别"><a href="#zepto-与-jquery-的区别" class="headerlink" title="zepto 与 jquery 的区别"></a>zepto 与 jquery 的区别</h2><ul><li>jquery 针对 pc 端，主要用于解决浏览器兼容性问题，zepto 主要针对移动端</li><li>zepto 比 jquery 轻量，文件体积更小</li><li>zepto 封装了一些移动端的手势事件</li></ul><h2 id="zepto-的基本使用"><a href="#zepto-的基本使用" class="headerlink" title="zepto 的基本使用"></a>zepto 的基本使用</h2><p>zepto的使用与jquery基本一致，zepto是分模块的，需要某个功能，就需要引入某个zepto的文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"zepto/zepto.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"zepto/event.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"zepto/fx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">".box"</span>).addClass(<span class="string">"demo"</span>)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="string">"button"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="string">".box"</span>).animate(&#123;<span class="attr">width</span>:<span class="number">500</span>&#125;, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="zepto-的定制"><a href="#zepto-的定制" class="headerlink" title="zepto 的定制"></a>zepto 的定制</h2><p>安装Nodejs环境</p><p>1、下载zepto.js</p><p>2、解压缩</p><p>3、cmd命令行进入解压缩后的目录</p><p>4、执行<code>npm install</code>命令</p><p>5、编辑make文件的<code>41行</code>，添加自定义模块并保存</p><p>7、然后执行命令 <code>npm run-script dist</code></p><p>8、查看目录dist即构建好的zepto.js</p><h2 id="zepto-手势事件"><a href="#zepto-手势事件" class="headerlink" title="zepto 手势事件"></a>zepto 手势事件</h2><p>zepto中根据<code>touchstart touchmove touchend</code>封装了一些常用的手势事件，这些事件都是基于touchstart touchmove touchend封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tap   <span class="comment">// 轻触事件,用于替代移动端的click事件，因为click事件在老版本中会有300ms的延迟</span></span><br><span class="line">swipe <span class="comment">//手指滑动时触发</span></span><br><span class="line">swipeLeft  <span class="comment">//左滑</span></span><br><span class="line">swipeRight  <span class="comment">//右滑</span></span><br><span class="line">swipeUp    <span class="comment">//上滑</span></span><br><span class="line">swipeDown   <span class="comment">//下滑</span></span><br></pre></td></tr></table></figure><h1 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h1><h2 id="什么是响应式布局"><a href="#什么是响应式布局" class="headerlink" title="什么是响应式布局"></a>什么是响应式布局</h2><blockquote><p>响应式布局（respond layout）是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是<strong>一个网站能够兼容多个终端（手机、平板、pc电脑、手表）</strong> ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的</p></blockquote><p><strong>为什么要有响应式布局？</strong></p><ul><li>在移动互联日益成熟的时候，在PC端开发的网页已经无法满足移动设备的要求</li><li>通常的做法是针对移动端单独做一套特定的版本</li><li>如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及）</li><li><strong>响应式布局</strong> ：一个网站能够兼容多个终端（节约开发成本）</li></ul><p><strong>优点：</strong></p><p>面对不同分辨率设备灵活性强</p><p>能够快捷解决多设备显示适应问题</p><p>*<em>缺点： *</em></p><p>兼容各种设备工作量大，效率低下</p><p>代码累赘，会出现隐藏无用的元素，加载时间加长</p><p>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</p><p>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p><p>响应式开发现状：</p><ul><li>如果已经存在PC的网站了，那么一般不会使用响应式开发，而是针对移动端再开发一套系统（比如京东、淘宝）</li><li>在<strong>新建站点</strong> 上采用响应式开发的越来越多</li><li>在国内，响应式开发还不是特别的流行。但响应式开发是大势所趋，会越来越流行</li></ul><h2 id="响应式开发与移动web开发的比较"><a href="#响应式开发与移动web开发的比较" class="headerlink" title="响应式开发与移动web开发的比较"></a>响应式开发与移动web开发的比较</h2><table><thead><tr><th>开发方式</th><th>移动web开发+pc开发</th><th>响应式开发</th></tr></thead><tbody><tr><td>引用场景</td><td>一般已经有了PC端网站，只需要端独开发移动端网站即可</td><td>针对一些新建网站，并且要求适配移动端</td></tr><tr><td>开发</td><td>针对性强，开发效率高</td><td>兼容各种终端，效率低</td></tr><tr><td>适配</td><td>只能适配移动端或者PC端，pad上体验比较差</td><td>可以适配各种终端</td></tr><tr><td>效率</td><td>代码简介，加载快</td><td>代码相对复杂，加载慢</td></tr></tbody></table><h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><blockquote><p>媒体查询（Media Query）是 CSS3 提出来的一个新的属性，通过媒体查询可以查询到 screen 的宽度，从而指定某个宽度区间的网页布局</p></blockquote><h2 id="设备分类"><a href="#设备分类" class="headerlink" title="设备分类"></a>设备分类</h2><table><thead><tr><th>分类</th><th>宽度范围</th></tr></thead><tbody><tr><td>大屏设备</td><td>&gt;1200px</td></tr><tr><td>中屏设备</td><td>992px~1200px</td></tr><tr><td>小屏设备</td><td>768px~992px</td></tr><tr><td>超小屏设备</td><td>&lt; 768px</td></tr></tbody></table><h2 id="媒体查询的使用"><a href="#媒体查询的使用" class="headerlink" title="媒体查询的使用"></a>媒体查询的使用</h2><p>需求：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    大屏设备(&gt;1200px)   版心：1170px   背景色：红色</span></span><br><span class="line"><span class="comment">    中屏设备(992-1200)  版心：970px    背景色：蓝色</span></span><br><span class="line"><span class="comment">    小屏设备(768-992)   版心：750px    背景色：黄色</span></span><br><span class="line"><span class="comment">    超小屏设备(&lt;768px)  版心：100%     背景色：绿色</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>响应式开发的原理：使用媒体查询实现不同终端的布局和样式的切换</p><p>媒体查询语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查询屏幕 */</span></span><br><span class="line"><span class="comment">/* screen 和第一个 and 可以省略 */</span></span><br><span class="line">@<span class="keyword">media</span> screen and 条件 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 条件的写法 */</span></span><br><span class="line"><span class="comment">/* min-width: 只要屏幕宽度超过这个值的设备样式就能生效 */</span></span><br><span class="line"><span class="comment">/* max-width: 只要屏幕宽度小于这个值的设备样式就能生效 */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1170px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">992px</span>) and (max-width: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) and (max-width: <span class="number">992px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bootstrap-框架"><a href="#bootstrap-框架" class="headerlink" title="bootstrap 框架"></a>bootstrap 框架</h1><p><strong>【项目：微金所】</strong></p><h1 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h1><h2 id="rem-是什么？"><a href="#rem-是什么？" class="headerlink" title="rem 是什么？"></a>rem 是什么？</h2><p><code>rem</code>（font size of the root element）是指相对于<code>根元素</code>的字体大小的单位。它就是一个相对单位。</p><p><code>em</code>（font size of the element）是指相对于当前元素的字体大小的单位。它也是一个相对单位。</p><p>它们之间其实很相似，只不过计算的规则一个是依赖根元素，一个是当前元素计算。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.em</span> &#123;</span><br><span class="line">  <span class="comment">/* em 的计算方式参照的当前元素的 font-size，如果不设置，默认继承自父盒子 */</span></span><br><span class="line">  <span class="attribute">width</span>:<span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* rem 的计算方式参照的是 html 的 font-size */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.rem</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要用-rem？"><a href="#为什么要用-rem？" class="headerlink" title="为什么要用 rem？"></a>为什么要用 rem？</h2><blockquote><p>rem 的主要目的就是解决用于不同屏幕的适配问题。rem 能够等比例的适配所有的屏幕。</p></blockquote><p>由于市面上手机种类繁多，导致移动端的屏幕种类非常的混乱，比如有常见的<code>320px  360px  375px  384px  480px  640px</code>等。在开发中，美工一般只会提供750px或者是640px的设计稿，这就要求我们通过一张设计稿能够适配所有的屏幕。通常解决方案如下：</p><ul><li>流式布局：虽然可以让各种屏幕都适配，但是显示效果不是非常的友好，因为只有几个尺寸的手机能够完美的显示出来视觉设计师和交互最想要的效果。但是目前使用流式布局的公司非常多，比如 <a href="https://www.amazon.cn/" target="_blank" rel="noopener">亚马逊</a> 、<a href="https://m.jd.com/" target="_blank" rel="noopener">京东</a> 、<a href="https://m.ctrip.com/" target="_blank" rel="noopener">携程</a></li><li>响应式布局：响应式这种方式在国内很少有大型企业的复杂性的网站在移动端用这种方法去做，主要原因是<strong>工作大，维护性难</strong> 。所以一般都是中小型的门户或者博客类站点会采用响应式的方法从PC端页面到移动端页面以及web app直接一步到位，因为这样反而可以节约成本。</li><li>rem布局：rem能够适配所有的屏幕，与less配合使用效果会更好。目前使用rem布局的有：<a href="https://m.taobao.com" target="_blank" rel="noopener">淘宝</a> 、 <a href="https://m.suning.com/" target="_blank" rel="noopener">苏宁</a></li></ul><h2 id="rem-布局"><a href="#rem-布局" class="headerlink" title="rem 布局"></a>rem 布局</h2><p>因为 rem 的基准点是根元素html的字体大小，因此我们只需要设置不同屏幕的 html 的 font-size 大小不一样就可以达到不同屏幕的适配了。</p><h3 id="rem-配合媒体查询"><a href="#rem-配合媒体查询" class="headerlink" title="rem 配合媒体查询"></a>rem 配合媒体查询</h3><p>使用 rem 配合媒体查询可以适配多个终端</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@media(min-width: 320px) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="comment">/* 基准值 / 设计图的大小  = 某个屏幕的font-size / 屏幕的宽度 */</span></span><br><span class="line">        <span class="comment">/* 100/750 = x/370 */</span></span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>优点：使用媒体查询适配，速度快。</p><p>缺点：适配多个终端时，需要添加响应的代码。</p><h3 id="rem-配合-javascript"><a href="#rem-配合-javascript" class="headerlink" title="rem 配合 javascript"></a>rem 配合 javascript</h3><p>通过 javascript 获取可视区的宽度，计算 font-size 的值，也可以适配多个终端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据屏幕的大小动态设置 html的 font-size</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">responsive</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> uiWidth = <span class="number">750</span> <span class="comment">// 设计图宽度</span></span><br><span class="line">  <span class="keyword">var</span> base = <span class="number">100</span> <span class="comment">// 设计图中1rem的大小</span></span><br><span class="line">  <span class="comment">// 当前屏幕的大小</span></span><br><span class="line">  <span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth</span><br><span class="line">  <span class="keyword">if</span>(pageWidth &gt;= <span class="number">750</span>) &#123;</span><br><span class="line">    pageWidth = <span class="number">750</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pageWidth &lt;= <span class="number">320</span>) &#123;</span><br><span class="line">    pageWidth = <span class="number">320</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 说白了就是把一个屏幕分成了 7.5 rem</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.style.fontSize = (base / uiWidth * pageWidth).toFixed(<span class="number">2</span>) + ’px‘</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：直接适配所有的终端</p><p>缺点：必须在页面加载之前设置html的font-size值，不然会出现文字大小调动的情况。</p><h3 id="rem-配合-flexible-插件"><a href="#rem-配合-flexible-插件" class="headerlink" title="rem 配合 flexible 插件"></a>rem 配合 flexible 插件</h3><ul><li><p>flexible 插件基准值（base）是设计图的 1/10</p></li><li><p>使用 flexible</p></li></ul><ol><li><p>在 header 中引入 flexible.js 这个文件</p></li><li><p>根据设计图能够确定基准值， 配合 px2rem 插件 ，需要设置一个 rootFontSize</p></li></ol><p>【案例：苏宁易购】</p><h1 id="swiper-插件"><a href="#swiper-插件" class="headerlink" title="swiper 插件"></a>swiper 插件</h1><blockquote><p>Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端</p></blockquote><p><a href="http://www.swiper.com.cn/" target="_blank" rel="noopener">swiper中文网</a></p><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="comment">/* 取消链接高亮, 移动端特有的样式  */</span></span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>: <span class="built_in">rgba</span>(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;移动web基础&quot;&gt;&lt;a href=&quot;#移动web基础&quot; class=&quot;headerlink&quot; title=&quot;移动web基础&quot;&gt;&lt;/a&gt;移动web基础&lt;/h1&gt;&lt;h2 id=&quot;移动端开发现状&quot;&gt;&lt;a href=&quot;#移动端开发现状&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="移动web" scheme="http://blog.clj.me/categories/%E7%A7%BB%E5%8A%A8web/"/>
    
    
      <category term="移动web" scheme="http://blog.clj.me/tags/%E7%A7%BB%E5%8A%A8web/"/>
    
  </entry>
  
  <entry>
    <title>LESS</title>
    <link href="http://blog.clj.me/2018/tool/less/"/>
    <id>http://blog.clj.me/2018/tool/less/</id>
    <published>2018-12-11T10:00:00.000Z</published>
    <updated>2018-12-09T10:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LESS"><a href="#LESS" class="headerlink" title="LESS"></a>LESS</h1><h2 id="Less-简介"><a href="#Less-简介" class="headerlink" title="Less 简介"></a>Less 简介</h2><blockquote><p> <strong><em>Less</em> 是一门 CSS 预处理语言（预先处理）,它扩展了 CSS 语言，增加了变量、Mixin、函数等特性</strong></p><p> 浏览器不直接识别 less 文件，浏览器只识别 css 文件，所以我们写了 less 文件之后，我们需要预先把 less 文件转换成css文件。</p></blockquote><p>本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。</p><p><strong>less仅仅是写css的另一种方式，写出来的less文件浏览器也不识别，所以啊，我们写完了less文件，还需要通过less解析器解析成css，最终浏览器引入的还是css文件。</strong></p><p>学习网站：</p><p><a href="http://lesscss.org/" target="_blank" rel="noopener">官网http://lesscss.org/</a><br><a href="http://lesscss.cn/" target="_blank" rel="noopener">中文网http://lesscss.cn/</a></p><h2 id="less-的编译"><a href="#less-的编译" class="headerlink" title="less 的编译"></a>less 的编译</h2><blockquote><p>如何把 less 文件变成 css 文件</p></blockquote><h3 id="使用打包工具"><a href="#使用打包工具" class="headerlink" title="使用打包工具"></a>使用打包工具</h3><p><code>gulp</code></p><p><code>webpack</code></p><h3 id="使用考拉"><a href="#使用考拉" class="headerlink" title="使用考拉"></a>使用考拉</h3><blockquote><p>koala 是一个前端预处理器语言（less/sass）图形编译工具，支持 Less、Sass、Compass、CoffeeScript，帮助web开发者更高效地使用它们进行开发。跨平台运行，完美兼容windows、linux、mac。</p></blockquote><p><a href="http://koala-app.com/index-zh.html" target="_blank" rel="noopener">考拉官网</a></p><p>使用步骤：</p><ol><li>把<code>less</code>文件夹拖进去</li><li>会在当前目录生成一个<code>css</code>目录</li></ol><p>优点：不用node环境，不用less环境，koala内置了</p><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>easy less</p><h2 id="Less-语法"><a href="#Less-语法" class="headerlink" title="Less 语法"></a>Less 语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>注释</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是CSS中的注释，因此会编译到css中 */</span></span><br><span class="line"><span class="comment">// 这是less的注释，css不能识别这个注释， 最后不会编译到css文件</span></span><br></pre></td></tr></table></figure><p><strong>变量</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @变量名: 变量值;</span></span><br><span class="line"><span class="variable">@color:</span> <span class="number">#ccc</span>;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mixin-函数"><a href="#mixin-函数" class="headerlink" title="mixin 函数"></a>mixin 函数</h3><p><strong>混入函数</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数：不带参数</span></span><br><span class="line"><span class="selector-class">.btn</span>() &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="selector-class">.btn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数：带参数</span></span><br><span class="line"><span class="selector-class">.btn_border</span>(<span class="variable">@width</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@width</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="comment">// 如果函数定义了参数，调用的时候必须传入参数，否则会报错</span></span><br><span class="line">  <span class="selector-class">.btn_border</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数：带参数默认值</span></span><br><span class="line"><span class="selector-class">.btn_border</span>(<span class="variable">@width</span>: <span class="number">1px</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">@width</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.my_btn</span> &#123;</span><br><span class="line">  <span class="comment">// 因为有默认值，所以不会报错</span></span><br><span class="line">  <span class="selector-class">.btn_border</span>();</span><br><span class="line">  <span class="selector-class">.btn_border</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：定义兼容多浏览器的圆角</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border_radius</span>(<span class="variable">@value</span>: <span class="number">5px</span>) &#123;</span><br><span class="line">  <span class="attribute">-webkit-border-radius</span>:<span class="variable">@value</span>;</span><br><span class="line">  <span class="attribute">-moz-border-radius</span>:<span class="variable">@value</span>;</span><br><span class="line">  <span class="attribute">-ms-border-radius</span>:<span class="variable">@value</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>:<span class="variable">@value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.border_radius</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><blockquote><p>我们可以在一个选择器中嵌套另一个选择器来实现继承，这样很大程度减少了代码量，并且代码看起来更加的清晰。</p></blockquote><ul><li>使用伪类的时候 可以使用<code>&amp;</code> 表示自己</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="comment">// 子代</span></span><br><span class="line">  <span class="selector-class">.son1</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 后代</span></span><br><span class="line">  &gt; <span class="selector-class">.son2</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 交集： &amp; 表示本身</span></span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-class">.now</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以省略后缀名</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"variable"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"maxin"</span>;</span><br></pre></td></tr></table></figure><p>模块化的思想，分模块进行管理这些less文件，最终只需要使用import将less引入到一起即可。</p><h3 id="函数（运算）"><a href="#函数（运算）" class="headerlink" title="函数（运算）"></a>函数（运算）</h3><blockquote><p>在我们的 CSS 中充斥着大量的数值型的 value，less可以直接支持运算，也提供了一系列的函数提供给我们使用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">li &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: round(100%/6, 2);</span><br><span class="line">  height: 100px + 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.1024i.com/demo/less/reference.html" target="_blank" rel="noopener">http://www.1024i.com/demo/less/reference.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LESS&quot;&gt;&lt;a href=&quot;#LESS&quot; class=&quot;headerlink&quot; title=&quot;LESS&quot;&gt;&lt;/a&gt;LESS&lt;/h1&gt;&lt;h2 id=&quot;Less-简介&quot;&gt;&lt;a href=&quot;#Less-简介&quot; class=&quot;headerlink&quot; title=&quot;Les
      
    
    </summary>
    
      <category term="工具" scheme="http://blog.clj.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="less" scheme="http://blog.clj.me/tags/less/"/>
    
  </entry>
  
  <entry>
    <title>技术栈</title>
    <link href="http://blog.clj.me/2018/other/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>http://blog.clj.me/2018/other/技术栈/</id>
    <published>2018-12-04T05:00:00.000Z</published>
    <updated>2019-02-24T15:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="技术栈："><a href="#技术栈：" class="headerlink" title="技术栈："></a>技术栈：</h3><p>ajax + jquery + art-template：较原始的开发方式</p><p>vue + vuex + vue-router + webpack + less + weex + nuxt(ssr)</p><p>react + react-router + redux + webpack + less + react-native</p><p>angular + webpack + typescript + less + ionic</p><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;技术栈：&quot;&gt;&lt;a href=&quot;#技术栈：&quot; class=&quot;headerlink&quot; title=&quot;技术栈：&quot;&gt;&lt;/a&gt;技术栈：&lt;/h3&gt;&lt;p&gt;ajax + jquery + art-template：较原始的开发方式&lt;/p&gt;
&lt;p&gt;vue + vuex + vue-
      
    
    </summary>
    
      <category term="other" scheme="http://blog.clj.me/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器的工作原理</title>
    <link href="http://blog.clj.me/2018/other/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.clj.me/2018/other/浏览器工作原理/</id>
    <published>2018-11-30T11:15:00.000Z</published>
    <updated>2018-12-03T07:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器的工作原理"><a href="#浏览器的工作原理" class="headerlink" title="浏览器的工作原理"></a>浏览器的工作原理</h1><h2 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h2><p><img src="How-browsers-work1.png" alt="浏览器的组成"></p><ul><li>用户界面－ 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分</li><li>浏览器引擎－ 用来查询及操作渲染引擎的接口</li><li>渲染引擎（浏览器内核）－ 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来</li><li>网络－ 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作</li><li>UI 后端－ 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口</li><li>JS解释器－ 用来解释执行JS代码</li><li>数据存储－ 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了Storage技术，这是一种轻量级完整的客户端存储技术</li></ul><h2 id="主流的渲染引擎"><a href="#主流的渲染引擎" class="headerlink" title="主流的渲染引擎"></a>主流的渲染引擎</h2><blockquote><p>浏览器的渲染引擎也叫排版引擎，或者是<strong>浏览器内核</strong></p></blockquote><p>主流的 渲染引擎 有</p><ul><li><strong>Chrome浏览器</strong>: Blink引擎（WebKit的一个分支）。</li><li><strong>Safari浏览器</strong>: WebKit引擎，windows版本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发Windows版的Safari。</li><li><strong>FireFox浏览器</strong>: Gecko引擎。</li><li><strong>Opera浏览器</strong>: Blink引擎(早期版使用Presto引擎）。</li><li><strong>Internet Explorer浏览器</strong>: Trident引擎。</li><li><strong>Microsoft Edge浏览器</strong>: EdgeHTML引擎（Trident的一个分支）。</li></ul><h2 id="渲染引擎工作原理"><a href="#渲染引擎工作原理" class="headerlink" title="渲染引擎工作原理"></a>渲染引擎工作原理</h2><p>渲染引擎解析的基本流程：</p><ol><li><p>解析 HTML 构建 <code>Dom树</code>，同时解析所有的 css 样式，构建 css 规则。DOM 是 W3C 组织推荐的处理可扩展置标语言的标准编程接口。</p></li><li><p>根据 DOM 树和 css 规则合并构建 <code>渲染树</code></p><ul><li>DOM树上的节点没有样式的，渲染树的节点有样式的</li><li>渲染树上的节点都是需要渲染的，所以渲染树上没有像<code>head</code>标签 或 <code>display: none</code>这样的元素，但是它们在Dom树中</li></ul></li><li><p>对渲染树进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫<code>layout</code> 或 <code>reflow</code>。</p></li><li><p>绘制渲染树，调用操作系统底层API(UI Backend)进行绘图操作。</p></li></ol><p><img src="flow.png" alt></p><p><strong>webkit内核工作流程</strong></p><p><img src="webkitflow.png" alt></p><p><strong>gecko内核工作流程</strong></p><p><img src="gecko.jpg" alt></p><p>结论：浏览器能够解析HTML文件，并且显示到页面中。所以我们写的文件能够使用浏览器打开并且能够看到效果。</p><h1 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h1><h2 id="重绘与回流-1"><a href="#重绘与回流-1" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p><code>回流(reflow)</code>: 又叫重排，当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。</p><p><code>重绘(repaint)</code>：当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。</p><ol><li>每个页面至少需要一次回流+重绘。</li><li>回流必将引起重绘</li></ol><p>回流什么时候发生？</p><p>1、添加或者删除可见的DOM元素</p><p>2、元素位置改变</p><p>3、元素尺寸改变——边距、填充、边框、宽度和高度</p><p>4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变</p><p>5、页面渲染初始化</p><p>6、浏览器窗口尺寸改变——resize事件发生时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style</span><br><span class="line">s.padding = <span class="string">"2px"</span> <span class="comment">// 回流+重绘</span></span><br><span class="line">s.border = <span class="string">"1px solid red"</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line">s.color = <span class="string">"blue"</span> <span class="comment">// 再一次重绘</span></span><br><span class="line">s.backgroundColor = <span class="string">"#ccc"</span> <span class="comment">// 再一次 重绘</span></span><br><span class="line">s.fontSize = <span class="string">"14px"</span> <span class="comment">// 再一次 回流+重绘</span></span><br><span class="line"><span class="comment">// 添加node，再一次 回流+重绘</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'abc!'</span>))</span><br></pre></td></tr></table></figure><h2 id="聪明的浏览器"><a href="#聪明的浏览器" class="headerlink" title="聪明的浏览器"></a>聪明的浏览器</h2><blockquote><p>从上个实例代码中可以看到几行简单的JS代码就引起了6次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句JS操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p></blockquote><p>虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些 style信息的时候，就会让浏览器flush队列，比如：</p><ol><li><p>offsetTop, offsetLeft, offsetWidth, offsetHeight</p></li><li><p>scrollTop/Left/Width/Height</p></li><li><p>clientTop/Left/Width/Height</p></li><li><p>width,height</p></li><li><p>请求了getComputedStyle(), 或者 IE的 currentStyle</p></li></ol><h2 id="如何性能优化"><a href="#如何性能优化" class="headerlink" title="如何性能优化"></a>如何性能优化</h2><blockquote><p>减少回流与重绘的次数，就需要简单对渲染树的操作</p></blockquote><ol><li>直接使用 <code>className</code> 修改样式，少用 style 设置样式</li><li>让要操作的元素进行”离线处理”，处理完后一起更新<ul><li>使用 <code>DocumentFragment</code> 进行缓存操作，引发一次回流和重绘</li><li>使用 <code>display:none</code> 技术，只引发两次回流和重绘</li></ul></li><li>将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow</li><li><strong>完成功能是前提，在完成功能的情况下想着优化代码</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浏览器的工作原理&quot;&gt;&lt;a href=&quot;#浏览器的工作原理&quot; class=&quot;headerlink&quot; title=&quot;浏览器的工作原理&quot;&gt;&lt;/a&gt;浏览器的工作原理&lt;/h1&gt;&lt;h2 id=&quot;浏览器的组成&quot;&gt;&lt;a href=&quot;#浏览器的组成&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="other" scheme="http://blog.clj.me/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS3 基础</title>
    <link href="http://blog.clj.me/2018/html&amp;css/css3/"/>
    <id>http://blog.clj.me/2018/html&amp;css/css3/</id>
    <published>2018-11-23T10:00:00.000Z</published>
    <updated>2019-04-29T03:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><p>如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，<strong>增强</strong> 或 <strong>新增</strong> 了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><ul><li>PC 端浏览器支持程度差，需要添加私有前缀</li><li>移动端支持优于 PC 端</li><li>不断改进中</li><li>应用相对广泛</li></ul><p>关于私有前缀：</p><blockquote><p>在标准还未确定时，部分浏览器已经根据最初草案实现了部分功能，为了与之后确定下来的标准进行兼容，所以每种浏览器使用了自己的私有前缀与标准进行区分，当标准确立后，各大浏览器将逐步支持不带前缀的 css3 新属性</p><p>目前已有很多私有前缀可以不写了，但为了兼容老版本的浏览器，可以仍沿用私有前缀和标准方法，逐渐过渡</p><p>一般来说，CSS3主要是为移动端而生的，因此我们在移动端没必要写太多的前缀，因为移动端的 ios 和 Android 的浏览器都是 webkit 内核</p><p>谷歌、苹果浏览器：<code>-webkit-</code><br>火狐浏览器：<code>-moz-</code><br>IE浏览器：<code>-ms-</code><br>欧朋浏览器：<code>-o-</code></p><p>一般工作中不用去加，会通过打包工具 webpack 自动添加</p></blockquote><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><ul><li>text-shadow: 文字阴影</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：text-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]*</span><br><span class="line">  &lt;shadow&gt; =&gt; &lt;length&gt;&#123;2,3&#125; &amp;&amp; &lt;color&gt;?</span><br><span class="line">text-shadow：水平偏移 垂直偏移 羽化大小 颜色</span><br><span class="line">水平偏移 垂直偏移 可以为负值，羽化大小可选且不可为负</span><br><span class="line">可以设置多组阴影值，用逗号隔开</span><br></pre></td></tr></table></figure><ul><li>box-shadow: 边框阴影</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：box-shadow：none | &lt;shadow&gt; [ , &lt;shadow&gt; ]*</span><br><span class="line">  &lt;shadow&gt; =&gt; inset? &amp;&amp; &lt;length&gt;&#123;2,4&#125; &amp;&amp; &lt;color&gt;?</span><br><span class="line"></span><br><span class="line">box-shadow：水平偏移 垂直偏移 羽化大小 阴影外延 颜色</span><br><span class="line">水平偏移、垂直偏移、阴影外延可以为负值，羽化大小、阴影外延可选，羽化大小不允许负值</span><br><span class="line">可以设置多组阴影值，用逗号隔开</span><br><span class="line">inset：设置对象的阴影类型为内阴影。该值为空时，则对象的阴影类型为外阴影</span><br></pre></td></tr></table></figure><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>background-size</p><p>bakground-clip</p><p>background-origin</p><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><blockquote><p>linear-gradient() 指沿着某条直线朝一个方向产生的渐变效果</p><p>渐变实际上相当与一张图片，因为需要加给 background-image 才会生效</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最简单的渐变 颜色至少两个 方向默认从上到下 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定渐变的方向 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 也可以设定渐变的角度 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(45<span class="selector-tag">deg</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设定渐变的范围 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span> 20%, <span class="selector-tag">green</span> 80%)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 每一个区间表示渐变颜色的范围 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span> 20%, <span class="selector-tag">green</span> 20%)</span><br></pre></td></tr></table></figure><h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><blockquote><p>radial-gradient 指从一个中心点开始沿着四周产生渐变效果</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最简单的渐变 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(<span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定圆的半径和圆心 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(200<span class="selector-tag">px</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定椭圆 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(200<span class="selector-tag">px</span> 80<span class="selector-tag">px</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>, <span class="selector-tag">red</span>, <span class="selector-tag">green</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定范围 */</span></span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(200<span class="selector-tag">px</span> <span class="selector-tag">at</span> <span class="selector-tag">center</span>, <span class="selector-tag">green</span> 50%, <span class="selector-tag">red</span> 50%);</span><br></pre></td></tr></table></figure><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><blockquote><p>CSS3 中可以通过 box-sizing 来指定盒模型，即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变</p></blockquote><p>可以分成两种情况：</p><ul><li>box-sizing: border-box 计算方式为 content = width – border - padding</li><li>box-sizing: content-box 计算方式为 content = width</li></ul><h2 id="calc-函数"><a href="#calc-函数" class="headerlink" title="calc() 函数"></a>calc() 函数</h2><p>用于动态计算长度值</p><ul><li>注意：运算符前后都需要保留一个空格，例如：<code>width: calc(100% - 10px)</code></li><li>任何长度值都可以使用 calc() 函数进行计算</li><li>calc() 函数支持 <code>+</code> 、<code>-</code>、 <code>*</code> 、<code>/</code> 运算</li><li>calc() 函数使用标准的数学运算优先级规则</li></ul><h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><ul><li>过渡的属性</li></ul><p>如果两个状态发生改变，没有过渡，效果是瞬间变化的，如果加上了过渡，那么这个过程就会有动画的效果，整个状态变化的过程是由浏览器来完成的，我们只需要关注开始状态与结束状态即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* transition-property：设置过渡属性 默认值为 all 表示全部*/</span></span><br><span class="line"><span class="comment">/* 多个用逗号分隔 */</span></span><br><span class="line"><span class="selector-tag">transition-property</span>: <span class="selector-tag">all</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-duration:设置过渡时间 */</span></span><br><span class="line"><span class="selector-tag">transition-duration</span>: 1<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-delay：设置过渡延时 */</span></span><br><span class="line"><span class="selector-tag">transition-delay</span>: 2<span class="selector-tag">s</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* transition-timing-function:设置过渡的速度 */</span></span><br><span class="line"><span class="comment">/* linear(匀速)，ease(平滑)，ease-in，ease-out，ease-in-out， steps(10)(分步动画) */</span></span><br><span class="line"><span class="selector-tag">transition-timing-function</span>: <span class="selector-tag">linear</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>过渡必须要有两个状态的变化</li><li>过渡除了可以加到初始的状态，可以加到 hover 状态，但效果不一样，如果加到 hover 状态，回来就没有过渡了</li></ol></blockquote><ul><li>属性合写</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 属性 时间 延时 速度 */</span></span><br><span class="line"><span class="comment">/* 多个过渡用逗号隔开 */</span></span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">width</span> 1<span class="selector-tag">s</span> 3<span class="selector-tag">s</span> <span class="selector-tag">linear</span>, <span class="selector-tag">border-radius</span> 3<span class="selector-tag">s</span>;</span><br></pre></td></tr></table></figure><h2 id="2D-转换"><a href="#2D-转换" class="headerlink" title="2D 转换"></a>2D 转换</h2><blockquote><p>transform: 转换，是 CSS3 最具颠覆性的几个特性之一，既可以用于 2D 转换，也可以用于 3D 转换</p><p>transform: 2D 转换，元素在平面上实现移动、旋转、缩放、斜切等操作</p></blockquote><h3 id="scale-缩放"><a href="#scale-缩放" class="headerlink" title="scale 缩放"></a>scale 缩放</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleX</span>(0<span class="selector-class">.5</span>); <span class="comment">/* 让宽度变化 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scaleY</span>(0<span class="selector-class">.5</span>); <span class="comment">/* 让高度变化，注意不能写多个transform，不然会覆盖 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>); <span class="comment">/* 让宽度和高度同时变化 */</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>scale 接收的值是倍数，因此没有单位</p></li><li><p>scale 是一个值时，宽度高度会等比例同事缩放</p></li><li><p>scale 缩放时内部内容也会缩放</p></li><li><blockquote><p>可以通过 transition-origin 设定缩放原点 （可以是数值或方位词top、left…)</p></blockquote></li></ul><h3 id="translate-平移"><a href="#translate-平移" class="headerlink" title="translate 平移"></a>translate 平移</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(100<span class="selector-tag">px</span>, 100<span class="selector-tag">px</span>);</span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(50%, 50%);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>translate 的值可以是 px，也可以是百分比，如果是百分比，那么参照的是<strong>自身的宽高</strong></li><li>translate 移动的元素并不会影响其他盒子，类似于相对定位</li></ul><h3 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(360<span class="selector-tag">deg</span>); <span class="comment">/* 旋转360度 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(<span class="selector-tag">-360deg</span>); <span class="comment">/* 逆时针旋转360度 */</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>单位是 deg，角度，不是 px</li><li>正值顺时针转，负值逆时针转</li><li>可以通过 transition-origin 设定旋转原点</li></ul><blockquote><p>rotate 旋转会让坐标轴也跟着旋转</p></blockquote><h3 id="skew-斜切-变形"><a href="#skew-斜切-变形" class="headerlink" title="skew 斜切(变形)"></a>skew 斜切(变形)</h3><p>skew 在实际开发中，是用的最少的一个属性。一般来说，x 和 y 只会倾斜其中的一个</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在水平方向倾斜30deg */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewX</span>(30<span class="selector-tag">deg</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在垂直方向倾斜30deg */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">skewY</span>(30<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure><p>【案例：扫光效果.html】</p><h3 id="transform-origin-转换原点"><a href="#transform-origin-转换原点" class="headerlink" title="transform-origin 转换原点"></a>transform-origin 转换原点</h3><blockquote><p>通过 transform-origin 可以设置转换的中心原点</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform-origin</span>: <span class="selector-tag">center</span> <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">transform-origin</span>: 40<span class="selector-tag">px</span> 40<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><h3 id="转换合写问题"><a href="#转换合写问题" class="headerlink" title="转换合写问题"></a>转换合写问题</h3><blockquote><p>transform 属性只能写一个，如果写了多个会覆盖，属性的值可以写多个， 用空格隔开即可</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(800<span class="selector-tag">px</span>) <span class="selector-tag">scale</span>(1<span class="selector-class">.5</span>) <span class="selector-tag">rotate</span>(360<span class="selector-tag">deg</span>);</span><br></pre></td></tr></table></figure><ul><li>transform 属性可以连写，但是顺序对效果影响的，因为它会在第一个效果的基础上执行第二个效果，然后执行第三个效果（通常会把 rotate 放后面）</li><li>如果对 transform 进行过度效果的时候，初始状态和结束状态要一一对应</li></ul><p>【案例：盾牌打散与合并效果.html】</p><h2 id="3D-转换"><a href="#3D-转换" class="headerlink" title="3D 转换"></a>3D 转换</h2><p>思考：2D与3D的区别？</p><h3 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h3><blockquote><p>用 X、Y、Z 分别表示空间的3个维度，三条轴互相垂直。<strong>注意+Y是向下的</strong></p></blockquote><p><img src="zbz.png" alt="img"></p><h3 id="perspective-透视"><a href="#perspective-透视" class="headerlink" title="perspective 透视"></a>perspective 透视</h3><blockquote><p>电脑显示屏是一个 2D 的平面，因为我们看不出来旋转的方向，通过 perspective 属性，可以定义 3D 元素距视图的距离，单位是 px。</p><p>说白了，设置了perspective属性后，就有了进大远小的效果了，在视觉上，让我们能看出来 3d 的效果。</p><p>注意：当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">perspective</span>：500<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>对于我们眼睛来说，离我们越近的房子，我们会感觉到这个房子越大，离我们越远的房子，就会感觉越小，其实房子的大小都是一样的，只是在视觉上的一种不同。</p><p><img src="per3.png" alt="img"></p><h3 id="rotate-旋转-1"><a href="#rotate-旋转-1" class="headerlink" title="rotate 旋转"></a>rotate 旋转</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素在平面2D中旋转，相当于沿着Z轴旋转 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateX</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素沿着X轴转45度 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateY</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素沿着Y轴转45度 */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotateZ</span>(45<span class="selector-tag">deg</span>); <span class="comment">/* 让元素沿着Z轴转45度 */</span></span><br></pre></td></tr></table></figure><p>【3D旋转.html】</p><h3 id="translate-平移-1"><a href="#translate-平移-1" class="headerlink" title="translate 平移"></a>translate 平移</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 沿着X轴的正方向移动45px */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(45<span class="selector-tag">px</span>);</span><br><span class="line"><span class="comment">/* 沿着Y轴的正方向移动45px */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateY</span>(45<span class="selector-tag">px</span>);</span><br><span class="line"><span class="comment">/* 沿着Z轴的正方向移动45px */</span></span><br><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">translateZ</span>(45<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure><p>【3D平移.html】</p><p>【立方体.html】</p><h3 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h3><p>transform-style 属性规定如何在 3D 空间中呈现被嵌套的元素。注意这个属性只能给父元素添加</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flat</span>: 默认值，2<span class="selector-tag">d</span>显示</span><br><span class="line"><span class="selector-tag">preserve-3d</span>: 3<span class="selector-tag">d</span>显示</span><br></pre></td></tr></table></figure><p>transform-style 与 perspective 区别</p><ul><li>透视：透视只是相当于设置了一个距离，辅助我们查看 3D 效果的工具</li><li>preserve-3d：给父盒子添加，让子元素保留 3D 的位置，说白了，只有设置了 preserve-3d，这个元素才能被称之为 3d 元素</li><li>一个 3d 元素可以没有perspective，但是不能没有 transform-style</li></ul><p>【3D导航案例.html】</p><p>【切割轮播图案例】</p><p>【3D相册案例】</p><h3 id="过渡结束事件"><a href="#过渡结束事件" class="headerlink" title="过渡结束事件"></a>过渡结束事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给最后一个ul添加过渡结束事件（节流阀）</span></span><br><span class="line">uls[uls.length - <span class="number">1</span>].addEventListener(<span class="string">'transitionend'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">isCanAnimate = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><blockquote><p>动画可以通过设置多个节点来精确控制一个或者一组动画，常用来实现复杂的动画效果</p></blockquote><p>动画与过渡的区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过渡必须触发，需要两个状态的改变。</span><br><span class="line">动画可以一直运行下去，不需要触发。实现效果与过渡差不多</span><br></pre></td></tr></table></figure><p>使用一个动画的基本步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.通过 @keyframes 指定动画序列</span><br><span class="line">2.通过百分比或者 from/to 将动画分割成多个节点</span><br><span class="line">3.在各个节点中分别定义样式</span><br><span class="line">4.通过 animation 将动画应用于相应的元素</span><br></pre></td></tr></table></figure><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>animation 是一个复合属性，一共有8个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">animation-name: 动画名称，由@keyframes定义的</span><br><span class="line">animation-duration: 动画的持续时间 默认0s</span><br><span class="line">animation-timing-function: 动画的过渡类型 ease(默认) linear steps</span><br><span class="line">animation-delay: 动画的延迟时间 默认0s</span><br><span class="line">animation-iteration-count: 动画的循环次数 默认1次  infinite：无限循环</span><br><span class="line">animation-direction: 设置动画在循环中的方向 normal：正向(默认) reverse(反向) alternate(往复循环)</span><br><span class="line">animation-fill-mode: 设置动画结束时的状态 none：默认 backwards：动画结束时停留在开始状态 forwards: 动画结束时停留在结束的状态</span><br><span class="line">animation-play-state: 设置动画的状态。running：运动(默认) paused：暂停</span><br></pre></td></tr></table></figure><h3 id="动画库的使用"><a href="#动画库的使用" class="headerlink" title="动画库的使用"></a>动画库的使用</h3><p><a href="https://daneden.github.io/animate.css/" target="_blank" rel="noopener">https://daneden.github.io/animate.css/</a></p><h2 id="字体图标"><a href="#字体图标" class="headerlink" title="字体图标"></a>字体图标</h2><p>我们经常把网页常用的一些小的图标，做成精灵图，然后通过 background-position 去调整位置，但是这个需要引入图片，并且图片大小改变之后会失真。在CSS3中可以使用字体图片，即使用图标跟使用文字一样</p><p>优点：</p><p>1、将所有图标打包成字体库，减少请求</p><p>2、具有矢量性，可保证清晰度，可以修改文字的颜色或者样式</p><p>3、使用灵活，便于维护</p><p>阿里巴巴矢量图标：<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">http://www.iconfont.cn/</a></p><p>Font Awesome 使用 <a href="http://fontawesome.dashgame.com/" target="_blank" rel="noopener">http://fontawesome.dashgame.com/</a></p><h2 id="弹性布局-伸缩布局"><a href="#弹性布局-伸缩布局" class="headerlink" title="弹性布局(伸缩布局)"></a>弹性布局(伸缩布局)</h2><blockquote><p>布局：其实就是调整元素在水平和垂直方向上的布局方式</p></blockquote><p>CSS3 在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。</p><p>当给一个盒子设置了 display：flex 之后，这个盒子就有了 <strong>主轴</strong> 和 <strong>侧轴</strong>  的概念<br>主轴：默认是水平方向向右，子元素在主轴上排列<br>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向向下</p><p><img src="flex.png" alt></p><h3 id="给容器设置的样式"><a href="#给容器设置的样式" class="headerlink" title="给容器设置的样式"></a>给容器设置的样式</h3><ul><li>flex-direction</li></ul><p>用来调整主轴的方向，默认是水平方向，可选值有：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">row</span>：主轴方向为水平向右（默认）</span><br><span class="line"><span class="selector-tag">column</span>：主轴方向为竖直向下</span><br><span class="line"><span class="selector-tag">row-reverse</span>: 主轴方向为水平向左</span><br><span class="line"><span class="selector-tag">column-reverse</span>: 主轴方向是竖直向上</span><br></pre></td></tr></table></figure><ul><li>justify-content</li></ul><p>用来设置子元素在 <strong>主轴方向的对齐方式</strong> ，可选的值有：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-start</span>: 弹性盒子元素将向起始位置对齐</span><br><span class="line"><span class="selector-tag">flex-end</span>: 弹性盒子元素将向结束位置对齐</span><br><span class="line"><span class="selector-tag">center</span>: 弹性盒子元素将向行中间位置对齐</span><br><span class="line"><span class="selector-tag">space-between</span>: 第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的</span><br><span class="line"><span class="selector-tag">space-around</span>: 弹性盒子元素会平均地分布在行里（不会贴边）</span><br></pre></td></tr></table></figure><ul><li>align-items</li></ul><p>用于调整 <strong>侧轴的对其方式</strong> ，可选的值有：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-start</span>：元素在侧轴的起始位置对其</span><br><span class="line"><span class="selector-tag">flex-end</span>：元素在侧轴的结束位置对其</span><br><span class="line"><span class="selector-tag">center</span>：元素在侧轴上居中对其</span><br><span class="line"><span class="selector-tag">stretch</span>：元素的高度会被拉伸到最大（不能给死高度）</span><br></pre></td></tr></table></figure><ul><li>flex-wrap</li></ul><p>控制 flex 容器是单行或者多行，默认不换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nowrap</span>：不换行（默认），会压缩子盒子的宽度</span><br><span class="line"><span class="selector-tag">wrap</span>：当宽度不够的时候，会换行</span><br></pre></td></tr></table></figure><ul><li>align-content</li></ul><p>用来设置多行时侧轴的排列方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex-start</span>：各行向侧轴的起始位置堆叠</span><br><span class="line"><span class="selector-tag">flex-end</span>：各行向弹性盒容器的结束位置堆叠</span><br><span class="line"><span class="selector-tag">center</span>：各行向弹性盒容器的中间位置堆叠</span><br><span class="line"><span class="selector-tag">space-between</span>：第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布</span><br><span class="line"><span class="selector-tag">space-around</span>：各行在侧轴中平均分布</span><br><span class="line"><span class="selector-tag">stretch</span>：拉伸，不设置高度的情况下</span><br></pre></td></tr></table></figure><p>align-items 与 align-content 的区别</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">align-items</span> 调整的是侧轴的对其方式，不换行一般用 <span class="selector-tag">align-items</span></span><br><span class="line"><span class="selector-tag">align-content</span>: 必须是多行才生效，如果单行，没有效果。换行了就用 <span class="selector-tag">align-content</span></span><br></pre></td></tr></table></figure><p>!&gt; 上述属性都是给父盒子设置的，这些样式影响的是所有的子元素，接下来的几个属性是给子盒子设置的，用来单独设置子元素的样式</p><h3 id="给子元素设置的样式"><a href="#给子元素设置的样式" class="headerlink" title="给子元素设置的样式"></a>给子元素设置的样式</h3><ul><li>flex</li></ul><p>用来设置子盒子如何分配主轴剩余空间</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">flex</span>: 1;</span><br></pre></td></tr></table></figure><ul><li>order</li></ul><p>定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">order</span>: 1;</span><br></pre></td></tr></table></figure><ul><li>align-self</li></ul><p>align-self 用于设置当前元素在侧轴的位置，是给子元素设置，优先级比 align-items 的优先级高</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取值与 <span class="selector-tag">align-items</span> 的取值一样</span><br></pre></td></tr></table></figure><p>阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p>【案例：6面神骰】</p><p>【案例：携程网】</p><p>【案例：360浏览器】</p><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><p>微调元素</p><ul><li>margin-top: - ;</li><li>transform：translateY();</li><li>position: relative; top: - ;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS3&quot;&gt;&lt;a href=&quot;#CSS3&quot; class=&quot;headerlink&quot; title=&quot;CSS3&quot;&gt;&lt;/a&gt;CSS3&lt;/h1&gt;&lt;p&gt;如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，&lt;strong&gt;增强&lt;/strong&gt; 或 &lt;st
      
    
    </summary>
    
      <category term="html&amp;css" scheme="http://blog.clj.me/categories/html-css/"/>
    
    
      <category term="html&amp;css" scheme="http://blog.clj.me/tags/html-css/"/>
    
      <category term="css3" scheme="http://blog.clj.me/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>fullpage 全屏网站插件</title>
    <link href="http://blog.clj.me/2018/jquery/fullpage/"/>
    <id>http://blog.clj.me/2018/jquery/fullpage/</id>
    <published>2018-11-23T10:00:00.000Z</published>
    <updated>2019-04-29T03:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fullpage"><a href="#fullpage" class="headerlink" title="fullpage"></a>fullpage</h2><p>fullPage.js 是一个基于 jQuery 的插件，它能够很方便、很轻松的制作出全屏网站</p><p>参考文档 <a href="http://www.dowebok.com/77.html" target="_blank" rel="noopener">http://www.dowebok.com/77.html</a></p><p>下载地址 <a href="http://www.dowebok.com/77.html" target="_blank" rel="noopener">https://github.com/alvarotrigo/fullPage.js</a></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li>引入jQuery文件，因为fullpage是jquery插件</li><li>引入fullpage的js文件</li><li>页面结构</li><li>编写js代码</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 每一个class为section的div都是一屏,section这个类是固定的 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>我是内容1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>我是内容2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>我是内容3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span>我是内容4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编写js代码</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#box'</span>).fullpage()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="鼠标滚轮滚动事件"><a href="#鼠标滚轮滚动事件" class="headerlink" title="鼠标滚轮滚动事件"></a>鼠标滚轮滚动事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'mousewheel'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.wheelDelta)</span><br><span class="line">  <span class="keyword">if</span> (e.wheelDelta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'往上滚了'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'往下滚了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'鼠标滚轮事件触发了'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>sectionsColor</strong></td><td>设置每一个section的背景颜色（为一个数组）</td></tr><tr><td>controlArrows</td><td>定义是否使用箭头来控制幻灯片，默认true</td></tr><tr><td><strong>verticalCentered</strong></td><td>设定每一个section的内容是否垂直居中，默认true，</td></tr><tr><td>resize</td><td>设定字体是否随着窗口缩放而缩放，默认false，一般不修改</td></tr><tr><td><strong>scrollingSpeed</strong></td><td>设置滚动的速度，默认700毫秒</td></tr><tr><td>easing</td><td>设置动画的方式，默认是easeInOutCubic,如果想要修改此页，需要引入jquery.easing.js</td></tr><tr><td>css3</td><td>是否使用css3 transform来实现滚动效果，默认true，不用修改，CSS3的动画效率比较js高。</td></tr><tr><td>loopTop</td><td>滚动到顶部后是否连续滚动到底部，默认false</td></tr><tr><td>loopBottom</td><td>滚动到底部后是否连续滚动到顶部，默认false</td></tr><tr><td>loopHorizontal</td><td>设置幻灯片是否循环滚动，默认true</td></tr><tr><td><strong>continuousVertical</strong></td><td>是否循环滚动，默认为false，如果设置为true，则页面会循环滚动，不会出现loopTop与loopBottom那样的跳动。</td></tr><tr><td>autoScrolling</td><td>是否使用插件的滚动方式，默认true，如果选择false，会出现浏览器子代的滚动条，将不会按页滚动，按照滚动进行滚动。</td></tr><tr><td>scrollBar</td><td>是否包含滚动条，默认false，如果设置为true，那么浏览器自定的滚动条会出现，这个时候，页面滚动还是按页滚动，但是浏览器也能滚动。不建议开启，不然会不同步。</td></tr><tr><td>paddingTop/paddingBottom</td><td>给每一个section设置一个paddingTop或者paddingBottom,默认值为0，如果需要给页面设置一个固定定位的头部菜单或者底部菜单的时候，可以使用这两个选项。</td></tr><tr><td>keyboardScrolling</td><td>是否可以使用键盘方向键导航，默认true</td></tr><tr><td><strong>navigation</strong></td><td>是否显示导航，默认为false，设置为true，会显示小圆点，作为导航</td></tr><tr><td>navigationPositon</td><td>导航小圆点的位置，设置left或者right，默认是right</td></tr><tr><td>navigationTooltips</td><td>小圆点的提示信息，鼠标一上去能看到提示信息</td></tr><tr><td>showActiveTooltip</td><td>是否显示当前页面的导航的tooltip信息，默认是false</td></tr><tr><td>slidesNavigation</td><td>是否显示横向幻灯片的导航，默认为false</td></tr><tr><td>slidesNavPosition</td><td>设置横向幻灯片的位置，top或者bottom，默认bottom</td></tr><tr><td>sectionSelector</td><td>section的选择器，默认是.section</td></tr><tr><td>slideSelector</td><td>slide的选择器，默认是.slide</td></tr></tbody></table><h3 id="常用回调函数"><a href="#常用回调函数" class="headerlink" title="常用回调函数"></a>常用回调函数</h3><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>afterLoad(anchorLink, index)</td><td>滚动到某一个section,当滚动结束后，会触发一次这个回调函数，anchorLink是锚链接的名称，index从1开始计算</td></tr><tr><td>onLeave(index,nextIndex,diretion)</td><td>当我们离开一个section时，会触发这个函数，index是离开的页面的序号，从1开始计算。  nextIndex是滚动到的页面的序号，direction是往上还是往下滚动，值是up或者down.  return false可以取消滚动</td></tr><tr><td>afterResize()</td><td>窗口大小发生改变后会触发的回调函数</td></tr><tr><td>afterSlideLoad(anchor,index,  slideAnchor,slideIndex)</td><td>页面滚动到某一个幻灯片的时候会触发这个回调函数</td></tr><tr><td>afterSlideLeave(anchor,index,slideIndex,  diretion,nextSlideIndex)</td><td>当离开某一个幻灯片的时候会触发一次这个回调函数。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fullpage&quot;&gt;&lt;a href=&quot;#fullpage&quot; class=&quot;headerlink&quot; title=&quot;fullpage&quot;&gt;&lt;/a&gt;fullpage&lt;/h2&gt;&lt;p&gt;fullPage.js 是一个基于 jQuery 的插件，它能够很方便、很轻松的制作出全屏网
      
    
    </summary>
    
      <category term="框架" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="jquery" scheme="http://blog.clj.me/categories/%E6%A1%86%E6%9E%B6/jquery/"/>
    
      <category term="插件" scheme="http://blog.clj.me/categories/%E6%8F%92%E4%BB%B6/"/>
    
    
      <category term="插件" scheme="http://blog.clj.me/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="jquery" scheme="http://blog.clj.me/tags/jquery/"/>
    
  </entry>
  
</feed>
