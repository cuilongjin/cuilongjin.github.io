<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>稻草人</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuilongjin.top/"/>
  <updated>2019-07-28T09:06:25.789Z</updated>
  <id>https://cuilongjin.top/</id>
  
  <author>
    <name>稻草人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动端兼容性问题</title>
    <link href="https://cuilongjin.top/2019/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://cuilongjin.top/2019/移动端兼容性问题/</id>
    <published>2019-07-24T16:00:00.000Z</published>
    <updated>2019-07-28T09:06:25.789Z</updated>
    
    <content type="html"><![CDATA[<p>ios 移动端页面对点击事件有 300ms 延时<br>使用 fastclick 库 <a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a></p><p>使用 FastClick 的时候，在需要使用的层上，实例化它。我们使用 document.body 是因为希望所有的按钮和链接都获得快速点击</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> FastClick <span class="keyword">from</span> <span class="string">'fastclick'</span></span><br><span class="line">FastClick.attach(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><p>ios 滚动卡顿</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  -webkit-overflow-scrolling: touch; // 当手指从触摸屏上移开，会保持一段时间的滚动</span><br><span class="line">  // -webkit-overflow-scrolling: auto; // 当手指从触摸屏上移开，滚动会立即停止</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ios 1px border 变宽<br>以 dpr=2 为例：<br>你拿到一张标准的基于 iphone6 的设计稿(750px)<br>你看到它设计的一个 border 宽度是 1px<br>你兴致勃勃地写下了 border: 1px solid #000;<br>然而 iphone6 实际渲染像素是 375px，那么设计需要 border 的其实是 border: 0.5px solid #000;<br>然后你的是 1px<br>不是 1px 变粗了，只是实际只是需要 0.5px 而已</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code> 意思是将物理设备的宽度设置给当前浏览器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ios 移动端页面对点击事件有 300ms 延时&lt;br&gt;使用 fastclick 库 &lt;a href=&quot;https://github.com/ftlabs/fastclick&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用 js 汇总</title>
    <link href="https://cuilongjin.top/2019/%E5%B8%B8%E7%94%A8js%E6%B1%87%E6%80%BB/"/>
    <id>https://cuilongjin.top/2019/常用js汇总/</id>
    <published>2019-07-22T16:00:00.000Z</published>
    <updated>2019-07-28T09:05:16.235Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个变量是字符串<br>类型识别</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'str'</span>) <span class="comment">// '[object String]'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'str'</span> <span class="comment">// 'string'</span></span><br></pre></td></tr></table></figure><p>getRawType：获取数据类型，返回结果为 Number、String、Object、Array 等</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRawType</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value).slice(<span class="number">8</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isObject：判断数据是不是引用类型的数据 (例如： arrays, functions, objects, regexes, new Number(0),以及 new String(‘’))</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> value</span><br><span class="line">  <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type == <span class="string">'object'</span> || type == <span class="string">'function'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isPlainObject：判断数据是不是 Object 类型的数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Object]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isArray：判断数据是不是数组类型的数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">'[object Array]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 isArray 挂载到 Array 上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray = <span class="built_in">Array</span>.isArray || isArray</span><br></pre></td></tr></table></figure><p>isRegExp：判断数据是不是正则对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRegExp</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object RegExp]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isDate：判断数据是不是时间对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDate</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object Date]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进制转换<br>parseInt(str,radix) // 任意进制转换为 10 进制整数值<br>与 Number.toString(radix) 返回表示该数字的指定进制形式的字符串</p><p>常用正则</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配邮箱</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^([a-zA-Z]|[0-9])(\w|\-)+@[a-zA-Z0-9]+\.([a-zA-Z]&#123;2,4&#125;)$</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 匹配手机号</span></span><br><span class="line"><span class="regexp">let reg = /</span>^<span class="number">1</span>[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">10</span>&#125;$/;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配8-16位数字和字母密码的正则表达式</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]&#123;8,16&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配国内电话号码 0510-4305211</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配身份证号码</span></span><br><span class="line"><span class="keyword">let</span> reg=<span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配腾讯QQ号</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/[1-9][0-9]&#123;4,&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配ip地址</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+\.\d+\.\d+\.\d+/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配中文</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^[\u4e00-\u9fa5]*$/</span></span><br></pre></td></tr></table></figure><p>检测平台（设备）类型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">isWechat = <span class="regexp">/micromessenger/i</span>.test(navigator.userAgent)</span><br><span class="line">isWeibo = <span class="regexp">/weibo/i</span>.test(navigator.userAgent)</span><br><span class="line">isQQ = <span class="regexp">/qq\//i</span>.test(navigator.userAgent)</span><br><span class="line">isIOS = <span class="regexp">/(iphone|ipod|ipad|ios)/i</span>.test(navigator.userAgent)</span><br><span class="line">isAndroid = <span class="regexp">/android/i</span>.test(navigator.userAgent)</span><br></pre></td></tr></table></figure><p>时间格式化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间格式化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format_date</span>(<span class="params">timeStamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(timeStamp)</span><br><span class="line">  <span class="keyword">return</span> date.getFullYear() + <span class="string">'年'</span> + prefix_zero(date.getMonth() + <span class="number">1</span>) + <span class="string">'月'</span> + prefix_zero(date.getDate()) + <span class="string">'日 '</span> + prefix_zero(date.getHours()) + <span class="string">':'</span> + prefix_zero(date.getMinutes())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字格式化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prefix_zero</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num &gt;= <span class="number">10</span> ? num : <span class="string">'0'</span> + num</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 倒计时时间格式化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format_time</span>(<span class="params">timeStamp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> day = <span class="built_in">Math</span>.floor(timeStamp / (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">let</span> leave1 = timeStamp % (<span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> hours = <span class="built_in">Math</span>.floor(leave1 / (<span class="number">3600</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">let</span> leave2 = leave1 % (<span class="number">3600</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> minutes = <span class="built_in">Math</span>.floor(leave2 / (<span class="number">60</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">let</span> leave3 = leave2 % (<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> seconds = <span class="built_in">Math</span>.floor(leave3 / <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">if</span> (day) <span class="keyword">return</span> day + <span class="string">'天'</span> + hours + <span class="string">'小时'</span> + minutes + <span class="string">'分'</span></span><br><span class="line">  <span class="keyword">if</span> (hours) <span class="keyword">return</span> hours + <span class="string">'小时'</span> + minutes + <span class="string">'分'</span> + seconds + <span class="string">'秒'</span></span><br><span class="line">  <span class="keyword">if</span> (minutes) <span class="keyword">return</span> minutes + <span class="string">'分'</span> + seconds + <span class="string">'秒'</span></span><br><span class="line">  <span class="keyword">if</span> (seconds) <span class="keyword">return</span> seconds + <span class="string">'秒'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'时间到！'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>敏感符号转义</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">entities</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> e = &#123;</span><br><span class="line">    <span class="string">'"'</span>: <span class="string">'&amp;quot;'</span>,</span><br><span class="line">    <span class="string">'&amp;'</span>: <span class="string">'&amp;amp;'</span>,</span><br><span class="line">    <span class="string">'&lt;'</span>: <span class="string">'&amp;lt;'</span>,</span><br><span class="line">    <span class="string">'&gt;'</span>: <span class="string">'&amp;gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.replace(<span class="regexp">/["&lt;&gt;&amp;]/g</span>, m =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> e[m]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组去重</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">v, i, array</span>) =&gt;</span> array.indexOf(v) === i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Object.create(null) 和 {} 区别</p><p>Object.create(null) 没有继承任何原型方法，也就是说它的原型链没有上一层</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.create(&#123;&#125;).toString) <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.create(<span class="literal">null</span>).toString) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object.create() 的定义</span></span><br><span class="line"><span class="built_in">Object</span>.create(proto, [propertiesObject])</span><br><span class="line"><span class="comment">// proto:新创建对象的原型对象</span></span><br><span class="line"><span class="comment">// propertiesObject:可选。要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。</span></span><br></pre></td></tr></table></figure><p>Object.create()方法的内部实现简单来说是这样的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;判断一个变量是字符串&lt;br&gt;类型识别&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Object&lt;/sp
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>【转】滑动穿透(锁body)终极探索</title>
    <link href="https://cuilongjin.top/2019/%E8%BD%AC-%E6%BB%91%E5%8A%A8%E7%A9%BF%E9%80%8F/"/>
    <id>https://cuilongjin.top/2019/转-滑动穿透/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-07-28T08:55:27.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>当页面出现浮层的时候，滑动浮层的内容，正常情况下预期应该是浮层下边的内容不会滚动；然而事实并非如此。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/4/3/169e299a9dc10d30?imageslim" alt="img"></p><p> 如图所示，浮层下边的内容并没有如想象中不受影响。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>先去github上搜索一番，发现有解决此问题的开源包，简单粗暴直接挑选了其中<strong>star</strong>的最高的(<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwillmcpo%2Fbody-scroll-lock" target="_blank" rel="noopener">body-scroll-lock</a>)操作一番！ 使用后发现有一些问题：</p><ul><li>安卓端全挂</li><li>ios端偶尔会有锁不住的情况</li></ul><p>查源码发现该包在<code>iOS</code>端使用<code>禁止touchmove</code>的方式单独处理，但是在其他端只是给<code>body</code>加<code>overflow: hidden</code>简单处理。 于是决定写一个针对多端通用的包来处理类似的问题。</p><h3 id="探索一：overflow-hidden"><a href="#探索一：overflow-hidden" class="headerlink" title="探索一：overflow: hidden"></a>探索一：overflow: hidden</h3><p>看到下边的滚动肯定立刻就想到了是整个<code>viewport</code>的滚动，那么如果给body设置<code>overflow: hidden</code>，此时body的内容就只有一屏了，肯定不会滚动了；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123; overflow: hidden; &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此方案在pc端完美解决了我们的问题，然而事情并没有那么简单；</p><p>再试试移动端： </p><p><img src="https://user-gold-cdn.xitu.io/2019/4/3/169e299a9e362565?imageslim" alt="img"></p><p> 移动端中并没有出现期待的效果。。。 既然pc端已经有了完美的方案，下边我们继续探索移动端的解决方案。</p><h3 id="探索二：body定位"><a href="#探索二：body定位" class="headerlink" title="探索二：body定位"></a>探索二：body定位</h3><p>上边想到给body设置<code>overflow: hidden</code>在移动端并不能解决我们的问题，是否在于body的height没有设置</p><ul><li>将html、body的高度都设置为<code>100%</code>；</li><li>给body设置绝对定位(fixed)；</li></ul><p>同时使用这两个操作似乎完美满足了我们的需求； </p><p><img src="https://user-gold-cdn.xitu.io/2019/4/3/169e299a9f2891b5?imageslim" alt="img"></p><p> 但是如图所示，每次都会将页面拉到最顶上的位置，这样看起来又不完美了； 既然使用了定位，那么给一个<code>top值</code></p><blockquote><p>tips: body 设置 <code>relative</code> 定位会页面自身拉上去，下边留白</p></blockquote><p>多次实验发现这个方案在<code>android</code>端中完美达到了我们想要的结果，但是在<code>ios</code>端并不理想；每次定位的时候会有闪动的问题；好事多磨，接着探索ios端的方案。</p><h3 id="探索三：禁止touchmove"><a href="#探索三：禁止touchmove" class="headerlink" title="探索三：禁止touchmove"></a>探索三：禁止touchmove</h3><p>如果禁止掉页面的<code>touchmove</code>是否可行呢？话不多说就是干！ 当弹出浮层的时候禁掉页面元素的<code>touchmove</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.addEventListener(&apos;touchmove&apos;, function (event) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>测试发现没有达到想象中的效果，感觉这个结果并不能接受啊，禁止<code>document</code> 的<code>touchmove</code>都不能禁止滚动的吗？</p><p>进一步的探索后发现原因竟是这个属性</p><ul><li>passive addEventListener第三个参数中传入</li></ul><p>原来是浏览器做的一些优化，<a href="https://link.juejin.im?target=https%3A%2F%2Fdevelopers.google.com%2Fweb%2Fupdates%2F2016%2F06%2Fpassive-event-listeners" target="_blank" rel="noopener">chrome passive-event-listeners</a> <strong>Passive Event Listeners</strong>是Chrome提出的一个新的浏览器<strong>特性</strong>：Web开发者通过一个新的属性<code>passive</code>来告诉浏览器，当前页面内注册的事件监听器内部是否会调用<code>preventDefault</code>函数来阻止事件的默认行为，以便浏览器根据这个信息更好地做出决策来优化页面性能。当属性<code>passive</code>的值为true的时候，代表该监听器内部不会调用<code>preventDefault</code>函数来阻止默认滑动行为，Chrome浏览器称这类型的监听器为被动（passive）监听器。</p><p>知道问题就好说了，给<code>addEventListener</code>传入第三个参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.addEventListener(&apos;touchmove&apos;, function (event) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">&#125;, &#123; passive: false &#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>大功告成！ 突然想到，如果浮层中还需要滚动那就不GG了! so,是不是可以有选择性的禁止滚动（在浮层中元素滚动到最顶部或者最底部之后禁止滚动）。 单独处理浮层中需要滚动的元素；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">targetElement.ontouchmove = function (event) &#123;</span><br><span class="line">    const clientY = event.targetTouches[0].clientY - initialClientY</span><br><span class="line"></span><br><span class="line">    if (targetElement &amp;&amp; targetElement.scrollTop === 0 &amp;&amp; clientY &gt; 0) &#123;</span><br><span class="line">        return preventDefault(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (targetElement &amp;&amp; (targetElement.scrollHeight - 1 - targetElement.scrollTop &lt;= targetElement.clientHeight) &amp;&amp; clientY &lt; 0) &#123;</span><br><span class="line">        return preventDefault(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.stopPropagation()</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个方案在<code>ios</code>中完美实现，但是在 <code>android</code>中还是有一点问题；浮层内容拉到最顶部或者最底部的时候依然会带动页面的内容有一定程度的移动。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/4/3/169e299a9ff99f84?imageslim" alt="img"></p><h3 id="tua-body-scroll-lock"><a href="#tua-body-scroll-lock" class="headerlink" title="tua-body-scroll-lock"></a><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ftuateam%2Ftua-body-scroll-lock" target="_blank" rel="noopener">tua-body-scroll-lock</a></h3><p>终极方案来啦!</p><p><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ftuateam%2Ftua-body-scroll-lock" target="_blank" rel="noopener">tua-body-scroll-lock</a>即是在<code>ios</code>、<code>android</code>和<code>PC</code>各个端单独处理，保证在每个端都可以实现完美的效果!</p><p><a href="https://link.juejin.im?target=https%3A%2F%2Ftuateam.github.io%2Ftua-body-scroll-lock%2F" target="_blank" rel="noopener">demo</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i -S tua-body-scroll-lock</span><br><span class="line"># OR</span><br><span class="line">$ yarn add tua-body-scroll-lock</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; lock, unlock &#125; from &apos;tua-body-scroll-lock&apos;</span><br><span class="line"></span><br><span class="line">// 禁止滑动后还需要内部可以滚动的元素(针对移动端ios处理)</span><br><span class="line">const targetElement = document.querySelector(&quot;#someElementId&quot;);</span><br><span class="line"></span><br><span class="line">lock(targetElement)</span><br><span class="line">unlock(targetElement)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h5><blockquote><p>tips: PC端不需要targetElement, 不传targetElement也不想要控制台提示可以传<code>null</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; lock, unlock &#125; from &apos;tua-body-scroll-lock&apos;</span><br><span class="line"></span><br><span class="line">lock()</span><br><span class="line">unlock()</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://juejin.im/post/5ca4816e5188250b251e34e9" target="_blank" rel="noopener">https://juejin.im/post/5ca4816e5188250b251e34e9</a></p><p>版权归原作者所有</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;当页面出现浮层的时候，滑动浮层的内容，正常情况下预期应该是浮层下边的内容不会滚动；然而事实并非如此。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3 配置通用模板及配置详解</title>
    <link href="https://cuilongjin.top/2019/vue-cli3%E9%85%8D%E7%BD%AE%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://cuilongjin.top/2019/vue-cli3配置通用模板及配置详解/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-07-25T15:21:46.458Z</updated>
    
    <content type="html"><![CDATA[<p>安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>创建一个项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create my-project</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">vue ui</span><br></pre></td></tr></table></figure><p>如果你仍然需要使用旧版本的 <code>vue init</code> 功能，你可以全局安装一个桥接工具：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"><span class="comment"># `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span></span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure><h3 id="在现有的项目中安装插件"><a href="#在现有的项目中安装插件" class="headerlink" title="在现有的项目中安装插件"></a>在现有的项目中安装插件</h3><p>每个 CLI 插件都会包含一个 (用来创建文件的) 生成器和一个 (用来调整 webpack 核心配置和注入命令的) 运行时插件。当你使用 <code>vue create</code> 来创建一个新项目的时候，有些插件会根据你选择的特性被预安装好。如果你想在一个已经被创建好的项目中安装一个插件，可以使用 <code>vue add</code> 命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add @vue/eslint</span><br></pre></td></tr></table></figure><p>提示</p><p><code>vue add</code> 的设计意图是为了安装和调用 Vue CLI 插件。对于普通的 npm 包而言，这不意味有一个替代（命令）。对于这些普通的 npm 包，你仍然需要（根据所选的 npm 包）使用包管理器。</p><h2 id="vue-config-js-配置"><a href="#vue-config-js-配置" class="headerlink" title="vue.config.js 配置"></a>vue.config.js 配置</h2><p><a href="https://cli.vuejs.org/zh/config" target="_blank" rel="noopener">官网配置参考</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h3><p>基本路径</p><p>vue-cli3.3 以下版本使用 baseUrl</p><p>vue-cli3.3+ 使用 publicPath</p><p>默认 ‘/‘</p><p>‘./‘ 或为空(‘’) 所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径, 当使用 pages 选项构建多页面应用时,应当避免使用相对路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">publicPath: <span class="string">'./'</span></span><br></pre></td></tr></table></figure><h3 id="outputDir"><a href="#outputDir" class="headerlink" title="outputDir"></a>outputDir</h3><p>默认 ‘dist’</p><p>当运行 vue-cli-service build 时生成的生产环境构建文件的目录</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">outputDir: <span class="string">'dist'</span></span><br></pre></td></tr></table></figure><h3 id="assetsDir"><a href="#assetsDir" class="headerlink" title="assetsDir"></a>assetsDir</h3><p>默认 ‘’</p><p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assetsDir: <span class="string">'static'</span></span><br></pre></td></tr></table></figure><h3 id="indexPath"><a href="#indexPath" class="headerlink" title="indexPath"></a>indexPath</h3><p>指定生成的 <code>index.html</code> 的输出路径 (相对于 <code>outputDir</code>)。也可以是一个绝对路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">indexPath: <span class="string">'index.html'</span></span><br></pre></td></tr></table></figure><h3 id="filenameHashing"><a href="#filenameHashing" class="headerlink" title="filenameHashing"></a>filenameHashing</h3><p>默认 true</p><p>默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。然而，这也要求 index 的 HTML 是被 Vue CLI 自动生成的。如果你无法使用 Vue CLI 生成的 index HTML，你可以通过将这个选项设为 false 来关闭文件名哈希</p><h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><p>默认 undefined</p><p>是否以多页模式构建应用程序</p><p>每个 ‘page’ 应该有一个对应的 JavaScript 入口文件。其值应该是一个对象，对象的 key 是入口的名字，value 是 一个指定了 entry, template, filename, title 和 chunks 的对象 (除了 entry 之外都是可选的) 或一个指定其 entry 的字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      <span class="comment">// page 的入口</span></span><br><span class="line">      entry: <span class="string">'src/pages/index/main.js'</span>,</span><br><span class="line">      <span class="comment">// 模板来源</span></span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      <span class="comment">// 在 dist/index.html 的输出</span></span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">      title: <span class="string">'Index Page'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    pageA: &#123;</span><br><span class="line">      entry: <span class="string">'src/pages/pageA/main.js'</span>,</span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'pageA.html'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当使用只有入口的字符串格式时, 模板会被推导为 `public/pageB.html`</span></span><br><span class="line">    <span class="comment">// 并且如果找不到的话，就回退到 `public/index.html`, 输出文件名会被推导为 `pageB.html`</span></span><br><span class="line">    pageB: <span class="string">'src/pages/pageB/main.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lintOnSave"><a href="#lintOnSave" class="headerlink" title="lintOnSave"></a>lintOnSave</h3><p>默认 true</p><p>是否在保存的时候检查，如果为 true ，build 时会启用 eslint-loader 进行代码检查，可以使用如下配置禁用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">lintOnSave: process.env.NODE_ENV !== <span class="string">'production'</span></span><br></pre></td></tr></table></figure><h3 id="runtimeCompiler"><a href="#runtimeCompiler" class="headerlink" title="runtimeCompiler"></a>runtimeCompiler</h3><p>默认 false</p><p>是否使用包含运行时编译器的 Vue 构建版本</p><p>使用 template 语法需要开启，但是这会让你的应用额外增加 10kb 左右，使用渲染函数不需要开启</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">runtimeCompiler: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="productionSourceMap"><a href="#productionSourceMap" class="headerlink" title="productionSourceMap"></a>productionSourceMap</h3><p>默认 true</p><p>生产环境是否生成 sourceMap 文件，一般情况不建议打开</p><p>map 文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。有了 map 就可以像未加密的代码一样，准确的输出是哪一行哪一列有错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">productionSourceMap: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h3><p>对内部的 webpack 配置进行更细粒度的修改</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chainWebpack = <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 删除预加载模块的 prefetch，降低带宽压力</span></span><br><span class="line">  <span class="comment">// https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch</span></span><br><span class="line">  <span class="comment">// 移除 prefetch 插件</span></span><br><span class="line">  config.plugins.delete(<span class="string">'prefetch'</span>)</span><br><span class="line">  <span class="comment">// 移除 preload 插件</span></span><br><span class="line">  config.plugins.delete(<span class="string">'preload'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// config.plugin('html').tap(args =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   args[0].minify = false</span></span><br><span class="line">  <span class="comment">//   return args</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改静态资源打包方式，下例为超过10k才用文件导入的方式，否则为base64.默认为4k</span></span><br><span class="line">  config.module</span><br><span class="line">    .rule(<span class="string">'images'</span>)</span><br><span class="line">    .use(<span class="string">'url-loader'</span>)</span><br><span class="line">    .loader(<span class="string">'url-loader'</span>)</span><br><span class="line">    .tap(<span class="function"><span class="params">options</span> =&gt;</span> <span class="built_in">Object</span>.assign(options, &#123; <span class="attr">limit</span>: <span class="number">10240</span> &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  chainWebpack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html#preload" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/html-and-static-assets.html#preload</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" target="_blank" rel="noopener"><code>&lt;link rel=&quot;preload&quot;&gt;</code></a>是一种 resource hint，用来指定页面加载后很快会被用到的资源，所以在页面加载的过程中，我们希望在浏览器开始主体渲染之前尽早 preload。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ" target="_blank" rel="noopener"><code>&lt;link rel=&quot;prefetch&quot;&gt;</code></a> 是一种 resource hint，用来告诉浏览器在页面加载完成后，利用空闲时间提前获取用户未来可能会访问的内容。</p><h3 id="configureWebpack"><a href="#configureWebpack" class="headerlink" title="configureWebpack"></a>configureWebpack</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 自定义配置</span></span><br><span class="line"><span class="comment">// https://cli.vuejs.org/zh/guide/webpack.html</span></span><br><span class="line"><span class="keyword">const</span> configureWebpack = <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 生产 and 测试环境</span></span><br><span class="line">  <span class="keyword">let</span> pluginsPro = [</span><br><span class="line">    <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">      <span class="comment">// 文件开启 Gzip，也可以通过服务端(如：nginx)(https://github.com/webpack-contrib/compression-webpack-plugin)</span></span><br><span class="line">      filename: <span class="string">'[path].gz[query]'</span>,</span><br><span class="line">      algorithm: <span class="string">'gzip'</span>,</span><br><span class="line">      test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\.('</span> + [<span class="string">'js'</span>, <span class="string">'css'</span>].join(<span class="string">'|'</span>) + <span class="string">')$'</span>),</span><br><span class="line">      threshold: <span class="number">8192</span>,</span><br><span class="line">      minRatio: <span class="number">0.8</span></span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Webpack 包文件分析器(https://github.com/webpack-contrib/webpack-bundle-analyzer)</span></span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打包时删除 debugger 和 console</span></span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          drop_debugger: <span class="literal">true</span>,</span><br><span class="line">          drop_console: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      sourceMap: <span class="literal">true</span>,</span><br><span class="line">      parallel: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// 开发环境</span></span><br><span class="line">  <span class="keyword">let</span> pluginsDev = [</span><br><span class="line">    <span class="comment">//  移动端模拟开发者工具 (https://github.com/diamont1001/vconsole-webpack-plugin  https://github.com/Tencent/vConsole)</span></span><br><span class="line">    <span class="comment">// new vConsolePlugin(&#123;</span></span><br><span class="line">    <span class="comment">//   filter: [], // 需要过滤的入口文件</span></span><br><span class="line">    <span class="comment">//   enable: true // 发布代码前记得改回 false</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// 为生产环境修改配置...process.env.NODE_ENV !== 'development'</span></span><br><span class="line">    config.plugins = [...config.plugins, ...pluginsPro]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 为开发环境修改配置...</span></span><br><span class="line">    config.plugins = [...config.plugins, ...pluginsDev]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  configureWebpack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境变量与分环境打包"><a href="#环境变量与分环境打包" class="headerlink" title="环境变量与分环境打包"></a>环境变量与分环境打包</h3><p><a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-build" target="_blank" rel="noopener">vue-cli-service-build</a><br>vue-cli-service build –mode 指定环境模式(默认值：production)</p><p>npm run build 默认模式为 production ，命令执行时会把 process.env.NODE_ENV(环境变量) 设置为 ‘production’<br>npm run serve 时会把 process.env.NODE_ENV 设置为 ‘development’</p><p>所以可以根据 process.env.NODE_ENV 简单的区分出本地和线上环境</p><p>但是线上环境也可能分多种，比如测试环境和预发布环境等</p><p><strong>配置 vue-cli3 区分不同的线上环境</strong></p><p>在项目根目录创建下列文件来制定环境变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.env                # 在所有的环境中被载入</span><br><span class="line">.env.local          # 在所有的环境中被载入，但会被 git 忽略</span><br><span class="line">.env.[mode]         # 只在指定的模式中被载入</span><br><span class="line">.env.[mode].local   # 只在指定的模式中被载入，但会被 git 忽略</span><br></pre></td></tr></table></figure><p><code>.env.test</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* VUE_APP_CURRENTMODE 当前环境变量 */</span><br><span class="line">VUE_APP_CURRENTMODE = &apos;t&apos; // 表明开发环境模式信息</span><br><span class="line">NODE_ENV = &apos;development&apos; // 使用开发环境（因为默认开启 devtool，便于调试）</span><br><span class="line">// VUE_APP_BASEURL=&apos;&apos; // 测试服务器地址</span><br><span class="line">VUE_APP_ENV = &apos;test 环境&apos;</span><br></pre></td></tr></table></figure><p>在 package.json 中添加</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "vue-cli-service build --mode t",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 baseUrl.js 文件通过环境变量改变 baseUrl</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.VUE_APP_CURRENTMODE === <span class="string">'t'</span>) &#123;</span><br><span class="line">  <span class="comment">// 测试环境</span></span><br><span class="line">  baseUrl = <span class="string">''</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 正式环境</span></span><br><span class="line">  baseUrl = <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要为测试环境进行打包的时候 , 只需要运行下面指令进行打包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>但是将打包环境设置为 NODE_ENV = ‘development’ 导致打包出来的 js 文件只有 index.js 文件并且在根目录下, 并不是我们想要的</p><p>所以我们可以这样配置<br>.env.test</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VUE_APP_CURRENTMODE = &apos;t&apos;</span><br><span class="line">NODE_ENV = &apos;production&apos;</span><br><span class="line">VUE_APP_ENV = &apos;test 环境&apos;</span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDebugMode = process.env.VUE_APP_CURRENTMODE === <span class="string">'t'</span></span><br><span class="line">Vue.config.debug = isDebugMode</span><br><span class="line">Vue.config.devtools = isDebugMode</span><br><span class="line">Vue.config.productionTip = isDebugMode</span><br></pre></td></tr></table></figure><h3 id="vue-公共路径提取"><a href="#vue-公共路径提取" class="headerlink" title="vue 公共路径提取"></a>vue 公共路径提取</h3><p>vue 项目中公共路径在打包之后一旦遇到整体的路径更改就需要再次打包。我们可以将公共路径提取出来，修改公共路径后不需要重新打包就能生效</p><p>在 public 文件夹下创建 config.js 文件，并配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> serverConfig = &#123;</span><br><span class="line">  baseUrl: <span class="string">''</span> <span class="comment">// 配置 url</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 index.html 中引入该文件即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add router</span><br><span class="line">vue add vuex</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install -g @vue/cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>【转】跨域多方位解决方案</title>
    <link href="https://cuilongjin.top/2019/%E8%BD%AC-%E8%B7%A8%E5%9F%9F%E5%A4%9A%E6%96%B9%E4%BD%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://cuilongjin.top/2019/转-跨域多方位解决方案/</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2019-07-28T08:57:36.397Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本次分享由趣头条cpc商业化技术部(周志祥-混元霹雳手)进行分享!欢迎大家投递简历加入趣头条,邮箱地址为<a href="mailto:qianjiongli@qutoutiao.net" target="_blank" rel="noopener">qianjiongli@qutoutiao.net</a> 期待您的加入。</p></blockquote><h3 id="你了解跨域吗？"><a href="#你了解跨域吗？" class="headerlink" title="你了解跨域吗？"></a>你了解跨域吗？</h3><p>了解(continue) 不了解 (end)</p><h3 id="为何会产生跨域"><a href="#为何会产生跨域" class="headerlink" title="为何会产生跨域?"></a>为何会产生跨域?</h3><p>跨域问题来源于浏览器同源策略的限制问题导致的。</p><h3 id="浏览器为何要设置同源策略？"><a href="#浏览器为何要设置同源策略？" class="headerlink" title="浏览器为何要设置同源策略？"></a>浏览器为何要设置同源策略？</h3><p>正是因为浏览器要出于安全考虑。如果缺少了同源策略，浏览器很容易受到<strong>XSS</strong>和<strong>CSRF</strong>等攻击。(<code>XSS</code>与<code>CSRF</code>可以单独成为一个额外的知识点) 此时会导致一个域名下网页的操作就可以直接拿到另一个非同域名下网页的任何信息,或者一个网页可以随意请求到不同域名服务器下的接口数据。</p><h3 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h3><p>同源策略是一种约定,这是浏览器核心的安全功能点之一。所谓的同源策略指的是【<strong>协议</strong> + <strong>域名</strong> + <strong>端口</strong>】三者相同,如果两个相同的域名指向同一个<code>ip</code>地址，也是非同源的情况。同时地址印射对应的<code>ip</code>两者也是非同源情况。</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/3/169e3844e8bd919e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="同源策略会存在那些限制？"><a href="#同源策略会存在那些限制？" class="headerlink" title="同源策略会存在那些限制？"></a>同源策略会存在那些限制？</h3><blockquote><p>DOM节点</p></blockquote><p>对于<code>DOM</code>节点只能操作当前域名下网页打开的<code>DOM</code>节点内容。</p><blockquote><p>存储信息</p></blockquote><p>对于<code>cookie</code>、<code>sessionStorage</code>、<code>localStorage</code>、 <code>indexedDB</code>等存储信息也不能非同源获取</p><blockquote><p>ajax请求</p></blockquote><p>对于<strong>ajax</strong>网络请求时,请求处于非同域的情况下会被浏览器自动拦截报错。</p><h3 id="举几个造成跨域的场景的例子？"><a href="#举几个造成跨域的场景的例子？" class="headerlink" title="举几个造成跨域的场景的例子？"></a>举几个造成跨域的场景的例子？</h3><p>前面说过当协议、域名、端口号中任意一个不相同时，都是跨域。同样包括(<strong>一级域名与二级域名的不同</strong>) 互相请求资源的情况下是一种跨域状态。</p><h3 id="跨域的地址场景图"><a href="#跨域的地址场景图" class="headerlink" title="跨域的地址场景图"></a>跨域的地址场景图</h3><p><img src="https://user-gold-cdn.xitu.io/2019/4/3/169e385797efb0ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="通过什么方式可以解决跨域？"><a href="#通过什么方式可以解决跨域？" class="headerlink" title="通过什么方式可以解决跨域？"></a>通过什么方式可以解决跨域？</h3><blockquote><p>可以通过JSONP的原理</p></blockquote><p>首先明白对于浏览器加载资源时可以通过:</p><ol><li>img</li><li>script</li><li>link</li></ol><p>以上几个标签是允许跨域加载资源的。意思就是在<code>www.baidu.com</code>域名下静态<code>html</code>文件中的<code>script</code>标签可以加载<code>wwww.google.com</code>服务器下的脚本资源等。</p><p>通过以上标签可以加载跨域资源的理解,那我们可以通过包装手段从其它域获取到期望的数据。</p><h3 id="讲讲JSONP的实现原理？"><a href="#讲讲JSONP的实现原理？" class="headerlink" title="讲讲JSONP的实现原理？"></a>讲讲JSONP的实现原理？</h3><p>之前已经有了原理的思路的铺垫。那就利用<code>script</code>标签这一允许跨域加资源的特性包装数据进行讲解。</p><blockquote><p>实现流程</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.html</span><br><span class="line">// jsonp的实现模拟</span><br><span class="line">function jsonp(&#123; url, params, callback &#125;) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let script = document.createElement(&apos;script&apos;)</span><br><span class="line">    window[callback] = function(data) &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">      document.body.removeChild(script)</span><br><span class="line">    &#125;</span><br><span class="line">    params = &#123; ...params, callback &#125;</span><br><span class="line">    let arrs = []</span><br><span class="line">    for (let key in params) &#123;</span><br><span class="line">      arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = `$&#123;url&#125;?$&#123;arrs.join(&apos;&amp;&apos;)&#125;`</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用方式</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: &apos;http://localhost:3000/getUser&apos;,</span><br><span class="line">  params: &#123; name: &apos;peter&apos; &#125;,</span><br><span class="line">  callback: &apos;user&apos;</span><br><span class="line">&#125;).then(data =&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过以上代码实现了一个基本的<code>JSONP</code>的调用执行代码。</p><ol><li>声明一个<code>JSONP</code>的模拟函数, 传入的参数分别为<strong>请求地址</strong>、<strong>请求参数</strong>、<strong>前后端约定的包装函数名</strong>、 内部通过返回<code>promise</code>机制来优雅的解决数据返回的获取方式。</li><li>通过<code>script</code>不存在跨域请求资源的机制创建一个<code>script</code>临时标签。把向后台请求的地址和参数组合成<code>query</code>参数的形式。 请求地址: <code>http://localhost:3000/getUser?name=peter&amp;callback=user</code></li></ol><p>关健点是把包装的函数名(<code>key</code>作为<code>callback</code>, <code>value</code>作为<code>user</code>) 包装函数名是前后端一个约定。</p><ol><li>最后组装后的<code>script</code>标签插入到<code>document</code>文档中,此时浏览器就会自动向标地址发起请求。</li></ol><blockquote><p>后台返回的结果原理</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// app.js 用express脚手架模拟的配合前台callback封装的返回结果</span><br><span class="line"></span><br><span class="line">app.get(&apos;/getUser&apos;, function(req, res, next) &#123;</span><br><span class="line">  let &#123; name, callback &#125; = req.query</span><br><span class="line">  console.log(name) // peter</span><br><span class="line">  console.log(callback) // user</span><br><span class="line">  res.send(`$&#123;callback&#125;(&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    msg: &apos;请求成功&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      id: 1234</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)`)</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>后台会通过<code>query</code>参数进行解析。如果此时返回的结果是一个对象,对象中存在<code>msg</code>消息,请求状态码<code>code</code>,数据信息<code>data</code>。</p><p>可能你会疑问为什么返回的结果的值是放在一个user执行函数中。这就是<code>JSONP</code>的核心原理。回头再看看这段没有解释的代码段:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window[callback] = function(data) &#123;</span><br><span class="line">  resolve(data)</span><br><span class="line">  document.body.removeChild(script)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当执行自己封装的<code>jsonp</code>的方法的时候在全局定义一个函数。此函数名则是前端与后端约定的函数封装名。当后台返回结果时会执行约定好的全局函数。就是执行上方代码段, 数据参数会通过<code>resolve</code>执行返回。最后删除对应的请求<code>script</code>标签。</p><h3 id="JSONP和AJAX对比-区别点在那里？"><a href="#JSONP和AJAX对比-区别点在那里？" class="headerlink" title="JSONP和AJAX对比,区别点在那里？"></a>JSONP和AJAX对比,区别点在那里？</h3><blockquote><p>相同点:</p></blockquote><p><code>JSONP</code>与<code>ajax</code>两者相同点都是客户端向服务端发起请求。</p><blockquote><p>不同点:</p></blockquote><p><code>JSONP</code>属于利用<code>script</code>标签进行了非同源策略请求，而<code>ajax</code>是同源策略请求。</p><h3 id="JSONP优缺点"><a href="#JSONP优缺点" class="headerlink" title="JSONP优缺点"></a>JSONP优缺点</h3><blockquote><p>优点:</p></blockquote><p><code>JSONP</code>的优点是兼容性很好。因为利用的是<code>script</code>标签可以非同源请求机制。这是每个浏览器基础特性。</p><blockquote><p>缺点:</p></blockquote><p>只支持<code>query</code>参数的这种<code>get</code>请求方式,交互方式存在局限性。也容易受到<code>xss</code>的攻击。</p><h3 id="如果后台不支持JSONP的封装方式怎么办？"><a href="#如果后台不支持JSONP的封装方式怎么办？" class="headerlink" title="如果后台不支持JSONP的封装方式怎么办？"></a>如果后台不支持JSONP的封装方式怎么办？</h3><p>可以通过CORS网络通信技术。(全称<strong>Cross-Orgin Resource Sharing</strong>),对于<code>CORS</code>同样也需要前后端进行一个配合。但是关健点在于后台的配置。可能你会认为。即然是后台进行配置,为什么前台也需要充分的了解。因为无论在生产还是开发的模式下, 跨域首先对前端的影响面是最大的, 只有充分的了解才能向后台去表达后台才能准确的设置和进行配合。</p><h3 id="简单的跨域请求需要建议后台进行什么设置？"><a href="#简单的跨域请求需要建议后台进行什么设置？" class="headerlink" title="简单的跨域请求需要建议后台进行什么设置？"></a>简单的跨域请求需要建议后台进行什么设置？</h3><blockquote><p>前台模拟设置</p></blockquote><p>先本地创建一个<code>index.html</code>写入请求脚本。通过<code>http-server -p 4000</code>启动在本地<code>4000</code>端口下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.html</span><br><span class="line">let url = &apos;http://localhost:3000/getUser&apos;;</span><br><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;get&apos;, url, true);</span><br><span class="line">xhr.send();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>后台模拟设置</p></blockquote><p>通过<code>express</code>框架设置请求地址，服务启动在本地<code>3000</code>端口下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// app.js</span><br><span class="line">let express = require(&apos;express&apos;)</span><br><span class="line">let app = express()</span><br><span class="line"></span><br><span class="line">app.get(&apos;/getUser&apos;, function(req, res) &#123;</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    code: 0,</span><br><span class="line">    msg: &apos;请求成功&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      id: 1234</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>浏览器返回结果</p></blockquote><p>访问<code>http://127.0.0.1:4000/index.html</code>可以通过<code>Network</code>控制台可以看到浏览器端向后台<code>http://localhost:3000/getUser</code>服务接口地址发出请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的<code>HTTP</code>回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为<code>HTTP</code>回应的状态码有可能是<code>200</code>。虽然返回的 <code>Status Code</code> 状态码是 <code>200 OK</code>,但是<code>response</code>响应头里并没有返回期望的值。同样在<code>console</code>控制台可以发现:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &apos;http://localhost:3000/getUser&apos; from origin &apos;http://127.0.0.1:4000&apos; has been blocked by CORS policy: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>CORS</code>策略阻止了从<code>http://127.0.0.1:4000</code>访问<code>http://localhost:3000/getuser</code>处的<code>XMLHttpRequest</code>:请求的资源上没有<code>&#39;Access- control - allow-origin&#39;</code>头。</p><p>这就是一个最简单的<code>CORS</code>的安全策略，从报错可以很明显的明白你需要告诉后台需要设置<code>&#39;Access- control-allow-origin&#39;</code>头。</p><blockquote><p>后台解决方案</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// app.js中添加</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;)</span><br><span class="line">  // res.setHeader(&apos;Access-Control-Allow-Origin&apos;, req.headers.origin)</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在接收到请求时做一层中间件的过滤, 以下两者方式皆可。</p><ol><li>返回时设置响应头的<code>Access-Control-Allow-Origin</code>为<code>*</code>(<strong>代表所有域名向当前服务请求都允许跨域访问</strong>)</li><li>返回时设置响应头的<code>Access-Control-Allow-Origin</code>为指定的域名。其它域名都不允许进行一个跨域访问</li></ol><h3 id="设置Access-Control-Allow-Origin头就可以解决了所有的跨域问题了麻？"><a href="#设置Access-Control-Allow-Origin头就可以解决了所有的跨域问题了麻？" class="headerlink" title="设置Access-Control-Allow-Origin头就可以解决了所有的跨域问题了麻？"></a>设置Access-Control-Allow-Origin头就可以解决了所有的跨域问题了麻？</h3><p><code>Access-Control-Allow-Origin</code>头的设置仅仅只能解决简单的跨域请求</p><blockquote><p>简单的跨域请求条件:</p></blockquote><p>条件1: 只能允许以下的请求方法</p><ul><li>GET</li><li>HEAD</li><li>POST</li></ul><p>条件2: <code>Content-Type</code>允许条件</p><ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul><p>条件3: 不能超过<code>http</code>的头信息以下字段</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li></ul><h3 id="那其它请求方式如何解决？属于什么类型的跨域请求"><a href="#那其它请求方式如何解决？属于什么类型的跨域请求" class="headerlink" title="那其它请求方式如何解决？属于什么类型的跨域请求?"></a>那其它请求方式如何解决？属于什么类型的跨域请求?</h3><p>其它的请求方式被称之为复杂的跨域请求。一旦不符合简单跨域请求策略的时候那就是复杂的跨域请求:</p><blockquote><p>复杂的跨域请求解释:</p></blockquote><ol><li>除了简单的跨域请求的方法。比如<code>PUT</code>、<code>DELETE</code></li><li>除了简单的跨域请求的<code>Content-type</code>类型。比如<code>application/json</code></li><li>自定义的<code>header</code>头</li><li>不同域名下的<code>cookie</code>传输</li></ol><blockquote><p>尝试解决复杂跨域的几种情况</p></blockquote><h4 id="1-put、delete等请求方法造成复杂请求"><a href="#1-put、delete等请求方法造成复杂请求" class="headerlink" title="1.put、delete等请求方法造成复杂请求"></a>1.put、delete等请求方法造成复杂请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 修改请求方法</span><br><span class="line">- xhr.open(&apos;get&apos;, url, true);</span><br><span class="line">+ xhr.open(&apos;put&apos;, url, true);</span><br><span class="line">复制代码</span><br><span class="line">// 修改后台接收请求方法</span><br><span class="line">app.put(&apos;/getUser&apos;) // 省略... 对于后台只是把get请求换成put接收请求</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在浏览器的<code>netWork</code>中发现并没有发送<code>put</code>请求,在<code>General</code>中的<code>Request Method</code>发现发送了一个<code>OPIONS</code>的预检请求(<strong>关于预检后续会在解决跨域问题中通过关闭浏览器策略中专门介绍相关详细知识点</strong>)</p><p>同时浏览器中会被发出报错信息:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &apos;http://localhost:3000/getUser&apos; from origin &apos;http://127.0.0.1:4000&apos; has been blocked by CORS policy: Response to preflight request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>解决方案:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在app.use中添加新的设置头</span><br><span class="line">// res.setHeader(&apos;Access-Control-Allow-Methods&apos;, &apos;*&apos;)</span><br><span class="line">res.setHeader(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT&apos;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上设置了接收允许那些请求方法:</p><ul><li>设置<code>*</code>, 表示所有请求方法都允许。</li><li>设置对应的请求方法以逗号分隔。</li></ul><h4 id="2-content-type造成复杂请求"><a href="#2-content-type造成复杂请求" class="headerlink" title="2.content-type造成复杂请求"></a>2.content-type造成复杂请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ xhr.setRequestHeader(&apos;content-type&apos;, &apos;application/json&apos;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在之前谈论简单跨域请求条件二, 关于<code>content-type</code>类型对于简单的跨域请求只支持三种。设置其它的则会产生复杂的跨域请求。当设置<code>content-type: application/json</code>的情况下,同样的浏览器会发出报错信息:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &apos;http://localhost:3000/getUser&apos; from origin &apos;http://127.0.0.1:4000&apos; has been blocked by CORS policy: Request header field content-type is not allowed by Access-Control-Allow-Headers in preflight response.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从报错提示可以看出后台需要对复杂跨域请求<code>content-type</code>进行一个额外的设置:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在app.use中添加新的设置头</span><br><span class="line">+ res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;content-type&apos;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="3-自定义头造成复杂请求"><a href="#3-自定义头造成复杂请求" class="headerlink" title="3.自定义头造成复杂请求"></a>3.自定义头造成复杂请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ xhr.setRequestHeader(&apos;X-Customer-Header&apos;, &apos;value&apos;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在之前谈论简单跨域请求条件三中, 除了以上几种<code>http</code>请求头之后，都属于自定义头。在请求带入时会造成复杂的跨域请求, 同样的浏览器会发出报错信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &apos;http://localhost:3000/getUser&apos; from origin &apos;http://127.0.0.1:4000&apos; has been blocked by CORS policy: Request header field x-customer-header is not allowed by Access-Control-Allow-Headers in preflight response.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>同样的原理对于前台设置的自定义头后,后台在接收的时候同样也要进行允许设置接收前台自定义传输出来的自定义头。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;content-type, X-Customer-Header&apos;)</span><br><span class="line">// res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;*&apos;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在<code>Access-Control-Allow-Headers</code>设置的时候，可以用逗号分隔,进行多个自定义头的设定。同时也可以传入<code>*</code>,允许所任何自定义头。</p><h3 id="谈谈CROS中的cookie"><a href="#谈谈CROS中的cookie" class="headerlink" title="谈谈CROS中的cookie?"></a>谈谈CROS中的cookie?</h3><blockquote><p>绝对同域的情况下</p></blockquote><p>在绝对同域的情况下。前台向后台请求的接口或者请求文件的时候,会自动把<code>cookie</code>带入请求头中。</p><blockquote><p>在非同域的情况下</p></blockquote><p>在非同域的情况下。需要使用<code>CORS</code>的策略进行传输。默认情况下,<code>cookie</code>并不会带入请求头中,需要对<code>xhr</code>设置请求凭证。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.withCredentials = true</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>简单的跨域请求与cookie</p></blockquote><p>如果此时是简单的跨域请求, 设置<code>withCredentials = true</code>的情况下。请求头中会带入<code>cookie</code>信息, 后台接收请求并且会发送到前台, 此时浏览器端从<code>response</code>中可以看到数据已经返回，但是并不能获取的后台返回的数据, 因为此时会被<code>xhr</code>的错误进行捕获,浏览器控制台会出现以下提示:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &apos;http://localhost:3000/getUser&apos; from origin &apos;http://localhost:4000&apos; has been blocked by CORS policy: The value of the &apos;Access-Control-Allow-Credentials&apos; header in the response is &apos;&apos; which must be &apos;true&apos; when the request&apos;s credentials mode is &apos;include&apos;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>复杂的跨域请求</p></blockquote><p>如果此时是复杂的跨域请求，设置<code>withCredentials = true</code>的情况下。此时会发送一个<code>OPTIONS</code>请求。浏览器发出的错误信息仍然是与简单的跨域请求报错一致。</p><blockquote><p>解决方案</p></blockquote><p>此时前台发送<code>cookie</code>凭证, 同样的后台一样需要同意接收凭证。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.setHeader(&apos;Access-Control-Allow-Credentials&apos;, true)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>反向原理:</p></blockquote><p>如果后台同意接收凭证。而前台没有设置发送凭证的情况下。就算后台发送到前台的响应头中设置了<code>cookie</code>信息(<strong>set-cookie头</strong>),无论是简单的跨域请求还是复杂的跨域请求都会导致<code>cookie</code>塞入无效,可以查看<code>appliation/cookie</code>中, 不会有后台写入的<code>cookie</code>信息。</p><blockquote><p>保持同源策略</p></blockquote><p>为了安全问题。<code>cookie</code>本质上还是保持了同源策略的模式。在前后台都设置了发送/接收凭证之后, 对于反回的<code>origin</code>头的设置<code>res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)</code> 不能为<code>*</code>, 需要设置成指定请求的来源 <code>res.setHeader(&#39;Access-Control-Allow-Origin&#39;, req.headers.origin)</code>。</p><blockquote><p>合法组合与非法组合。</p></blockquote><p>当设置<code>Credentials</code>的时候,后台需要知道<code>Access-Control-Allow</code>的合法与非法组合性。 一旦<code>Access-Control-Allow-Credentials</code>设置为<code>true</code>的时候, 此时以下几个不能设置为<code>*</code>, 需要进行指定, 否则以下三者一率视为无效设置。</p><ul><li>Access-Control-Allow-Headers</li><li>Access-Control-Allow-Origin</li><li>Access-Control-Allow-Methods</li></ul><h3 id="CORS情况下如何在xhr中拿到响应头中的信息？"><a href="#CORS情况下如何在xhr中拿到响应头中的信息？" class="headerlink" title="CORS情况下如何在xhr中拿到响应头中的信息？"></a>CORS情况下如何在xhr中拿到响应头中的信息？</h3><p>可以通过<code>xhr.getResponseHeader</code>方法进行获取。但是此方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。</p><p>在后台响应的时候可以响应头中塞入一些自定义的头和值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.setHeader(&apos;name&apos;, &apos;peter&apos;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在响应体的报文中可以看到:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Allow-Headers: content-type, X-Customer-Header</span><br><span class="line">Access-Control-Allow-Methods: PUT</span><br><span class="line">Access-Control-Allow-Origin: http://localhost:4000</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 50</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Date: Sun, 17 Feb 2019 08:18:08 GMT</span><br><span class="line">ETag: W/&quot;32-oUKytSTXnBL0hnySFj9PpHgmBQk&quot;</span><br><span class="line">name: peter   // 重点在这里</span><br><span class="line">X-Powered-By: Express</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过报文可以发现返回的很多之前后台设置的信息和这里最关健的<code>name</code>头信息。但是通过以下方法测试之后结论:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">  if (xhr.readyState === 4) &#123;</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">      console.log(xhr.getResponseHeader(&apos;Content-Type&apos;))</span><br><span class="line">      console.log(xhr.getResponseHeader(&apos;name&apos;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在<code>xhr</code>返回成功之后。分别获取两个头信息。</p><ul><li><code>Content-Type</code> 则会返回 <code>application/json; charset=utf-8</code></li><li><code>name</code> 则会提示<strong>报错信息</strong>，并且返回<code>null</code>空值。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Refused to get unsafe header &quot;name&quot; // 拒绝获取不安全的头信息“name”</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以明确的知识，除了之前提到的以上六种头信息可以进行获取之外，其余的一律都需要在后台进行允许那响应些头访问的设置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.setHeader(&apos;Access-Control-Expose-Headers&apos;, &apos;name&apos;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此时浏览器中报错信息不会存在，同时也能打印出<code>name</code>在响应头中的值。<strong>注意</strong> 如果设置的值为 <code>*</code> 则无效。需要对指定字段头进行设置。</p><h3 id="复杂的跨域请求会造成每次请求都发送一个OPTIONS请求，如何解决？"><a href="#复杂的跨域请求会造成每次请求都发送一个OPTIONS请求，如何解决？" class="headerlink" title="复杂的跨域请求会造成每次请求都发送一个OPTIONS请求，如何解决？"></a>复杂的跨域请求会造成每次请求都发送一个OPTIONS请求，如何解决？</h3><p>通过以上的所有对复杂的跨域请求的分析清楚的认识到,那些请求方式会造成发送预检，一句话概括，<strong>Access-Control-Max-Age 这个响应首部表示 preflight request （预检请求）的返回结果（即 Access-Control-Allow-Methods 和Access-Control-Allow-Headers 提供的信息） 可以被缓存多久。</strong>这样对<code>network</code>中的请求观察和请求性能来说都不友好。如果做到友好又安全的机制。</p><blockquote><p>对预检进行一个时间请求有效期</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">res.setHeader(&apos;Access-Control-Max-Age&apos;, 600)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对预检请求设置<code>10</code>分钟的过期时间(时间可以根据项目情况进行自定义)。但是对于每个浏览器的缓存时间机制都不一样。在本地调试的时候，有时候你会发现设置了预检的过期时间并不生效。<strong>注意一下可能开启了浏览器的Disable cache导致了此原因</strong></p><h3 id="在前后端联调时-不通过后端设置-如何解决跨域问题？"><a href="#在前后端联调时-不通过后端设置-如何解决跨域问题？" class="headerlink" title="在前后端联调时,不通过后端设置,如何解决跨域问题？"></a>在前后端联调时,不通过后端设置,如何解决跨域问题？</h3><blockquote><p>关闭浏览器跨域策略。</p></blockquote><p>通过之前分析整个跨域模式是由前台浏览器的所作所为造成的。为了安全,浏览器对跨域请求做了一系列的验证。那是否可以想想, 通过手动关闭浏览器跨域策略是不是可以解决根本性的问题。</p><blockquote><p>Mac 创建一个chrome.sh文件</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">open -a &quot;Google Chrome&quot; --args --disable-web-security  --user-data-dir</span><br><span class="line"></span><br><span class="line">exit 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过终端运行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh 加上chrome.sh文件地址</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 在运行终端命令的时候,先检查是否已经启动过<code>chrome</code>,如果启动过需要手动关闭整个<code>chrome</code>的进程。</p><blockquote><p>成功结果:</p></blockquote><p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="573">)</svg></p><p>输入<code>URL</code>地址之后。所有的跨域问题会一并解决。</p><blockquote><p>原理</p></blockquote><p>虽然浏览器的跨域策略已经被关闭了。不存在任何浏览发送的跨域行为, 其内部原理正是因为浏览器会对简单的跨域请求做了拦截和复杂的跨域请求做了发送预检。</p><h3 id="简单的跨域请求通过什么进行拦截？"><a href="#简单的跨域请求通过什么进行拦截？" class="headerlink" title="简单的跨域请求通过什么进行拦截？"></a>简单的跨域请求通过什么进行拦截？</h3><p>在理解简单的跨域请求时先需要理解两个请求头的字段。</p><blockquote><p>request请求头中的Origin</p></blockquote><p>请求首部字段 <code>Origin</code> 指示了请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息。该首部用于 <code>CORS</code> 请求。</p><p>通俗的说就是告诉服务器此时是从那个域名地址发送来的。只有在<code>CORS</code>的情况下<code>Origin</code>才会在请求头中出现。</p><blockquote><p>request请求头中的HOST</p></blockquote><p><code>Host</code> 请求头指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的TCP端口号。 如果没有给定端口号，会自动使用被请求服务的默认端口（比如请求一个<code>HTTP</code>的<code>URL</code>会自动使用<code>80</code>端口）。 <code>HTTP/1.1</code> 的所有请求报文中必须包含一个Host头字段。如果一个 <code>HTTP/1.1</code>请求缺少<code>Host</code> 头字段或者设置了超过一个的 <code>Host</code> 头字段，一个<code>400（Bad Request</code>）状态码会被返回。</p><p>通俗的说就是浏览器向服务端发送请求时, 所请求的服务器的域名地址。</p><blockquote><p>响应头中的Access-Control-Allow-Origin</p></blockquote><p>响应头指定了该响应的资源是否被允许与前台请求头给定的<code>origin</code>共享。</p><blockquote><p>结论</p></blockquote><p>所以跨域请求返回浏览器之后。虽然数据会返回但是。浏览器会比对请求头中的<code>Origin</code>与响应头中的<code>Access-Control-Allow-Origin</code>是否是共享匹配,如果不匹配。浏览器的<code>xhr</code>会捕获错误并且在浏览器端控制台抛出错误。并不能拿到期望的数据。</p><h3 id="复杂的请求浏览器是如何检测跨域的？"><a href="#复杂的请求浏览器是如何检测跨域的？" class="headerlink" title="复杂的请求浏览器是如何检测跨域的？"></a>复杂的请求浏览器是如何检测跨域的？</h3><p>对于复杂的请求跨域, 浏览器一旦检测此发送的请求头存在属于复杂的跨域请求时, 首先会发送一个预请求, 请求头中包函着以下重要的内容:</p><ol><li><code>Access-Control-Request-Headers</code>(如果有自定义头或者<code>content-type</code>类形不属于简单请求的类型的情况下才会出来)</li><li><code>Access-Control-Request-Method</code>(除了简单的请求方法才会出现）</li></ol><p>并且在发送预检请求时并不会把请求数据和<code>cookie</code>信息带入请求信息中。</p><h3 id="什么是预检请求？"><a href="#什么是预检请求？" class="headerlink" title="什么是预检请求？"></a>什么是预检请求？</h3><p>在<code>CORS</code>中会使用 <code>OPTIONS</code> 方法发起一个预检请求(<strong>preflight request</strong>), 以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p><p>当浏览器请求头中发出<code>request-Header</code>或者<code>request-Method</code>时。此时服务端需要同意这两个请求头中对应的信息通过允许。需要在响应返回的时候对响应头做出响应处理。需要对<code>Access-Control-Allow-Methods</code>和<code>Access-Control-Allow-Headers</code>设置。</p><blockquote><p>原理图:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/4/3/169e3951968333fb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><h3 id="附带Credentials-身份凭证的-请求属于简单的跨域请求还是复杂的跨域请求？"><a href="#附带Credentials-身份凭证的-请求属于简单的跨域请求还是复杂的跨域请求？" class="headerlink" title="附带Credentials(身份凭证的)请求属于简单的跨域请求还是复杂的跨域请求？"></a>附带<code>Credentials</code>(身份凭证的)请求属于简单的跨域请求还是复杂的跨域请求？</h3><p>关于<code>Credentials</code>在<code>CORS</code>中原理性已经讲的很明白了。但是这里想讲的就是在<code>xhr</code>中<code>Credentials</code>设置为<code>true</code>时。此时只是简单的跨域请求,不会发送预检(<code>OPTIONS</code>)请求, 如果此时是复杂的跨域请求。会发送预检(<code>OPTIONS</code>)请求。</p><p>所以<code>Credentials</code>是否会发送预检,主要需要通过其它请求头的判定来决定是否需要发送预检。</p><blockquote><p>原理图:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/4/3/169e395b89ae0d93?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><blockquote><p>总结:</p></blockquote><p>只有当<code>request</code>请求头与<code>response</code>返回头一一对应上了。互相允许通过共享策略。对于简单的跨域请求则不会被捕获错误.对于复杂的跨域请求则会发送真正的请求。同时会把<code>cookie</code>等传输数据带入请求体中。所以说关闭浏览器跨域策略就是关闭了浏览器对响应<code>Origin</code>头匹配时不再捕获，同时也会关闭对应的<code>OPTIONS</code>预检请求。直接发送给对应的后台服务器。所以说本质上虽然存在跨域,但是服务端永远是返回数据。一切的错误或者没有发送真正的请求都是浏览器的安全机制所为。</p><h3 id="如何通过代理劫持机制解决跨域？"><a href="#如何通过代理劫持机制解决跨域？" class="headerlink" title="如何通过代理劫持机制解决跨域？"></a>如何通过代理劫持机制解决跨域？</h3><p>前面我们已经知道浏览器向服务器请求是存在跨域问题，但是服务器向服务器发送请求是不存在跨域问题。通过<code>MS(middle server)</code>进行请求劫持之后，通过服务端向服务端发送请求，再二次返回给浏览器端。</p><blockquote><p>示意图:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/4/3/169e39a32b8717c3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>在各大框架中都通过脚手架启动<code>node</code>服务承载着项目。例如<code>vue-cli</code>中就利用了<code>http-proxy-middle</code>进行一个请求的代理拦截,向目标服务器发送请求来解决跨域问题。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过express启用3000端口</span><br><span class="line"></span><br><span class="line">// index.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let url = &apos;/api/getUser&apos;;</span><br><span class="line">  let xhr = new XMLHttpRequest();</span><br><span class="line">  xhr.open(&apos;post&apos;, url, true);</span><br><span class="line">  xhr.setRequestHeader(&apos;content-type&apos;, &apos;application/json&apos;);</span><br><span class="line">  xhr.setRequestHeader(&apos;X-Customer-Header&apos;, &apos;value&apos;);</span><br><span class="line">  xhr.send();</span><br><span class="line">  xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if (xhr.readyState === 4) &#123;</span><br><span class="line">      if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">        console.log(xhr.response)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const proxyOption = &#123;</span><br><span class="line">target: &apos;http://localhost:4000&apos;,</span><br><span class="line">pathRewrite: &#123;</span><br><span class="line">        &apos;^/api/&apos; : &apos;/&apos;  // 重写请求，api/解析为/</span><br><span class="line">    &#125;,</span><br><span class="line">    changeOrigin:true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.use(&apos;/api&apos;, proxy(proxyOption))</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">// 后台服务启动4000端口</span><br><span class="line">app.post(&apos;/getUser&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">  res.send(&#123;</span><br><span class="line">    code: 1</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当<code>3000</code>端口的静态文件发送<code>ajax</code>请求的时候，本身就是在一个域名下，不会造成任何跨域问题,同时会被<code>app.use(&#39;/api/&#39;)</code>捕获拦截,同时改写<code>url</code>地址向服务端<code>4000</code>端进行请求发送数据。此时就是<code>server</code>端与<code>server</code>端的请求通信。当<code>4000</code>端口的<code>server</code>接收到请求之后把数据返回给<code>3000</code>端口的<code>server</code>端，同时再返回给请求的<code>ajax</code>。</p><h3 id="用node原生API如何实现？"><a href="#用node原生API如何实现？" class="headerlink" title="用node原生API如何实现？"></a>用node原生API如何实现？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(&apos;/api&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  const reqHttp = http.request(&#123;</span><br><span class="line">    host: &apos;127.0.0.1&apos;,</span><br><span class="line">    path: &apos;/getUser&apos;,</span><br><span class="line">    port: &apos;4000&apos;,</span><br><span class="line">    method: req.method,</span><br><span class="line">    headers: req.headers</span><br><span class="line">  &#125;, (resHttp) =&gt; &#123;</span><br><span class="line">    let body = &apos;&apos;</span><br><span class="line">    resHttp.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">      console.log(chunk.toString())</span><br><span class="line">      body += chunk</span><br><span class="line">    &#125;);</span><br><span class="line">    resHttp.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">      res.end(body)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  reqHttp.end()</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上代码本质上是模拟了代理劫持的方式，同时当拦截到<code>url</code>开头以<code>/api</code>起始的请求之后,通过<code>node</code>原生<code>http</code>模块的<code>request</code>方法向对应的后台发送请求，同时把浏览器请求过来的一些请求体，请求头等数据一并传给<code>server</code>端。通过<code>http</code>模块监听的结束方法最后把数据再返回到<code>client</code>浏览器端。这样形成了二次转方式解决跨域问题。整体就是利用了服务端向服务发送请求不会有跨域策略的限制,就是所谓的同源策略。因为浏览器会做<code>options</code>等预检的检测，而服务端并不会。</p><p>原文链接：<a href="https://juejin.im/post/5ca4ba9ff265da30a40d5283" target="_blank" rel="noopener">https://juejin.im/post/5ca4ba9ff265da30a40d5283</a></p><p>版权归原作者所有</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本次分享由趣头条cpc商业化技术部(周志祥-混元霹雳手)进行分享!欢迎大家投递简历加入趣头条,邮箱地址为&lt;a href=&quot;mailto:qianjiongli@qutoutiao.net&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【转】滑动穿透(锁body)终极探索</title>
    <link href="https://cuilongjin.top/2019/%E8%BD%AC-%E4%BD%BF%E7%94%A8Git%20Submodule%E7%AE%A1%E7%90%86%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    <id>https://cuilongjin.top/2019/转-使用Git Submodule管理子模块/</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2019-07-28T08:55:39.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>基于公司的项目会越来越多，常常需要提取一个公共的类库提供给多个项目使用，但是这个<code>library</code>怎么和<code>git</code>在一起方便管理呢？<br>我们需要解决下面几个问题：</p><ul><li>如何在git项目中导入<code>library库</code>?</li><li><code>library库</code>在其他的项目中被修改了可以更新到远程的代码库中?</li><li>其他项目如何获取到<code>library库</code>最新的提交?</li><li>如何在clone的时候能够自动导入<code>library库</code>?</li></ul><p>解决以上问题，可以考虑使用git的 <code>Submodule</code>来解决。</p><h2 id="什么是Submodule"><a href="#什么是Submodule" class="headerlink" title="什么是Submodule?"></a>什么是Submodule?</h2><p><code>git Submodule</code> 是一个很好的多项目使用共同类库的工具，他允许类库项目做为<code>repository</code>,子项目做为一个单独的<code>git项目</code>存在父项目中，子项目可以有自己的独立的<code>commit</code>，<code>push</code>，<code>pull</code>。而父项目以<code>Submodule</code>的形式包含子项目，父项目可以指定子项目<code>header</code>，父项目中会的提交信息包含<code>Submodule</code>的信息，再<code>clone父项目</code>的时候可以把<code>Submodule</code>初始化。</p><h2 id="在项目中使用Submodule"><a href="#在项目中使用Submodule" class="headerlink" title="在项目中使用Submodule"></a>在项目中使用Submodule</h2><p>使用<code>git</code>命令可以直接添加<code>Submodule</code>：</p><blockquote><p>git submodule add <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:jjz/pod-library.git pod-library</p></blockquote><p>使用 <code>git status</code>命令可以看到</p><blockquote><p>git status</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">    new file:   .gitmodules</span><br><span class="line">    new file:   pod-library</span><br></pre></td></tr></table></figure><p>可以看到多了两个需要提交的文件：<code>.gitmodules</code>和 <code>pod-library</code><br><code>.gitmodules</code> 内容包含<code>Submodule</code>的主要信息，指定<code>reposirory</code>,指定路径:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[submodule &quot;pod-library&quot;]</span><br><span class="line">    path = pod-library</span><br><span class="line">    url = git@github.com:jjz/pod-library.git</span><br></pre></td></tr></table></figure><p>可以看到记录了子项目的目录和子项目的<code>git</code>地址信息。<br><code>pod-libray</code>内容只保护子项目的<code>commit id</code>，就能指定到对于的<code>git header</code>上,例如:</p><blockquote><p>Subproject commit 4ac42d2f8b9ba0c2f0f2f2ec87ddbd529275fea5</p></blockquote><p><code>4ac42d2f8b9ba0c2f0f2f2ec87ddbd529275fea5</code>就是子项目的<code>commit id</code>，父项目的git并不会记录<code>Submodule</code>的文件变动，它是按照<code>commit git</code>指定<code>Submodule</code>的<code>git header</code>。</p><p>另外,<em>这两个文件都需要提交到父项目的git中</em>。</p><p>还可以这样使用命令添加<code>Submodule</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .gitmodules pod-ibrary</span><br><span class="line">git commit -m &quot;pod-library submodule&quot;</span><br><span class="line">git submodule init</span><br></pre></td></tr></table></figure><h2 id="修改Submodule"><a href="#修改Submodule" class="headerlink" title="修改Submodule"></a>修改Submodule</h2><p><strong>首先需要确认有对Submodule的commit权限</strong>。<br>进入<code>Submodule</code>目录里面:</p><blockquote><p>cd pod-library/</p></blockquote><p>修改其中的一个文件看下文件的可以用<code>git status</code>查看变动:</p><blockquote><p>git status</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modified: pod-library/UseAFHTTP.h</span><br></pre></td></tr></table></figure><p>提交<code>Submodule</code>的更改内容：</p><blockquote><p>git commit -a -m’test submodule’</p></blockquote><p>然后<code>push</code> 到远程服务器:</p><blockquote><p>git push</p></blockquote><p>然后再回到父目录,提交<code>Submodule</code>在父项目中的变动：</p><blockquote><p>cd ..</p></blockquote><p>git status<br>on branch master</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modified: pod-library (new commits)</span><br></pre></td></tr></table></figure><p>可以看到<code>pod-library</code>中已经变更为<code>Submodule</code>最新的<code>commit id</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Subproject commit 330417cf3fc1d2c42092b20506b0d296d90d0b5f</span><br></pre></td></tr></table></figure><p>需要把<code>Submodule</code>的变动信息推送到父项目的远程服务器</p><blockquote><p>git commit -m’update submodule’</p></blockquote><p>git push</p><p>这样就把子模块的变更信息以及子模块的变更信息提交到远程服务器了，从远程服务器上更新下来的内容就是最新提交的内容了。</p><h2 id="更新Submodule"><a href="#更新Submodule" class="headerlink" title="更新Submodule"></a>更新Submodule</h2><p>更新<code>Submodule</code>有两种方式:<br>在父项目的目录下直接运行</p><blockquote><p>git submodule foreach git pull</p></blockquote><p>在Submodule的目录下面更新</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;cd pod-library</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>可以看到在<code>Submodule</code>的目录中,使用<code>git</code>和单独的一个项目是一样的,注意更新<code>Submodule</code>的时候如果有新的<code>commit id</code>产生，需要在父项目产生一个新的提交，pod-libray文件中的 <code>Subproject commit</code>会变为最新的<code>commit id</code>。</p><h2 id="clone-Submodule"><a href="#clone-Submodule" class="headerlink" title="clone Submodule"></a>clone Submodule</h2><p><code>clone Submodule</code>有两种方式 一种是采用递归的方式clone整个项目，一种是clone父项目，再更新子项目。</p><ol><li>采用递归参数 <code>--recursive</code></li></ol><blockquote><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:jjz/pod-project.git –recursive</p></blockquote><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loning into &apos;pod-project&apos;...</span><br><span class="line">remote: Counting objects: 57, done.</span><br><span class="line">remote: Compressing objects: 100% (45/45), done.</span><br><span class="line">remote: Total 57 (delta 13), reused 49 (delta 8), pack-reused 0</span><br><span class="line">Receiving objects: 100% (57/57), 18.79 KiB | 0 bytes/s, done.</span><br><span class="line">Resolving deltas: 100% (13/13), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Submodule &apos;pod-library&apos; (git@github.com:jjz/pod-library.git) registered for path &apos;pod-library&apos;</span><br><span class="line">Cloning into &apos;pod-library&apos;...</span><br><span class="line">remote: Counting objects: 34, done.</span><br><span class="line">remote: Compressing objects: 100% (25/25), done.</span><br><span class="line">remote: Total 34 (delta 8), reused 30 (delta 7), pack-reused 0</span><br><span class="line">Receiving objects: 100% (34/34), 12.95 KiB | 0 bytes/s, done.</span><br><span class="line">Resolving deltas: 100% (8/8), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Submodule path &apos;pod-library&apos;: checked out &apos;330417cf3fc1d2c</span><br><span class="line"></span><br><span class="line">42092b20506b0d296d90d0b5f&apos;</span><br></pre></td></tr></table></figure><p>可以看到<code>init Submodule</code> 会自动被<code>clone</code>下来</p><ol><li>第二种方法先clone父项目，再初始化<code>Submodule</code></li></ol><blockquote><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:jjz/pod-project.git<br>cd pod-project</p></blockquote><p>git submodule init</p><p>输出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Submodule &apos;pod-library&apos; (git@github.com:jjz/pod-library.git) </span><br><span class="line">registered for path &apos;pod-library&apos;</span><br></pre></td></tr></table></figure><p>更新<code>Submodule</code>:</p><blockquote><p>git submodule update</p></blockquote><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cloning into &apos;pod-library&apos;...</span><br><span class="line">remote: Counting objects: 34, done.</span><br><span class="line">remote: Compressing objects: 100% (25/25), done.</span><br><span class="line">remote: Total 34 (delta 8), reused 30 (delta 7), pack-reused 0</span><br><span class="line">Receiving objects: 100% (34/34), 12.95 KiB | 0 bytes/s, done.</span><br><span class="line">Resolving deltas: 100% (8/8), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Submodule path &apos;pod-library&apos;: checked out &apos;330417cf3fc1d2c42092b20506b0d296d90d0b5f&apos;</span><br></pre></td></tr></table></figure><h2 id="删除Submodule"><a href="#删除Submodule" class="headerlink" title="删除Submodule"></a>删除Submodule</h2><p><code>git</code> 并不支持直接删除<code>Submodule</code>需要手动删除对应的文件:</p><blockquote><p>cd pod-project</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; git rm --cached pod-library</span><br><span class="line">&gt; rm -rf pod-library</span><br><span class="line">&gt; rm .gitmodules</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>更改git的配置文件<code>config</code>:<br>vim .git/config</p></blockquote><p>可以看到<code>Submodule</code>的配置信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[submodule &quot;pod-library&quot;]</span><br><span class="line">  url = git@github.com:jjz/pod-library.git</span><br></pre></td></tr></table></figure><p>删除submodule相关的内容,然后提交到远程服务器:</p><blockquote><p>git commit -a -m ‘remove pod-library submodule’</p></blockquote><p>原文链接：<a href="https://segmentfault.com/a/1190000003076028" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003076028</a></p><p>版权归原作者所有</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;p&gt;基于公司的项目会越来越多，常常需要提取一个公共的类库提供给多个项目使用，但是这个&lt;code&gt;library&lt;/code&gt;怎么
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>axios 取消请求</title>
    <link href="https://cuilongjin.top/2019/javascript/axios%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/"/>
    <id>https://cuilongjin.top/2019/javascript/axios取消请求/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>原生 js abort() 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = $.ajax(&#123;&#125;)</span><br><span class="line">A.abort()</span><br></pre></td></tr></table></figure><p>Axios 提供了一个 CancelToken 的函数，这是一个构造函数，该函数的作用就是用来取消接口请求的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  getMsg () &#123;</span><br><span class="line">    <span class="keyword">let</span> CancelToken = axios.CancelToken</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    axios.get(<span class="string">''</span>, &#123;</span><br><span class="line">      cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        that.cancel = c</span><br><span class="line">        <span class="built_in">console</span>.log(c)</span><br><span class="line">        <span class="comment">// 这个参数 c 就是 CancelToken 构造函数里面自带的取消请求的函数，这里把该函数当参数用</span></span><br><span class="line">      &#125;)</span><br><span class="line">      params: &#123;&#125;</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.items = res.data</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelGetMsg () &#123;</span><br><span class="line">    <span class="keyword">this</span>.cancel()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原生 js abort() 方法&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; A 
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>高阶函数与柯里化</title>
    <link href="https://cuilongjin.top/2019/javascript/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://cuilongjin.top/2019/javascript/高阶函数与柯里化/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数定义：将函数作为参数或者返回值是函数的函数<br>常见的 sort、reduce 等函数就是高阶函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = add(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6写法</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术</p><p>柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要 n 个参数的函数变成只需要剩下的（n - 1 个）参数就可以调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形如</span></span><br><span class="line">a =&gt; <span class="function"><span class="params">b</span> =&gt;</span> c =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br><span class="line"><span class="keyword">let</span> add1 = add(<span class="number">1</span>) <span class="comment">// a = 1; b =&gt; a + b</span></span><br><span class="line">add1(<span class="number">2</span>) <span class="comment">// 1 + 2 = 3</span></span><br></pre></td></tr></table></figure><p>add1 函数等价于有了 a 这个闭包变量的 b = a + b</p><p>add 函数按照 wiki 的定义可以理解成只柯里化了一次，n 个连续箭头组成的函数实际上就是柯里化了 n - 1 次<br>前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值</p><p>所以多个连续箭头函数就是多次柯里化的 es6 写法</p><p><strong>应用：</strong></p><p>函数懒执行<br>函数式编程</p><p><strong>柯里化函数使用场景：</strong></p><p>减少重复传递不变的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price, discount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * discount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次都要重复传入 discount 参数，可以将这个函数柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price, discount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">price</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price * discount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tenPercentDiscount = discount(<span class="number">0.9</span>) <span class="comment">// 9折</span></span><br><span class="line"><span class="keyword">const</span> twentyPercentDiscount = discount(<span class="number">0.8</span>) <span class="comment">// 8折</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在每次计算价格只需要：</span></span><br><span class="line">tenPercentDiscount(<span class="number">500</span>) <span class="comment">// 500 * 0.9</span></span><br><span class="line">twentyPercentDiscount(<span class="number">1000</span>) <span class="comment">// 1000 * 0.8</span></span><br></pre></td></tr></table></figure><h2 id="柯里化实现"><a href="#柯里化实现" class="headerlink" title="柯里化实现"></a>柯里化实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="keyword">this</span>, args.concat(args2))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum)</span><br><span class="line"><span class="built_in">console</span>.log(curriedSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curriedSum(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高阶函数&quot;&gt;&lt;a href=&quot;#高阶函数&quot; class=&quot;headerlink&quot; title=&quot;高阶函数&quot;&gt;&lt;/a&gt;高阶函数&lt;/h2&gt;&lt;p&gt;高阶函数定义：将函数作为参数或者返回值是函数的函数&lt;br&gt;常见的 sort、reduce 等函数就是高阶函数&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3 多页模式</title>
    <link href="https://cuilongjin.top/2019/vue/%E5%A4%9A%E9%A1%B5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://cuilongjin.top/2019/vue/多页模式/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2019-07-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cli.vuejs.org/zh/config/#pages" target="_blank" rel="noopener">vue-cli 多页面的配置官方介绍</a></p><p><code>vue.config.js</code> 配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      <span class="comment">// page 的入口</span></span><br><span class="line">      entry: <span class="string">'src/pages/index/main.js'</span>,</span><br><span class="line">      <span class="comment">// 模板来源</span></span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      <span class="comment">// 在 dist/index.html 的输出</span></span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">      title: <span class="string">'Index Page'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    pageA: &#123;</span><br><span class="line">      entry: <span class="string">'src/pages/pageA/main.js'</span>,</span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'pageA.html'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当使用只有入口的字符串格式时, 模板会被推导为 `public/pageB.html`</span></span><br><span class="line">    <span class="comment">// 并且如果找不到的话，就回退到 `public/index.html`, 输出文件名会被推导为 `pageB.html`</span></span><br><span class="line">    pageB: <span class="string">'src/pages/pageB/main.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个页面一套 SPA，入口文件、路由、资源的路径都要根据实际情况进行设置</p><p>页面内可以继续使用<code>SPA</code>模式的<code>&lt;router-link&gt;</code>，但是页面之间的跳转需要使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/pageA.html"</span>&gt;</span>前往 pageA 页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cli.vuejs.org/zh/config/#pages&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cli 多页面的配置官方介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vue.config.js&lt;/code&gt; 
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>keep-alive 实现页面缓存</title>
    <link href="https://cuilongjin.top/2019/vue/keep-alive/"/>
    <id>https://cuilongjin.top/2019/vue/keep-alive/</id>
    <published>2019-07-14T16:00:00.000Z</published>
    <updated>2019-07-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>缓存</p><ul><li><p>pageAList -&gt; pageADetail -&gt; pageAList，缓存 pageAList，同时如果 pageAList 发生变化需要更新</p></li><li><p>其他页面 -&gt; pageAList，pageAList 不缓存</p></li></ul><p>router 配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/pageAList'</span>,</span><br><span class="line">        name: <span class="string">'pageAList'</span>,</span><br><span class="line">        component: pageAList</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/pageADetail'</span>,</span><br><span class="line">        name: <span class="string">'pageADetail'</span>,</span><br><span class="line">        component: pageADetail</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>vuex 配置 store.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    includeComponents: [] <span class="comment">// 需要缓存的组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    addIncludeComponent(state, includeComponent) &#123;</span><br><span class="line">      <span class="comment">// includeComponent 可能是组件 name 字符串或者数组</span></span><br><span class="line">      <span class="keyword">let</span> includeComponents = state.includeComponents</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(includeComponent)) &#123;</span><br><span class="line">        state.includeComponents = [...new <span class="built_in">Set</span>([...includeComponents, ...includeComponent])]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.includeComponents = [...new <span class="built_in">Set</span>([...includeComponents, includeComponent])]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    removeIncludeComponent(state, includeComponent) &#123;</span><br><span class="line">      <span class="keyword">let</span> includeComponents = state.includeComponents</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(includeComponent)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; includeComponent.length; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> index = includeComponents.findIndex(<span class="function"><span class="params">v</span> =&gt;</span> v === includeComponent[i])</span><br><span class="line">          <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            includeComponents.splice(index, <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = includeComponents.length; i &lt; len; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (includeComponents[i] === includeComponent) &#123;</span><br><span class="line">            includeComponents.splice(i, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state.includeComponents = includeComponents</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>home.vue</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- keep-alive 包裹 router-view --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"includeComponents"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    computed: &#123;</span></span><br><span class="line"><span class="undefined">      includeComponents() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.includeComponents</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>pageAList.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'pageAList'</span>,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/pageADetail/</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(to.name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'addIncludeComponent'</span>, <span class="string">'pageADetail'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'removeIncludeComponent'</span>, <span class="string">'pageADetail'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pageADetail.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'pageADetail'</span>,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/pageA/</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(to.name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'addIncludeComponent'</span>, <span class="string">'pageAList'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'removeIncludeComponent'</span>, <span class="string">'pageAList'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>进入 pageAList，离开当前组件的时候有两种情况：<ul><li>跳转进去 pageADetail，在 pageAList 的 beforeRouteLeave 钩子里面缓存 pageAList</li><li>跳转到非 pageADetail 的页面，在 pageAList 的 beforeRouteLeave 钩子里面清除 pageAList 的缓存</li></ul></li></ul><ul><li>从 pageADetail 离开的时候，也有两种情况：<ul><li>回到 pageAList，在 pageADetail 的 beforeRouteLeave 钩子里面缓存 pageAList，所以从 pageAList-pageADetail-pageAList 的时候，pageAList 可以被缓存，还是之前的页码状态</li><li>进入其他路由，在 pageADetail 的 beforeRouteLeave 钩子里面清除 pageAList 的缓存</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pageAList -&amp;gt; pageADetail -&amp;gt; pageAList，缓存 pageAList，同时如果 pageAList 发生变化需要更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他页面 -&amp;gt; pageAList
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3.0 内存溢出 JavaScript heap out of memory</title>
    <link href="https://cuilongjin.top/2019/vue/vue-cli3%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3/"/>
    <id>https://cuilongjin.top/2019/vue/vue-cli3 内存溢出解决/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-17T15:37:34.293Z</updated>
    
    <content type="html"><![CDATA[<p>错误内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;--- JS stacktrace ---&gt;</span><br><span class="line"></span><br><span class="line">==== JS stack trace =========================================</span><br><span class="line"></span><br><span class="line">    0: ExitFrame [pc: 000002861B95C5C1]</span><br><span class="line">Security context: 0x002fdeb1e6e9 &lt;JSObject&gt;</span><br><span class="line">    1: DoJoin(aka DoJoin) [0000002FDEB05E91] [native array.js:~87] [pc=000002861C436409](this=0x0037aae826f1 &lt;undefined&gt;,l=0x01420be65761 &lt;JSArray[2]&gt;,m=2,A=0x0037aae828c9 &lt;true&gt;,w=0x0375f51b46d9 &lt;String[1]\: \n&gt;,v=0x0037aae829a1 &lt;false&gt;)</span><br><span class="line">    2: Join(aka Join) [0000002FDEB05EE1] [native array.js:~112] [pc=000002861BC4F978](this=0x0037aae826f1 &lt;undefined&gt;,l...</span><br><span class="line"></span><br><span class="line">FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory</span><br></pre></td></tr></table></figure><p>nodejs 内存限制，通过添加启动参数可以解决</p><p>vue-cli2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev 和 npm run build 直接在前面加上--max_old_space_size=4096</span><br></pre></td></tr></table></figure><p>vue-cli3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx --max_old_space_size=4096 vue-cli-service serve</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i increase-memory-limit cross-env</span><br><span class="line">scripts 中添加指令 &quot;fix-memory-limit&quot;: &quot;cross-env LIMIT=4096 increase-memory-limit&quot;</span><br><span class="line">npm run fix-memory-limit</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>最后将 lintOnsave: false 解决了</p><p><a href="https://github.com/vuejs/vue-cli/issues/1453" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli/issues/1453</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;错误内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;--- JS stacktrace ---&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli 常用配置</title>
    <link href="https://cuilongjin.top/2019/vue/vue-cli%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://cuilongjin.top/2019/vue/vue-cli常用配置/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h2 id="vue-cli-webpack-打包后-index-html-引入文件没有引号"><a href="#vue-cli-webpack-打包后-index-html-引入文件没有引号" class="headerlink" title="vue-cli webpack 打包后 index.html 引入文件没有引号"></a>vue-cli webpack 打包后 index.html 引入文件没有引号</h2></li></ul><p>解决办法：</p><p>vue-cli2：</p><p>在 webpack.prod.conf.js 中修改：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeAttributeQuotes: <span class="literal">false</span> <span class="comment">// 如果该方法没有用那就把整个 minify 去掉</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>vue-cli3:</p><p>在 vue.config.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">    args[<span class="number">0</span>].minify = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="svue-cli-打包时删除-console、deugger、注释"><a href="#svue-cli-打包时删除-console、deugger、注释" class="headerlink" title="svue-cli 打包时删除 console、deugger、注释"></a>svue-cli 打包时删除 console、deugger、注释</h2></li></ul><p>vue-cli2：</p><p>在 webpack.prod.conf.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">    uglifyOptions: &#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        drop_debugger: <span class="literal">true</span>,</span><br><span class="line">        drop_console: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        comment: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>vue-cli3：</p><p>安装 uglifyjs-webpack-plugin</p><p>在 vue.config.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          drop_debugger: <span class="literal">true</span>,</span><br><span class="line">          drop_console: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">          comment: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      parallel: <span class="literal">true</span>,</span><br><span class="line">      cache: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;vue-cli-webpack-打包后-index-html-引入文件没有引号&quot;&gt;&lt;a href=&quot;#vue-cli-webpack-打包后-index-html-引入文件没有引号&quot; class=&quot;headerlink&quot; title=&quot;vue-c
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>js 中编码（encode）和解码（decode）的三种方法</title>
    <link href="https://cuilongjin.top/2019/other/js%20%E4%B8%AD%E7%BC%96%E7%A0%81%EF%BC%88encode%EF%BC%89%E5%92%8C%E8%A7%A3%E7%A0%81%EF%BC%88decode%EF%BC%89%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://cuilongjin.top/2019/other/js 中编码（encode）和解码（decode）的三种方法/</id>
    <published>2019-07-09T08:42:00.000Z</published>
    <updated>2019-07-09T09:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js-中编码（encode）和解码（decode）的三种方法"><a href="#js-中编码（encode）和解码（decode）的三种方法" class="headerlink" title="js 中编码（encode）和解码（decode）的三种方法"></a>js 中编码（encode）和解码（decode）的三种方法</h3><p>js 对文字进行编码涉及 3 个函数：escape、encodeURI、encodeURIComponent，相应 3 个解码函数：unescape、decodeURI、decodeURIComponent</p><ul><li>escape()函数</li></ul><p>定义和用法：escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串<br>语法：escape(string)<br>参数：string 必需，要被转义或编码的字符串。<br>返回值：已编码的 string 的副本。其中某些字符被替换成了十六进制的转义序列<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： <code>-_.!~*&#39;()</code> ，其他所有的字符都会被转义序列替换</p><ul><li>encodeURI()函数</li></ul><p>定义和用法：encodeURI() 函数可把字符串作为 URI 进行编码<br>语法：encodeURI(URIstring)<br>参数：URIstring 必需，一个字符串，含有 URI 或其他要编码的文本。<br>返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：<code>-_.!~*&#39;()</code> ，该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：<code>;/?:@&amp;=+$,#</code></p><ul><li>encodeURIComponent()</li></ul><p>定义和用法：encodeURIComponent() 函数可把字符串作为 URI 组件进行编码<br>语法：encodeURIComponent(URIstring)<br>参数：URIstring 必需，一个字符串，含有 URI 组件或其他要编码的文本<br>返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：<code>-_.!~*&#39;()</code>，其他字符（比如 ：<code>;/?:@&amp;=+$,#</code> 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的</p><p>说明：</p><ul><li><p>encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号</p></li><li><p>传递参数时需要使用 encodeURIComponent，这样组合的 url 才不会被#等特殊字符截断</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js-中编码（encode）和解码（decode）的三种方法&quot;&gt;&lt;a href=&quot;#js-中编码（encode）和解码（decode）的三种方法&quot; class=&quot;headerlink&quot; title=&quot;js 中编码（encode）和解码（decode）的三种方法&quot;&gt;
      
    
    </summary>
    
      <category term="other" scheme="https://cuilongjin.top/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端(Safari)浏览网页时对数字不启用电话功能</title>
    <link href="https://cuilongjin.top/2019/%E7%A7%BB%E5%8A%A8web/%E7%A7%BB%E5%8A%A8%E7%AB%AF(Safari)%E6%B5%8F%E8%A7%88%E7%BD%91%E9%A1%B5%E6%97%B6%E5%AF%B9%E6%95%B0%E5%AD%97%E4%B8%8D%E5%90%AF%E7%94%A8%E7%94%B5%E8%AF%9D%E5%8A%9F%E8%83%BD/"/>
    <id>https://cuilongjin.top/2019/移动web/移动端(Safari)浏览网页时对数字不启用电话功能/</id>
    <published>2019-07-09T06:51:00.000Z</published>
    <updated>2019-07-09T13:14:28.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端-Safari-浏览网页时对数字不启用电话功能"><a href="#移动端-Safari-浏览网页时对数字不启用电话功能" class="headerlink" title="移动端(Safari)浏览网页时对数字不启用电话功能"></a>移动端(Safari)浏览网页时对数字不启用电话功能</h2><ul><li>标准的电话号码格式是：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"tel:+86-123-456-7890"</span>&gt;</span>1234567890<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>有时候不是电话号码的数字会被浏览器自动解析为如上电话号码格式，导致样式和布局改变</p></li><li><p>忽略页面中的数字识别为电话号码, 只要把这个默认行为关闭就行</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这个关闭不会影响真正电话号码的识别</li></ul><p>说明：Meta 标签中的 format-detection 属性及含义<br>format-detection 中文的意思是 “格式检测”，它是用来检测 html 里的一些格式的</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 禁止了把数字转化为拨号链接 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 禁止作为邮箱地址 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"email=no"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 禁止跳转至地图 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"adress=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no,email=no,adress=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移动端-Safari-浏览网页时对数字不启用电话功能&quot;&gt;&lt;a href=&quot;#移动端-Safari-浏览网页时对数字不启用电话功能&quot; class=&quot;headerlink&quot; title=&quot;移动端(Safari)浏览网页时对数字不启用电话功能&quot;&gt;&lt;/a&gt;移动端(Safa
      
    
    </summary>
    
      <category term="移动web" scheme="https://cuilongjin.top/categories/%E7%A7%BB%E5%8A%A8web/"/>
    
    
  </entry>
  
  <entry>
    <title>npm 使用</title>
    <link href="https://cuilongjin.top/2019/tool/npm/"/>
    <id>https://cuilongjin.top/2019/tool/npm/</id>
    <published>2019-07-02T16:00:00.000Z</published>
    <updated>2019-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-使用"><a href="#npm-使用" class="headerlink" title="npm 使用"></a>npm 使用</h2><h3 id="解决-npm-包无法下载"><a href="#解决-npm-包无法下载" class="headerlink" title="解决 npm 包无法下载"></a>解决 npm 包无法下载</h3><p>electron sass</p><p>进入 <code>~/.npmrc</code>，增加如下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org</span><br><span class="line">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjs</span><br><span class="line">electron_mirror=http://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure><p>淘宝 npm 镜像 <a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a></p><h3 id="npm-基本命令"><a href="#npm-基本命令" class="headerlink" title="npm 基本命令"></a>npm 基本命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 npm</span></span><br><span class="line">npm -v|--version</span><br><span class="line">npm install npm@latest -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># nvm : npm Version Manager</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索包</span></span><br><span class="line">npm search &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt; <span class="comment"># [&lt;@scope&gt;/] 安装限定范围的包</span></span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt;</span><br><span class="line">npm install &lt;folder&gt;</span><br><span class="line">npm install &lt;tarball file&gt;  <span class="comment"># .tar, .tar.gz, or .tgz</span></span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install &lt;github usename&gt;/&lt;guthub project&gt;</span><br><span class="line">npm install &lt;git:// url&gt;</span><br><span class="line"></span><br><span class="line">npm install &lt;pkg&gt; -S|--save <span class="comment"># 安装到 dependencies</span></span><br><span class="line">npm install &lt;pkg&gt; -D|--save-dev <span class="comment"># 安装到 devDependencies</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装全局包</span></span><br><span class="line">npm install -g &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包</span></span><br><span class="line">npm update</span><br><span class="line"><span class="comment"># 更新全局安装的包</span></span><br><span class="line">npm update -g <span class="comment"># 更新全部</span></span><br><span class="line">npm update -g| --global &lt;pkg&gt; <span class="comment"># 更新指定包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地包</span></span><br><span class="line">npm uninstall &lt;pkg&gt;</span><br><span class="line">npm uninstall --save &lt;pkg&gt; <span class="comment"># 从 `package.json` 文件中删除依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载全局安装的包</span></span><br><span class="line">npm uninstall -g &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开官网</span></span><br><span class="line">npm docs|home [&lt;pkg&gt;]</span><br><span class="line"><span class="comment"># 打开源码仓库页面</span></span><br><span class="line">npm repo [&lt;pkg&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 package.json 文件</span></span><br><span class="line">npm init</span><br><span class="line"><span class="comment"># 创建默认 package.json 文件</span></span><br><span class="line">npm init --yes or -y</span><br></pre></td></tr></table></figure><h3 id="npm-修改源"><a href="#npm-修改源" class="headerlink" title="npm 修改源"></a>npm 修改源</h3><ul><li><p>进入~/.npmrc 增加 <code>registry=https://registry.npm.taobao.org</code></p></li><li><p>通过命令 <code>npm config set registry http://registry.cnpmjs.org</code></p></li><li><p>临时使用指定源下载 <code>npm install jquery --registry=https://registry.npm.taobao.org</code></p></li><li><p>使用 nrm 管理源</p></li></ul><h3 id="npm-配置文件"><a href="#npm-配置文件" class="headerlink" title="npm 配置文件"></a>npm 配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .npmrc 配置文件位置（~/.npmrc）</span></span><br><span class="line">npm config list</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 缓存目录，默认 C:\Users\&lt;username&gt;\AppData\Roaming\npm-cache</span></span><br><span class="line">npm config get cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 npm 缓存</span></span><br><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 全局 node 包位置</span></span><br><span class="line">npm config get prefix</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm root -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 npm 全局文件位置及缓存文件位置</span></span><br><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"&lt;new_path&gt;"</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"&lt;new_path&gt;"</span></span><br></pre></td></tr></table></figure><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>使用 NPM 下载和发布代码时都会接触到版本号。NPM 使用语义版本号来管理代码</p><p>语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p><ul><li>如果只是修复 bug，需要更新 Z 位</li><li>如果是新增了功能，但是向下兼容，需要更新 Y 位</li><li>如果有大变动，向下不兼容，需要更新 X 位</li></ul><h3 id="nrm-使用"><a href="#nrm-使用" class="headerlink" title="nrm 使用"></a>nrm 使用</h3><p>nrm ls 查看配置列表，带*号即为当前使用的配置</p><p>nrm use 源的别名：切换源</p><p>nrm add 别名 地址 ： 添加源</p><p>nrm test 别名 ： 测速</p><p>nrm del 别名 ：删除源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;npm-使用&quot;&gt;&lt;a href=&quot;#npm-使用&quot; class=&quot;headerlink&quot; title=&quot;npm 使用&quot;&gt;&lt;/a&gt;npm 使用&lt;/h2&gt;&lt;h3 id=&quot;解决-npm-包无法下载&quot;&gt;&lt;a href=&quot;#解决-npm-包无法下载&quot; class=&quot;head
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Markdown" scheme="https://cuilongjin.top/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://cuilongjin.top/2019/tool/docker/"/>
    <id>https://cuilongjin.top/2019/tool/docker/</id>
    <published>2019-06-18T11:52:00.000Z</published>
    <updated>2019-07-09T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-dcoker"><a href="#安装-dcoker" class="headerlink" title="安装 dcoker"></a>安装 dcoker</h2><h3 id="ubuntu-16-04-LTS-安装-docker"><a href="#ubuntu-16-04-LTS-安装-docker" class="headerlink" title="ubuntu 16.04 (LTS) 安装 docker"></a>ubuntu 16.04 (LTS) 安装 docker</h3><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p>镜像仓库方式安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置镜像仓库</span></span><br><span class="line"><span class="comment"># 更新 apt 软件包索引：</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># 安装软件包，以允许 apt 通过 HTTPS 使用镜像仓库：</span></span><br><span class="line">$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥：</span></span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 验证密钥指纹是否为 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。</span></span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p>设置 stable 镜像仓库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># amd64：</span></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br></pre></td></tr></table></figure><p>安装 DOCKER CE</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><p>验证是否正确安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令将下载一个测试镜像并在容器中运行它。容器运行时，它将输出一条参考消息并退出</p><p>升级 docker ce</p><p>如需升级 Docker CE，首先运行 <code>sudo apt-get update</code>，然后按照顺序执行操作，并选择您要安装的新版本</p><p>卸载 docker ce</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure><p>主机上的镜像、容器、存储卷、或定制配置文件不会自动删除。如需删除所有镜像、容器和存储卷，请运行下列命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><p>将 docker 配置为在启动时启动</p><h3 id="centos-安装-docker"><a href="#centos-安装-docker" class="headerlink" title="centos 安装 docker"></a>centos 安装 docker</h3><p>卸载旧版本(如果安装过旧版本的话)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><p>安装需要的软件包， yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>设置 yum 源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>可以查看所有仓库中所有 docker 版本，并选择特定版本安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 报错：Requires: container-selinux &gt;= 2:2.74 </span></span><br><span class="line">You could try using --skip-broken to work around the problem</span><br><span class="line"></span><br><span class="line">$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo  </span><br><span class="line">$ yum install epel-release   <span class="comment"># 阿里云上的 epel 源</span></span><br><span class="line">$ yum makecache</span><br><span class="line">$ yum install container-selinux</span><br></pre></td></tr></table></figure><h2 id="使用-docker"><a href="#使用-docker" class="headerlink" title="使用 docker"></a>使用 docker</h2><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><p>修改 docker 源</p><p>daemon.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 docker</p><p>安装 Ubuntu</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search ubuntu <span class="comment"># 查找 Ubuntu 镜像</span></span><br><span class="line">docker pull ubuntu <span class="comment"># 安装 Ubuntu 镜像</span></span><br><span class="line">docker images <span class="comment">#查看 docker 镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并运行 docker 容器</span></span><br><span class="line">docker run -it -d --name ubuntu_test -p 8088:80 ubuntu</span><br><span class="line"><span class="comment"># --name 自定义容器名，-p 指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回 id</span></span><br><span class="line"><span class="comment"># 多个 -p 指定多个端口映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 docker 容器  启动一个 bash 交互终端</span></span><br><span class="line">docker run -it 容器名:容器tag /bin/bash</span><br><span class="line"></span><br><span class="line">docker start container_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有启动的容器(查看所有容器加 -a)</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 id 查看容器信息</span></span><br><span class="line">docker inspect id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker(或者把容器id改为容器名，也可以进入)</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id或容器名 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi 删除镜像</span><br></pre></td></tr></table></figure><p>备份镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 制作 docker 镜像  1.0 为版本号</span></span><br><span class="line">docker commit 98 ubuntu_test:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像是否创建</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存镜像到 docker 账号中</span></span><br><span class="line"><span class="comment"># 登录进 Docker 注册中心</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送镜像</span></span><br><span class="line">docker tag a25ddfec4d2a arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line">docker push arunpyasi/container-backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包镜像并查看</span></span><br><span class="line">docker save -o ubuntu_test.tar ubuntu_test:1.0</span><br></pre></td></tr></table></figure><p>恢复容器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从docker账号中拉取</span></span><br><span class="line">docker pull arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地</span></span><br><span class="line">docker load -i ~/container-backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用加载的镜像去运行Docker容器</span></span><br><span class="line">docker run -d -p 80:80 container-backup</span><br></pre></td></tr></table></figure><p><strong>docker 给已存在的容器添加或修改端口映射</strong></p><p>方式 1：</p><p>提交一个运行中的容器为镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker commit containerid foo/live</span><br></pre></td></tr></table></figure><p>运行镜像并添加端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 8000:80  foo/live /bin/bash</span><br></pre></td></tr></table></figure><p>方式 2：iptable 转发端口</p><p>将容器的 8000 端口映射到 docker 主机的 8001 端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iptables -t nat -A  DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.19:8000</span><br></pre></td></tr></table></figure><h3 id="docker-容器使用问题"><a href="#docker-容器使用问题" class="headerlink" title="docker 容器使用问题"></a>docker 容器使用问题</h3><p>Centos7 docker 容器报 docker Failed to get D-Bus connection 错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start nginx</span><br><span class="line">Failed to get D-Bus connection: Operation not permitted。</span><br></pre></td></tr></table></figure><p>原因是 dbus-daemon 没能启动</p><p>解决方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --privileged -ti --name test1  centos /usr/sbin/init</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-dcoker&quot;&gt;&lt;a href=&quot;#安装-dcoker&quot; class=&quot;headerlink&quot; title=&quot;安装 dcoker&quot;&gt;&lt;/a&gt;安装 dcoker&lt;/h2&gt;&lt;h3 id=&quot;ubuntu-16-04-LTS-安装-docker&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="https://cuilongjin.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>移动端调试</title>
    <link href="https://cuilongjin.top/2019/tool/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    <id>https://cuilongjin.top/2019/tool/移动端调试/</id>
    <published>2019-06-18T11:52:00.000Z</published>
    <updated>2019-06-18T11:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些调试工具"><a href="#一些调试工具" class="headerlink" title="一些调试工具"></a>一些调试工具</h2><ol><li><p>直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法 100% 还原手机的真实情况</p></li><li><p>chrome <a href="https://developer.chrome.com/devtools/docs/remote-debugging" target="_blank" rel="noopener">远程调试功能</a></p><p><code>chrome://inspect/#devices</code></p><p>需要连接数据线，其次是设置比较繁琐，而且还限制了 android 手机。对于 IOS 的调试则可能要使用 Safari 的另一套工具</p></li><li><p><a href="https://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener">weinre</a>：远程调试，在 PC 上生成一个像 chrome 开发工具一样的调试器，需要手动引入 js</p></li><li><p>Eruda、vConsole：在移动端页面上生成一个调试器，调试信息会挡住操作元素，查看复杂数据结构的 log 不方便，需要手动引入 js</p></li><li><p>安装各种虚拟机sdk，在电脑上进行手机调试。能比较真实模拟手机，但是安装繁琐，操作不方便，无法模拟真实的手势操作</p></li></ol><h2 id="Eruda"><a href="#Eruda" class="headerlink" title="Eruda"></a>Eruda</h2><p><a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">https://github.com/liriliri/eruda</a></p><p>Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。</p><ol><li>按钮拖拽，面板透明度大小设置。</li><li>Console面板：捕获Console日志，支持log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括%c自定义样式输出；支持按日志类型及正则表达式过滤；支持快捷命令加载underscore、jQuery库；支持JavaScript脚本执行。</li><li>Elements面板：查看标签内容及属性；查看应用在Dom上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看Dom上绑定的各类事件。</li><li>Network面板：捕获请求，查看发送数据、返回头、返回内容等信息。</li><li>Resources面板：查看并清除localStorage、sessionStorage及cookie；查看页面加载脚本及样式文件；查看页面加载图片。</li><li>Sources面板：查看页面源码；格式化html，css，js代码及json数据。</li><li>Info面板：输出URL及User Agent；支持自定义输出内容。</li><li>Snippets面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。</li></ol><p>使用</p><p>通过 CDN 使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/eruda/1.5.2/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 npm 安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install eruda --save</span><br></pre></td></tr></table></figure><p>在页面中加载脚本：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/eruda/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Js文件对于移动端来说略重（gzip后大概100kb）。建议通过url参数来控制是否加载调试器，比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> src = <span class="string">'node_modules/eruda/eruda.min.js'</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/eruda=true/</span>.test(<span class="built_in">window</span>.location) &amp;&amp; localStorage.getItem(<span class="string">'active-eruda'</span>) != <span class="string">'true'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt src="'</span> + src + <span class="string">'"&gt;&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt&gt;eruda.init();&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>初始化时可以传入配置：</p><ul><li>container：用于插件初始化的 Dom 元素，如果不设置，默认创建 div 作为容器直接置于 html 根结点下面</li><li>tool：指定要初始化哪些面板，默认加载所有</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el)</span><br><span class="line"></span><br><span class="line">eruda.init(&#123;</span><br><span class="line">  container: el,</span><br><span class="line">  tool: [<span class="string">'console'</span>, <span class="string">'elements'</span>],</span><br><span class="line">  useShadowDom: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vConsole"><a href="#vConsole" class="headerlink" title="vConsole"></a>vConsole</h2><p><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">https://github.com/Tencent/vConsole</a></p><p>一个轻量、可拓展、针对手机网页的前端开发者调试面板。</p><p>特性</p><ul><li>查看 console 日志</li><li>查看网络请求</li><li>查看页面 element 结构</li><li>查看 Cookies、localStorage 和 SessionStorage</li><li>手动执行 JS 命令行</li><li>自定义插件</li></ul><p><a href="https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md" target="_blank" rel="noopener">使用说明</a></p><p>下载 vConsole 的<a href="https://github.com/Tencent/vConsole/releases/latest" target="_blank" rel="noopener">最新版本</a>。（不要直接下载 dev 分支下的 <code>dist/vconsole.min.js</code>）</p><p>或者使用 npm 安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure><p>引入 <code>dist/vconsole.min.js</code> 到项目中：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/vconsole.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vConsole = <span class="keyword">new</span> VConsole()</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'Hello world'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="weinre"><a href="#weinre" class="headerlink" title="weinre"></a>weinre</h2><p><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html" target="_blank" rel="noopener">http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html</a></p><ol><li>Element： 查看/修改dom，查看/修改 dom CSS</li><li>Resources：查看/修改 localStorage, sessionStorage</li><li>Network：查看网络请求</li><li>Timeline：</li><li>Console：查看控制台输出</li></ol><p>不能做 JS 调试</p><p>使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install -g weinre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 weinre 服务</span></span><br><span class="line">weinre --boundHost 192.168.3.44 --httpPort 8888</span><br><span class="line"></span><br><span class="line">启动调试客户端</span><br><span class="line">在浏览器中打开 <span class="string">'http://192.168.3.44:8888'</span> 即可启动调试客户端</span><br><span class="line"></span><br><span class="line">在需要调试的页面中添加如下</span><br><span class="line">&lt;script src=<span class="string">"http://192.168.3.44:8888/target/target-script-min.js#anonymous"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="spy-debugger"><a href="#spy-debugger" class="headerlink" title="spy-debugger"></a>spy-debugger</h2><p><a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="noopener">https://github.com/wuchangming/spy-debugger</a></p><p>微信调试，各种 WebView 样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP/HTTPS，无需USB连接设备</p><p>spy-debugger 集成了<code>weinre</code>，简化了<code>weinre</code>需要给每个调试的页面添加 js 代码。原理是拦截所有 html 页面请求注入<code>weinre</code>所需要的 js 代码。让页面调试更加方便</p><p>1、页面调试＋抓包<br>2、操作简单，无需USB连接设备<br>3、<strong>支持HTTPS</strong><br>4、<code>spy-debugger</code>内部集成了<a href="http://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener"><code>weinre</code></a>、<a href="https://github.com/wuchangming/node-mitmproxy" target="_blank" rel="noopener"><code>node-mitmproxy</code></a>、<a href="https://github.com/alibaba/anyproxy" target="_blank" rel="noopener"><code>AnyProxy</code></a>。<br>5、自动忽略原生 App 发起的 https 请求，只拦截 webview 发起的 https 请求。对使用了 SSL pinning 技术的原生App 不造成任何影响。<br>6、可以配合其它代理工具一起使用(默认使用AnyProxy) <a href="https://github.com/wuchangming/spy-debugger#%E8%AE%BE%E7%BD%AE%E5%A4%96%E9%83%A8%E4%BB%A3%E7%90%86%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8anyproxy" target="_blank" rel="noopener">(设置外部代理)</a></p><p>基本使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install spy-debugger -g</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">spy-debugger</span><br><span class="line"><span class="comment">#设置手机的HTTP代理</span></span><br><span class="line">代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)</span><br><span class="line"><span class="comment"># 手机安装证书</span></span><br><span class="line">手机浏览器访问 http://s.xxx</span><br><span class="line">设置-&gt;通用-&gt;描述文件与设备管理-&gt;找到node-mitmproxy CA（安装）</span><br><span class="line">设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到node-mitmproxy CA（打开）</span><br></pre></td></tr></table></figure><p>自定义选项</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义端口</span></span><br><span class="line">spy-debugger -p 8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置页面内容为可编辑模式</span></span><br><span class="line">spy-debugger -w <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否只拦截浏览器发起的https请求(默认： true)</span></span><br><span class="line">spy-debugger -b <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许weinre监控iframe加载的页面(默认： false)</span></span><br><span class="line">spy-debugger -i <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 HTTP 缓存(默认： false)</span></span><br><span class="line">spy-debugger -c <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="m-console"><a href="#m-console" class="headerlink" title="m-console"></a>m-console</h2><p><a href="https://github.com/fwon/m-console" target="_blank" rel="noopener">https://github.com/fwon/m-console</a></p><p>手机远程调试工具，手机通过代理连接上PC后，可以在PC版浏览器打印log和错误日志</p><p>需要手动给每个调试的页面添加 js 代码</p><h2 id="DebugGap-VIDE"><a href="#DebugGap-VIDE" class="headerlink" title="DebugGap-VIDE"></a>DebugGap-VIDE</h2><p><a href="https://www.debuggap.com/debug_webview.html" target="_blank" rel="noopener">https://www.debuggap.com/debug_webview.html</a></p><h2 id="Mobile-Debug"><a href="#Mobile-Debug" class="headerlink" title="Mobile Debug"></a>Mobile Debug</h2><p><a href="https://www.mobiledebug.com/" target="_blank" rel="noopener">https://www.mobiledebug.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些调试工具&quot;&gt;&lt;a href=&quot;#一些调试工具&quot; class=&quot;headerlink&quot; title=&quot;一些调试工具&quot;&gt;&lt;/a&gt;一些调试工具&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="移动端调试" scheme="https://cuilongjin.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://cuilongjin.top/2019/other/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://cuilongjin.top/2019/other/面试题/</id>
    <published>2019-03-21T10:30:00.000Z</published>
    <updated>2019-03-26T02:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><h3 id="http-相关"><a href="#http-相关" class="headerlink" title="http 相关"></a>http 相关</h3><h3 id="HTML-css-相关"><a href="#HTML-css-相关" class="headerlink" title="HTML css 相关"></a>HTML css 相关</h3><h3 id="js-相关"><a href="#js-相关" class="headerlink" title="js 相关"></a>js 相关</h3><h3 id="jquery-相关"><a href="#jquery-相关" class="headerlink" title="jquery 相关"></a>jquery 相关</h3><h3 id="工具类相关"><a href="#工具类相关" class="headerlink" title="工具类相关"></a>工具类相关</h3><p><a href="zh-cn/_Tool/webpack配置?id=webpack-和-gulp-区别">webpack 和 gulp 区别</a><br><a href></a><br><a href></a><br><a href></a><br><a href></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器相关&quot;&gt;&lt;a href=&quot;#浏览器相关&quot; class=&quot;headerlink&quot; title=&quot;浏览器相关&quot;&gt;&lt;/a&gt;浏览器相关&lt;/h3&gt;&lt;h3 id=&quot;http-相关&quot;&gt;&lt;a href=&quot;#http-相关&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="other" scheme="https://cuilongjin.top/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="https://cuilongjin.top/2019/tool/webpack%E9%85%8D%E7%BD%AE/"/>
    <id>https://cuilongjin.top/2019/tool/webpack配置/</id>
    <published>2019-01-15T10:00:00.000Z</published>
    <updated>2019-07-09T10:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><ul><li><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack 官网</a></li><li><a href="https://webpack.docschina.org/" target="_blank" rel="noopener">webpack 中文网</a></li><li><a href="https://github.com/cuilongjin/webpack-config/" target="_blank" rel="noopener">webpack 配置文件</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webpack 是一个现代 JavaScript 应用程序的模块打包器（module bundler）</p><p>webpack 是一个模块化方案（预编译）</p><p>webpack 获取具有依赖关系的模块，并生成表示这些模块的静态资源</p><p>webpack 的两个特点：模块化、打包</p><p>四个核心概念：<strong>入口(entry)</strong>、<strong>输出(output)</strong>、<strong>加载器(loader)</strong>、<strong>插件(plugins)</strong></p><p>模块化方案：webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）<br>browserify 是与 webpack 相似的模块化打包工具</p><h3 id="webpack-起源"><a href="#webpack-起源" class="headerlink" title="webpack 起源"></a>webpack 起源</h3><ul><li>webpack 解决了现存模块打包器的两个痛点：<ul><li>Code Spliting - 代码分离</li><li>静态资源的模块化处理方案</li></ul></li></ul><h3 id="webpack-与模块"><a href="#webpack-与模块" class="headerlink" title="webpack 与模块"></a>webpack 与模块</h3><ul><li><p><a href="http://zhaoda.net/webpack-handbook/module-system.html" target="_blank" rel="noopener">前端模块系统的演进</a></p></li><li><p>在 webpack 看来：所有的<strong>静态资源都是模块</strong></p></li><li><p>webpack 模块能够识别以下等形式的模块之间的依赖：</p><ul><li><p>ES2015 <code>import</code> <code>export</code></p></li><li><p>CommonJS <code>require()</code> <code>module.exports</code></p></li><li><p>AMD <code>define</code> 和 <code>require</code></p></li><li><p>css/sass/less 文件中的 <code>@import</code></p></li><li><p>图片连接，比如：样式 <code>url(...)</code> 或 HTML <code>&lt;img src=...&gt;</code></p></li><li><p>字体等</p></li></ul></li></ul><ul><li>在webpack提供的模块化环境中<ul><li>想要加载一个JS文件，只需要 require(‘a.js’)</li><li>想要加载一个CSS文件，只需要 require(‘css/index.css’)</li><li>想要加载一个图片文件，只需要 require(‘images/a.png’)</li></ul></li></ul><ul><li><a href="http://www.jianshu.com/p/42e11515c10f#" target="_blank" rel="noopener">入门 Webpack，看这篇就够了</a></li></ul><h3 id="webpack-打包原理："><a href="#webpack-打包原理：" class="headerlink" title="webpack 打包原理："></a>webpack 打包原理：</h3><p>​        入口文件： main.js</p><p>​        webpack 从入口出发，递归分析项目中所有的依赖项（模块），使用loader来处理对应的模块最终，打包生成一个 bundle.js 文件。</p><p>​        如果配置了 webpack 中的 代码分离（Code Spliting），webpack 会根据 分离点 将这个模块生成一个独立的JS文件</p><p>​        还可以通过配置，将 CSS 、 图片、 字体 等文件，从 bundle.js 中抽离为独立的文件</p><h2 id="webpack-的基本使用"><a href="#webpack-的基本使用" class="headerlink" title="webpack 的基本使用"></a>webpack 的基本使用</h2><p>安装：<code>npm i -D webpack webpack-cli</code></p><p>webpack：是 webpack 工具的核心包</p><p>webpack-cli：提供了一些在终端中使用的命令</p><p>-D(–save-dev)：表示项目开发期间的依赖</p><p>webpack 的两种使用方式：命令行、配置文件（<code>webpack.config.js</code>）</p><h3 id="命令行使用说明"><a href="#命令行使用说明" class="headerlink" title="命令行使用说明"></a>命令行使用说明</h3><ul><li><code>package.json</code>中的<code>scripts</code>中可以存放一些 bash 命令，这些 bash 命令可以通过 <code>npm run 命令名称</code> 来执行</li><li>注意：npm 在执行 scripts 中的命令的时候，是在电脑系统后台默认开启一个 bash，将当前目录下的<code>./node_modules/.bin</code>这个文件夹临时加入了系统环境变量</li><li>使用方式：<code>npm run build</code></li><li>设置开发状态： <code>mode</code>  如果没有设置 mode 配置项，webpack 会默认提供开发环境(production)</li><li>在入口文件中可以使用 <code>import</code> 引入 js css less 等文件</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // webpack 是 webpack-cli 提供的命令</span><br><span class="line">  // src/js/main.js 为入口文件</span><br><span class="line">  // --output dist/bundle.js 为出口文件</span><br><span class="line">  // --mode development 生产环境</span><br><span class="line">  "build": "webpack"</span><br><span class="line">  "build1": "webpack src/js/main.js --output dist/bundle.js --mode development"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件方式（推荐）"><a href="#配置文件方式（推荐）" class="headerlink" title="配置文件方式（推荐）"></a>配置文件方式（推荐）</h3><p>项目<code>根目录</code>下创建一个 <code>webpack.config.js</code>文件，运行 <code>webpack</code> 命令时的默认配置文件</p><p>指定其他文件：<code>--config  webpack.XX.js</code></p><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;build&quot;: &quot;webpack&quot;</code></p><p>执行命令 : <code>npm run build</code></p><p>示例代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置</span></span><br><span class="line"><span class="comment">// 注意 : 不要再这个文件中使用ES6的的模块化 import语法</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  entry: path.join(__dirname, <span class="string">'./src/js/main.js'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出口</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 出口目录</span></span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发模式</span></span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>安装：<code>npm i -D webpack-dev-server</code></p><p>作用：配合 webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率</p><p>注意：无法直接在终端中执行 <code>webpack-dev-server</code>，需要在 <code>package.json</code> 配置 <code>scripts</code> 后使用</p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>webpack-dev-server</code>将打包好的文件存储在内存中，提高编译和加载速度，效率更高（不会生成dist目录）</li><li>在内存中出口目录为项目根目录（命令行中的提示：<code>webpack output is served from /</code>）<ul><li>在<code>index.html</code>页面中引入文件不需要加<code>dist</code></li></ul></li></ul><h3 id="CLI-配置"><a href="#CLI-配置" class="headerlink" title="CLI 配置"></a>CLI 配置</h3><ul><li><code>--contentBase</code> ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的 index.html）<ul><li><code>--contentBase ./src</code>：当前目录下的 src 文件夹</li></ul></li><li><code>--open true</code> ：自动打开浏览器</li><li><code>--port 3000</code> ：指定端口号</li><li><code>--hot</code> ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载</li><li><code>--progress</code>：显示进度条</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --contentBase src --open --port 8888 --hot"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;dev&quot;: &quot;webpack-dev-server --hot&quot;</code></p><p>执行命令 : <code>npm run dev</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --hot 热更新写在命令行里，不然的话还要配其他插件麻烦</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'src'</span>),</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// hot: true,</span></span><br><span class="line">    </span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123; <span class="comment">// api 表示当前项目请求的 key</span></span><br><span class="line">        target: <span class="string">'http://www.baidu.com'</span>, <span class="comment">// 代理服务器路径</span></span><br><span class="line">        pathRewrite: &#123; <span class="string">'^/api'</span>: <span class="string">'/api'</span> &#125;, <span class="comment">// 重写路径</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求 localhost:8080/api/.. 会被代理到 http://www.baidu.com/api/..</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// plugins: [</span></span><br><span class="line">  <span class="comment">//   new webpack.HotModuleReplacementPlugin()</span></span><br><span class="line">  <span class="comment">// ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="html-webpack-plugin-插件"><a href="#html-webpack-plugin-插件" class="headerlink" title="html-webpack-plugin 插件"></a>html-webpack-plugin 插件</h2><ul><li>安装：<code>npm i -D html-webpack-plugin</code></li><li>作用：根据模板，在内存中自动生成 html 页面，并自动引入<code>bundle.js</code>、<code>css</code>等文件</li></ul><p>配置文件配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 html-webpack-plugin 插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 配置插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin 配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 模板页面路径</span></span><br><span class="line">      template: path.join(__dirname, <span class="string">'src/index.html'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包非js文件"><a href="#打包非js文件" class="headerlink" title="打包非js文件"></a>打包非js文件</h2><p>webpack 默认只能处理 js 文件，非 js(css、less、图片、字体等)处理不了，借助 loader 加载器</p><h3 id="处理-css-文件"><a href="#处理-css-文件" class="headerlink" title="处理 css 文件"></a>处理 css 文件</h3><p>在 <code>main.js</code>中引入css文件 <code>import &#39;../css/main.css&#39;</code></p><p>安装 : <code>npm i -D style-loader css-loader</code></p><p>在 <code>webpack.config.js</code> 中，添加个新的配置项 <code>module</code></p><p>在 <code>module</code> 中添加 <code>loader</code> 来处理 <code>css</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理 css</span></span><br><span class="line">      <span class="comment">// 注意点 use 执行loader 顺序 从右往左</span></span><br><span class="line">      <span class="comment">// css-loader: 读取css文件内容，将其转化为一个模块</span></span><br><span class="line">      <span class="comment">// style-loader: 拿到模块, 创建一个style标签，插入页面中</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-less-文件"><a href="#处理-less-文件" class="headerlink" title="处理 less 文件"></a>处理 less 文件</h3><p>在 <code>main.js</code>中引入 less 文件 <code>import &#39;../css/main.less&#39;</code></p><p>安装 : <code>npm i -D less-loader less style-loader css-loader</code></p><p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理 <code>less</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">//处理 css</span></span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h3><p>安装 : <code>npm i -D url-loader file-loader</code></p><p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理图片</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">//  图片大小 &lt;= 10000 =&gt; 转化为base64</span></span><br><span class="line">              <span class="comment">//  图片大小 &gt;= 10000 =&gt; 不会转base64 内部调用 file-loader 加载图片</span></span><br><span class="line">              limit: <span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url-loader</strong> 默认会将图片转化为 base64 编码格式，目的：提高性能</p><p><strong>file-loader</strong> 在处理图片时，会对文件进行重命名</p><p>base64 编码格式的图片说明：</p><ul><li>精灵图：将一些小图片合并为一张图片，减少请求次数，提高性能</li><li>字体图标：直接将一些小的图片,合并到字体文件中，并且不会失真</li><li>base64：是一种编码格式,能够将图片、文字等常见的文件，转化为 base64 格式，这种字符串格式浏览器能够识别并且读取显示到页面中</li><li>base64 是一个字符串，也可以直接被内嵌到页面中，或者 css 中</li><li>注意：大图片不适合用 base64 处理，只有小的图标才适合 base64 处理</li></ul><h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><p>在 <strong>main.js</strong> 中引入 css 文件 <code>import &#39;../css/iconfont/iconfont.css&#39;</code></p><p>在 webpack.config.js 中配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理字体图标</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(svg|woff|woff2|ttf|eot)$/</span>,</span><br><span class="line">        use: <span class="string">'url-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-ES6-语法"><a href="#处理-ES6-语法" class="headerlink" title="处理 ES6 语法"></a>处理 ES6 语法</h3><ol><li>现在的项目都是使用 ES6 开发的，但是这些新的 ES6 语法，并不是所有的浏览器都支持，所以就需要有一个工具，帮我们转成 es5 语法，这个就是：babel</li><li><a href="https://babeljs.io/" target="_blank" rel="noopener">babel</a></li><li>Babel is a JavaScript compiler. ==&gt; babel 是一个 JavaScript 编译器</li><li>webpack 只能处理 import / export 这个 es6 模块化语法，而其他的 js 新语法，应该使用 babel 来处理</li></ol><p>babel 的使用 :</p><ul><li>安装： <code>npm i -D babel-core babel-loader@7</code><ul><li>babel-core 是 babel 的核心包</li><li>babel-loader 加载 js 文件，并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js</li></ul></li></ul><ul><li>安装：<code>npm i -D babel-preset-env babel-preset-stage-2</code><ul><li>babel-preset-env：表示能够解析 es2015、es2016、es2017、es2018 这些标准的语法</li><li>babel-preset-stage-2：用来解析还没有被采纳为标准的语法</li><li><code>babel-polyfill与babel-plugin-transform-runtime</code> 也是做兼容处理的,以前都是用这个，兼容更早的</li></ul></li></ul><ul><li>配置 : 在 webpack.config.js 中添加一个 loader</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理 ES6 语法</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">        <span class="comment">// 设置忽略 node-modules 文件夹</span></span><br><span class="line">        exclude: <span class="regexp">/node-modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在项目根目录中创建 babel 的配置文件，叫：<code>.babelrc</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;,</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  -----------</span><br><span class="line">  // 暂时不用</span><br><span class="line">  // 如果未来某一天真的用到了polify</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;, &#123;</span><br><span class="line">      &quot;helpers&quot;: false,</span><br><span class="line">      &quot;polyfill&quot;: true,</span><br><span class="line">      &quot;regenerator&quot;: true,</span><br><span class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目打包上线"><a href="#项目打包上线" class="headerlink" title="项目打包上线"></a>项目打包上线</h2><p>执行 : <code>npm run build</code> 对项目进行打包，生成dist文件</p><p>模拟本地服务器 : 安装 : <code>npm i -g http-server</code></p><p>把dist文件里的内容放到服务器里即可，直接运行<code>http-server</code></p><h2 id="webpack-和-gulp-区别"><a href="#webpack-和-gulp-区别" class="headerlink" title="webpack 和 gulp 区别"></a>webpack 和 gulp 区别</h2><ol><li>Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给 gulp 配置不通的 task（通过Gulp 中的 gulp.task() 方法配置，比如启动 server、sass/less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程</li><li>Webpack 也称之为模块打包机 ，由此也可以看出 Webpack 更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块，最初 Webpack 本身就是为前端 JS 代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack 是通过 loader（加载器）和 plugins（插件）对资源进行处理的</li><li>gulp是构建工具，Webpack是 js 模块化的解决方案</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Webpack&quot;&gt;&lt;a href=&quot;#Webpack&quot; class=&quot;headerlink&quot; title=&quot;Webpack&quot;&gt;&lt;/a&gt;Webpack&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Webpack" scheme="https://cuilongjin.top/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://cuilongjin.top/2019/javascript/promise/"/>
    <id>https://cuilongjin.top/2019/javascript/promise/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-23T09:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul><li>Promise 是<code>异步编程</code>的一种解决方案，它允许你以一种同步的方式编写异步代码</li><li><code>promise</code>：承诺、保证</li><li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES6 - Promise</a></li><li>JS 是通过回调函数来实现异步编程的，当异步操作多了以后，就会产生回调嵌套回调的问题，这就是<code>回调地狱</code></li><li>Promise 方式：将异步操作以同步操作的方式表达出来，避免了层层嵌套的回调函数</li></ul><h2 id="封装一个-Promise"><a href="#封装一个-Promise" class="headerlink" title="封装一个 Promise"></a>封装一个 Promise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按序读取文件：a -&gt; b -&gt; c</span></span><br><span class="line"><span class="comment">// 按顺序读取 a b c 文件</span></span><br><span class="line"><span class="comment">// 以前</span></span><br><span class="line"><span class="comment">// 读取 a 文件</span></span><br><span class="line">fs.readFile(<span class="string">'./a'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 b 文件</span></span><br><span class="line">  fs.readFile(<span class="string">'./b'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 c 文件</span></span><br><span class="line">    fs.readFile(<span class="string">'./a'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise</span></span><br><span class="line"><span class="comment">// 封装</span></span><br><span class="line"><span class="comment">// Promise 是一个构造函数</span></span><br><span class="line"><span class="comment">// 通过 new 创建 Promise 的实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化 Promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve 表示成功，异步操作成功调用</span></span><br><span class="line">    <span class="comment">// reject  表示失败，异步操作失败调用</span></span><br><span class="line">    fs.readFile(path, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 读取错误，调用 reject()</span></span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取成功 调用 resolve</span></span><br><span class="line">      resolve(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 Promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">readFile(<span class="string">'a'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'a'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="promise-的三个状态"><a href="#promise-的三个状态" class="headerlink" title="promise 的三个状态"></a>promise 的三个状态</h2><ul><li><p>pending : 等待  (等待成功或者失败去调用)</p></li><li><p>resolved : 成功调用</p></li><li><p>rejected : 失败调用</p></li></ul><h2 id="then-和-catch"><a href="#then-和-catch" class="headerlink" title="then 和 catch"></a>then 和 catch</h2><ul><li>说明：获取异步操作的结果</li><li><code>then()</code> ：用于获取异步操作成功时的结果 -&gt; <em>resolve</em></li><li><code>catch()</code>：用于获取异步操作失败时的结果 -&gt; <em>reject</em></li><li>说明：<code>then()</code>方法可以有多个，按照先后顺序执行，通过回调函数返回值传递数据给下一个 then</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p</span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件a的内容为：'</span>, value)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 失败（比如：文件路径错误）</span></span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件读取失败：'</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------- 或者 -----------</span></span><br><span class="line">p.then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="all-和-race"><a href="#all-和-race" class="headerlink" title="all 和 race"></a>all 和 race</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有请求完成，才会执行后续代码</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  axios(<span class="string">'/a'</span>),</span><br><span class="line">  axios(<span class="string">'/b'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// res 是 all() 方法中所有异步操作的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有一个请求完成，就会继续执行后续代码</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  axios(<span class="string">'/a'</span>),</span><br><span class="line">  axios(<span class="string">'/b'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// res 是 race() 方法中先完成的异步操作的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><ul><li>异步编程终极方案</li></ul><ul><li>async / await 用同步编写代码的方式 处理异步操作的一个方案</li><li>async：修饰 (修饰一个内部有异步操作的函数)    格式 :  async + 函数 (里面有异步操作的函数)</li><li>await : 等待 (等上一个异步操作完成啊 , 修饰 一个结果是promise的)异步操作    格式 : await + 异步操作(结果promise对象)</li><li>async 和 await 是成对出现的，await 只能在 async 函数中使用</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 实例化 promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 操作错误 调用 =&gt;  reject  =&gt; catch</span></span><br><span class="line">        <span class="keyword">return</span> reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 操作成功  调用 =&gt; resolve =&gt; then</span></span><br><span class="line">      resolve(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 2. 返回 promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：使用 (async/await)</span></span><br><span class="line"><span class="comment">// async + 函数 (里面有异步操作的函数)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await + 异步操作(结果promise对象)</span></span><br><span class="line">  <span class="comment">// 读取a文件</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFile(<span class="string">'./data/a1.txt'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 b 文件</span></span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFile(<span class="string">'./data/b.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 c 文件</span></span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> readFile(<span class="string">'./data/c.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(b)</span><br><span class="line">    &#125;, a)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> sleep(<span class="number">1000</span>, <span class="string">'a'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res1)</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> sleep(<span class="number">5000</span>, <span class="string">'b'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> sleep(<span class="number">3000</span>, <span class="string">'c'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn()</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>, <span class="string">'a'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> sleep(<span class="number">5000</span>, <span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> sleep(<span class="number">3000</span>, <span class="string">'c'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.all([sleep(<span class="number">1000</span>, <span class="string">'a'</span>), sleep(<span class="number">5000</span>, <span class="string">'b'</span>)])</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.race([sleep(<span class="number">1000</span>, <span class="string">'a'</span>), sleep(<span class="number">5000</span>, <span class="string">'b'</span>)])</span><br><span class="line">p2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Promise 是&lt;code&gt;异步编程&lt;/code&gt;的一种解决方案，它允许你以一种同步的
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
      <category term="promise" scheme="https://cuilongjin.top/tags/promise/"/>
    
  </entry>
  
</feed>
