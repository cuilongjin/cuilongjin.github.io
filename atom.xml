<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>稻草人</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuilongjin.top/"/>
  <updated>2019-07-29T13:19:52.830Z</updated>
  <id>https://cuilongjin.top/</id>
  
  <author>
    <name>稻草人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动端兼容性问题总结</title>
    <link href="https://cuilongjin.top/2019/%E7%A7%BB%E5%8A%A8web/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://cuilongjin.top/2019/移动web/移动端兼容性问题/</id>
    <published>2019-07-22T16:00:00.000Z</published>
    <updated>2019-07-29T13:19:52.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ios-移动端页面对点击事件有-300ms-延时"><a href="#1-ios-移动端页面对点击事件有-300ms-延时" class="headerlink" title="1. ios 移动端页面对点击事件有 300ms 延时"></a>1. ios 移动端页面对点击事件有 300ms 延时</h3><p>使用 fastclick 库 <a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a></p><p>使用 FastClick 的时候，在需要使用的层上，实例化它。我们使用 document.body 是因为希望所有的按钮和链接都获得快速点击</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> FastClick <span class="keyword">from</span> <span class="string">'fastclick'</span></span><br><span class="line">FastClick.attach(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><h3 id="2-ios-滚动卡顿"><a href="#2-ios-滚动卡顿" class="headerlink" title="2. ios 滚动卡顿"></a>2. ios 滚动卡顿</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  -webkit-overflow-scrolling: touch; // 当手指从触摸屏上移开，会保持一段时间的滚动</span><br><span class="line">  // -webkit-overflow-scrolling: auto; // 当手指从触摸屏上移开，滚动会立即停止</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ios-1px-border-变宽"><a href="#3-ios-1px-border-变宽" class="headerlink" title="3. ios 1px border 变宽"></a>3. ios 1px border 变宽</h3><p>以 dpr=2 为例：<br>你拿到一张标准的基于 iphone6 的设计稿(750px)<br>你看到它设计的一个 border 宽度是 1px<br>你兴致勃勃地写下了 border: 1px solid #000;<br>然而 iphone6 实际渲染像素是 375px，那么设计需要 border 的其实是 border: 0.5px solid #000;<br>然后你的是 1px<br>不是 1px 变粗了，只是实际只是需要 0.5px 而已</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code> 意思是将物理设备的宽度设置给当前浏览器。</p><h3 id="4-webapp-软键盘弹起时问题"><a href="#4-webapp-软键盘弹起时问题" class="headerlink" title="4. webapp 软键盘弹起时问题"></a>4. webapp 软键盘弹起时问题</h3><p>页面放大:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>输入框被遮挡，看不见输入的内容: <code>element.scrollIntoView()</code></p><p>页面自动上移，但收回软键盘时页面少了一截:</p><p>fixed 定位效果失效: <code>ios 弹出软键盘的时候, webview 的高度没有变化导致超出屏幕范围</code></p><h3 id="5-手机端页面文件上传兼容性问题"><a href="#5-手机端页面文件上传兼容性问题" class="headerlink" title="5. 手机端页面文件上传兼容性问题"></a>5. 手机端页面文件上传兼容性问题</h3><h3 id="6-移动和-PC-端中的-hover-处理-移动端点击时会有-pc-端-hover-效果"><a href="#6-移动和-PC-端中的-hover-处理-移动端点击时会有-pc-端-hover-效果" class="headerlink" title="6. 移动和 PC 端中的 hover 处理 移动端点击时会有 pc 端 hover 效果"></a>6. 移动和 PC 端中的 hover 处理 移动端点击时会有 pc 端 hover 效果</h3><h3 id="7-webapp-禁用长按复制"><a href="#7-webapp-禁用长按复制" class="headerlink" title="7. webapp 禁用长按复制"></a>7. webapp 禁用长按复制</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">user-select</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><h3 id="8-ios-a-链接-input-type-”file”-等在点击时会出现灰色（touch-高亮）"><a href="#8-ios-a-链接-input-type-”file”-等在点击时会出现灰色（touch-高亮）" class="headerlink" title="8. ios a 链接 input type=”file” 等在点击时会出现灰色（touch 高亮）"></a>8. ios a 链接 input type=”file” 等在点击时会出现灰色（touch 高亮）</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-tap-highlight-color</span>: <span class="selector-tag">transparent</span>;</span><br></pre></td></tr></table></figure><h3 id="9-禁用浏览器自动调整字体大小"><a href="#9-禁用浏览器自动调整字体大小" class="headerlink" title="9. 禁用浏览器自动调整字体大小"></a>9. 禁用浏览器自动调整字体大小</h3><p>移动端浏览器切换橫向模式时会调整字体大小（字体变大），解决方式:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  -webkit-text-size-adjust: none; // 或 100%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>谷歌浏览器已不支持这个属性了，不能通过该方式实现小于 12px 的字体，可使用缩放（transform:scale(0.8)）来实现小于 12px 的字体</p></blockquote><h3 id="10-appearance-属性"><a href="#10-appearance-属性" class="headerlink" title="10. appearance 属性"></a>10. appearance 属性</h3><p>normal|icon|window|button|menu|field;<br>所有主流浏览器都不支持 appearance 属性</p><p><code>-webkit-appearance: none;</code> 去除默认样式，使 ios 端和安卓端显示效果一样，但有一个问题，input 的 checkbox 和 radio 类型在安卓端可能无法正常显示</p><h3 id="11-webkit-touch-callout-none"><a href="#11-webkit-touch-callout-none" class="headerlink" title="11. -webkit-touch-callout: none;"></a>11. -webkit-touch-callout: none;</h3><p>在 iOS 上，当你触摸并按住触摸的目标，比如一个链接，浏览器将显示链接有关的系统默认菜单。该属性可以禁用系统默认菜单。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-ios-移动端页面对点击事件有-300ms-延时&quot;&gt;&lt;a href=&quot;#1-ios-移动端页面对点击事件有-300ms-延时&quot; class=&quot;headerlink&quot; title=&quot;1. ios 移动端页面对点击事件有 300ms 延时&quot;&gt;&lt;/a&gt;1. ios 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>axios 取消请求</title>
    <link href="https://cuilongjin.top/2019/javascript/axios%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/"/>
    <id>https://cuilongjin.top/2019/javascript/axios取消请求/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>原生 js abort() 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = $.ajax(&#123;&#125;)</span><br><span class="line">A.abort()</span><br></pre></td></tr></table></figure><p>Axios 提供了一个 CancelToken 的函数，这是一个构造函数，该函数的作用就是用来取消接口请求的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  getMsg () &#123;</span><br><span class="line">    <span class="keyword">let</span> CancelToken = axios.CancelToken</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    axios.get(<span class="string">''</span>, &#123;</span><br><span class="line">      cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        that.cancel = c</span><br><span class="line">        <span class="built_in">console</span>.log(c)</span><br><span class="line">        <span class="comment">// 这个参数 c 就是 CancelToken 构造函数里面自带的取消请求的函数，这里把该函数当参数用</span></span><br><span class="line">      &#125;)</span><br><span class="line">      params: &#123;&#125;</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.items = res.data</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelGetMsg () &#123;</span><br><span class="line">    <span class="keyword">this</span>.cancel()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原生 js abort() 方法&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; A 
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>高阶函数与柯里化</title>
    <link href="https://cuilongjin.top/2019/javascript/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://cuilongjin.top/2019/javascript/高阶函数与柯里化/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数定义：将函数作为参数或者返回值是函数的函数<br>常见的 sort、reduce 等函数就是高阶函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = add(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6写法</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术</p><p>柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要 n 个参数的函数变成只需要剩下的（n - 1 个）参数就可以调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形如</span></span><br><span class="line">a =&gt; <span class="function"><span class="params">b</span> =&gt;</span> c =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br><span class="line"><span class="keyword">let</span> add1 = add(<span class="number">1</span>) <span class="comment">// a = 1; b =&gt; a + b</span></span><br><span class="line">add1(<span class="number">2</span>) <span class="comment">// 1 + 2 = 3</span></span><br></pre></td></tr></table></figure><p>add1 函数等价于有了 a 这个闭包变量的 b = a + b</p><p>add 函数按照 wiki 的定义可以理解成只柯里化了一次，n 个连续箭头组成的函数实际上就是柯里化了 n - 1 次<br>前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值</p><p>所以多个连续箭头函数就是多次柯里化的 es6 写法</p><p><strong>应用：</strong></p><p>函数懒执行<br>函数式编程</p><p><strong>柯里化函数使用场景：</strong></p><p>减少重复传递不变的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price, discount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * discount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次都要重复传入 discount 参数，可以将这个函数柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price, discount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">price</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price * discount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tenPercentDiscount = discount(<span class="number">0.9</span>) <span class="comment">// 9折</span></span><br><span class="line"><span class="keyword">const</span> twentyPercentDiscount = discount(<span class="number">0.8</span>) <span class="comment">// 8折</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在每次计算价格只需要：</span></span><br><span class="line">tenPercentDiscount(<span class="number">500</span>) <span class="comment">// 500 * 0.9</span></span><br><span class="line">twentyPercentDiscount(<span class="number">1000</span>) <span class="comment">// 1000 * 0.8</span></span><br></pre></td></tr></table></figure><h2 id="柯里化实现"><a href="#柯里化实现" class="headerlink" title="柯里化实现"></a>柯里化实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="keyword">this</span>, args.concat(args2))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum)</span><br><span class="line"><span class="built_in">console</span>.log(curriedSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curriedSum(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高阶函数&quot;&gt;&lt;a href=&quot;#高阶函数&quot; class=&quot;headerlink&quot; title=&quot;高阶函数&quot;&gt;&lt;/a&gt;高阶函数&lt;/h2&gt;&lt;p&gt;高阶函数定义：将函数作为参数或者返回值是函数的函数&lt;br&gt;常见的 sort、reduce 等函数就是高阶函数&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3 多页模式</title>
    <link href="https://cuilongjin.top/2019/vue/%E5%A4%9A%E9%A1%B5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://cuilongjin.top/2019/vue/多页模式/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2019-07-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cli.vuejs.org/zh/config/#pages" target="_blank" rel="noopener">vue-cli 多页面的配置官方介绍</a></p><p><code>vue.config.js</code> 配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      <span class="comment">// page 的入口</span></span><br><span class="line">      entry: <span class="string">'src/pages/index/main.js'</span>,</span><br><span class="line">      <span class="comment">// 模板来源</span></span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      <span class="comment">// 在 dist/index.html 的输出</span></span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">      title: <span class="string">'Index Page'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    pageA: &#123;</span><br><span class="line">      entry: <span class="string">'src/pages/pageA/main.js'</span>,</span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'pageA.html'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当使用只有入口的字符串格式时, 模板会被推导为 `public/pageB.html`</span></span><br><span class="line">    <span class="comment">// 并且如果找不到的话，就回退到 `public/index.html`, 输出文件名会被推导为 `pageB.html`</span></span><br><span class="line">    pageB: <span class="string">'src/pages/pageB/main.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个页面一套 SPA，入口文件、路由、资源的路径都要根据实际情况进行设置</p><p>页面内可以继续使用<code>SPA</code>模式的<code>&lt;router-link&gt;</code>，但是页面之间的跳转需要使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/pageA.html"</span>&gt;</span>前往 pageA 页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cli.vuejs.org/zh/config/#pages&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cli 多页面的配置官方介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vue.config.js&lt;/code&gt; 
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>keep-alive 实现页面缓存</title>
    <link href="https://cuilongjin.top/2019/vue/keep-alive/"/>
    <id>https://cuilongjin.top/2019/vue/keep-alive/</id>
    <published>2019-07-14T16:00:00.000Z</published>
    <updated>2019-07-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>缓存</p><ul><li><p>pageAList -&gt; pageADetail -&gt; pageAList，缓存 pageAList，同时如果 pageAList 发生变化需要更新</p></li><li><p>其他页面 -&gt; pageAList，pageAList 不缓存</p></li></ul><p>router 配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/pageAList'</span>,</span><br><span class="line">        name: <span class="string">'pageAList'</span>,</span><br><span class="line">        component: pageAList</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/pageADetail'</span>,</span><br><span class="line">        name: <span class="string">'pageADetail'</span>,</span><br><span class="line">        component: pageADetail</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>vuex 配置 store.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    includeComponents: [] <span class="comment">// 需要缓存的组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    addIncludeComponent(state, includeComponent) &#123;</span><br><span class="line">      <span class="comment">// includeComponent 可能是组件 name 字符串或者数组</span></span><br><span class="line">      <span class="keyword">let</span> includeComponents = state.includeComponents</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(includeComponent)) &#123;</span><br><span class="line">        state.includeComponents = [...new <span class="built_in">Set</span>([...includeComponents, ...includeComponent])]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.includeComponents = [...new <span class="built_in">Set</span>([...includeComponents, includeComponent])]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    removeIncludeComponent(state, includeComponent) &#123;</span><br><span class="line">      <span class="keyword">let</span> includeComponents = state.includeComponents</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(includeComponent)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; includeComponent.length; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> index = includeComponents.findIndex(<span class="function"><span class="params">v</span> =&gt;</span> v === includeComponent[i])</span><br><span class="line">          <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            includeComponents.splice(index, <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = includeComponents.length; i &lt; len; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (includeComponents[i] === includeComponent) &#123;</span><br><span class="line">            includeComponents.splice(i, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state.includeComponents = includeComponents</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>home.vue</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- keep-alive 包裹 router-view --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"includeComponents"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    computed: &#123;</span></span><br><span class="line"><span class="undefined">      includeComponents() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.includeComponents</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>pageAList.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'pageAList'</span>,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/pageADetail/</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(to.name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'addIncludeComponent'</span>, <span class="string">'pageADetail'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'removeIncludeComponent'</span>, <span class="string">'pageADetail'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pageADetail.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'pageADetail'</span>,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/pageA/</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(to.name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'addIncludeComponent'</span>, <span class="string">'pageAList'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'removeIncludeComponent'</span>, <span class="string">'pageAList'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>进入 pageAList，离开当前组件的时候有两种情况：<ul><li>跳转进去 pageADetail，在 pageAList 的 beforeRouteLeave 钩子里面缓存 pageAList</li><li>跳转到非 pageADetail 的页面，在 pageAList 的 beforeRouteLeave 钩子里面清除 pageAList 的缓存</li></ul></li></ul><ul><li>从 pageADetail 离开的时候，也有两种情况：<ul><li>回到 pageAList，在 pageADetail 的 beforeRouteLeave 钩子里面缓存 pageAList，所以从 pageAList-pageADetail-pageAList 的时候，pageAList 可以被缓存，还是之前的页码状态</li><li>进入其他路由，在 pageADetail 的 beforeRouteLeave 钩子里面清除 pageAList 的缓存</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pageAList -&amp;gt; pageADetail -&amp;gt; pageAList，缓存 pageAList，同时如果 pageAList 发生变化需要更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他页面 -&amp;gt; pageAList
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3.0 内存溢出 JavaScript heap out of memory</title>
    <link href="https://cuilongjin.top/2019/vue/vue-cli3%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3/"/>
    <id>https://cuilongjin.top/2019/vue/vue-cli3 内存溢出解决/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-17T15:37:34.293Z</updated>
    
    <content type="html"><![CDATA[<p>错误内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;--- JS stacktrace ---&gt;</span><br><span class="line"></span><br><span class="line">==== JS stack trace =========================================</span><br><span class="line"></span><br><span class="line">    0: ExitFrame [pc: 000002861B95C5C1]</span><br><span class="line">Security context: 0x002fdeb1e6e9 &lt;JSObject&gt;</span><br><span class="line">    1: DoJoin(aka DoJoin) [0000002FDEB05E91] [native array.js:~87] [pc=000002861C436409](this=0x0037aae826f1 &lt;undefined&gt;,l=0x01420be65761 &lt;JSArray[2]&gt;,m=2,A=0x0037aae828c9 &lt;true&gt;,w=0x0375f51b46d9 &lt;String[1]\: \n&gt;,v=0x0037aae829a1 &lt;false&gt;)</span><br><span class="line">    2: Join(aka Join) [0000002FDEB05EE1] [native array.js:~112] [pc=000002861BC4F978](this=0x0037aae826f1 &lt;undefined&gt;,l...</span><br><span class="line"></span><br><span class="line">FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory</span><br></pre></td></tr></table></figure><p>nodejs 内存限制，通过添加启动参数可以解决</p><p>vue-cli2：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev 和 npm run build 直接在前面加上--max_old_space_size=4096</span><br></pre></td></tr></table></figure><p>vue-cli3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx --max_old_space_size=4096 vue-cli-service serve</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i increase-memory-limit cross-env</span><br><span class="line">scripts 中添加指令 &quot;fix-memory-limit&quot;: &quot;cross-env LIMIT=4096 increase-memory-limit&quot;</span><br><span class="line">npm run fix-memory-limit</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>最后将 lintOnsave: false 解决了</p><p><a href="https://github.com/vuejs/vue-cli/issues/1453" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli/issues/1453</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;错误内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;--- JS stacktrace ---&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli 常用配置</title>
    <link href="https://cuilongjin.top/2019/vue/vue-cli%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://cuilongjin.top/2019/vue/vue-cli常用配置/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h2 id="vue-cli-webpack-打包后-index-html-引入文件没有引号"><a href="#vue-cli-webpack-打包后-index-html-引入文件没有引号" class="headerlink" title="vue-cli webpack 打包后 index.html 引入文件没有引号"></a>vue-cli webpack 打包后 index.html 引入文件没有引号</h2></li></ul><p>解决办法：</p><p>vue-cli2：</p><p>在 webpack.prod.conf.js 中修改：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeAttributeQuotes: <span class="literal">false</span> <span class="comment">// 如果该方法没有用那就把整个 minify 去掉</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>vue-cli3:</p><p>在 vue.config.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">    args[<span class="number">0</span>].minify = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="svue-cli-打包时删除-console、deugger、注释"><a href="#svue-cli-打包时删除-console、deugger、注释" class="headerlink" title="svue-cli 打包时删除 console、deugger、注释"></a>svue-cli 打包时删除 console、deugger、注释</h2></li></ul><p>vue-cli2：</p><p>在 webpack.prod.conf.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">    uglifyOptions: &#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        drop_debugger: <span class="literal">true</span>,</span><br><span class="line">        drop_console: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        comment: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>vue-cli3：</p><p>安装 uglifyjs-webpack-plugin</p><p>在 vue.config.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          drop_debugger: <span class="literal">true</span>,</span><br><span class="line">          drop_console: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">          comment: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      parallel: <span class="literal">true</span>,</span><br><span class="line">      cache: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;vue-cli-webpack-打包后-index-html-引入文件没有引号&quot;&gt;&lt;a href=&quot;#vue-cli-webpack-打包后-index-html-引入文件没有引号&quot; class=&quot;headerlink&quot; title=&quot;vue-c
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>js 中编码（encode）和解码（decode）的三种方法</title>
    <link href="https://cuilongjin.top/2019/other/js%20%E4%B8%AD%E7%BC%96%E7%A0%81%EF%BC%88encode%EF%BC%89%E5%92%8C%E8%A7%A3%E7%A0%81%EF%BC%88decode%EF%BC%89%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://cuilongjin.top/2019/other/js 中编码（encode）和解码（decode）的三种方法/</id>
    <published>2019-07-09T08:42:00.000Z</published>
    <updated>2019-07-09T09:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js-中编码（encode）和解码（decode）的三种方法"><a href="#js-中编码（encode）和解码（decode）的三种方法" class="headerlink" title="js 中编码（encode）和解码（decode）的三种方法"></a>js 中编码（encode）和解码（decode）的三种方法</h3><p>js 对文字进行编码涉及 3 个函数：escape、encodeURI、encodeURIComponent，相应 3 个解码函数：unescape、decodeURI、decodeURIComponent</p><ul><li>escape()函数</li></ul><p>定义和用法：escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串<br>语法：escape(string)<br>参数：string 必需，要被转义或编码的字符串。<br>返回值：已编码的 string 的副本。其中某些字符被替换成了十六进制的转义序列<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： <code>-_.!~*&#39;()</code> ，其他所有的字符都会被转义序列替换</p><ul><li>encodeURI()函数</li></ul><p>定义和用法：encodeURI() 函数可把字符串作为 URI 进行编码<br>语法：encodeURI(URIstring)<br>参数：URIstring 必需，一个字符串，含有 URI 或其他要编码的文本。<br>返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：<code>-_.!~*&#39;()</code> ，该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：<code>;/?:@&amp;=+$,#</code></p><ul><li>encodeURIComponent()</li></ul><p>定义和用法：encodeURIComponent() 函数可把字符串作为 URI 组件进行编码<br>语法：encodeURIComponent(URIstring)<br>参数：URIstring 必需，一个字符串，含有 URI 组件或其他要编码的文本<br>返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：<code>-_.!~*&#39;()</code>，其他字符（比如 ：<code>;/?:@&amp;=+$,#</code> 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的</p><p>说明：</p><ul><li><p>encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号</p></li><li><p>传递参数时需要使用 encodeURIComponent，这样组合的 url 才不会被#等特殊字符截断</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js-中编码（encode）和解码（decode）的三种方法&quot;&gt;&lt;a href=&quot;#js-中编码（encode）和解码（decode）的三种方法&quot; class=&quot;headerlink&quot; title=&quot;js 中编码（encode）和解码（decode）的三种方法&quot;&gt;
      
    
    </summary>
    
      <category term="other" scheme="https://cuilongjin.top/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端(Safari)浏览网页时对数字不启用电话功能</title>
    <link href="https://cuilongjin.top/2019/%E7%A7%BB%E5%8A%A8web/%E7%A7%BB%E5%8A%A8%E7%AB%AF(Safari)%E6%B5%8F%E8%A7%88%E7%BD%91%E9%A1%B5%E6%97%B6%E5%AF%B9%E6%95%B0%E5%AD%97%E4%B8%8D%E5%90%AF%E7%94%A8%E7%94%B5%E8%AF%9D%E5%8A%9F%E8%83%BD/"/>
    <id>https://cuilongjin.top/2019/移动web/移动端(Safari)浏览网页时对数字不启用电话功能/</id>
    <published>2019-07-09T06:51:00.000Z</published>
    <updated>2019-07-09T13:14:28.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端-Safari-浏览网页时对数字不启用电话功能"><a href="#移动端-Safari-浏览网页时对数字不启用电话功能" class="headerlink" title="移动端(Safari)浏览网页时对数字不启用电话功能"></a>移动端(Safari)浏览网页时对数字不启用电话功能</h2><ul><li>标准的电话号码格式是：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"tel:+86-123-456-7890"</span>&gt;</span>1234567890<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>有时候不是电话号码的数字会被浏览器自动解析为如上电话号码格式，导致样式和布局改变</p></li><li><p>忽略页面中的数字识别为电话号码, 只要把这个默认行为关闭就行</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这个关闭不会影响真正电话号码的识别</li></ul><p>说明：Meta 标签中的 format-detection 属性及含义<br>format-detection 中文的意思是 “格式检测”，它是用来检测 html 里的一些格式的</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 禁止了把数字转化为拨号链接 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 禁止作为邮箱地址 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"email=no"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 禁止跳转至地图 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"adress=no"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no,email=no,adress=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移动端-Safari-浏览网页时对数字不启用电话功能&quot;&gt;&lt;a href=&quot;#移动端-Safari-浏览网页时对数字不启用电话功能&quot; class=&quot;headerlink&quot; title=&quot;移动端(Safari)浏览网页时对数字不启用电话功能&quot;&gt;&lt;/a&gt;移动端(Safa
      
    
    </summary>
    
      <category term="移动web" scheme="https://cuilongjin.top/categories/%E7%A7%BB%E5%8A%A8web/"/>
    
    
  </entry>
  
  <entry>
    <title>npm 使用</title>
    <link href="https://cuilongjin.top/2019/tool/npm/"/>
    <id>https://cuilongjin.top/2019/tool/npm/</id>
    <published>2019-07-02T16:00:00.000Z</published>
    <updated>2019-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-使用"><a href="#npm-使用" class="headerlink" title="npm 使用"></a>npm 使用</h2><h3 id="解决-npm-包无法下载"><a href="#解决-npm-包无法下载" class="headerlink" title="解决 npm 包无法下载"></a>解决 npm 包无法下载</h3><p>electron sass</p><p>进入 <code>~/.npmrc</code>，增加如下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org</span><br><span class="line">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjs</span><br><span class="line">electron_mirror=http://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure><p>淘宝 npm 镜像 <a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a></p><h3 id="npm-基本命令"><a href="#npm-基本命令" class="headerlink" title="npm 基本命令"></a>npm 基本命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 npm</span></span><br><span class="line">npm -v|--version</span><br><span class="line">npm install npm@latest -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># nvm : npm Version Manager</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索包</span></span><br><span class="line">npm search &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt; <span class="comment"># [&lt;@scope&gt;/] 安装限定范围的包</span></span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt;</span><br><span class="line">npm install &lt;folder&gt;</span><br><span class="line">npm install &lt;tarball file&gt;  <span class="comment"># .tar, .tar.gz, or .tgz</span></span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install &lt;github usename&gt;/&lt;guthub project&gt;</span><br><span class="line">npm install &lt;git:// url&gt;</span><br><span class="line"></span><br><span class="line">npm install &lt;pkg&gt; -S|--save <span class="comment"># 安装到 dependencies</span></span><br><span class="line">npm install &lt;pkg&gt; -D|--save-dev <span class="comment"># 安装到 devDependencies</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装全局包</span></span><br><span class="line">npm install -g &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包</span></span><br><span class="line">npm update</span><br><span class="line"><span class="comment"># 更新全局安装的包</span></span><br><span class="line">npm update -g <span class="comment"># 更新全部</span></span><br><span class="line">npm update -g| --global &lt;pkg&gt; <span class="comment"># 更新指定包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地包</span></span><br><span class="line">npm uninstall &lt;pkg&gt;</span><br><span class="line">npm uninstall --save &lt;pkg&gt; <span class="comment"># 从 `package.json` 文件中删除依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载全局安装的包</span></span><br><span class="line">npm uninstall -g &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开官网</span></span><br><span class="line">npm docs|home [&lt;pkg&gt;]</span><br><span class="line"><span class="comment"># 打开源码仓库页面</span></span><br><span class="line">npm repo [&lt;pkg&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 package.json 文件</span></span><br><span class="line">npm init</span><br><span class="line"><span class="comment"># 创建默认 package.json 文件</span></span><br><span class="line">npm init --yes or -y</span><br></pre></td></tr></table></figure><h3 id="npm-修改源"><a href="#npm-修改源" class="headerlink" title="npm 修改源"></a>npm 修改源</h3><ul><li><p>进入~/.npmrc 增加 <code>registry=https://registry.npm.taobao.org</code></p></li><li><p>通过命令 <code>npm config set registry http://registry.cnpmjs.org</code></p></li><li><p>临时使用指定源下载 <code>npm install jquery --registry=https://registry.npm.taobao.org</code></p></li><li><p>使用 nrm 管理源</p></li></ul><h3 id="npm-配置文件"><a href="#npm-配置文件" class="headerlink" title="npm 配置文件"></a>npm 配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .npmrc 配置文件位置（~/.npmrc）</span></span><br><span class="line">npm config list</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 缓存目录，默认 C:\Users\&lt;username&gt;\AppData\Roaming\npm-cache</span></span><br><span class="line">npm config get cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 npm 缓存</span></span><br><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 全局 node 包位置</span></span><br><span class="line">npm config get prefix</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm root -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 npm 全局文件位置及缓存文件位置</span></span><br><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"&lt;new_path&gt;"</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"&lt;new_path&gt;"</span></span><br></pre></td></tr></table></figure><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>使用 NPM 下载和发布代码时都会接触到版本号。NPM 使用语义版本号来管理代码</p><p>语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p><ul><li>如果只是修复 bug，需要更新 Z 位</li><li>如果是新增了功能，但是向下兼容，需要更新 Y 位</li><li>如果有大变动，向下不兼容，需要更新 X 位</li></ul><h3 id="nrm-使用"><a href="#nrm-使用" class="headerlink" title="nrm 使用"></a>nrm 使用</h3><p>nrm ls 查看配置列表，带*号即为当前使用的配置</p><p>nrm use 源的别名：切换源</p><p>nrm add 别名 地址 ： 添加源</p><p>nrm test 别名 ： 测速</p><p>nrm del 别名 ：删除源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;npm-使用&quot;&gt;&lt;a href=&quot;#npm-使用&quot; class=&quot;headerlink&quot; title=&quot;npm 使用&quot;&gt;&lt;/a&gt;npm 使用&lt;/h2&gt;&lt;h3 id=&quot;解决-npm-包无法下载&quot;&gt;&lt;a href=&quot;#解决-npm-包无法下载&quot; class=&quot;head
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Markdown" scheme="https://cuilongjin.top/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://cuilongjin.top/2019/tool/docker/"/>
    <id>https://cuilongjin.top/2019/tool/docker/</id>
    <published>2019-06-18T11:52:00.000Z</published>
    <updated>2019-07-09T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-dcoker"><a href="#安装-dcoker" class="headerlink" title="安装 dcoker"></a>安装 dcoker</h2><h3 id="ubuntu-16-04-LTS-安装-docker"><a href="#ubuntu-16-04-LTS-安装-docker" class="headerlink" title="ubuntu 16.04 (LTS) 安装 docker"></a>ubuntu 16.04 (LTS) 安装 docker</h3><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p>镜像仓库方式安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置镜像仓库</span></span><br><span class="line"><span class="comment"># 更新 apt 软件包索引：</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># 安装软件包，以允许 apt 通过 HTTPS 使用镜像仓库：</span></span><br><span class="line">$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥：</span></span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 验证密钥指纹是否为 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。</span></span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p>设置 stable 镜像仓库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># amd64：</span></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br></pre></td></tr></table></figure><p>安装 DOCKER CE</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><p>验证是否正确安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令将下载一个测试镜像并在容器中运行它。容器运行时，它将输出一条参考消息并退出</p><p>升级 docker ce</p><p>如需升级 Docker CE，首先运行 <code>sudo apt-get update</code>，然后按照顺序执行操作，并选择您要安装的新版本</p><p>卸载 docker ce</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure><p>主机上的镜像、容器、存储卷、或定制配置文件不会自动删除。如需删除所有镜像、容器和存储卷，请运行下列命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><p>将 docker 配置为在启动时启动</p><h3 id="centos-安装-docker"><a href="#centos-安装-docker" class="headerlink" title="centos 安装 docker"></a>centos 安装 docker</h3><p>卸载旧版本(如果安装过旧版本的话)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><p>安装需要的软件包， yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>设置 yum 源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>可以查看所有仓库中所有 docker 版本，并选择特定版本安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 报错：Requires: container-selinux &gt;= 2:2.74 </span></span><br><span class="line">You could try using --skip-broken to work around the problem</span><br><span class="line"></span><br><span class="line">$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo  </span><br><span class="line">$ yum install epel-release   <span class="comment"># 阿里云上的 epel 源</span></span><br><span class="line">$ yum makecache</span><br><span class="line">$ yum install container-selinux</span><br></pre></td></tr></table></figure><h2 id="使用-docker"><a href="#使用-docker" class="headerlink" title="使用 docker"></a>使用 docker</h2><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><p>修改 docker 源</p><p>daemon.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 docker</p><p>安装 Ubuntu</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search ubuntu <span class="comment"># 查找 Ubuntu 镜像</span></span><br><span class="line">docker pull ubuntu <span class="comment"># 安装 Ubuntu 镜像</span></span><br><span class="line">docker images <span class="comment">#查看 docker 镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并运行 docker 容器</span></span><br><span class="line">docker run -it -d --name ubuntu_test -p 8088:80 ubuntu</span><br><span class="line"><span class="comment"># --name 自定义容器名，-p 指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回 id</span></span><br><span class="line"><span class="comment"># 多个 -p 指定多个端口映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 docker 容器  启动一个 bash 交互终端</span></span><br><span class="line">docker run -it 容器名:容器tag /bin/bash</span><br><span class="line"></span><br><span class="line">docker start container_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有启动的容器(查看所有容器加 -a)</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 id 查看容器信息</span></span><br><span class="line">docker inspect id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker(或者把容器id改为容器名，也可以进入)</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id或容器名 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi 删除镜像</span><br></pre></td></tr></table></figure><p>备份镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 制作 docker 镜像  1.0 为版本号</span></span><br><span class="line">docker commit 98 ubuntu_test:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像是否创建</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存镜像到 docker 账号中</span></span><br><span class="line"><span class="comment"># 登录进 Docker 注册中心</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送镜像</span></span><br><span class="line">docker tag a25ddfec4d2a arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line">docker push arunpyasi/container-backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包镜像并查看</span></span><br><span class="line">docker save -o ubuntu_test.tar ubuntu_test:1.0</span><br></pre></td></tr></table></figure><p>恢复容器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从docker账号中拉取</span></span><br><span class="line">docker pull arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地</span></span><br><span class="line">docker load -i ~/container-backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用加载的镜像去运行Docker容器</span></span><br><span class="line">docker run -d -p 80:80 container-backup</span><br></pre></td></tr></table></figure><p><strong>docker 给已存在的容器添加或修改端口映射</strong></p><p>方式 1：</p><p>提交一个运行中的容器为镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker commit containerid foo/live</span><br></pre></td></tr></table></figure><p>运行镜像并添加端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 8000:80  foo/live /bin/bash</span><br></pre></td></tr></table></figure><p>方式 2：iptable 转发端口</p><p>将容器的 8000 端口映射到 docker 主机的 8001 端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iptables -t nat -A  DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.19:8000</span><br></pre></td></tr></table></figure><h3 id="docker-容器使用问题"><a href="#docker-容器使用问题" class="headerlink" title="docker 容器使用问题"></a>docker 容器使用问题</h3><p>Centos7 docker 容器报 docker Failed to get D-Bus connection 错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start nginx</span><br><span class="line">Failed to get D-Bus connection: Operation not permitted。</span><br></pre></td></tr></table></figure><p>原因是 dbus-daemon 没能启动</p><p>解决方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --privileged -ti --name test1  centos /usr/sbin/init</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-dcoker&quot;&gt;&lt;a href=&quot;#安装-dcoker&quot; class=&quot;headerlink&quot; title=&quot;安装 dcoker&quot;&gt;&lt;/a&gt;安装 dcoker&lt;/h2&gt;&lt;h3 id=&quot;ubuntu-16-04-LTS-安装-docker&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="https://cuilongjin.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>移动端调试</title>
    <link href="https://cuilongjin.top/2019/tool/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    <id>https://cuilongjin.top/2019/tool/移动端调试/</id>
    <published>2019-06-18T11:52:00.000Z</published>
    <updated>2019-06-18T11:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些调试工具"><a href="#一些调试工具" class="headerlink" title="一些调试工具"></a>一些调试工具</h2><ol><li><p>直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法 100% 还原手机的真实情况</p></li><li><p>chrome <a href="https://developer.chrome.com/devtools/docs/remote-debugging" target="_blank" rel="noopener">远程调试功能</a></p><p><code>chrome://inspect/#devices</code></p><p>需要连接数据线，其次是设置比较繁琐，而且还限制了 android 手机。对于 IOS 的调试则可能要使用 Safari 的另一套工具</p></li><li><p><a href="https://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener">weinre</a>：远程调试，在 PC 上生成一个像 chrome 开发工具一样的调试器，需要手动引入 js</p></li><li><p>Eruda、vConsole：在移动端页面上生成一个调试器，调试信息会挡住操作元素，查看复杂数据结构的 log 不方便，需要手动引入 js</p></li><li><p>安装各种虚拟机sdk，在电脑上进行手机调试。能比较真实模拟手机，但是安装繁琐，操作不方便，无法模拟真实的手势操作</p></li></ol><h2 id="Eruda"><a href="#Eruda" class="headerlink" title="Eruda"></a>Eruda</h2><p><a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">https://github.com/liriliri/eruda</a></p><p>Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。</p><ol><li>按钮拖拽，面板透明度大小设置。</li><li>Console面板：捕获Console日志，支持log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括%c自定义样式输出；支持按日志类型及正则表达式过滤；支持快捷命令加载underscore、jQuery库；支持JavaScript脚本执行。</li><li>Elements面板：查看标签内容及属性；查看应用在Dom上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看Dom上绑定的各类事件。</li><li>Network面板：捕获请求，查看发送数据、返回头、返回内容等信息。</li><li>Resources面板：查看并清除localStorage、sessionStorage及cookie；查看页面加载脚本及样式文件；查看页面加载图片。</li><li>Sources面板：查看页面源码；格式化html，css，js代码及json数据。</li><li>Info面板：输出URL及User Agent；支持自定义输出内容。</li><li>Snippets面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。</li></ol><p>使用</p><p>通过 CDN 使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/eruda/1.5.2/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 npm 安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install eruda --save</span><br></pre></td></tr></table></figure><p>在页面中加载脚本：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/eruda/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Js文件对于移动端来说略重（gzip后大概100kb）。建议通过url参数来控制是否加载调试器，比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> src = <span class="string">'node_modules/eruda/eruda.min.js'</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/eruda=true/</span>.test(<span class="built_in">window</span>.location) &amp;&amp; localStorage.getItem(<span class="string">'active-eruda'</span>) != <span class="string">'true'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt src="'</span> + src + <span class="string">'"&gt;&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt&gt;eruda.init();&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>初始化时可以传入配置：</p><ul><li>container：用于插件初始化的 Dom 元素，如果不设置，默认创建 div 作为容器直接置于 html 根结点下面</li><li>tool：指定要初始化哪些面板，默认加载所有</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el)</span><br><span class="line"></span><br><span class="line">eruda.init(&#123;</span><br><span class="line">  container: el,</span><br><span class="line">  tool: [<span class="string">'console'</span>, <span class="string">'elements'</span>],</span><br><span class="line">  useShadowDom: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vConsole"><a href="#vConsole" class="headerlink" title="vConsole"></a>vConsole</h2><p><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">https://github.com/Tencent/vConsole</a></p><p>一个轻量、可拓展、针对手机网页的前端开发者调试面板。</p><p>特性</p><ul><li>查看 console 日志</li><li>查看网络请求</li><li>查看页面 element 结构</li><li>查看 Cookies、localStorage 和 SessionStorage</li><li>手动执行 JS 命令行</li><li>自定义插件</li></ul><p><a href="https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md" target="_blank" rel="noopener">使用说明</a></p><p>下载 vConsole 的<a href="https://github.com/Tencent/vConsole/releases/latest" target="_blank" rel="noopener">最新版本</a>。（不要直接下载 dev 分支下的 <code>dist/vconsole.min.js</code>）</p><p>或者使用 npm 安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure><p>引入 <code>dist/vconsole.min.js</code> 到项目中：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/vconsole.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vConsole = <span class="keyword">new</span> VConsole()</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'Hello world'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="weinre"><a href="#weinre" class="headerlink" title="weinre"></a>weinre</h2><p><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html" target="_blank" rel="noopener">http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html</a></p><ol><li>Element： 查看/修改dom，查看/修改 dom CSS</li><li>Resources：查看/修改 localStorage, sessionStorage</li><li>Network：查看网络请求</li><li>Timeline：</li><li>Console：查看控制台输出</li></ol><p>不能做 JS 调试</p><p>使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install -g weinre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 weinre 服务</span></span><br><span class="line">weinre --boundHost 192.168.3.44 --httpPort 8888</span><br><span class="line"></span><br><span class="line">启动调试客户端</span><br><span class="line">在浏览器中打开 <span class="string">'http://192.168.3.44:8888'</span> 即可启动调试客户端</span><br><span class="line"></span><br><span class="line">在需要调试的页面中添加如下</span><br><span class="line">&lt;script src=<span class="string">"http://192.168.3.44:8888/target/target-script-min.js#anonymous"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="spy-debugger"><a href="#spy-debugger" class="headerlink" title="spy-debugger"></a>spy-debugger</h2><p><a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="noopener">https://github.com/wuchangming/spy-debugger</a></p><p>微信调试，各种 WebView 样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP/HTTPS，无需USB连接设备</p><p>spy-debugger 集成了<code>weinre</code>，简化了<code>weinre</code>需要给每个调试的页面添加 js 代码。原理是拦截所有 html 页面请求注入<code>weinre</code>所需要的 js 代码。让页面调试更加方便</p><p>1、页面调试＋抓包<br>2、操作简单，无需USB连接设备<br>3、<strong>支持HTTPS</strong><br>4、<code>spy-debugger</code>内部集成了<a href="http://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener"><code>weinre</code></a>、<a href="https://github.com/wuchangming/node-mitmproxy" target="_blank" rel="noopener"><code>node-mitmproxy</code></a>、<a href="https://github.com/alibaba/anyproxy" target="_blank" rel="noopener"><code>AnyProxy</code></a>。<br>5、自动忽略原生 App 发起的 https 请求，只拦截 webview 发起的 https 请求。对使用了 SSL pinning 技术的原生App 不造成任何影响。<br>6、可以配合其它代理工具一起使用(默认使用AnyProxy) <a href="https://github.com/wuchangming/spy-debugger#%E8%AE%BE%E7%BD%AE%E5%A4%96%E9%83%A8%E4%BB%A3%E7%90%86%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8anyproxy" target="_blank" rel="noopener">(设置外部代理)</a></p><p>基本使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install spy-debugger -g</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">spy-debugger</span><br><span class="line"><span class="comment">#设置手机的HTTP代理</span></span><br><span class="line">代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)</span><br><span class="line"><span class="comment"># 手机安装证书</span></span><br><span class="line">手机浏览器访问 http://s.xxx</span><br><span class="line">设置-&gt;通用-&gt;描述文件与设备管理-&gt;找到node-mitmproxy CA（安装）</span><br><span class="line">设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到node-mitmproxy CA（打开）</span><br></pre></td></tr></table></figure><p>自定义选项</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义端口</span></span><br><span class="line">spy-debugger -p 8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置页面内容为可编辑模式</span></span><br><span class="line">spy-debugger -w <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否只拦截浏览器发起的https请求(默认： true)</span></span><br><span class="line">spy-debugger -b <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许weinre监控iframe加载的页面(默认： false)</span></span><br><span class="line">spy-debugger -i <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 HTTP 缓存(默认： false)</span></span><br><span class="line">spy-debugger -c <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="m-console"><a href="#m-console" class="headerlink" title="m-console"></a>m-console</h2><p><a href="https://github.com/fwon/m-console" target="_blank" rel="noopener">https://github.com/fwon/m-console</a></p><p>手机远程调试工具，手机通过代理连接上PC后，可以在PC版浏览器打印log和错误日志</p><p>需要手动给每个调试的页面添加 js 代码</p><h2 id="DebugGap-VIDE"><a href="#DebugGap-VIDE" class="headerlink" title="DebugGap-VIDE"></a>DebugGap-VIDE</h2><p><a href="https://www.debuggap.com/debug_webview.html" target="_blank" rel="noopener">https://www.debuggap.com/debug_webview.html</a></p><h2 id="Mobile-Debug"><a href="#Mobile-Debug" class="headerlink" title="Mobile Debug"></a>Mobile Debug</h2><p><a href="https://www.mobiledebug.com/" target="_blank" rel="noopener">https://www.mobiledebug.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些调试工具&quot;&gt;&lt;a href=&quot;#一些调试工具&quot; class=&quot;headerlink&quot; title=&quot;一些调试工具&quot;&gt;&lt;/a&gt;一些调试工具&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="移动端调试" scheme="https://cuilongjin.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://cuilongjin.top/2019/other/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://cuilongjin.top/2019/other/面试题/</id>
    <published>2019-03-21T10:30:00.000Z</published>
    <updated>2019-03-26T02:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><h3 id="http-相关"><a href="#http-相关" class="headerlink" title="http 相关"></a>http 相关</h3><h3 id="HTML-css-相关"><a href="#HTML-css-相关" class="headerlink" title="HTML css 相关"></a>HTML css 相关</h3><h3 id="js-相关"><a href="#js-相关" class="headerlink" title="js 相关"></a>js 相关</h3><h3 id="jquery-相关"><a href="#jquery-相关" class="headerlink" title="jquery 相关"></a>jquery 相关</h3><h3 id="工具类相关"><a href="#工具类相关" class="headerlink" title="工具类相关"></a>工具类相关</h3><p><a href="zh-cn/_Tool/webpack配置?id=webpack-和-gulp-区别">webpack 和 gulp 区别</a><br><a href></a><br><a href></a><br><a href></a><br><a href></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器相关&quot;&gt;&lt;a href=&quot;#浏览器相关&quot; class=&quot;headerlink&quot; title=&quot;浏览器相关&quot;&gt;&lt;/a&gt;浏览器相关&lt;/h3&gt;&lt;h3 id=&quot;http-相关&quot;&gt;&lt;a href=&quot;#http-相关&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="other" scheme="https://cuilongjin.top/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="https://cuilongjin.top/2019/tool/webpack%E9%85%8D%E7%BD%AE/"/>
    <id>https://cuilongjin.top/2019/tool/webpack配置/</id>
    <published>2019-01-15T10:00:00.000Z</published>
    <updated>2019-07-09T10:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><ul><li><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack 官网</a></li><li><a href="https://webpack.docschina.org/" target="_blank" rel="noopener">webpack 中文网</a></li><li><a href="https://github.com/cuilongjin/webpack-config/" target="_blank" rel="noopener">webpack 配置文件</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webpack 是一个现代 JavaScript 应用程序的模块打包器（module bundler）</p><p>webpack 是一个模块化方案（预编译）</p><p>webpack 获取具有依赖关系的模块，并生成表示这些模块的静态资源</p><p>webpack 的两个特点：模块化、打包</p><p>四个核心概念：<strong>入口(entry)</strong>、<strong>输出(output)</strong>、<strong>加载器(loader)</strong>、<strong>插件(plugins)</strong></p><p>模块化方案：webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）<br>browserify 是与 webpack 相似的模块化打包工具</p><h3 id="webpack-起源"><a href="#webpack-起源" class="headerlink" title="webpack 起源"></a>webpack 起源</h3><ul><li>webpack 解决了现存模块打包器的两个痛点：<ul><li>Code Spliting - 代码分离</li><li>静态资源的模块化处理方案</li></ul></li></ul><h3 id="webpack-与模块"><a href="#webpack-与模块" class="headerlink" title="webpack 与模块"></a>webpack 与模块</h3><ul><li><p><a href="http://zhaoda.net/webpack-handbook/module-system.html" target="_blank" rel="noopener">前端模块系统的演进</a></p></li><li><p>在 webpack 看来：所有的<strong>静态资源都是模块</strong></p></li><li><p>webpack 模块能够识别以下等形式的模块之间的依赖：</p><ul><li><p>ES2015 <code>import</code> <code>export</code></p></li><li><p>CommonJS <code>require()</code> <code>module.exports</code></p></li><li><p>AMD <code>define</code> 和 <code>require</code></p></li><li><p>css/sass/less 文件中的 <code>@import</code></p></li><li><p>图片连接，比如：样式 <code>url(...)</code> 或 HTML <code>&lt;img src=...&gt;</code></p></li><li><p>字体等</p></li></ul></li></ul><ul><li>在webpack提供的模块化环境中<ul><li>想要加载一个JS文件，只需要 require(‘a.js’)</li><li>想要加载一个CSS文件，只需要 require(‘css/index.css’)</li><li>想要加载一个图片文件，只需要 require(‘images/a.png’)</li></ul></li></ul><ul><li><a href="http://www.jianshu.com/p/42e11515c10f#" target="_blank" rel="noopener">入门 Webpack，看这篇就够了</a></li></ul><h3 id="webpack-打包原理："><a href="#webpack-打包原理：" class="headerlink" title="webpack 打包原理："></a>webpack 打包原理：</h3><p>​        入口文件： main.js</p><p>​        webpack 从入口出发，递归分析项目中所有的依赖项（模块），使用loader来处理对应的模块最终，打包生成一个 bundle.js 文件。</p><p>​        如果配置了 webpack 中的 代码分离（Code Spliting），webpack 会根据 分离点 将这个模块生成一个独立的JS文件</p><p>​        还可以通过配置，将 CSS 、 图片、 字体 等文件，从 bundle.js 中抽离为独立的文件</p><h2 id="webpack-的基本使用"><a href="#webpack-的基本使用" class="headerlink" title="webpack 的基本使用"></a>webpack 的基本使用</h2><p>安装：<code>npm i -D webpack webpack-cli</code></p><p>webpack：是 webpack 工具的核心包</p><p>webpack-cli：提供了一些在终端中使用的命令</p><p>-D(–save-dev)：表示项目开发期间的依赖</p><p>webpack 的两种使用方式：命令行、配置文件（<code>webpack.config.js</code>）</p><h3 id="命令行使用说明"><a href="#命令行使用说明" class="headerlink" title="命令行使用说明"></a>命令行使用说明</h3><ul><li><code>package.json</code>中的<code>scripts</code>中可以存放一些 bash 命令，这些 bash 命令可以通过 <code>npm run 命令名称</code> 来执行</li><li>注意：npm 在执行 scripts 中的命令的时候，是在电脑系统后台默认开启一个 bash，将当前目录下的<code>./node_modules/.bin</code>这个文件夹临时加入了系统环境变量</li><li>使用方式：<code>npm run build</code></li><li>设置开发状态： <code>mode</code>  如果没有设置 mode 配置项，webpack 会默认提供开发环境(production)</li><li>在入口文件中可以使用 <code>import</code> 引入 js css less 等文件</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // webpack 是 webpack-cli 提供的命令</span><br><span class="line">  // src/js/main.js 为入口文件</span><br><span class="line">  // --output dist/bundle.js 为出口文件</span><br><span class="line">  // --mode development 生产环境</span><br><span class="line">  "build": "webpack"</span><br><span class="line">  "build1": "webpack src/js/main.js --output dist/bundle.js --mode development"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件方式（推荐）"><a href="#配置文件方式（推荐）" class="headerlink" title="配置文件方式（推荐）"></a>配置文件方式（推荐）</h3><p>项目<code>根目录</code>下创建一个 <code>webpack.config.js</code>文件，运行 <code>webpack</code> 命令时的默认配置文件</p><p>指定其他文件：<code>--config  webpack.XX.js</code></p><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;build&quot;: &quot;webpack&quot;</code></p><p>执行命令 : <code>npm run build</code></p><p>示例代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置</span></span><br><span class="line"><span class="comment">// 注意 : 不要再这个文件中使用ES6的的模块化 import语法</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  entry: path.join(__dirname, <span class="string">'./src/js/main.js'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出口</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 出口目录</span></span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发模式</span></span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>安装：<code>npm i -D webpack-dev-server</code></p><p>作用：配合 webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率</p><p>注意：无法直接在终端中执行 <code>webpack-dev-server</code>，需要在 <code>package.json</code> 配置 <code>scripts</code> 后使用</p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>webpack-dev-server</code>将打包好的文件存储在内存中，提高编译和加载速度，效率更高（不会生成dist目录）</li><li>在内存中出口目录为项目根目录（命令行中的提示：<code>webpack output is served from /</code>）<ul><li>在<code>index.html</code>页面中引入文件不需要加<code>dist</code></li></ul></li></ul><h3 id="CLI-配置"><a href="#CLI-配置" class="headerlink" title="CLI 配置"></a>CLI 配置</h3><ul><li><code>--contentBase</code> ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的 index.html）<ul><li><code>--contentBase ./src</code>：当前目录下的 src 文件夹</li></ul></li><li><code>--open true</code> ：自动打开浏览器</li><li><code>--port 3000</code> ：指定端口号</li><li><code>--hot</code> ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载</li><li><code>--progress</code>：显示进度条</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --contentBase src --open --port 8888 --hot"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;dev&quot;: &quot;webpack-dev-server --hot&quot;</code></p><p>执行命令 : <code>npm run dev</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --hot 热更新写在命令行里，不然的话还要配其他插件麻烦</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'src'</span>),</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// hot: true,</span></span><br><span class="line">    </span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123; <span class="comment">// api 表示当前项目请求的 key</span></span><br><span class="line">        target: <span class="string">'http://www.baidu.com'</span>, <span class="comment">// 代理服务器路径</span></span><br><span class="line">        pathRewrite: &#123; <span class="string">'^/api'</span>: <span class="string">'/api'</span> &#125;, <span class="comment">// 重写路径</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求 localhost:8080/api/.. 会被代理到 http://www.baidu.com/api/..</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// plugins: [</span></span><br><span class="line">  <span class="comment">//   new webpack.HotModuleReplacementPlugin()</span></span><br><span class="line">  <span class="comment">// ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="html-webpack-plugin-插件"><a href="#html-webpack-plugin-插件" class="headerlink" title="html-webpack-plugin 插件"></a>html-webpack-plugin 插件</h2><ul><li>安装：<code>npm i -D html-webpack-plugin</code></li><li>作用：根据模板，在内存中自动生成 html 页面，并自动引入<code>bundle.js</code>、<code>css</code>等文件</li></ul><p>配置文件配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 html-webpack-plugin 插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 配置插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin 配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 模板页面路径</span></span><br><span class="line">      template: path.join(__dirname, <span class="string">'src/index.html'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包非js文件"><a href="#打包非js文件" class="headerlink" title="打包非js文件"></a>打包非js文件</h2><p>webpack 默认只能处理 js 文件，非 js(css、less、图片、字体等)处理不了，借助 loader 加载器</p><h3 id="处理-css-文件"><a href="#处理-css-文件" class="headerlink" title="处理 css 文件"></a>处理 css 文件</h3><p>在 <code>main.js</code>中引入css文件 <code>import &#39;../css/main.css&#39;</code></p><p>安装 : <code>npm i -D style-loader css-loader</code></p><p>在 <code>webpack.config.js</code> 中，添加个新的配置项 <code>module</code></p><p>在 <code>module</code> 中添加 <code>loader</code> 来处理 <code>css</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理 css</span></span><br><span class="line">      <span class="comment">// 注意点 use 执行loader 顺序 从右往左</span></span><br><span class="line">      <span class="comment">// css-loader: 读取css文件内容，将其转化为一个模块</span></span><br><span class="line">      <span class="comment">// style-loader: 拿到模块, 创建一个style标签，插入页面中</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-less-文件"><a href="#处理-less-文件" class="headerlink" title="处理 less 文件"></a>处理 less 文件</h3><p>在 <code>main.js</code>中引入 less 文件 <code>import &#39;../css/main.less&#39;</code></p><p>安装 : <code>npm i -D less-loader less style-loader css-loader</code></p><p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理 <code>less</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">//处理 css</span></span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h3><p>安装 : <code>npm i -D url-loader file-loader</code></p><p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理图片</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">//  图片大小 &lt;= 10000 =&gt; 转化为base64</span></span><br><span class="line">              <span class="comment">//  图片大小 &gt;= 10000 =&gt; 不会转base64 内部调用 file-loader 加载图片</span></span><br><span class="line">              limit: <span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url-loader</strong> 默认会将图片转化为 base64 编码格式，目的：提高性能</p><p><strong>file-loader</strong> 在处理图片时，会对文件进行重命名</p><p>base64 编码格式的图片说明：</p><ul><li>精灵图：将一些小图片合并为一张图片，减少请求次数，提高性能</li><li>字体图标：直接将一些小的图片,合并到字体文件中，并且不会失真</li><li>base64：是一种编码格式,能够将图片、文字等常见的文件，转化为 base64 格式，这种字符串格式浏览器能够识别并且读取显示到页面中</li><li>base64 是一个字符串，也可以直接被内嵌到页面中，或者 css 中</li><li>注意：大图片不适合用 base64 处理，只有小的图标才适合 base64 处理</li></ul><h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><p>在 <strong>main.js</strong> 中引入 css 文件 <code>import &#39;../css/iconfont/iconfont.css&#39;</code></p><p>在 webpack.config.js 中配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理字体图标</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(svg|woff|woff2|ttf|eot)$/</span>,</span><br><span class="line">        use: <span class="string">'url-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-ES6-语法"><a href="#处理-ES6-语法" class="headerlink" title="处理 ES6 语法"></a>处理 ES6 语法</h3><ol><li>现在的项目都是使用 ES6 开发的，但是这些新的 ES6 语法，并不是所有的浏览器都支持，所以就需要有一个工具，帮我们转成 es5 语法，这个就是：babel</li><li><a href="https://babeljs.io/" target="_blank" rel="noopener">babel</a></li><li>Babel is a JavaScript compiler. ==&gt; babel 是一个 JavaScript 编译器</li><li>webpack 只能处理 import / export 这个 es6 模块化语法，而其他的 js 新语法，应该使用 babel 来处理</li></ol><p>babel 的使用 :</p><ul><li>安装： <code>npm i -D babel-core babel-loader@7</code><ul><li>babel-core 是 babel 的核心包</li><li>babel-loader 加载 js 文件，并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js</li></ul></li></ul><ul><li>安装：<code>npm i -D babel-preset-env babel-preset-stage-2</code><ul><li>babel-preset-env：表示能够解析 es2015、es2016、es2017、es2018 这些标准的语法</li><li>babel-preset-stage-2：用来解析还没有被采纳为标准的语法</li><li><code>babel-polyfill与babel-plugin-transform-runtime</code> 也是做兼容处理的,以前都是用这个，兼容更早的</li></ul></li></ul><ul><li>配置 : 在 webpack.config.js 中添加一个 loader</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理 ES6 语法</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">        <span class="comment">// 设置忽略 node-modules 文件夹</span></span><br><span class="line">        exclude: <span class="regexp">/node-modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在项目根目录中创建 babel 的配置文件，叫：<code>.babelrc</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;,</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  -----------</span><br><span class="line">  // 暂时不用</span><br><span class="line">  // 如果未来某一天真的用到了polify</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;, &#123;</span><br><span class="line">      &quot;helpers&quot;: false,</span><br><span class="line">      &quot;polyfill&quot;: true,</span><br><span class="line">      &quot;regenerator&quot;: true,</span><br><span class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目打包上线"><a href="#项目打包上线" class="headerlink" title="项目打包上线"></a>项目打包上线</h2><p>执行 : <code>npm run build</code> 对项目进行打包，生成dist文件</p><p>模拟本地服务器 : 安装 : <code>npm i -g http-server</code></p><p>把dist文件里的内容放到服务器里即可，直接运行<code>http-server</code></p><h2 id="webpack-和-gulp-区别"><a href="#webpack-和-gulp-区别" class="headerlink" title="webpack 和 gulp 区别"></a>webpack 和 gulp 区别</h2><ol><li>Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给 gulp 配置不通的 task（通过Gulp 中的 gulp.task() 方法配置，比如启动 server、sass/less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程</li><li>Webpack 也称之为模块打包机 ，由此也可以看出 Webpack 更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块，最初 Webpack 本身就是为前端 JS 代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack 是通过 loader（加载器）和 plugins（插件）对资源进行处理的</li><li>gulp是构建工具，Webpack是 js 模块化的解决方案</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Webpack&quot;&gt;&lt;a href=&quot;#Webpack&quot; class=&quot;headerlink&quot; title=&quot;Webpack&quot;&gt;&lt;/a&gt;Webpack&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Webpack" scheme="https://cuilongjin.top/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="https://cuilongjin.top/2019/vue/vue+elementui/"/>
    <id>https://cuilongjin.top/2019/vue/vue+elementui/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-19T11:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p>组件抽离</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 标签不要动，只需要把内容题出去后，添加 src 引入即可</span><br><span class="line">&lt;template src=&quot;./Roles.html&quot;&gt;&lt;/template&gt;</span><br><span class="line">&lt;script src=&quot;./Roles.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style src=&quot;./Roles.less&quot; lang=&quot;less&quot; scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>scoped</p><p>vue 组件之间的样式有自动复用的问题，给一个类设置样式，其他组件中相同类的元素也会被设置样式</p><p>解决：在 <code>style</code> 标签上添加 <code>scoped</code> 字段，设置样式只作用于当前组件</p><p><code>&lt;style scoped&gt;&lt;/style&gt;</code></p><p>作用 1：让当前组件内的样式，只能在当前组件上起效果<br>作用 2：如果添加了 scoped，样式只会对本来就存在的标签/组件起效果，如果是动态添加的组件/标签，是无效的</p><p>动态添加的组件/标签，在 <code>.vue</code>文件里添加一个 style 标签，在标签里设置该样式属性，或者在选择器前添加<code>/deep/</code></p><p>vm.$nextTick( [callback] )：将回调延迟到下次 DOM 更新循环之后执行</p><p>如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise：<code>await this.$nextTick()</code></p><p>插槽</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">  通过 scope.row 获取当前行的数据</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面跳转</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'login'</span> &#125;)</span><br><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="element"><a href="#element" class="headerlink" title="element"></a>element</h2><p><code>span=&#39;1&#39;</code>：赋值 span 的是一个字符串 ‘1’</p><p><code>:span=&#39;1&#39;</code>：前面加一个<code>:</code> 意思是动态数据绑定，赋值 span 的是具体数据类型的数据，即数字 1</p><h3 id="时间日期选择器"><a href="#时间日期选择器" class="headerlink" title="时间日期选择器"></a>时间日期选择器</h3><p>日期选择器限制选择范围</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-date-picker</span> <span class="attr">v-model</span>=<span class="string">"options.endDate"</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">:picker-options</span>=<span class="string">"endDateOptions"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-date-picker</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">endDateOptions: &#123;</span><br><span class="line">  disabledDate: <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 限制结束时间范围为大于开始时间，并在一周内</span></span><br><span class="line">    <span class="keyword">return</span> time.getTime() &lt; <span class="keyword">this</span>.options.startDate || time.getTime() &gt; <span class="keyword">this</span>.options.startDate + <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tree-树形控件"><a href="#Tree-树形控件" class="headerlink" title="Tree 树形控件"></a>Tree 树形控件</h3><ul><li>Attributes</li></ul><p>show-checkbox：节点是否可被选择</p><p>default-expand-all：是否默认展开所有节点</p><p>node-key： 每个树节点用来作为唯一标识的属性，整棵树应该是唯一的</p><ul><li>方法</li></ul><p>this.$refs.tree.setCheckedKeys：通过 keys 设置目前勾选的节点，使用此方法必须设置 node-key 属性</p><p>this.$refs.tree.getCheckedKeys：若节点可被选择（即 show-checkbox 为 true），则返回目前被选中的节点的 key 所组成的数组</p><h3 id="NavMenu-导航菜单"><a href="#NavMenu-导航菜单" class="headerlink" title="NavMenu 导航菜单"></a>NavMenu 导航菜单</h3><h4 id="Menu-Attribute"><a href="#Menu-Attribute" class="headerlink" title="Menu Attribute"></a>Menu Attribute</h4><p>router：是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转</p><p>background-color：菜单的背景色（仅支持 hex 格式）#ffffff</p><p>text-color：菜单的文字颜色（仅支持 hex 格式）</p><p>active-text-color：当前激活菜单的文字颜色（仅支持 hex 格式）</p><p>default-active：当前激活菜单的 index</p><p>unique-opened：是否只保持一个子菜单的展开</p><h3 id="Table-表格"><a href="#Table-表格" class="headerlink" title="Table 表格"></a>Table 表格</h3><h4 id="Table-column-Attributes"><a href="#Table-column-Attributes" class="headerlink" title="Table-column Attributes"></a>Table-column Attributes</h4><ul><li>type：设置 <code>index</code> 则显示该行的索引（从 1 开始计算）；设置 <code>expand</code> 则显示为一个可展开的按钮；</li></ul><p>设置了 <code>selection</code> 则显示多选框</p><ul><li>自定义索引 <code>index</code>：如果设置了 <code>type=index</code>，可以通过传递 <code>index</code> 属性来自定义索引，属性传入数字时，将作为索引的起始值。传入方法是，它提供当前行的行号（从 <code>0</code> 开始）作为参数，返回值将作为索引展示。</li></ul><p><code>type=&quot;index&quot; :index=&quot;indexMethod&quot;</code> <code>indexMethod(index) {return index}</code></p><h3 id="Radio-单选框"><a href="#Radio-单选框" class="headerlink" title="Radio 单选框"></a>Radio 单选框</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-radio v-model=&quot;radio&quot; label=&quot;1&quot;&gt;备选项&lt;/el-radio&gt;</span><br><span class="line">&lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;备选项&lt;/el-radio&gt;</span><br></pre></td></tr></table></figure><p>选中意味着变量的值为相应 <code>label</code> 属性的值，<code>label</code>可以是<code>String</code>、<code>Number</code>或<code>Boolean</code>。</p><h4 id="禁用状态"><a href="#禁用状态" class="headerlink" title="禁用状态"></a>禁用状态</h4><p>设置<code>disabled</code>属性<code>true</code>为禁用</p><h4 id="单选框组"><a href="#单选框组" class="headerlink" title="单选框组"></a>单选框组</h4><p>结合 el-radio-group 元素和子元素 el-radio 可以实现单选组，在 el-radio-group 中绑定 v-model，在 el-radio 中设置好 label 即可，无需再给每一个 el-radio 绑定变量，另外，还提供了 change 事件来响应变化，它会传入一个参数 value</p><h4 id="Radio-Events"><a href="#Radio-Events" class="headerlink" title="Radio Events"></a>Radio Events</h4><p>change：绑定值变化时触发的事件 选中的 Radio label 值</p><h3 id="Cascader-级联选择器"><a href="#Cascader-级联选择器" class="headerlink" title="Cascader 级联选择器"></a>Cascader 级联选择器</h3><h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>options：可选项数据源，键名可通过 <code>props</code> 属性配置</p><p>props：配置选项，对象</p><p>​ value：指定选项的值为选项对象的某个属性值</p><p>​ label：指定选项标签为选项对象的某个属性值</p><p>​ children：指定选项的子选项为选项对象的某个属性值</p><h3 id="Upload-上传"><a href="#Upload-上传" class="headerlink" title="Upload 上传"></a>Upload 上传</h3><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><ul><li><p>action: 必选参数，上传的完整地址</p></li><li><p>multiple: 是否支持多选文件</p></li><li><p>:on-preview: 点击文件列表中已上传的文件时的钩子 function(file)</p></li><li><p>:on-remove: 文件列表移除文件时的钩子 function(file, fileList)</p></li><li><p>list-type: 文件列表的类型</p></li><li><p>:before-upload: 对文件校验 function(file)，若返回 false 或者返回 Promise 且被 reject，则停止上传</p></li><li><p>:on-success: 文件上传成功时的钩子 function(response, file, fileList)</p></li></ul><p>​ response：参数一， 接口的响应结；file：参数二， 文件对象；fileLIst：参数三，文件对象列表</p><p>​ 自定义参数 <code>:on-success=&quot;(res, file, fileList) =&gt; UploadImg(1, res, file, fileList)&quot;</code></p><ul><li><p>headers: 设置上传的请求头部 object</p></li><li><p>:auto-upload=”false”：手动调用<code>this.$refs.upload.submit()</code>上传</p></li><li><p>on-progress: 文件上传时的钩子 function(event, file, fileList)</p></li></ul><h3 id="Steps-步骤条"><a href="#Steps-步骤条" class="headerlink" title="Steps 步骤条"></a>Steps 步骤条</h3><p>active 设置当前激活步骤 number</p><p>设置<code>active</code>属性，接受一个<code>Number</code>，表明步骤的 index，从 0 开始</p><h3 id="Tabs-标签页"><a href="#Tabs-标签页" class="headerlink" title="Tabs 标签页"></a>Tabs 标签页</h3><h4 id="Tabs-Attributes"><a href="#Tabs-Attributes" class="headerlink" title="Tabs Attributes"></a>Tabs Attributes</h4><p>value / v-model 绑定值，选中选项卡的 name string — 第一个选项卡的 name</p><p>tab-position 选项卡所在位置 string top/right/bottom/left top</p><h4 id="Tabs-Events"><a href="#Tabs-Events" class="headerlink" title="Tabs Events"></a>Tabs Events</h4><p>tab-click tab 被选中时触发 被选中的标签 tab 实例</p><h3 id="element-中的-Events-和-Methods"><a href="#element-中的-Events-和-Methods" class="headerlink" title="element 中的 Events 和 Methods"></a>element 中的 Events 和 Methods</h3><p>// 假设有个 el-box ,如果看文档,有个 Events 和 Methods<br><el-box></el-box></p><p>// Events<br>close</p><p>// Methdos<br>getData</p><p>// 使用<br>&lt;el-box ref=’box’ @close=’函数名自己写’&gt;</p><p>this.$refs.box.getData()</p><h3 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h3><p>打包 : npm run build<br>把打好的包放到 http-server 里面</p><p>介绍 vendor : 里面放一些第三方包 vue/vue-router/element-ui 包等</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化 :"></a>优化 :</h4><ul><li><p>按需加载</p></li><li><p>首屏加载时间，是衡量一个网站性能快慢的很重要的一个指标</p></li><li><p>如何提高加载速度呢?</p></li></ul><p>只加载首屏中看到的内容，没有看到的内容都不加载，需要用到的时候，再去加载<br>进来减少首屏的请求次数</p><ul><li>vue 项目打包的时候，如何实现按需加载功能 ?</li></ul><p>vue 的异步组件(路由) 配合 webpack 代码分割的功能实现按需加载功能</p><p>路由懒加载：<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'Home.vue'</span></span><br><span class="line">==&gt;</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'Home.vue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个组件打包在一起</span></span><br><span class="line"><span class="keyword">const</span> Goods = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'goods' */</span> <span class="string">'Goods.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> GoodsAdd = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'goods' */</span> <span class="string">'GoodsAdd.vue'</span>)</span><br></pre></td></tr></table></figure><ul><li>CDN</li></ul><p>在 index.html 引入 CDN 提供的文件</p><p>在 webpack.base.conf.js 中配置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  <span class="comment">// 键：表示 导入包语法 from 后面跟着的名称</span></span><br><span class="line">  <span class="comment">// 值：表示 script 引入JS文件时，在全局环境中的变量名称</span></span><br><span class="line">  vue: <span class="string">'Vue'</span>,</span><br><span class="line">  <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">  axios: <span class="string">'axios'</span>,</span><br><span class="line">  <span class="string">'element-ui'</span>: <span class="string">'ELEMENT'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 index.html 引入 css 文件就不需要在 main.js 中引入了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue&quot;&gt;&lt;a href=&quot;#vue&quot; class=&quot;headerlink&quot; title=&quot;vue&quot;&gt;&lt;/a&gt;vue&lt;/h2&gt;&lt;p&gt;组件抽离&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
      <category term="vue" scheme="https://cuilongjin.top/tags/vue/"/>
    
      <category term="element" scheme="https://cuilongjin.top/tags/element/"/>
    
  </entry>
  
  <entry>
    <title>Vue 生命周期</title>
    <link href="https://cuilongjin.top/2019/vue/vue-lifecycle/"/>
    <id>https://cuilongjin.top/2019/vue/vue-lifecycle/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-13T12:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" rel="noopener">生命周期</a></p><p>下图展示了实例的生命周期。你不需要立马弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。</p><p><img src="lifecycle.png" alt title=":no-zoom"></p><p><img src="Vue%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE.png" alt title=":no-zoom"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
      <category term="vue" scheme="https://cuilongjin.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="https://cuilongjin.top/2019/vue/vuex/"/>
    <id>https://cuilongjin.top/2019/vue/vuex/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-19T11:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="vuex-是什么"><a href="#vuex-是什么" class="headerlink" title="vuex 是什么?"></a>vuex 是什么?</h2><ul><li>状态管理工具</li><li>状态即数据，状态管理就是管理组件中的 data(数据)</li><li>Vuex 中的状态管理工具采用 <code>集中式</code> 统一管理项目中组件之间需要通讯的数据</li><li>最佳实践：只将组件之间共享的数据放在 vuex 中，而不是将所有的数据都放在 vuex 中，也就是如果数据只是在组件内部使用的，这个数据应该放在组件中，而不要放在 vuex</li><li>vuex 中的数据也是响应式的，如果一个组件中修改了 vuex 中的数据，另外一个使用的 vuex 数据的组件，就会自动更新</li><li>任何组件中都可以直接获取 vuex</li><li>前端状态该管理的思想最早是由 react 团队提出来的，就是 Flux(思想以及具体的实现)</li><li>前端状态管理工具 : Flux / Redux / Mobx / vuex 等等</li></ul><h2 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用?"></a>什么时候用?</h2><ul><li>项目体量很小，不需要使用 vuex，如果项目中组件通讯不复杂，也不需要使用 vuex</li><li>写项目的时候，发现组件通讯多，组件之间的关系复杂，项目已经无法继续开发了，此时就应该使用 vuex</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>安装 : <code>npm i vuex</code></li><li>导入 vuex</li><li>创建 vuex 示例</li></ul><h2 id="vuex-中的概念"><a href="#vuex-中的概念" class="headerlink" title="vuex 中的概念"></a>vuex 中的概念</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li>状态 , 状态即数据</li><li>状态是由 store 提供的</li><li>状态也是响应的</li><li>推荐通过 mutations 中提供的方法去修改数据，因为在严格模式下不允许在 mutation 外部修改 state 下的数据，否则会报错</li></ul><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><ul><li>作用：提供修改 state 的状态数据的方法</li><li>只要想改变 state 中的状态数据，就应该在 mutations 中提供一个方法来修改，接受 <code>state</code> 作为第一个参数（如果定义在模块中，则为模块的局部状态），<code>payload</code> 作为第二个参数（可选）</li><li>通过 <code>$store.commit(&#39;方法名&#39;)</code> 调用 mutations 中的方法</li><li>传参数的话，紧挨着方法名后面继续传就可以了，推荐传入一个对象（payload 即可）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addTodo () &#123;</span><br><span class="line">    <span class="comment">// commit =&gt; 找 mutations</span></span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'addTodo'</span>, &#123;</span><br><span class="line">      todoName: <span class="keyword">this</span>.todoName</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  addTodo (state, playload) &#123;</span><br><span class="line">    state.list.push(playload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>提供异步修改 state 的状态数据的方法</p><p>处理函数总是接受 <code>context</code> 作为第一个参数，<code>payload</code>作为第二个参数（可选）</p><p>通过 <code>$store.dispatch(&#39;方法名&#39;)</code> 调用 actions 中的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addTodo () &#123;</span><br><span class="line">    <span class="comment">// 异步: 分发 dispatch  =&gt; actions</span></span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'addTodoAsync'</span>, &#123;</span><br><span class="line">      todoName: <span class="keyword">this</span>.todoName</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  addTodoAsync (context, playload) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">'addTodo'</span>, playload)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>可以认为是 store 的计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</p><p>getter 接受 state 作为其第一个参数，Getter 也可以接受其他 getter 作为第二个参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：<code>store.getters.doneTodos</code></p><h2 id="vue-和-vuex-的配合使用"><a href="#vue-和-vuex-的配合使用" class="headerlink" title="vue 和 vuex 的配合使用"></a>vue 和 vuex 的配合使用</h2><ol><li>实例 vue 和实例 store</li><li>一定要把 store 挂在到 vue 上</li><li>读取</li></ol><ul><li>组件读取:<code></code></li><li>js 读取: <code>this.$store.state.count</code></li><li>js 操作: 在 mutations 里放一个方法，在方法里修改</li><li>js 中触发这个方法 <code>this.​$store.commit(&#39;addCount&#39;, { num : 8})</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h1&gt;&lt;h2 id=&quot;vuex-是什么&quot;&gt;&lt;a href=&quot;#vuex-是什么&quot; class=&quot;headerlink&quot; title=&quot;v
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
      <category term="vue" scheme="https://cuilongjin.top/tags/vue/"/>
    
      <category term="vuex" scheme="https://cuilongjin.top/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="https://cuilongjin.top/2019/vue/vue/"/>
    <id>https://cuilongjin.top/2019/vue/vue/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-03-21T18:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><ul><li><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue 中文网</a></p></li><li><p><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">github 下载地址</a></p></li><li><p>Vue.js (读音 /vju:/ view)</p></li><li><p>渐进式 JavaScript 框架</p><ul><li><p>渐进式：小型项目使用 vue 就够了，随着页面的复杂程度提高，就要学习 vue-rouer 来管理更多的页面，再随着项目的数据越来越多，管理数据也变得麻烦起来了，就开始使用 vuex 来管理数据</p></li><li><p>框架 : 一整套的解决方案</p></li></ul></li></ul><h2 id="框架和库的区别"><a href="#框架和库的区别" class="headerlink" title="框架和库的区别"></a>框架和库的区别</h2><h3 id="库-Library-，代表-jquery"><a href="#库-Library-，代表-jquery" class="headerlink" title="库(Library) ，代表 : jquery"></a>库(Library) ，代表 : jquery</h3><ul><li>库就是一系列函数的集合，我们开发人员在使用库的时候，想要完成什么样的功能，就调用库中提供的某个方法</li></ul><p>比如：想要添加样式，就调用 jquery 中的 .css() / .addClass()</p><ul><li>库起到了一个辅助的作用，在使用库的是时候，是由开发人员说了算，也是由开发人员起主导作用</li></ul><h3 id="框架-Framework-，代表-vue"><a href="#框架-Framework-，代表-vue" class="headerlink" title="框架 (Framework)，代表 : vue"></a>框架 (Framework)，代表 : vue</h3><ul><li><p>在使用框架的时候，是由框架说了算，由框架起到了主导作用</p></li><li><p>框架是一套完整的解决方案，框架中制定了一套规则，使用框架的时候，只需要按照规则把代码放到合适的地方，然后框架会在合适的时机，主动调用开发人员的代码</p></li></ul><p>比如 : 想用vue组件里遍历就得使用 v-for，使用 for 不行</p><h3 id="主要区别：控制反转"><a href="#主要区别：控制反转" class="headerlink" title="主要区别：控制反转"></a>主要区别：控制反转</h3><blockquote><p>也就是 : 谁起到了主导作用</p></blockquote><ul><li><p>使用库的时候：开发人员起主导作用</p></li><li><p>使用框架的时候：框架起到了主导作用</p></li><li><p>从体量上看，框架一般比库大</p></li><li><p>会发现使用框架的时候，会受到很多限制</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/26078359?group_id=830801800406917120" target="_blank" rel="noopener">我们所说的前端框架与库的区别？</a></p></li></ul><h2 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC + MVVM"></a>MVC + MVVM</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><ol><li><p>MVC 是一种软件架构模式，也有人叫做设计模式</p></li><li><p>M : Model 数据模型 (专门用来操作数据，数据的 CRUD)</p></li><li><p>V : View 视图 (对于前端来说就是页面)</p></li><li><p>C : Controller 控制器 (是视图和数据模型沟通的桥梁，用于处理业务逻辑)</p></li></ol><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><blockquote><p>Vue 使用的是 MVVM 模式</p></blockquote><ul><li><p>MVVM ===&gt; M / V / VM</p></li><li><p>M : model 数据层</p></li><li><p>V : view 视图层</p></li><li><p>VM : ViewModel 视图模型</p></li><li><p>核心 : M &lt;===&gt; VM &lt;===&gt; V</p></li></ul><h3 id="MVVM-优势"><a href="#MVVM-优势" class="headerlink" title="MVVM 优势"></a>MVVM 优势</h3><ul><li><p>MVC 模式将应用程序划为三个部分，实现职责分离</p><ul><li><p>但是，在前端中，经常要通过 js 代码来进行一些逻辑操作，最终还要把这些逻辑操作展示页面中，也需要<code>频繁的操作DOM</code></p></li><li><p>比如 : ajax 请求、添加、修改、设置样式、动画</p></li></ul></li><li><p>MVVM 的思想通过 <code>数据双向绑定</code> 让数据自动的双向同步</p><ul><li><p>V (修改视图) –&gt; M</p></li><li><p>M (修改数据) –&gt; V</p></li></ul></li><li><p>采用的是 : <strong>数据驱动视图</strong>的思想，<strong>数据是核心</strong>。不要再想着怎么操作 DOM，而是想着如何操作数据</p></li></ul><h3 id="Vue-中的-MVVM"><a href="#Vue-中的-MVVM" class="headerlink" title="Vue 中的 MVVM"></a>Vue 中的 MVVM</h3><ul><li>注意 : 不推荐直接手动操作 DOM</li></ul><blockquote><p>每个人操作 DOM 的方法不一样，会造成性能不一样<br>官网 : 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例</p></blockquote><h2 id="Vue-基本使用"><a href="#Vue-基本使用" class="headerlink" title="Vue 基本使用"></a>Vue 基本使用</h2><ol><li><p>安装 : <code>npm i vue</code></p></li><li><p>导入 : <code>&lt;script src=&#39;./vue.js&#39;&gt;&lt;/script&gt;</code></p></li><li><p>实例化 vue</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 指定 vue 管理的边界，不能是 body 或 html 节点</span></span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  <span class="comment">// 提供视图中需要的数据</span></span><br><span class="line">  <span class="comment">// 视图可以直接使用 data 中的数据</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">'xxx'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>使用 vm 表示 vue 实例</p><p>Vue 构造函数首字母大写</p><p>参数是一个对象</p><p>id=’#app’，其他也可以</p><p>边界外无法使用 msg</p><h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &#123;&#123;&#125;&#125; : mustache 语法，小胡子语法，插值表达式</span><br><span class="line">2. 作用 : 使用`&#123;&#123;&#125;&#125;` 从`data`中获取数据，并展示在模板中</span><br><span class="line">3. 说明 : `&#123;&#123;&#125;&#125;` 中只能出现 js 表达式</span><br><span class="line">4. `&#123;&#123;&#125;&#125;` 语法不能作用在 HTML 元素的属性上</span><br></pre></td></tr></table></figure><p>表达式 (有返回值的)：</p><ul><li>基本的数据类型 <code>1 &#39;abc&#39; false [] {}</code></li><li>数据类型 和 运算符结合在一起<code>1+2 arr.join(&#39;-&#39;) true ? 123 : 321</code></li></ul><p>语句： <code>if 语句 for 语句</code></p><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><h3 id="input-v-model"><a href="#input-v-model" class="headerlink" title="input + v-model"></a>input + v-model</h3><p> v-model 指令：数据双向绑定的指令</p><ul><li>作用：把 data 中的 num 值 和 input 上的值绑定到一起，一方的值发生了改变，另 一方也会跟着改变</li><li>注意：v-model 只能用在表单控件上（input checkbox 等）</li></ul><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"><span class="comment">// 参数1：要给哪个对象设置属性</span></span><br><span class="line"><span class="comment">// 参数2：给对象设置什么属性</span></span><br><span class="line"><span class="comment">// 参数3：属性的修饰符</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'赋值了'</span>, newVal)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'取值了'</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据双向绑定的原理"><a href="#数据双向绑定的原理" class="headerlink" title="数据双向绑定的原理"></a>数据双向绑定的原理</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function (newVal) &#123;</span><br><span class="line">    <span class="comment">// 设置属性时会触发该函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'设置'</span>, newVal)</span><br><span class="line">    temp = newVal</span><br><span class="line">    input.value = newVal</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>: function () &#123;</span><br><span class="line">    <span class="comment">// 获取属性时会触发该函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'获取'</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">input.oninput = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(this.value)</span></span><br><span class="line">  obj.name = <span class="keyword">this</span>.value</span><br><span class="line">  <span class="built_in">console</span>.log(obj.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><p>检测变化注意：受现代 JavaScript 的限制 (而且 <code>Object.observe</code> 也已经被废弃)，Vue <strong>不能检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性必须在 <code>data</code> 对象上存在才能让 Vue 转换它，这样才能让它是响应的</p><p><strong>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性</strong>，可以使用 <code>Vue.set(object, key, value)</code> 方法将响应属性添加到嵌套的对象上，或者创建一个包含原对象属性和新属性的对象替换掉原对象</p><h3 id="列表渲染数组更新检测"><a href="#列表渲染数组更新检测" class="headerlink" title="列表渲染数组更新检测"></a>列表渲染数组更新检测</h3><p>数组的方法可以触发视图更新：方法如下：</p><p><code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code></p><p>替换数组</p><p>用一个含有相同元素的数组去替换原来的数组并不会导致 Vue 丢弃现有 DOM 并重新渲染整个列表</p><p>注意：由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p><ol><li>当你利用索引直接设置一个项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><p>解决第一类问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure><p>解决第二类问题：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><h2 id="指令学习"><a href="#指令学习" class="headerlink" title="指令学习"></a>指令学习</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>指令：就是一个特殊的标记，起一个辅助作用，使 html 具备原来没有的功能</li><li>vue 中所有的指令都是以 <code>v-</code> 开头的，比如 : v-model v-bind v-if v-for 等等</li></ul><h3 id="v-model-常用"><a href="#v-model-常用" class="headerlink" title="v-model (常用)"></a>v-model (常用)</h3><blockquote><p>说明：用在<code>表单</code>元素中，用来实现<code>数据双向绑定</code> (input checkbox 等等)<br>作用：将 <code>数据</code> 和 <code>文本框的值</code> 绑定到一起，任何一方发生改变，都会引起对方的改变<br>注意：v-model 在不同类型的表单元素中作用不同<br><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 的初始值而总是将 Vue 实例的数据作为数据来源</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 文本输入框 绑定的是值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"num"</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 多选框  绑定的选中状态 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"isChecked"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    num: <span class="number">0</span>,</span><br><span class="line">    isChecked: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-text-和-v-html"><a href="#v-text-和-v-html" class="headerlink" title="v-text 和 v-html"></a>v-text 和 v-html</h3><blockquote><p>说明 : 设置文本内容</p></blockquote><p>v-text :  相当于之前的 innerText</p><p>v-html :  相当于之前的 innerHTML，会解析 html 标签，（已经废弃三大括号的插值）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">"msg1"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-html</span>=<span class="string">"msg2"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg1: <span class="string">'&lt;a href="#"&gt;haha&lt;/a&gt;'</span>,</span><br><span class="line">    msg2: <span class="string">'&lt;a href="#"&gt;haha&lt;/a&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-bind-常用"><a href="#v-bind-常用" class="headerlink" title="v-bind (常用)"></a>v-bind (常用)</h3><blockquote><p>说明：动态绑定数据 (单向)<br>出现原因：在 HTML 属性中，无法使用插值表达式</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"href"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-bind 可以直接省略 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"href"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-bind：</span></span><br><span class="line"><span class="comment">// 说明：动态数据绑定 (单向)，因为html的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据, 需要使用 v-bind</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    href: <span class="string">'https://www.baidu.com'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="v-bind-和-v-model-的区别"><a href="#v-bind-和-v-model-的区别" class="headerlink" title="v-bind 和 v-model 的区别"></a>v-bind 和 v-model 的区别</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-model 数据双向绑定 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--场景：表单元素中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"isChecked1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  v-bind 数据动态绑定 (单向) --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--场景：主要用在属性中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">:checked</span>=<span class="string">"isChecked2"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 操作样式 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1. 动态添加类，但不符合vue数据是核心的思想 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">"cls"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 2. class值是一个对象 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性名为类名 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性值为布尔值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:class</span>=<span class="string">"&#123;red: isRed, fz: isFz&#125;"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 3. style --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">:style</span>=<span class="string">"&#123;backgroundColor: 'red', fontSize: fz + 'px'&#125;"</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-bind :</span></span><br><span class="line"><span class="comment">// 说明 : 动态数据绑定 (单向)，因为html的`属性`不能使用&#123;&#123;&#125;&#125; 来动态的读取数据 , 需要使用 v-bind</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    href: <span class="string">'https://www.baidu.com'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其他操作</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"['red', 'fz']"</span>&gt;</span>heheheh<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ===&gt; &lt;div class="red fz"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 多个样式对象写成数组的形式，如果有相同样式后面会覆盖前面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[&#123;red: true&#125;, 'fz']"</span>&gt;</span>hehehe<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ===&gt; &lt;div class="red fz"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><blockquote><p>注册事件/绑定事件</p></blockquote><ol><li><p>v-on:click 绑定了一个 click 事件</p></li><li><p>缩写 : @click=’fn’</p></li><li><p>函数写在 <code>methods</code> 里面</p></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"fn"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 简写 @ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn1"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传参 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn2(123)"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-on 注册事件</span></span><br><span class="line"><span class="comment">// v-on:click =&gt; 绑定点击事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 事件函数写在 methods 中</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'haha'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn1 () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'haha'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn2 (ref) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(ref)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="4"><li>函数里面的 this 指的就是 vm 实例</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span> === vm <span class="comment">// true</span></span><br><span class="line"><span class="keyword">this</span>.msg <span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">this</span>.msg = <span class="string">'XXX'</span> <span class="comment">// 修改数据</span></span><br></pre></td></tr></table></figure><ol start="5"><li>事件对象 $event</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定事件对象的时候, 没有添加小括号，此时，直接在方法中，通过参数 e 就可以获取到事件对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果绑定事件的地方,事件函数有()  @click='fn()' 则需要通过 $event 获取 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"fn1($event, 123)"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;,</span><br><span class="line">    fn1 (e, ref) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">      <span class="built_in">console</span>.log(ref)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>遍历数据，为数据中的每一项生成一个指令所在的标签</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1: 最常用 遍历数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in list1"</span>&gt;</span>&#123;&#123; item &#125;&#125; - &#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2: 遍历元素是对象的数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in list2"</span>&gt;</span>&#123;&#123; item.name &#125;&#125; - id:&#123;&#123; item.id &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3: 遍历对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- item 是 属性值，key 是属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, key) in obj"</span>&gt;</span>&#123;&#123; item &#125;&#125;-&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4: 生成10个h1 （item是1-10）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-for</span>=<span class="string">"item in 10"</span>&gt;</span>我是h1 &#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="headerlink" title="v-if 和 v-show"></a>v-if 和 v-show</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">'isShow'</span>&gt;</span>我是h1 v-if<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">'isShow'</span>&gt;</span>我是h1 v-show<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-if 和 v-show 的异同点：</p><ul><li><p>相同点: 可以切换元素的显示与隐藏</p></li><li><p>不同点: 切换显示和隐藏的实现不同</p><ul><li>v-if：显示：创建节点；隐藏：删除节点</li><li>v-show：显示：display:block；隐藏： display:none</li></ul></li><li><p>使用场景 :</p><ul><li>v-if 因为要不断的创建和删除来切换显示与隐藏，所以性能不高</li><li>v-if：切换次数不频繁的时候</li><li>v-show：切换次数频繁的时候</li></ul></li></ul><h3 id="v-else-if-和-v-else"><a href="#v-else-if-和-v-else" class="headerlink" title="v-else-if 和 v-else"></a>v-else-if 和 v-else</h3><ul><li>v-else：两种情况的</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"num &gt; 40"</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>v-else-if：三种以上情况</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"num &gt;= 40"</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else-if</span>=<span class="string">"num &gt;= 30 &amp;&amp; num &lt; 40"</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><p>作用：告诉 vue 这个标签中的内容只需要解析一次，即便是数据再发送改变，这个标签中的内容也不会被更新</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>带 onece 的 &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><p>作用：告诉 vue 这段节点中没有指令或表达式，不需要解析，从而，提升性能</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span>带 v-pre &#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><p>使用遮盖</p><ul><li><p>给要遮盖的元素添加一个 v-cloak 指令：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用属性选择器，添加样式：<code>[v-cloak] { display: none }</code></p></li><li><p>vue 会在解析模板后将 v-cloak 指令从页面中移除，移除指令的时候，差值表达式已经变为对应的数据</p></li></ul><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符</p><p> Vue 为最常用的按键提供了别名：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>全部的按键别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。</p><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li><li><code>.passive</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p><h2 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h2><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h3><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>写起来像一个方法，用起来像一个属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fn () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：只有跟计算属性相关的数据发生了改变，计算属性才会重新计算<br>注意点:</p><ul><li><p>计算属性必须返回一个值</p></li><li><p>计算属性只能当属性用，不能当方法用</p></li><li><p>不能和 data 中的属性名重名</p></li></ul><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。它的工作方式类似于一个属性，所以你需要用 <code>v-bind</code> 来绑定动态值</p><p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升</p><ul><li><code>就地复用</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">  &#123;&#123;item.name&#125;&#125; <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据 --&gt;</span></span><br><span class="line">data: &#123;list: [&#123;id: 1, name: 'zs'&#125;, &#123;id: 2, name: 'ls'&#125;, &#123;id: 3, name: 'ww'&#125;]</span><br><span class="line"><span class="comment">&lt;!-- 演示  --&gt;</span></span><br><span class="line">vm.list.unshift(&#123;id:4, name:'zl'&#125;)</span><br></pre></td></tr></table></figure><ul><li>使用 key<ul><li>如果数组的元素是一个对象，使用对象里固定属性，一般情况下，对象里都有 id</li><li>如果数组的元素是一个简单类型，不是一个对象，就可以取索引作为 key</li></ul></li></ul><h2 id="异步-DOM-更新"><a href="#异步-DOM-更新" class="headerlink" title="异步 DOM 更新"></a>异步 DOM 更新</h2><ol><li>Vue 中采用了 <code>异步DOM更新</code> 的机制</li><li>数据发生改变后，vue 没有立即将数据的改变更新到视图中，而是等到数据不再变化的时候 一次性的将数据的改变更新到视图中</li></ol><p>为什么是异步 DOM 更新?</p><ul><li>性能的考虑</li><li>因为对于前端来说，修改数据进行 DOM 操作是常有的事情，如果频繁操作 DOM，会严重影响页面的加载性能</li><li>DOM 操作这是前端的性能的瓶颈</li><li>比如 : for (let i = 1; i &lt; 10000; i++&gt;) 如果同步 就要重新渲染 1000 次</li></ul><p>验证异步 DOM 更新：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过dom来获取count的值</span></span><br><span class="line"><span class="comment">// this.$el ==&gt; vue 边界元素</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.count = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>需求：在数据更新后，立即获取到更新后的内容</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 更新后，会执行 this.$nextTick() 的回调函数，所以能拿到值</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.children[<span class="number">0</span>].innerText) <span class="comment">// 100</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="监听-watch"><a href="#监听-watch" class="headerlink" title="监听 watch"></a>监听 watch</h2><p>vue 中可以通过 watch 配置项来监听 vue 实例中数据的变化</p><ul><li>基本使用</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  num: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//  监听</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 监听 num 属性的数据变化</span></span><br><span class="line">  <span class="comment">// 作用: 只要 num 的值发生变化，这个方法就会被调用</span></span><br><span class="line">  <span class="comment">// 第一个参数: 新值</span></span><br><span class="line">  <span class="comment">// 第二个参数: 旧值</span></span><br><span class="line">  num (newVal, oldVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'新:'</span>, newVal)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'旧:'</span>, oldVal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>监听对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  msg: <span class="string">''</span>,</span><br><span class="line">  obj: &#123;</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 监听对象</span></span><br><span class="line">  obj (newVal) &#123;</span><br><span class="line">    <span class="comment">// 虽然 obj 中的属性值发生改变了，但 obj 引用的地址没有发生改变，所以不会触发事件</span></span><br><span class="line">    <span class="built_in">console</span>.log(newVal)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 监听对象的属性</span></span><br><span class="line">  <span class="comment">// 从对象的角度来监听的</span></span><br><span class="line">  obj: &#123;</span><br><span class="line">    <span class="comment">// 深度监听 监听对象里面的属性</span></span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页面刚进入立即触发监听，以表达式的当前值触发回调</span></span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象里的属性值发生变化，调用 handler 方法</span></span><br><span class="line">    handler (newVal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.msg = <span class="string">`obj.age 值变化了，新值：<span class="subst">$&#123;newVal.age&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 从属性的角度来监听</span></span><br><span class="line">  <span class="string">'obj.age'</span> (newVal) &#123;</span><br><span class="line">    <span class="keyword">this</span>.msg = <span class="string">`obj.age 值变化了，新值：<span class="subst">$&#123;newVal&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用案例：需求 : 监听文本框字符个数，并显示格式验证码</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"val"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">'isTrue'</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  val: <span class="string">''</span>,</span><br><span class="line">  msg: <span class="string">'请输入 6-12 位'</span>,</span><br><span class="line">  isTrue: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  val (newVal) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^[0-9a-zA-z]&#123;6,12&#125;$/</span>.test(newVal)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.isTrue = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.isTrue = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><ul><li>所有的 vue 组件，都是 vue 实例，一个组件对应一个实例，并且接收相同的选项对象（一些根实例特有的选项除外）</li><li>实例生命周期也叫做：组件生命周期</li><li>声明周期图：<a href="/zh-cn/_vue/Vue实例生命周期图">01</a></li></ul><h3 id="生命周期介绍"><a href="#生命周期介绍" class="headerlink" title="生命周期介绍"></a>生命周期介绍</h3><p><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">vue 生命周期钩子函数</a></p><ul><li>简单说：一个组件（实例）从开始到最后消化所经历的各种状态，就是一个组件的生命周期</li><li>生命周期钩子函数的定义：从组件被创建，到组件挂在到页面上运行，再到页面关闭组件被销毁，这三个阶段总是伴随着组件的各种事件，这些事件，统称为组件的生命周期函数（简称 : 钩子函数）</li><li>开发人员可以通过 vue 提供的钩子函数，让我们写的代码参与到 vue 的生命周期里面来，让我们的代码在合适的阶段起到相应的作用</li></ul><p>注意：</p><ul><li>vue 在执行过程中会 <strong>自动调用</strong> <code>生命周期钩子函数</code>，我们只需要提供这些钩子函数即可</li><li>钩子函数的名称都是  vue 中规定好的</li></ul><p><a href="https://segmentfault.com/a/1190000008879966" target="_blank" rel="noopener">vue 实例生命周期 参考 1</a></p><p><a href="https://segmentfault.com/a/1190000008010666" target="_blank" rel="noopener">vue 实例生命周期 参考 2</a></p><h3 id="钩子函数-beforeCreate"><a href="#钩子函数-beforeCreate" class="headerlink" title="钩子函数 - beforeCreate"></a>钩子函数 - beforeCreate</h3><ul><li>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li><li>此时组件的选项还未挂载，因此无法访问 methods，data，computed 上的方法或数据</li><li>使用场景 : 几乎不用</li></ul><h3 id="钩子函数-created-掌握"><a href="#钩子函数-created-掌握" class="headerlink" title="钩子函数 - created (掌握)"></a>钩子函数 - created (掌握)</h3><ul><li>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见</li><li>可以调用 methods 中的方法、改变 data 中的数据，并且修改可以通过 vue 的响应式绑定体现在页面上、获取computed 中的计算属性等</li><li>使用场景：发送 ajax、本地存储获取数据</li></ul><h3 id="钩子函数-beforeMounted"><a href="#钩子函数-beforeMounted" class="headerlink" title="钩子函数 - beforeMounted()"></a>钩子函数 - beforeMounted()</h3><ul><li>在挂载开始之前被调用（挂载：DOM 渲染）</li></ul><h3 id="钩子函数-mounted-掌握"><a href="#钩子函数-mounted-掌握" class="headerlink" title="钩子函数 - mounted() (掌握)"></a>钩子函数 - mounted() (掌握)</h3><ul><li><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</li><li>这个周期可以获取 DOM</li><li>指令的生效在 mounted 周期之前</li><li>在这个周期内，对 data 的改变可以生效。但是要进下一轮的 DOM 更新，DOM 上的数据才会更新</li><li>使用场景：发送 ajax、操作 DOM</li></ul><h3 id="钩子函数-beforeUpdate"><a href="#钩子函数-beforeUpdate" class="headerlink" title="钩子函数 - beforeUpdate()"></a>钩子函数 - beforeUpdate()</h3><ul><li><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程</p></li><li><p>此处获取的数据是更新后的数据，但是获取页面中的 DOM 元素是更新之前的</p><blockquote><p>小提示 : 打印 this.$el ，打开小三角是之后的，是因为打印是有监听的功能，展示的是后面更改之后的</p></blockquote></li></ul><h3 id="钩子函数-updated"><a href="#钩子函数-updated" class="headerlink" title="钩子函数 - updated()"></a>钩子函数 - updated()</h3><ul><li>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</li><li>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作</li><li>应该避免在此期间更改状态。如果要相应状态改变，通常最好使用 <strong>计算属性</strong> 或 <strong>watcher</strong> 取而代之</li></ul><h3 id="钩子函数-beforeDestroy"><a href="#钩子函数-beforeDestroy" class="headerlink" title="钩子函数 - beforeDestroy()"></a>钩子函数 - beforeDestroy()</h3><ul><li>实例销毁之前调用。在这一步，实例仍然完全可用。</li><li>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">this</span>.timerId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1111</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果当组件销毁了,还不清除定时器会出现性能问题</span></span><br><span class="line"> <span class="comment">// 在浏览器中可以尝试销毁 vm.$destroy()</span></span><br><span class="line"> <span class="comment">// 最后销毁</span></span><br><span class="line">beforeDestroy () &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timerId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="钩子函数-destroyed"><a href="#钩子函数-destroyed" class="headerlink" title="钩子函数 - destroyed()"></a>钩子函数 - destroyed()</h3><ul><li>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul><h2 id="使用接口的形式发送数据"><a href="#使用接口的形式发送数据" class="headerlink" title="使用接口的形式发送数据"></a>使用接口的形式发送数据</h2><h3 id="json-server-提供假数据接口"><a href="#json-server-提供假数据接口" class="headerlink" title="json-server 提供假数据接口"></a>json-server 提供假数据接口</h3><ul><li>作用：根据指定的 JSON 文件，提供假数据接口</li><li>地址：<a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">json-server</a></li><li>使用步骤</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 全局安装 json-server: <span class="string">`npm i -g json-server`</span></span><br><span class="line"><span class="number">2.</span> 准备一个json数据</span><br><span class="line"><span class="number">3.</span> 执行：<span class="string">`json-server data.json`</span></span><br><span class="line"></span><br><span class="line">data.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"todos"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">      <span class="string">"age"</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>REST API格式</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 查询：GET</span><br><span class="line"><span class="number">2.</span> 添加：POST</span><br><span class="line"><span class="number">3.</span> 删除：DELETE</span><br><span class="line"><span class="number">4.</span> 更新：</span><br><span class="line">PUT：需要将对象里的所有属性提交</span><br><span class="line">  PATCH(打补丁)：只需要提交需要修改的属性</span><br></pre></td></tr></table></figure><ul><li>具体接口<ul><li>查询全部数据 <a href="http://localhost:3000/todos" target="_blank" rel="noopener">http://localhost:3000/todos</a><br>查询指定数据 <a href="http://localhost:3000/todos/2" target="_blank" rel="noopener">http://localhost:3000/todos/2</a></li><li>添加一个对象 <a href="http://localhost:3000/todos" target="_blank" rel="noopener">http://localhost:3000/todos</a><br>POST<br>id 会自动帮我们添加</li><li>更新数据 <a href="http://localhost:3000/todos/3" target="_blank" rel="noopener">http://localhost:3000/todos/3</a><br>PUT 或者 PATCH<br>PUT 需要提供该对象的所有数据<br>PATCH 只需要提供要修改的数据即可</li><li>删除数据<a href="http://localhost:3000/todos/3" target="_blank" rel="noopener">http://localhost:3000/todos/3</a><br>DELETE</li></ul></li><li>可以借助 <code>postman</code> 测试接口</li></ul><h3 id="axios-发送请求"><a href="#axios-发送请求" class="headerlink" title="axios 发送请求"></a>axios 发送请求</h3><ul><li><strong>作用</strong> : 一个专门用来发送 ajax 请求的库,  可以在浏览器或者node.js 中使用</li><li><strong>使用步骤</strong><ul><li>本地安装 axios : <code>npm i -g axios</code></li><li>导入 axios</li></ul></li><li><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios 使用说明</a></li><li><strong>GTE 方式发送请求</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">axios.get(<span class="string">'http://localhost:3000/todoList/1'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'获取到数据了：'</span>, res.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">axios.get(<span class="string">'http://localhost:3000/todoList'</span>,&#123;</span><br><span class="line">  params : &#123;</span><br><span class="line">    id : <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'获取到数据了：'</span>, res.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><strong>POST 方式发送请求</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// post 请求</span></span><br><span class="line">axios</span><br><span class="line"><span class="comment">// 第一个参数：表示接口地址</span></span><br><span class="line"><span class="comment">// 第二个参数：表示接口需要的参数</span></span><br><span class="line">  .post(<span class="string">'http://localhost:3000/todoList'</span>, &#123;</span><br><span class="line">  name: <span class="string">'haha'</span>,</span><br><span class="line">  done: <span class="literal">true</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><strong>概念 :</strong></p><ul><li>vue 中的过滤器(filter)：<strong>数据格式化</strong>，让数据按照我们规定的格式输出</li><li>比如 : 对于日期来说，将日期格式化转化为 <code>年-月-日 小时:分:秒</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">显示：2019-01-11T10:11:19.566Z</span><br><span class="line">不是我们想要的</span><br><span class="line">我们想要的：2019-01-11 18-11-53</span><br></pre></td></tr></table></figure><p><strong>全局过滤器 和 局部过滤器</strong></p><ul><li>全局方式创建的过滤器，在任何一个 Vue 实例中都可以使用 (一般情况下，为了项目方便管理，都是一个 vue 实例)</li><li>局部创建的过滤器只能在当前 vue 实例中使用</li><li>全局过滤器应在 Vue 实例创建之前创建</li></ul><p><strong>注册全局过滤器</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数：过滤器的名字</span></span><br><span class="line"><span class="comment">// 第二个参数：是一个回调函数，只要使用过滤器的时候，这个回调函数就会执行，res =&gt; 原始数据</span></span><br><span class="line"><span class="comment">// 必须要有返回值：通过回调函数的返回值得到格式化后的数据</span></span><br><span class="line">Vue.filter(<span class="string">'date'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注册局部过滤器</strong></p><p>在 vm 的配置项里写一个 <code>filters</code>，对应的是一个对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  date (res) &#123;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>moment 插件</strong></p><ul><li><p><a href="http://momentjs.cn/" target="_blank" rel="noopener">moment</a></p></li><li><p>使用：<code>npm i moment</code></p></li><li><p>日期 =&gt; 指定格式<code>moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;)</code></p></li><li><p>时间戳 =&gt; 指定格式<code>moment(res).format(&#39;YYYY-MM-DD HH-mm-ss&#39;)</code></p></li><li><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'dataFilter'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> moment(res).format(<span class="string">'YYYY-MM-DD HH-mm-ss'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>使用过滤器</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- data: 原始数据  dataFilter: 过滤器名称  |：管道--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date | dataFilter &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局</span></span><br><span class="line">Vue.filter(<span class="string">'dataFilter'</span>, res =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> moment(res).format(<span class="string">'YYYY-MM-DD HH-mm-ss'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部</span></span><br><span class="line">filters: &#123;</span><br><span class="line">  date (res, format = <span class="string">'YYYY-MM-DD'</span>, arg) &#123;</span><br><span class="line">    <span class="keyword">return</span> moment(res).format(format)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数问题</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; date | dateFilter('YYYY-MM-DD HH-mm-ss', 888) &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.filter(<span class="string">'dateFilter'</span>, (res, format = <span class="string">'YYYY-MM-DD'</span>, arg) =&gt; &#123;</span><br><span class="line">  <span class="comment">// res: 原始数据</span></span><br><span class="line">  <span class="comment">// format：dateFilter 中的第一个参数，等号后面为默认值</span></span><br><span class="line">  <span class="comment">// arg: dateFilter 中的第二个参数</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg) <span class="comment">// 888</span></span><br><span class="line">  <span class="keyword">return</span> moment(res).format(format)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><blockquote><p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常 <strong>可复用</strong> 的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p></blockquote><p><img src="components.png" alt="组件化图释"></p><ul><li>注册组件的两种方式：全局组件、局部组件</li><li>Vue实例中的配置项（如：methods、filters、watch、computed、directives、生命周期钩子函数）都可以在组件中使用</li></ul><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><ul><li>说明：全局组件在所有的 vue 实例中都可以使用</li><li>注意：<ul><li>注册全局组件应放在 vm 实例之前</li><li>模板只允许有一个根节点</li><li>组件中的 <code>data</code> 必须是函数，并且要返回一个对象</li><li>组件复用时如果 data 为对象，所有复用的组件的 data 指向同一片内存空间，一个组件被修改了会影响其他组件，这不是我们想要的</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册全局组件</span></span><br><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;A custom component!&lt;/p&gt;'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'注意：组件的data必须是一个函数！！！'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给组件指定返回值</span></span><br><span class="line"><span class="comment">// 组件名称为 One</span></span><br><span class="line"><span class="keyword">const</span> One = Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;A custom component!&lt;/p&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 可以简写为 ==&gt;</span></span><br><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;A custom component!&lt;/p&gt;'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用：以自定义元素的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染结果 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><ul><li>局部组件是在某一个具体的vue实例（组件）中定义的，只能在当前 vue 实例（组件）中使用</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 局部组件</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// 子组件 com-a</span></span><br><span class="line">    <span class="string">'com-a'</span>: &#123;</span><br><span class="line">      template: <span class="string">`&lt;h1&gt;局部组件：&#123;&#123; num &#125;&#125;&lt;/h1&gt;`</span>,</span><br><span class="line">      data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          num: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组件通讯"><a href="#组件通讯" class="headerlink" title="组件通讯"></a>组件通讯</h3><ul><li>组件是一个独立、封闭的个体</li><li>也就是说：组件中的数据默认情况下，只能在组件内部使用，无法直接在组件外部使用</li><li>可以将 vue 实例看做一个组件</li><li>对于组件之间需要相互使用彼此的情况，应该使用 <strong>组件通讯机制</strong> 来解决</li><li>组件通讯的三种情况 :<ul><li>父组件将数据传递给子组件(父 -&gt; 子)</li><li>子组件将数据传递给父组件 (子 =&gt; 父)</li><li>非父子组件(兄弟组件)</li></ul></li></ul><h4 id="父组件到子组件"><a href="#父组件到子组件" class="headerlink" title="父组件到子组件"></a>父组件到子组件</h4><ul><li>将要传递的数据，通过属性传递给子组件</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:msg</span>=<span class="string">"pmsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子组件通过 <code>props</code> 配置项来指定要接收的数据，props 是一个数组<ul><li>在使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名代替</li><li>如果使用字符串模板，那么这个限制就不存在了</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'msg'</span>]</span><br></pre></td></tr></table></figure><ul><li>传递过来的 <code>props</code> 属性的用法与 <code>data</code> 属性的用法相同</li><li>子组件不能直接修改父组件传过来的数据，可以将父组件传过来的值保存在一个临时变量中<ul><li>如果 props 传过来的数据为引用类型，只要不是重新赋值，修改数据不会报错，但不推荐这样做</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一步：将你要传递的数据,作为属性传递给子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hello</span> <span class="attr">:num</span>=<span class="string">"pnum"</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二部：子组件通过 props 配置项来指定要接收的数据</span></span><br><span class="line">  props: [<span class="string">'num'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="子组件到父组件"><a href="#子组件到父组件" class="headerlink" title="子组件到父组件"></a>子组件到父组件</h4><ul><li>方式：父组件给子组件传递一个函数，由子组件调用这个函数</li><li>说明：借助 vue 中的自定义事件(v-on:cunstomFn=”fn”)</li><li><code>$emit()</code>：触发事件</li><li>第一步：父组件了里准备一个方法</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    pfn (num) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>第二步：把这个方法作为事件传递给子组件</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello</span> @<span class="attr">fn</span>=<span class="string">"pfn"</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>第三步：子组件调用父组件传过来的方法</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;button @click='click'&gt;按钮&lt;/button&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">num</span>: <span class="number">5</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    click () &#123;</span><br><span class="line">      <span class="comment">// 第一个参数：表示要触发的自定义事件名称，也就是 @fn</span></span><br><span class="line">    <span class="comment">// 第二个参数：表示要传递给父组件的数据</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'fn'</span>, <span class="keyword">this</span>.num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="非父子组件通讯"><a href="#非父子组件通讯" class="headerlink" title="非父子组件通讯"></a>非父子组件通讯</h4><ul><li><p>是通过 <code>事件总线 (event bus 公交车) 机制</code> 来实现的</p></li><li><p>事件总线：实际上就是一个 <code>空 Vue 实例</code></p></li><li><p>可以实现任意两个组件之间的通讯而不管两个组件到底有什么样的层级关系</p></li><li><p><code>$emit()</code>：发送数据</p></li><li><p><code>$on()</code>：接收数据</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步：实例化事件总线 bus</span></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发组件 A 中的事件</span></span><br><span class="line">bus.$emit(<span class="string">'id'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件 B 创建的钩子中监听事件</span></span><br><span class="line">bus.$on(<span class="string">'id'</span>, id =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例：组件A —&gt; 组件B</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com-a</span>&gt;</span><span class="tag">&lt;/<span class="name">com-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">com-b</span>&gt;</span><span class="tag">&lt;/<span class="name">com-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步：实例化事件总线 bus</span></span><br><span class="line"><span class="keyword">const</span> bus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 A</span></span><br><span class="line">Vue.component(<span class="string">'com-a'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;h1 @click="click"&gt;组件A&lt;/h1&gt;`</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    click () &#123;</span><br><span class="line">      <span class="comment">// 第二部：发送数据</span></span><br><span class="line">      bus.$emit(<span class="string">'hello'</span>, <span class="string">'你好'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 B</span></span><br><span class="line">Vue.component(<span class="string">'com-b'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;h1&gt;组件B&lt;/h1&gt;`</span>,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">// 第三步：接收数据</span></span><br><span class="line">    bus.$on(<span class="string">'hello'</span>, res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'接收到数据'</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>[开关灯案例]</p><h3 id="单向数据流-组件与组件之间"><a href="#单向数据流-组件与组件之间" class="headerlink" title="单向数据流(组件与组件之间)"></a>单向数据流(组件与组件之间)</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个<code>单向下行绑定</code>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>当 todo-head 中的 todoName 设置数据后回车添加到 todoList，todoList 的长度就会发生变化，然后就会根据(组件与组件之间的)单向数据流，把数据单向下流到子组件中<br>而且必须是通过 props 往下传递的才可以</p><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p> <code>vm.$refs</code> 一个对象，持有已注册过 ref 的所有子组件 ( HTML 元素)</p><ul><li>使用 :</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML元素 中，添加ref属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"div"</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在JS中通过 $refs.属性 来获取</span></span><br><span class="line"><span class="comment">// 在 mounted 函数中使用</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;h1&gt;组件A&lt;/h1&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">num</span>: <span class="number">100</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fn () &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.div) <span class="comment">// div 标签</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child) <span class="comment">// child 组件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果获取的是一个子组件，那么通过 ref 就能获取到子组件中的 <code>data</code> 和 <code>methods</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child.num) <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.child.fn) <span class="comment">// fn</span></span><br></pre></td></tr></table></figure><ul><li>一般在第三方的组件中， 可能会用到这个功能</li></ul><h2 id="单页面应用程序"><a href="#单页面应用程序" class="headerlink" title="单页面应用程序"></a>单页面应用程序</h2><p>SPA : <strong>Single Page Application</strong> 单页面应用程序</p><p>MPA : <strong>Multiple Page Application</strong> 多页面应用程序</p><ul><li>单页 web 应用，就是只有一个 web 页面的应用，是加载单个 HTML 页面，并在用户与应用程序交互时动态更新该页面的 web 应用程序</li></ul><ul><li>区别<ul><li>对于传统的多页面应用程序来说，每次请求服务器返回的都是一个完整的页面</li><li>对于单页应用程序来说，只有第一次会加载页面，以后的每次请求，仅仅是获取必要的数据，然后由页面中js解析获取的数据展示在页面中</li></ul></li></ul><ul><li>优势 :<ul><li>减少了请求体积，加快页面响应速度，降低了对服务器的压力</li><li>更好的用户体验，让用户在 web app 感受 native app 的流畅</li></ul></li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul><li><strong>路由</strong> : 是浏览器 URL 中的<code>哈希值</code>( # hash) 与 <code>展示视图内容</code> 之间的<code>对应规则</code><ul><li>在 web App 中，通过一个页面来展示和管理整个应用的功能。SPA 往往是功能复杂的应用，为了有效管理所有视图内容，前端路由应运而生。简单来说，路由就是一套映射规则(一对一的对应规则)，由开发人员制定规则。当 URL 中的哈希值( <code>#</code> hash) 发生改变后，路由会根据制定好的规则，展示对应的视图内容。</li></ul></li><li><strong>vue 中的路由</strong>；是 <strong>hash</strong> 和 <strong>component</strong> 的对应关系，一个哈希值对应一个组件</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装路由 : <code>npm i vue-router</code></p><p>引入路由</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./node_modules/vue-router/dist/vue-router.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>详细使用步骤</p><ul><li>实例路由对象并挂载到 vue 实例 上</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由实例 与 Vue 实例 关联到一起</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter()</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>入口 (#哈希值)</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">方式1 : url地址为入口 输入url地址改变哈希值</span></span><br><span class="line"><span class="comment">router.html#/one</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方式2 : router-link+to</span></span><br><span class="line"><span class="comment">to 属性：实际上就是哈希值，将来要参与路由规则中进行与组件匹配</span></span><br><span class="line"><span class="comment">router-link 标签最终会转化为 a 标签，to 属性转化为 a 标签的 href 属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/two"</span>&gt;</span>Tow<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注册组件并设置返回值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置规则</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path : 路由路径</span></span><br><span class="line"><span class="comment">// component : 将来要展示的路由组件</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/one'</span>, <span class="attr">component</span>: One&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/two'</span>, <span class="attr">component</span>: Two&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>出口</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  出口：组件要展示的地方--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>示例 ：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 入口 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可以直接通过url地址访问路由 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- to 属性：路由匹配路径</span></span><br><span class="line"><span class="comment">router-link 最终会转化为 a 标签</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/two"</span>&gt;</span>Tow<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 5. 出口 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 注册组件并设置返回值</span></span><br><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实例化路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 4. 配置路由规则，路由和实例一一对应</span></span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/one'</span>, <span class="attr">component</span>: One&#125;,</span><br><span class="line">    &#123;<span class="attr">path</span>: <span class="string">'/two'</span>, <span class="attr">component</span>: Two&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 2. 将路由挂载到 vue 实例上，让 vue 和路由关联在一起</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>多出口情况</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 多个出口的形式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"one"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"two"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> One = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 One&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Two = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;组件 Two&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 配置路由规则，一个路由对应多个实例</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      <span class="comment">// conponents 为一个对象</span></span><br><span class="line">      components: &#123;</span><br><span class="line">        <span class="comment">// key 为出口的 name 属性值</span></span><br><span class="line">        <span class="comment">// value 为组件实例</span></span><br><span class="line">        one: One,</span><br><span class="line">        two: Two</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="入口菜单高亮处理"><a href="#入口菜单高亮处理" class="headerlink" title="入口菜单高亮处理"></a>入口菜单高亮处理</h3><p>点击导航会给链接添加两个类名：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/one"</span> <span class="attr">class</span>=<span class="string">"router-link-exact-active router-link-active"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/two"</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改方式 1：直接修改类的内容</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.router-link-exact-active</span>,</span><br><span class="line"><span class="selector-class">.router-link-active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修饰方式 2：给默认高亮类名设置别名，别名为已经定义好样式的类名 (推荐)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改默认高亮的a标签的类名</span></span><br><span class="line">  linkActiveClass: <span class="string">'red'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="精确匹配和模糊匹配"><a href="#精确匹配和模糊匹配" class="headerlink" title="精确匹配和模糊匹配"></a>精确匹配和模糊匹配</h3><ul><li>精确匹配：router-link-exact-active 类名 : 只有当浏览器地址栏中的哈希值 与 router-link 的 to 属性值完全匹配才会添加该类</li><li>模糊匹配：router-link-active 类名 : 只要浏览器地址栏中的哈希值包含 router-link 的 to 属性值就会添加该类名</li><li>解决办法：加个 exact</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span> <span class="attr">exact</span>&gt;</span></span><br><span class="line">  One</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：精确匹配和模糊匹配，只对添加类名这个机制有效，与路由的匹配规则无关</li></ul><h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><p>入口</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 入口  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/detail/1"</span>&gt;</span>手机1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/detail/2"</span>&gt;</span>手机2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/detail/3"</span>&gt;</span>手机3<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>传参</p><p><a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D" target="_blank" rel="noopener">动态路由匹配</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Detail = Vue.component(<span class="string">'detail'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">routes: [</span><br><span class="line">  <span class="comment">// 方式1：手动一个一个配置</span></span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/1'</span>, <span class="attr">component</span>: Detail&#125;,</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/2'</span>, <span class="attr">component</span>: Detail&#125;,</span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/3'</span>, <span class="attr">component</span>: Detail&#125;，</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确的方式：把传过去的 1/2/3 当成参数</span></span><br><span class="line">  &#123;<span class="attr">path</span>: <span class="string">'/detail/:id?'</span>, <span class="attr">component</span>: Detail&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>?</code> 代表参数可传可不传，即可识别的路径包括：<code>detail</code>、<code>detail/1</code>、<code>detail2</code>、<code>detail3</code></p><p>获取参数的三种正确方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $route =&gt; 路由配置对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Detail = Vue.component(<span class="string">'detail'</span>, &#123;</span><br><span class="line">  <span class="comment">// 方式1：组件中直接读取</span></span><br><span class="line">  <span class="comment">// $route.path 为路由路径</span></span><br><span class="line">  <span class="comment">// $route.params.id 为路由参数</span></span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;div&gt;&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="comment">// 方式2：js直接读取</span></span><br><span class="line">    <span class="comment">// 打印只会打印一次，因为组件是复用的，每次进来钩子函数只会执行一次</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// #/detail/2?name=zs</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route) <span class="comment">// 路由配置对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.path) <span class="comment">// #/detail/2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.params) <span class="comment">// &#123;id: "2"&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.query) <span class="comment">// &#123;name: 'zs'&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$route.params.id) <span class="comment">// 2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 方式3：监听路由的参数变化(因为不是 data 中的数据，不需要深度监听)</span></span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// to：新值</span></span><br><span class="line">    <span class="comment">// from：旧值</span></span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(to.params.id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://router.vuejs.org/zh/guide/essentials/navigation.html#%E7%BC%96%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%AF%BC%E8%88%AA" target="_blank" rel="noopener">编程式导航</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">'123'</span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">'/user'</span>) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象, path为路由的path属性值</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span> &#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由，name 为路由的 name 属性值</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">'user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 如果提供了 path，params 会被忽略</span></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">'register'</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">'private'</span> &#125;&#125;) <span class="comment">// -&gt; /register?plan=private</span></span><br><span class="line"></span><br><span class="line">routes: [&#123; <span class="attr">path</span>: <span class="string">'/user/:id?'</span>, name=<span class="string">'user'</span>, <span class="attr">component</span>: User &#125;]</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><code>redirect</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 / 重定向到 /home</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">redirect</span>: <span class="string">'/home'</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h2><h3 id="vue-是单文件组件"><a href="#vue-是单文件组件" class="headerlink" title="vue 是单文件组件"></a>vue 是单文件组件</h3><p>后缀为 .vue 的文件</p><p>单文件组件，无法直接在浏览器中使用，必须经过 webpack 这种打包工具处理后，才能在浏览器中使用</p><p>单文件组件的三个组成部分</p><ul><li>template (模板结构)</li><li>script 组件的代码逻辑</li><li>style 样式</li></ul><h3 id="脚手架介绍"><a href="#脚手架介绍" class="headerlink" title="脚手架介绍"></a>脚手架介绍</h3><p><strong>vue-cli</strong> 是 vue 的脚手架工具</p><p>因为 webpack 配置繁琐，阻止一批想用 vue 但是不会 webpack 的开发人员</p><p>vue-cli 提供了一条命令，我们直接通过这条命令就可以快速的生成一个 vue 项目 (<code>vue init XX</code>)，项目的基本结构、以及 webpack 配置项  <strong>全部配置</strong>  好了</p><p><a href="https://vue-loader.vuejs.org/zh/" target="_blank" rel="noopener">Vue Loader</a> 手动配置置 <code>webpack</code></p><p><a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">Vue CLI3</a></p><p><a href="https://vuejs-templates.github.io/webpack/" target="_blank" rel="noopener">Vue webpack 配置</a></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>安装：<code>npm i -g vue-cli</code></p><p>初始化 vue 项目：<code>vue init webpack 项目名称</code></p><p>进入到项目根目录运行项目：<code>npm run dev</code></p><p>项目安装过程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">? Project name demo</span><br><span class="line">? Project description A Vue.js project</span><br><span class="line">? Author</span><br><span class="line">? Vue build standalone  =&gt; 运行时+编译</span><br><span class="line">? Install vue-router? Yes</span><br><span class="line">? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard</span><br><span class="line">? <span class="built_in">Set</span> up unit tests No</span><br><span class="line">? Setup e2e tests <span class="keyword">with</span> Nightwatch? No</span><br></pre></td></tr></table></figure><h4 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a>项目目录介绍</h4><p><a href="https://vuejs-templates.github.io/webpack/structure.html" target="_blank" rel="noopener">https://vuejs-templates.github.io/webpack/structure.html</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── build/                      # webpack config files</span><br><span class="line">├── config/index.js             # main project config</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.js                 # app entry file</span><br><span class="line">│   ├── App.vue                 # main app component</span><br><span class="line">│   ├── components/             # ui components</span><br><span class="line">│   └── assets/                 # module assets (processed by webpack)</span><br><span class="line">├── static/                     # pure static assets (directly copied)</span><br><span class="line">├── test/</span><br><span class="line">│   └── unit/                   # unit tests</span><br><span class="line">│   └── e2e/                    # e2e tests</span><br><span class="line">├── .babelrc                    # babel config</span><br><span class="line">├── .editorconfig               # settings for your editor</span><br><span class="line">├── .eslintrc.js                # eslint config</span><br><span class="line">├── .eslintignore               # eslint ignore rules</span><br><span class="line">├── .gitignore                  # sensible defaults for gitignore</span><br><span class="line">├── .postcssrc.js               # postcss config</span><br><span class="line">├── index.html                  # index.html template</span><br><span class="line">├── package.json                # build scripts and dependencies</span><br><span class="line">└── README.md                   # Default README file</span><br></pre></td></tr></table></figure><ul><li>build 和 config 不要动，都是一些配置好的，还有一些他们之间的约定</li><li>.gitkeep：static 为预留的文件夹，空文件夹默认不会上传到 github，添加这个文件让static文件夹被 git 上传</li><li><code>.editorconfig</code> 编译器配置，需要安装 vscode 插件：Editorconfig</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">charset = utf-8   utf-8 格式编码</span><br><span class="line">indent_style = space   空格和tab都可以缩进</span><br><span class="line">indent_size = 2    缩进为2个</span><br><span class="line">end_of_line = lf  回车换行</span><br><span class="line">insert_final_newline = true   结束最后一行+一个空白</span><br><span class="line">trim_trailing_whitespace = true   开头去除空白</span><br></pre></td></tr></table></figure><ul><li><code>eslint</code> 校验<ul><li>忽略文件中有这个 =&gt; /*.js =&gt; 意思是根目录下的.js 文件不校验,,但是发现根目录就没有.js 文件</li><li>/*  eslint-disable no-new */ eslint 忽略 no-new规则</li><li>/_ eslint-disable_/ 也可以</li><li>如果去掉,就会提示你 不要以 new 开头</li><li>可以前面给个变量 var vm = new Vue()</li><li>但是又提示没有用,还要打印一下,其实这个赋值是没有意义的</li><li>不要去掉.这是 eslint 的<code>不校验下一行代码</code></li><li><a href="https://standardjs.com/readme-zhcn.html" target="_blank" rel="noopener">standard 代码规范</a></li></ul></li><li>postcssrc 处理 less css 等</li><li>src<ul><li>assets 静态资源</li><li>components 组件</li><li>router 路由</li><li>App.vue 根组件 =&gt; 指定路由出口</li><li>脚手架之后，所有的组件都将渲染到 app.vue 中</li><li>vm 中的 #app 还是 index.html 中的 #app， app.vue 中的会覆盖前者<br>可以通过分别添加 title 属性验证一下</li><li><code>&lt;router-view/&gt;</code> 路由出口要写在 app.vue 组件模板中</li><li>main.js<ul><li>入口 js 文件</li><li>作用：创建 vue 实例，导入其他组件并挂在到 vue 实例上</li><li><code>Vue.config.productionTip = false</code> 不要打印提示</li></ul></li><li>route/index.js：路由<ul><li><code>@</code>：build/ webpack.base.config.js =&gt;  <code>&#39;@&#39;: resolve(&#39;src&#39;)</code></li><li>如果在一个模块化工程中使用它，必须要通过 <code>Vue.use()</code> 明确地安装路由功能</li><li><code>https://router.vuejs.org/zh/installation.html</code></li></ul></li></ul></li></ul><h3 id="两种编译模式"><a href="#两种编译模式" class="headerlink" title="两种编译模式"></a>两种编译模式</h3><p>完整版和运行时版</p><p><a href="https://cn.vuejs.org/v2/guide/installation.html#%E5%AF%B9%E4%B8%8D%E5%90%8C%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A" target="_blank" rel="noopener">参考官网</a></p><p>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码</p><p>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切</p><ul><li>使用 完整版 (包含编译器)</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>只使用运行时</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查看编译模式：build =&gt; webpack.base.config.js =&gt;  <code>&#39;vue\$&#39;: &#39;vue/dist/vue.esm.js&#39;,</code></p><h3 id="手动配置路由"><a href="#手动配置路由" class="headerlink" title="手动配置路由"></a>手动配置路由</h3><p>安装路由 <code>npm i vue-router</code></p><p>准备工作：创建一个文件夹 router/router.js</p><p>具体配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* router.js */</span></span><br><span class="line"><span class="comment">// 引入路由</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'@/components/home/Home'</span>   (template + script + style)</span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'@/components/login/Login'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把路由当成插件安装</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由，配置路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 路由规则</span></span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path : <span class="string">'/home'</span>,</span><br><span class="line">    component : Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path : <span class="string">'/login'</span>,</span><br><span class="line">    component : Login</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main.js 中绑定路由</span></span><br><span class="line">router</span><br><span class="line"></span><br><span class="line">在跟组件 App.vue 下配置出口</span><br><span class="line">&lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* main.js */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 绑定路由</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置出口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编辑器配置插件"><a href="#编辑器配置插件" class="headerlink" title="编辑器配置插件"></a>编辑器配置插件</h3><ul><li><p><code>vetur</code>：vue 单文件组件的高亮</p></li><li><p>eslint</p><ul><li>关闭 <strong>eslint</strong>：打开 config/index.js，将26行 :  <code>dev.useEslint</code>设置为false，重启项目 ( npm run dev)</li></ul></li><li><p><code>Prettier</code>：格式化插件</p></li></ul><h2 id="TODOMVC-案例"><a href="#TODOMVC-案例" class="headerlink" title="TODOMVC 案例"></a>TODOMVC 案例</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><a href="http://todomvc.com/examples/vue/" target="_blank" rel="noopener">Vue-TodoMVC</a></li><li><a href="https://github.com/tastejs/todomvc-app-template" target="_blank" rel="noopener">下载模板地址</a> <code>git clone https://github.com/tastejs/todomvc-app-template.git</code></li><li>安装依赖包 : <code>npm i</code></li><li>安装 vue : <code>npm i vue</code></li><li>开始 <a href="https://github.com/cuilongjin/todomvc-app-template/tree/master" target="_blank" rel="noopener">https://github.com/cuilongjin/todomvc-app-template/tree/master</a></li></ol><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><ul><li>渲染任务列表：<code>&lt;label&gt;&lt;/label&gt;</code></li><li>任务完成 : <code>:class=&quot;{ completed : item.done }&quot;</code></li><li>多选框选中状态 : <code>v-model=&#39;item.done&#39;</code></li></ul><h3 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h3><ul><li>获取文本输入框的内容 (关键点)<ul><li>把 input 通过 v-model 双向数据绑定 == todoName</li><li>@keyup.enter 触发事件 addTodo =&gt; 拿到 todoName 的值</li><li>判断文本框不能为空</li><li>按回车添加任务</li></ul></li><li>对象{done: false, id: , name : todoName}<ul><li>获取数组里最后一个元素的 id+1</li><li>如果数组之前一个元素都没有 , id = 1</li></ul></li><li>将对象添加进数组</li><li>添加完，清除文本框内容</li></ul><h3 id="删除任务"><a href="#删除任务" class="headerlink" title="删除任务"></a>删除任务</h3><ul><li>传索引<br><code>this.todoList.splice(index, 1)</code></li><li>传 id</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 id  找到对应的元素索引</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="keyword">this</span>.todoList.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id)</span><br><span class="line"><span class="comment">// 根据索引删除</span></span><br><span class="line"><span class="keyword">this</span>.todoList.splice(index, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>传 id 过滤</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传过来一个 id, 过滤出来不等于这个 id 的元素，重新赋值给 todoList</span></span><br><span class="line"><span class="keyword">this</span>.todoList = <span class="keyword">this</span>.todoList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id !== id)</span><br></pre></td></tr></table></figure><h3 id="编辑任务"><a href="#编辑任务" class="headerlink" title="编辑任务"></a>编辑任务</h3><ul><li><p>显示<code>编辑框</code> ( editing : true) (难点)</p><ul><li>在 data 中添加一个 editId : -1</li><li>在 :class<br>editing: item.id === editId</li><li>双击 : 接收过来双击元素的id<br>this.editId = id</li><li>关键点 :<br>vue 中 data 中的数据一旦发生改变，当前页面的指令和表达式都会重新计算</li></ul></li><li><p>读取内容<br><code>&lt;input class=&quot;edit&quot; v-model=&quot;item.name&quot;&gt;</code></p></li><li><p>回车隐藏编辑框</p></li></ul><h3 id="底部的显示与隐藏"><a href="#底部的显示与隐藏" class="headerlink" title="底部的显示与隐藏"></a>底部的显示与隐藏</h3><ul><li>v-if/v-show</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件部分</span></span><br><span class="line">&lt;footer <span class="class"><span class="keyword">class</span></span>=<span class="string">"footer"</span> v-show=<span class="string">"isFooter()"</span>&gt;</span><br><span class="line"><span class="comment">// js</span></span><br><span class="line">  isFooter() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.todoList.length &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>因为 vue 中 data 的数据发送了改变，当前页面中的指令和表达式都会重新计算，所以只要文本框里的内容发生改变，todoName 也会发送改变，isFooter 会一直被调用，性能不好。我们需要的是数组列表的个数改变才会影响底部的变化，所以需要用到计算属性</p></li><li><p>计算属性</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span> <span class="attr">v-show</span>=<span class="string">"isFooter"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 计算属性 判断底部是否显示</span></span><br><span class="line">  <span class="comment">// 1. 计算属性只会跟着相关属性的值发生变化而变化</span></span><br><span class="line">  <span class="comment">// 2. 一定要有返回值</span></span><br><span class="line">  <span class="comment">// 3. 一定要写在 computed 里面</span></span><br><span class="line">  <span class="comment">// 4. 写起来像一个方法，用起来像一个属性</span></span><br><span class="line">  isFooter () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.todoList.length &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><ul><li>存储数据<ul><li>监听 list 数据的改变，只要 list 数据变了，就调用保存数据的方法</li><li>使用 vue 的 watch 监听 list 的数据改变</li><li>保存值，记得把对象转化为字符串(存的快省空间)</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 监听 todoList</span></span><br><span class="line">  todoList: &#123;</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    handler (newVal) &#123;</span><br><span class="line">   localStorage.setItem(<span class="string">'todoList'</span>, <span class="built_in">JSON</span>.stringify(newVal))</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取数据</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 data 中可以初始值</span></span><br><span class="line"><span class="comment">// 设置一个默认值 空数组 []</span></span><br><span class="line">todoList: <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'todoList'</span>)) || []</span><br></pre></td></tr></table></figure><h3 id="使用钩子函数来完善数据存储"><a href="#使用钩子函数来完善数据存储" class="headerlink" title="使用钩子函数来完善数据存储"></a>使用钩子函数来完善数据存储</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">created () &#123;</span><br><span class="line">  <span class="keyword">this</span>.todoList = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'todoList'</span>)) || []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取接口数据"><a href="#获取接口数据" class="headerlink" title="获取接口数据"></a>获取接口数据</h3><p><a href="https://github.com/typicode/json-server" target="_blank" rel="noopener">json-server</a> 提供假数据接口</p><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a> 发送请求</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g json-server</span><br><span class="line">npm i axios</span><br><span class="line">json-server data.json</span><br></pre></td></tr></table></figure><h3 id="组件化TODOMVC"><a href="#组件化TODOMVC" class="headerlink" title="组件化TODOMVC"></a>组件化TODOMVC</h3><p><a href="https://github.com/cuilongjin/todomvc-app-template/tree/zujianhua" target="_blank" rel="noopener">https://github.com/cuilongjin/todomvc-app-template/tree/zujianhua</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
      <category term="vue" scheme="https://cuilongjin.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://cuilongjin.top/2019/javascript/promise/"/>
    <id>https://cuilongjin.top/2019/javascript/promise/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-23T09:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul><li>Promise 是<code>异步编程</code>的一种解决方案，它允许你以一种同步的方式编写异步代码</li><li><code>promise</code>：承诺、保证</li><li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES6 - Promise</a></li><li>JS 是通过回调函数来实现异步编程的，当异步操作多了以后，就会产生回调嵌套回调的问题，这就是<code>回调地狱</code></li><li>Promise 方式：将异步操作以同步操作的方式表达出来，避免了层层嵌套的回调函数</li></ul><h2 id="封装一个-Promise"><a href="#封装一个-Promise" class="headerlink" title="封装一个 Promise"></a>封装一个 Promise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按序读取文件：a -&gt; b -&gt; c</span></span><br><span class="line"><span class="comment">// 按顺序读取 a b c 文件</span></span><br><span class="line"><span class="comment">// 以前</span></span><br><span class="line"><span class="comment">// 读取 a 文件</span></span><br><span class="line">fs.readFile(<span class="string">'./a'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 b 文件</span></span><br><span class="line">  fs.readFile(<span class="string">'./b'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 c 文件</span></span><br><span class="line">    fs.readFile(<span class="string">'./a'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'读取错误'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise</span></span><br><span class="line"><span class="comment">// 封装</span></span><br><span class="line"><span class="comment">// Promise 是一个构造函数</span></span><br><span class="line"><span class="comment">// 通过 new 创建 Promise 的实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化 Promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve 表示成功，异步操作成功调用</span></span><br><span class="line">    <span class="comment">// reject  表示失败，异步操作失败调用</span></span><br><span class="line">    fs.readFile(path, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 读取错误，调用 reject()</span></span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读取成功 调用 resolve</span></span><br><span class="line">      resolve(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 Promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">readFile(<span class="string">'a'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'a'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> readFile(<span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="promise-的三个状态"><a href="#promise-的三个状态" class="headerlink" title="promise 的三个状态"></a>promise 的三个状态</h2><ul><li><p>pending : 等待  (等待成功或者失败去调用)</p></li><li><p>resolved : 成功调用</p></li><li><p>rejected : 失败调用</p></li></ul><h2 id="then-和-catch"><a href="#then-和-catch" class="headerlink" title="then 和 catch"></a>then 和 catch</h2><ul><li>说明：获取异步操作的结果</li><li><code>then()</code> ：用于获取异步操作成功时的结果 -&gt; <em>resolve</em></li><li><code>catch()</code>：用于获取异步操作失败时的结果 -&gt; <em>reject</em></li><li>说明：<code>then()</code>方法可以有多个，按照先后顺序执行，通过回调函数返回值传递数据给下一个 then</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p</span><br><span class="line">  <span class="comment">// 成功</span></span><br><span class="line">  .then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件a的内容为：'</span>, value)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 失败（比如：文件路径错误）</span></span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件读取失败：'</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------- 或者 -----------</span></span><br><span class="line">p.then(</span><br><span class="line">  value =&gt; &#123;</span><br><span class="line">    <span class="comment">// 成功</span></span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 失败</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="all-和-race"><a href="#all-和-race" class="headerlink" title="all 和 race"></a>all 和 race</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所有请求完成，才会执行后续代码</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([</span><br><span class="line">  axios(<span class="string">'/a'</span>),</span><br><span class="line">  axios(<span class="string">'/b'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// res 是 all() 方法中所有异步操作的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要有一个请求完成，就会继续执行后续代码</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  axios(<span class="string">'/a'</span>),</span><br><span class="line">  axios(<span class="string">'/b'</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// res 是 race() 方法中先完成的异步操作的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><ul><li>异步编程终极方案</li></ul><ul><li>async / await 用同步编写代码的方式 处理异步操作的一个方案</li><li>async：修饰 (修饰一个内部有异步操作的函数)    格式 :  async + 函数 (里面有异步操作的函数)</li><li>await : 等待 (等上一个异步操作完成啊 , 修饰 一个结果是promise的)异步操作    格式 : await + 异步操作(结果promise对象)</li><li>async 和 await 是成对出现的，await 只能在 async 函数中使用</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 实例化 promise</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 操作错误 调用 =&gt;  reject  =&gt; catch</span></span><br><span class="line">        <span class="keyword">return</span> reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 操作成功  调用 =&gt; resolve =&gt; then</span></span><br><span class="line">      resolve(data.toString())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 2. 返回 promise 对象</span></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：使用 (async/await)</span></span><br><span class="line"><span class="comment">// async + 函数 (里面有异步操作的函数)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await + 异步操作(结果promise对象)</span></span><br><span class="line">  <span class="comment">// 读取a文件</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> readFile(<span class="string">'./data/a1.txt'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 b 文件</span></span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> readFile(<span class="string">'./data/b.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 c 文件</span></span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> readFile(<span class="string">'./data/c.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(b)</span><br><span class="line">    &#125;, a)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> sleep(<span class="number">1000</span>, <span class="string">'a'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res1)</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> sleep(<span class="number">5000</span>, <span class="string">'b'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res2)</span><br><span class="line">  <span class="keyword">const</span> res3 = <span class="keyword">await</span> sleep(<span class="number">3000</span>, <span class="string">'c'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(res3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn()</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>, <span class="string">'a'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> sleep(<span class="number">5000</span>, <span class="string">'b'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">return</span> sleep(<span class="number">3000</span>, <span class="string">'c'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.all([sleep(<span class="number">1000</span>, <span class="string">'a'</span>), sleep(<span class="number">5000</span>, <span class="string">'b'</span>)])</span><br><span class="line">p1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.race([sleep(<span class="number">1000</span>, <span class="string">'a'</span>), sleep(<span class="number">5000</span>, <span class="string">'b'</span>)])</span><br><span class="line">p2.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Promise&quot;&gt;&lt;a href=&quot;#Promise&quot; class=&quot;headerlink&quot; title=&quot;Promise&quot;&gt;&lt;/a&gt;Promise&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Promise 是&lt;code&gt;异步编程&lt;/code&gt;的一种解决方案，它允许你以一种同步的
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
      <category term="promise" scheme="https://cuilongjin.top/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>ES6（ECMAScript）</title>
    <link href="https://cuilongjin.top/2018/javascript/ES6/"/>
    <id>https://cuilongjin.top/2018/javascript/ES6/</id>
    <published>2018-12-29T10:00:00.000Z</published>
    <updated>2019-07-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6（ECMAScript）"><a href="#ES6（ECMAScript）" class="headerlink" title="ES6（ECMAScript）"></a>ES6（ECMAScript）</h1><p>ECMAScript 6.0（以下简称 ES6）是在 2015 年 6 月正式发布的标准。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言</p><p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门 阮一峰</a></p><h2 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h2><blockquote><p>ES6 中提供了两个声明变量的关键字：const 和 let</p></blockquote><p>参考链接</p><p><a href="https://zhuanlan.zhihu.com/p/28140450" target="_blank" rel="noopener">[知乎]我用了两个月的时间才理解 let</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting" target="_blank" rel="noopener">[MDN]变量提升</a></p><h3 id="let-的使用"><a href="#let-的使用" class="headerlink" title="let 的使用"></a>let 的使用</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code></p><ul><li>let 声明的变量只有在当前作用域(块作用域)有效</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure><ul><li>不允许重复声明</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> <span class="comment">// SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure><ul><li><span class="red">不绑定全局作用域</span></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li><span class="error">存在变量提升</span></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">  <span class="keyword">let</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 let 不会提升，那么 a = 2 就会将外面的 a 由 1 变成 2</span></span><br><span class="line"><span class="comment">// 但运行发现 a = 2 报错：Uncaught ReferenceError: Cannot access 'a' before initialization</span></span><br></pre></td></tr></table></figure><p>总结1：</p><ul><li>let 声明会提升到块顶部</li><li>从块顶部到该变量的初始化语句，这块区域叫做 TDZ（临时死区）</li><li>如果你在 TDZ 内使用该变量，JS 就会报错</li></ul><p>总结2：</p><ul><li>let 的「创建」过程被提升了，但是初始化没有提升</li><li>var 的「创建」和「初始化」都被提升了</li><li>function 的「创建」「初始化」和「赋值」都被提升了</li></ul><p>所谓暂时死区，就是不能在初始化之前，使用变量</p><p>总结3：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>; <span class="keyword">let</span> a; <span class="comment">// Uncaught ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line">a <span class="comment">// Uncaught ReferenceError: Cannot access 'a' before initialization</span></span><br></pre></td></tr></table></figure><p>如果 let x 的初始化过程失败了，那么</p><ul><li>x 变量就将永远处于 created 状态</li><li>你无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）</li><li>由于 x 无法被初始化，所以 x 永远处在暂时死区</li></ul><h3 id="const-的使用"><a href="#const-的使用" class="headerlink" title="const 的使用"></a>const 的使用</h3><p><code>const</code>声明一个常量。常量：代码执行的过程中，不可以修改常量里面的值</p><ul><li>const 声明的量不可以改变</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span></span><br><span class="line">PI = <span class="number">3</span> <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><ul><li>const 声明的变量必须赋值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure><ul><li>如果 const 声明了一个对象，仅仅保证地址不变，可以修改对象的属性</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">'zs'</span>&#125;</span><br><span class="line">obj.age = <span class="number">18</span> <span class="comment">// 正确</span></span><br><span class="line">obj = &#123;&#125; <span class="comment">// TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><ul><li>其他用法和 let 一样</li></ul><p>只能在当前代码块中使用<br>不能重复声明<br>不绑定全局作用域</p><h2 id="模板字符串-模板字面量"><a href="#模板字符串-模板字面量" class="headerlink" title="模板字符串(模板字面量)"></a>模板字符串(模板字面量)</h2><p>模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 通过``可以定义一个字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`hello world`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 模板字符串内部允许换行</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">  hello</span></span><br><span class="line"><span class="string">  world</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 模板字符串内部可以使用表达式</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">你好，我是<span class="subst">$&#123;name&#125;</span></span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>ES6 标准新增了一种新的函数：Arrow Function（箭头函数）</p><p>为什么叫 Arrow Function？因为它的定义用的就是一个箭头</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line"><span class="comment">// 语法： (参数列表) =&gt; &#123;函数体&#125;</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><ul><li>如果没有参数列表，使用()表示参数列表</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果只有一个参数，可以省略()</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">n1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果有多个参数，需要使用 () 把参数列表括起来</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>给参数指定默认值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">n = <span class="number">1</span></span>) =&gt;</span> <span class="built_in">console</span>.log(n)</span><br><span class="line">a() <span class="comment">// 1</span></span><br><span class="line">a(<span class="number">3</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>不存在 prototype 这个属性</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li><p>没有 arguments</p><p>箭头函数没有自己的 arguments 对象，箭头函数可以访问外围函数的 arguments 对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">1</span>, <span class="number">2</span>)()) <span class="comment">// [Arguments] &#123; '0': 1, '1': 2 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问箭头函数的参数</span></span><br><span class="line"><span class="comment">// Rest 参数接受函数的多余参数组成一个数组</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function">(<span class="params">a, b, ...Args</span>) =&gt;</span> <span class="built_in">console</span>.log(Args)</span><br><span class="line">a(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// [3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.length) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>Rest 参数和 arguments 对象的区别：</li></ul><p>rest 参数只包括那些没有给出名称的参数，arguments 包含所有参数</p><p>rest 参数之后不能再有其他参数，否则会报错</p><p>函数的 length 属性，不包括 rest 参数</p><p>arguments 对象不是真正的数组，而 rest 参数是数组实例，可以直接使用数组的方法</p><p>arguments 对象拥有一些自己额外的功能</p><h3 id="返回值详解"><a href="#返回值详解" class="headerlink" title="返回值详解"></a>返回值详解</h3><ul><li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">n1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">  <span class="keyword">return</span> n1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于：</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="params">n1</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'哈哈'</span>)</span><br><span class="line">  <span class="keyword">return</span> n1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果函数体只有一行一句，并且需要返回这个值，那么可以省略 {} 和 return</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2</span><br></pre></td></tr></table></figure><h3 id="箭头函数的注意点"><a href="#箭头函数的注意点" class="headerlink" title="箭头函数的注意点"></a>箭头函数的注意点</h3><ol><li>箭头函数内部没有 this，因此箭头函数内部的 this 指向了外部的 this</li><li>因为箭头函数没有 this，因此箭头函数不能作为构造函数</li><li>不能用 call()、apply()、bind() 这些方法改变 this 的指向</li></ol><p>【定义一个对象，定时器打招呼】</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'zs'</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'大家好，我是'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.sayHi()</span><br></pre></td></tr></table></figure><h2 id="对象简化语法"><a href="#对象简化语法" class="headerlink" title="对象简化语法"></a>对象简化语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当属性的 key 和变量的名相同时可以简写</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: name&#125; ==&gt; <span class="keyword">let</span> person = &#123;name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">let</span> cal = &#123;</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 可以省略 `:function`</span></span><br><span class="line">  add()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><ul><li>ES6 允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">'foo'</span></span><br><span class="line"><span class="keyword">let</span> methodKey = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// foo: true</span></span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="number">123</span>,</span><br><span class="line">  <span class="comment">// abc: 123</span></span><br><span class="line">  [methodKey]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="class-关键字"><a href="#class-关键字" class="headerlink" title="class 关键字"></a>class 关键字</h2><p>ES5 中通过 构造函数 + 原型 的方式来实现面向对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'jack'</span></span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在原型中添加实例方法</span></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure><p>ES6 中出现了 class 关键字，用来实现面向对象。</p><p>class 仅仅是一个语法结构（语法糖），本质上还是通过构造函数+原型的方式来实现继承的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="comment">// 创建 Person 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 类的构造函数</span></span><br><span class="line">  <span class="comment">// constructor 固定名称</span></span><br><span class="line">  <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加实例方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">'tom'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line">p.say()</span><br></pre></td></tr></table></figure><p>继承：要实现至少需要两个class（子类 和 父类），子类继承自父类，继承后，子类就可以使用父类中的属性或方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类中的 say 方法'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// 子类中使用 constructor 必须手动调用 super</span></span><br><span class="line">    <span class="comment">// super 表示父类的构造函数</span></span><br><span class="line">    <span class="comment">// 先调用 super() 在使用 this</span></span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'ls'</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Chinese()</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line">c.say() <span class="comment">// 父类中的方法</span></span><br></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 对象解构</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b&#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取变量并赋值</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">a</span>: p, <span class="attr">b</span>: q&#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(p, q) <span class="comment">// 10 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余数组赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> &#123; a, b, ...rest &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span>, <span class="attr">d</span>: <span class="number">40</span> &#125;</span><br><span class="line"><span class="comment">// ;(&#123; a, b, ...rest &#125; = &#123; a: 10, b: 20, c: 30, d: 40 &#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest) <span class="comment">// 10 20 &#123;c: 30, d: 40&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123; a = <span class="number">1</span>, b = <span class="number">1</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值并提供默认值</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">a</span>:aa = <span class="number">10</span>, <span class="attr">b</span>:bb = <span class="number">1</span>&#125; = &#123;<span class="attr">a</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(aa, bb) <span class="comment">// 10 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 数组解构</span></span><br><span class="line"><span class="keyword">var</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将剩余数组赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> [a, b, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, rest) <span class="comment">// 1 2 [3, 4]</span></span><br><span class="line"><span class="comment">// ==&gt; var a = arr[0]; var b = arr[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供默认值</span></span><br><span class="line"><span class="keyword">var</span> [c = <span class="number">2</span>, d = <span class="number">2</span>] = [<span class="number">10</span>]</span><br><span class="line"><span class="built_in">console</span>.log(c, d) <span class="comment">// 10 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略某些值</span></span><br><span class="line"><span class="keyword">var</span> [a = <span class="number">2</span>, , b = <span class="number">2</span>] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 10 30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 函数参数的解构赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">foo(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x = <span class="number">10</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 解构的特殊应用</span></span><br><span class="line"><span class="comment">// 交换变量</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">[a, b] = [b, a]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串解构</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'love'</span></span><br><span class="line"><span class="keyword">var</span> [a, b, c, d] = str</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// l o v e</span></span><br></pre></td></tr></table></figure><h2 id="数组扩展运算符"><a href="#数组扩展运算符" class="headerlink" title="数组扩展运算符"></a>数组扩展运算符</h2><p>扩展运算符（spread）是三个点（…）。作用：将一个数组转为用逗号分隔的参数序列</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr)</span><br><span class="line"><span class="comment">// 上面这句代码相当于：</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>应用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组深拷贝</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = [...arr]</span><br><span class="line"><span class="built_in">console</span>.log(arr === arr1) <span class="comment">// false, 说明arr1和arr指向不同数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把一个数组插入另一个数组字面量</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转数组</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'love'</span></span><br><span class="line"><span class="keyword">var</span> arr3 = [...str]</span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [ 'l', 'o', 'v', 'e' ]</span></span><br></pre></td></tr></table></figure><h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6（ECMAScript）&quot;&gt;&lt;a href=&quot;#ES6（ECMAScript）&quot; class=&quot;headerlink&quot; title=&quot;ES6（ECMAScript）&quot;&gt;&lt;/a&gt;ES6（ECMAScript）&lt;/h1&gt;&lt;p&gt;ECMAScript 6.0（以下简
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
      <category term="es6" scheme="https://cuilongjin.top/tags/es6/"/>
    
  </entry>
  
</feed>
