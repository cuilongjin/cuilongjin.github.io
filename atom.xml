<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>稻草人</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuilongjin.top/"/>
  <updated>2019-08-24T16:00:00.000Z</updated>
  <id>https://cuilongjin.top/</id>
  
  <author>
    <name>稻草人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chrome Developer Tools 使用技巧</title>
    <link href="https://cuilongjin.top/2019/tool/ChromeDeveloperTools%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://cuilongjin.top/2019/tool/ChromeDeveloperTools使用技巧/</id>
    <published>2019-08-24T16:00:00.000Z</published>
    <updated>2019-08-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="console-log"><a href="#console-log" class="headerlink" title="console.log()"></a>console.log()</h3><p>占位符 %o 它接受对象，%s 接受字符串，%d 表示小数或整数，%c CSS 值的占位符,对应的后面的参数必须是 CSS 语句</p><p>如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'%s 的价格是 %d 磅 %d 便士'</span>, <span class="string">'衬衫'</span>, <span class="number">9</span>, <span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>输出：衬衫的价格是 9 磅 15 便士</p><p>如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'I am a %cbutton'</span>, <span class="string">'color: white; background-color: orange; padding: 2px 5px; border-radius: 2px'</span>)</span><br></pre></td></tr></table></figure><p>输出：I am a <span style="color: white; background-color: orange; padding: 2px 5px; border-radius: 2px">button</span></p><h3 id="console-dir"><a href="#console-dir" class="headerlink" title="console.dir()"></a>console.dir()</h3><h3 id="console-warn"><a href="#console-warn" class="headerlink" title="console.warn()"></a>console.warn()</h3><p>输出警告信息，字的颜色是黄色的，用于区分或过滤掉无用的输出</p><h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h3><p>将数据以表格的形式输出，对于数据列表的输出更容易观察其数据结构，并且点击输出的表头可以对数据排序</p><p>第二个可选参数是需要输出的字段。默认输出所有字段</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.table(data) <span class="comment">// 输出全部</span></span><br><span class="line"><span class="built_in">console</span>.table(data, [<span class="string">'id'</span>, <span class="string">'price'</span>]) <span class="comment">// 输出 data 中的 id price 字段</span></span><br></pre></td></tr></table></figure><h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h3><p>计数器，可以用来统计代码被执行的次数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.count(<span class="string">'odds'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">odds: 1</span><br><span class="line">odds: 2</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.countReset() <span class="comment">// 可以使用它重置计数器。</span></span><br></pre></td></tr></table></figure><h3 id="console-time"><a href="#console-time" class="headerlink" title="console.time()"></a>console.time()</h3><p>是一个用于跟踪操作时间的专用函数，可以用来跟踪 js 的执行时间</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'a'</span>)</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'a'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  a()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd()</span><br></pre></td></tr></table></figure><h3 id="选择-DOM-元素"><a href="#选择-DOM-元素" class="headerlink" title="选择 DOM 元素"></a>选择 DOM 元素</h3><ul><li>在谷歌开发控制台中, 可以使用 <code>$(&#39;选择器&#39;)</code> 类似于 jquery 的方式选择 DOM 元素</li></ul><p><code>$(&#39;&#39;)</code> 等效于 <code>document.querySelector(&#39;&#39;)</code>，这将返回 DOM 中与选择器匹配的第一个元素，可以使用 <code>$$(tagName)</code> 或 <code>$$(.class)</code>，选择 DOM 的所有元素并返回一个数组。可以通过下标获取指定的元素，例如，<code>$$(&#39;.box&#39;)</code> 获取具有类 box 的所有元素，<code>$$(&#39;.box&#39;)[0]</code>和 <code>$$(&#39;.box&#39;)[1]</code>分别获取第一个和第二个元素</p><ul><li><code>inspect($(&#39;selector&#39;))</code> 将检查与选择器匹配的元素，并转到 Elements 选项卡</li></ul><ul><li><code>$0</code>，<code>$1</code>，<code>$2</code> 等可以获取最近检查过的元素，即通过 <code>$0</code> 即可直接获取当前高亮的元素，<code>$1</code> 可以获取上一个高亮的元素</li></ul><h3 id="将页面转换为可编辑状态"><a href="#将页面转换为可编辑状态" class="headerlink" title="将页面转换为可编辑状态"></a>将页面转换为可编辑状态</h3><p>在 Console 中输入:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.contentEditable = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>之后页面中的内容即为可编辑状态，可以编辑 DOM 中的任何内容</p><h3 id="查找与-DOM-中的元素关联的事件"><a href="#查找与-DOM-中的元素关联的事件" class="headerlink" title="查找与 DOM 中的元素关联的事件"></a>查找与 DOM 中的元素关联的事件</h3><p><code>getEventListeners($(&#39;selector&#39;))</code> 返回一个对象数组，其中包含绑定到该元素的所有事件。你可以展开对象来查看事件</p><p>要找到特定事件的侦听器，可以这样做:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getEventListeners($(<span class="string">'selector'</span>)).eventName[<span class="number">0</span>].listener</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将显示与 id 为 btn 的元素的单击事件关联的侦听器</span></span><br><span class="line">getEventListeners($(<span class="string">'btn'</span>)).click[<span class="number">0</span>].listener</span><br></pre></td></tr></table></figure><h3 id="监控事件"><a href="#监控事件" class="headerlink" title="监控事件"></a>监控事件</h3><p>监视绑定到 DOM 中特定元素的事件，然后在它们被触发后立即将它们记录在控制台中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监控绑定到 '#box' 元素的所有事件</span></span><br><span class="line">monitorEvents($(<span class="string">'#box'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监控绑定到 'selector' 元素的 click 事件</span></span><br><span class="line">monitorEvents($(<span class="string">'#box'</span>), <span class="string">'click'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监控绑定到 'selector' 元素的 click 和 focus 事件</span></span><br><span class="line">monitorEvents($(<span class="string">'#box'</span>), [<span class="string">'click'</span>, <span class="string">'focus'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止监视</span></span><br><span class="line">unmonitorEvents($(<span class="string">'#box'</span>))</span><br></pre></td></tr></table></figure><p>检索最后一个结果的值<br><code>$_</code> 表示控制台中最近一次返回的值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 + 1</span><br><span class="line">&gt; 2</span><br><span class="line"></span><br><span class="line">$_</span><br><span class="line">&gt; 2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;console-log&quot;&gt;&lt;a href=&quot;#console-log&quot; class=&quot;headerlink&quot; title=&quot;console.log()&quot;&gt;&lt;/a&gt;console.log()&lt;/h3&gt;&lt;p&gt;占位符 %o 它接受对象，%s 接受字符串，%d 表示小数或
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>vue 项目加载第 3 方 js 优化</title>
    <link href="https://cuilongjin.top/2019/vue/vue%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96-%E5%8A%A0%E8%BD%BD%E7%AC%AC%E4%B8%89%E6%96%B9js/"/>
    <id>https://cuilongjin.top/2019/vue/vue项目优化-加载第三方js/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-08-25T13:49:34.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-项目加载第-3-方-js-优化"><a href="#vue-项目加载第-3-方-js-优化" class="headerlink" title="vue 项目加载第 3 方 js 优化"></a>vue 项目加载第 3 方 js 优化</h3><blockquote><p>这里的第 3 方组件大多不能通过 npm 或其他模块安装的组件(地图 sdk)，所以不能直接用 vue 里的异步组件</p></blockquote><p>在 index.html 里引入的第三方组件，有很多在首屏上根本用不到，严重拖慢的网页的加载速度造成长时间的白屏</p><p>可以根据需要动态插入 js</p><p>定义插入 js 到 document 的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! loadjs.js</span></span><br><span class="line"><span class="keyword">const</span> loadjsAsync = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> scriptHasLoad = <span class="built_in">document</span>.querySelector(<span class="string">'script[src="'</span> + url + <span class="string">'"]'</span>)</span><br><span class="line">    <span class="keyword">if</span> (scriptHasLoad) &#123;</span><br><span class="line">      resolve()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    script.src = url</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">    script.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    script.onerror = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> loadjsAsync</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入加载js方法</span></span><br><span class="line"><span class="keyword">import</span> loadjsAsync <span class="keyword">from</span> <span class="string">'../assets/js/loadjs'</span></span><br><span class="line"></span><br><span class="line">beforeCreate () &#123;</span><br><span class="line">  <span class="comment">// 引入第三方 js</span></span><br><span class="line">  loadjsAsync(<span class="string">'static/ueditor/ueditor.all.min.js'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.editor = UE.delEditor(<span class="string">'editor'</span>)</span><br><span class="line">    <span class="keyword">this</span>.editor = UE.getEditor(<span class="string">'editor'</span>, <span class="keyword">this</span>.config)</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vue-项目加载第-3-方-js-优化&quot;&gt;&lt;a href=&quot;#vue-项目加载第-3-方-js-优化&quot; class=&quot;headerlink&quot; title=&quot;vue 项目加载第 3 方 js 优化&quot;&gt;&lt;/a&gt;vue 项目加载第 3 方 js 优化&lt;/h3&gt;&lt;bloc
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue 异步组件</title>
    <link href="https://cuilongjin.top/2019/vue/vue%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6/"/>
    <id>https://cuilongjin.top/2019/vue/vue异步组件/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-08-25T13:49:26.152Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用 CDN 资源,减小服务器带宽压力</li><li>路由懒加载</li><li>将一些静态 js css 放到其他地方（如 OSS），减小服务器压力</li><li>按需加载三方资源，如 iview,建议按需引入 iview 中的组件</li><li>使用 nginx 开启 gzip 减小网络传输的流量大小</li><li>若首屏为登录页，可以做成多入口，登录页单独分离为一个入口</li><li>使用 uglifyjs-webpack-plugin 插件代替 webpack 自带 UglifyJsPlugin 插件</li></ol><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#异步组件" target="_blank" rel="noopener">官方文档-异步组件</a></p><p>同步方式引入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./views/Login'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>异步方式引入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./views/Login'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>必须使用 Vue Router 2.4.0+ 版本</p><p>异步方式引入的组件在需要的时候才从服务器加载，且会把结果缓存起来供未来重渲染，组件本身不需要做任何修改可以直接引用</p><p>利用此特性，我们便能做很多针对前端的优化<br>比如：针对大型项目，将页面核心功能打包成一个核心模块，通过框架优先加载。其他的一些周边功能打包后，通过服务器异步加载，从而解决业务需求越来越多导致的系统难维护、访问慢问题</p><p>也可以引入一个对象来处理异步组件的加载状态</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Login = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./views/Login'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件(如果提供了超时时间且组件加载也超时了， 则使用该组件)</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 超时时间,默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;使用 CDN 资源,减小服务器带宽压力&lt;/li&gt;
&lt;li&gt;路由懒加载&lt;/li&gt;
&lt;li&gt;将一些静态 js css 放到其他地方（如 OSS），减小服务器压力&lt;/li&gt;
&lt;li&gt;按需加载三方资源，如 iview,建议按需引入 iview 中的组件&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>icon 图标在 vue 项目中的使用</title>
    <link href="https://cuilongjin.top/2019/other/icon%E5%9B%BE%E6%A0%87%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://cuilongjin.top/2019/other/icon图标的使用/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-08-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<br><a href="https://juejin.im/post/59bb864b5188257e7a427c09" target="_blank" rel="noopener">https://juejin.im/post/59bb864b5188257e7a427c09</a></p><h3 id="使用-iconfont"><a href="#使用-iconfont" class="headerlink" title="使用 iconfont"></a>使用 iconfont</h3><p>阿里开源图库 <a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p><p>下载代码到本地（也可以使用在线链接）打开 demo_index.html 使用说明，有三种使用方式 unicode font-class symbol<br>unicode 方式： <span class="iconfont">&#x33;</span> 这样，不直观，语意不明确，不支持多色图标<br>font-class 方式： <span class="iconfont icon-xxx"></span> 使用 class 定义，有语意，需要注意命名空间的问题，也是不支持多色图标<br>symbol 方式：使用 svg 不用再去请求 woff|eot|ttf| 这些字体库，且缩放不会失真，支持更加复杂的图标</p><p>symbol 方式使用步骤：</p><p>第一步：引入项目下面生成的 symbol 代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./iconfont.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或通过 import 导入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./iconfont.js'</span></span><br></pre></td></tr></table></figure><p>第二步：加入通用 CSS 代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: -<span class="number">0.15em</span>;</span><br><span class="line">  <span class="attribute">fill</span>: currentColor;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：挑选相应图标并获取类名，应用于页面：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon-xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>symbol 其实使用了 SVG Sprite 技术， 所有的 svg-sprite 都是通过 iconfont 的 iconfont.js 生成的，所以：</p><p>所有图标 icon 都很不直观，完全不知道哪个图标名对应什么图标，每次增删改图标，或者添加一些自定义的 svg 图标，只能将其也上传到 iconfont 和原有的图标放在一个项目库中，之后再重新下载，将整体 js 文件一起替换，而且也做不到按需加载</p><p>导出的 svg 包含大量的无用信息，例如编辑器源信息、注释等。通常包含其它一些不会影响渲染结果或可以移除的内容</p><h3 id="vue-cli3-项目使用-svg-sprite-loader-打包-svg"><a href="#vue-cli3-项目使用-svg-sprite-loader-打包-svg" class="headerlink" title="vue cli3 项目使用 svg-sprite-loader 打包 svg"></a>vue cli3 项目使用 svg-sprite-loader 打包 svg</h3><p>vue cli3 默认使用 file-loader 处理 svg：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* config.module.rule('svg') */</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(svg)(\?.*)?$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="comment">/* config.module.rule('svg').use('file-loader') */</span></span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'file-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        name: <span class="string">'static/img/[name].[hash:8].[ext]'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并路径指定为在 img 文件夹下，但我们的 svg 并不在 img 文件夹，而且 svg-sprite-loader 已经自带了 file-loader 的功能，所以，我们可以在我们自定义的 vue.config.js 文件下将 rule(svg) 清除：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.module.rule(<span class="string">'svg'</span>).uses.clear()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者添加忽略，然后加上自定义的 svg rule，最后的配置如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用 svg-sprite-loader 处理 svg */</span></span><br><span class="line"><span class="comment">// 默认规则忽略 src/icons 文件夹</span></span><br><span class="line">config.module</span><br><span class="line">  .rule(<span class="string">'svg'</span>)</span><br><span class="line">  .exclude.add(path.resolve(__dirname, <span class="string">'src/icons'</span>))</span><br><span class="line">  .end()</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/icons 文件夹下的 svg 使用 svg-sprite-loader</span></span><br><span class="line">config.module</span><br><span class="line">  .rule(<span class="string">'svg-sprite-loader'</span>)</span><br><span class="line">  .include.add(path.resolve(__dirname, <span class="string">'src/icons'</span>))</span><br><span class="line">  .end()</span><br><span class="line">  .test(<span class="regexp">/\.svg$/</span>)</span><br><span class="line">  .use(<span class="string">'svg-sprite'</span>)</span><br><span class="line">  .loader(<span class="string">'svg-sprite-loader'</span>)</span><br><span class="line">  .options(&#123;</span><br><span class="line">    symbolId: <span class="string">'icon-[name]'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .end()</span><br></pre></td></tr></table></figure><p>之后可以通过如下方式使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'@/icons/qq.svg'</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- xlink:href="#icon-图标文件名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon-qq"</span> /&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用缺点：需要手动导入图标</p><h3 id="自动导入"><a href="#自动导入" class="headerlink" title="自动导入"></a>自动导入</h3><p>使用 webpack 的 <a href="https://webpack.js.org/guides/dependency-management/#require-context" target="_blank" rel="noopener">require.context</a> api</p><p>require.context 语法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(directory, (useSubdirectories = <span class="literal">false</span>), (regExp = <span class="regexp">/^\.\//</span>))</span><br><span class="line"><span class="comment">// directory：说明需要检索的目录</span></span><br><span class="line"><span class="comment">// useSubdirectories：是否检索子目录</span></span><br><span class="line"><span class="comment">// regExp: 匹配文件的正则表达式</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="built_in">require</span>.context(<span class="string">'./test'</span>, <span class="literal">false</span>, /\.test\.js$/)</span><br><span class="line"><span class="comment">// 表示在 test 文件夹（不包含子目录）下面的找所有文件名以 .test.js 结尾的能被 require 的文件</span></span><br></pre></td></tr></table></figure><p>自动引入 @/icons 下面所有的图标</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础组件的自动化全局注册</span></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(<span class="string">'../../components'</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// console.log(requireComponent.keys())</span></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(filename)</span><br><span class="line">  <span class="comment">// console.log(componentConfig)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> componentName = filename</span><br><span class="line">    .split(<span class="string">'/'</span>)</span><br><span class="line">    .pop()</span><br><span class="line">    .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>)</span><br><span class="line">  <span class="comment">// console.log(componentName)</span></span><br><span class="line"></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> requireAll = <span class="function"><span class="params">requireContext</span> =&gt;</span> requireContext.keys().map(requireContext)</span><br><span class="line"><span class="keyword">const</span> req = <span class="built_in">require</span>.context(<span class="string">'@/icons'</span>, <span class="literal">false</span>)</span><br><span class="line">requireAll(req)</span><br></pre></td></tr></table></figure><p>之后直接将图标放入 <code>@/icons</code> 文件夹下就可以直接使用了，删改图标同理</p><h3 id="优化-svg"><a href="#优化-svg" class="headerlink" title="优化 svg"></a>优化 svg</h3><p>删除无用信息 <a href="https://github.com/svg/svgo" target="_blank" rel="noopener">svgo</a><br>阿里云导出的 svg 是带有默认的 fill 的，导致图标不能继承父级元素的颜色,可以通过删除默认 fill 解决</p><p>安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i svgo svgo-loader -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">config.module</span><br><span class="line">  .rule(<span class="string">'svg-sprite-loader'</span>)</span><br><span class="line">  .include.add(path.resolve(__dirname, <span class="string">'src/icons'</span>))</span><br><span class="line">  .use(<span class="string">'svgo-loader'</span>)</span><br><span class="line">  .loader(<span class="string">'svgo-loader'</span>)</span><br><span class="line">  .tap(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">    options = &#123;</span><br><span class="line">      plugins: [</span><br><span class="line">        &#123; <span class="attr">removeXMLNS</span>: <span class="literal">true</span> &#125;, <span class="comment">// 删除xmlns属性（对于内联svg，默认情况下禁用）</span></span><br><span class="line">        &#123; <span class="attr">convertStyleToAttrs</span>: <span class="literal">true</span> &#125; <span class="comment">// 将css样式转换为svg元素属性</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> options</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考链接：&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/59bb864b5188257e7a427c09&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/59bb864b5188257e
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>addEventListener 以及 vue 中的 .passive 修饰符</title>
    <link href="https://cuilongjin.top/2019/javascript/addEventListener%E4%BB%A5%E5%8F%8Avue%E4%B8%AD%E7%9A%84.passive%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>https://cuilongjin.top/2019/javascript/addEventListener以及vue中的.passive修饰符/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-08-01T12:05:11.459Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener</a></p><p>添加事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">target.addEventListener(type, listener[, useCapture])</span><br><span class="line"><span class="comment">// type: 事件的类型: click mouseover  字符串类型，不带 on</span></span><br><span class="line"><span class="comment">// listener: 函数，每次点击，执行这个函数</span></span><br><span class="line"><span class="comment">// useCapture: 可选，true: 事件在捕获阶段执行，false: 事件在冒泡阶段执行(默认)</span></span><br><span class="line"></span><br><span class="line">target.addEventListener(type, listener[, options])</span><br></pre></td></tr></table></figure><p>options 可选，可用的选项如下：<br>capture: Boolean，默认 false，等价于以前的 useCapture 参数<br>once: Boolean，默认 false，如果是 true，表示 listener 在添加之后最多只调用一次。 listener 也会在其被调用之后自动移除<br>passive: Boolean，默认 false，设置为 true 时，表示 listener 永远不会调用 preventDefault() 如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</p><p>浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿</p><p><code>.passive</code> 修饰符尤其能够提升移动端的性能<br><a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">vue .passive 事件修饰符</a></p><p>移除事件</p><p>removeEventListener</p><p>在第三个参数是布尔值的时候，addEventListener(“foo”, listener, true) 添加的监听器，必须用 removeEventListener(“foo”, listener, true) 才能删除掉, 因为这个监听器也有可能还注册在了冒泡阶段, 如果第三个参数为 false 则直接通过 removeEventListener(“foo”, listener) 就可以删除</p><p>通过 addEventListener(“foo”, listener, {capture: true}) 添加的监听器删除时也同样需要添加 {capture: true} 来删除，当然 {capture: true} 换成 true 也可以</p><p>通过 addEventListener(“foo”, listener, {passive: true}) 添加的监听器直接通过 removeEventListener(“foo”, listener) 就可以删除了<br>因为一个监听器同时是 passive 和非 passive（以及同时是 once 和非 once）是说不通的，如果你添加了多个，那么后添加的会忽略</p><p>removeEventListener(“foo”, listener, {capture: true}) // {capture: true} 必须加，当然 {capture: true} 换成 true 也可以</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端兼容性问题总结</title>
    <link href="https://cuilongjin.top/2019/%E7%A7%BB%E5%8A%A8web/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://cuilongjin.top/2019/移动web/移动端兼容性问题/</id>
    <published>2019-07-22T16:00:00.000Z</published>
    <updated>2019-07-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ios-移动端页面对点击事件有-300ms-延时"><a href="#1-ios-移动端页面对点击事件有-300ms-延时" class="headerlink" title="1. ios 移动端页面对点击事件有 300ms 延时"></a>1. ios 移动端页面对点击事件有 300ms 延时</h3><p>使用 fastclick 库 <a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a></p><p>使用 FastClick 的时候，在需要使用的层上，实例化它。我们使用 document.body 是因为希望所有的按钮和链接都获得快速点击</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> FastClick <span class="keyword">from</span> <span class="string">'fastclick'</span></span><br><span class="line">FastClick.attach(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><h3 id="2-ios-滚动卡顿"><a href="#2-ios-滚动卡顿" class="headerlink" title="2. ios 滚动卡顿"></a>2. ios 滚动卡顿</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch; <span class="comment">/* 当手指从触摸屏上移开，会保持一段时间的滚动 */</span></span><br><span class="line">  <span class="comment">/* -webkit-overflow-scrolling: auto; */</span> <span class="comment">/* 当手指从触摸屏上移开，滚动会立即停止 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ios-1px-border-变宽"><a href="#3-ios-1px-border-变宽" class="headerlink" title="3. ios 1px border 变宽"></a>3. ios 1px border 变宽</h3><p>以 dpr = 2 为例：<br>你拿到一张标准的基于 iphone6 的设计稿(750px)<br>你看到它设计的一个 border 宽度是 1px<br>你兴致勃勃地写下了 border: 1px solid #000;<br>然而 iphone6 实际渲染像素是 375px，那么设计需要 border 的其实是 border: 0.5px solid #000;<br>然后你的是 1px<br>不是 1px 变粗了，只是实际只是需要 0.5px 而已</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code> 意思是将物理设备的宽度设置给当前浏览器</p><p>在使用 table 标签设置 <code>border: 1px</code> 并使用 <code>border-collapse: collapse;</code> 合并边框后，发现 td 之间的边框宽度并不是 1px，而是比 1px 宽，大概为 1.5px</p><h3 id="4-webapp-软键盘弹起时问题"><a href="#4-webapp-软键盘弹起时问题" class="headerlink" title="4. webapp 软键盘弹起时问题"></a>4. webapp 软键盘弹起时问题</h3><p>页面放大:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>输入框被遮挡，看不见输入的内容: <code>element.scrollIntoView()</code></p><p>页面自动上移，但收回软键盘时页面少了一截:</p><p>fixed 定位效果失效: <code>ios 弹出软键盘的时候, webview 的高度没有变化导致超出屏幕范围</code></p><h3 id="5-手机端页面文件上传兼容性问题"><a href="#5-手机端页面文件上传兼容性问题" class="headerlink" title="5. 手机端页面文件上传兼容性问题"></a>5. 手机端页面文件上传兼容性问题</h3><h3 id="6-移动和-PC-端中的-hover-处理-移动端点击时会有-pc-端-hover-效果"><a href="#6-移动和-PC-端中的-hover-处理-移动端点击时会有-pc-端-hover-效果" class="headerlink" title="6. 移动和 PC 端中的 hover 处理 移动端点击时会有 pc 端 hover 效果"></a>6. 移动和 PC 端中的 hover 处理 移动端点击时会有 pc 端 hover 效果</h3><h3 id="7-webapp-禁用长按复制"><a href="#7-webapp-禁用长按复制" class="headerlink" title="7. webapp 禁用长按复制"></a>7. webapp 禁用长按复制</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">user-select</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><h3 id="8-ios-a-链接-input-type-”file”-等在点击时会出现灰色（touch-高亮）"><a href="#8-ios-a-链接-input-type-”file”-等在点击时会出现灰色（touch-高亮）" class="headerlink" title="8. ios a 链接 input type=”file” 等在点击时会出现灰色（touch 高亮）"></a>8. ios a 链接 input type=”file” 等在点击时会出现灰色（touch 高亮）</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-tap-highlight-color</span>: <span class="selector-tag">transparent</span>;</span><br></pre></td></tr></table></figure><h3 id="9-禁用浏览器自动调整字体大小"><a href="#9-禁用浏览器自动调整字体大小" class="headerlink" title="9. 禁用浏览器自动调整字体大小"></a>9. 禁用浏览器自动调整字体大小</h3><p>移动端浏览器切换橫向模式时会调整字体大小（字体变大），解决方式:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-text-size-adjust</span>: none; <span class="comment">/* 或 100% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>谷歌浏览器已不支持这个属性了，不能通过该方式实现小于 12px 的字体，可使用缩放（transform:scale(0.8)）来实现小于 12px 的字体</p></blockquote><h3 id="10-appearance-属性"><a href="#10-appearance-属性" class="headerlink" title="10. appearance 属性"></a>10. appearance 属性</h3><p>normal|icon|window|button|menu|field<br>所有主流浏览器都不支持 appearance 属性</p><p><code>-webkit-appearance: none;</code> 去除默认样式，使 ios 端和安卓端显示效果一样，但有一个问题，input 的 checkbox 和 radio 类型在安卓端可能无法正常显示</p><h3 id="11-webkit-touch-callout-none"><a href="#11-webkit-touch-callout-none" class="headerlink" title="11. -webkit-touch-callout: none;"></a>11. -webkit-touch-callout: none;</h3><p>在 iOS 上，当你触摸并按住触摸的目标，比如一个链接，浏览器将显示链接有关的系统默认菜单。该属性可以禁用系统默认菜单</p><p>点击穿透<br>假如页面上有两个元素 A 和 B。B 元素在 A 元素之上。我们在 B 元素的 touchstart 事件上注册了一个回调函数，该回调函数的作用是隐藏 B 元素。我们发现，当我们点击 B 元素，B 元素被隐藏了，随后，A 元素触发了 click 事件。<br>这是因为在移动端浏览器，事件执行的顺序是 touchstart &gt; touchend &gt; click。而 click 事件有 300ms 的延迟，当 touchstart 事件把 B 元素隐藏之后，隔了 300ms，浏览器触发了 click 事件，但是此时 B 元素不见了，所以该事件被派发到了 A 元素身上。如果 A 元素是一个链接，那此时页面就会意外地跳转。<br>跨页面点击穿透问题 点击页内按钮跳转至新页，然后发现新页面中对应位置元素的 click 事件被触发了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-ios-移动端页面对点击事件有-300ms-延时&quot;&gt;&lt;a href=&quot;#1-ios-移动端页面对点击事件有-300ms-延时&quot; class=&quot;headerlink&quot; title=&quot;1. ios 移动端页面对点击事件有 300ms 延时&quot;&gt;&lt;/a&gt;1. ios 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3 配置通用模板及配置详解</title>
    <link href="https://cuilongjin.top/2019/vue/vue-cli3%E9%85%8D%E7%BD%AE%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://cuilongjin.top/2019/vue/vue-cli3配置通用模板及配置详解/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-08-13T12:03:02.764Z</updated>
    
    <content type="html"><![CDATA[<p>安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>创建一个项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create my-project</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">vue ui</span><br></pre></td></tr></table></figure><p>如果你仍然需要使用旧版本的 <code>vue init</code> 功能，你可以全局安装一个桥接工具：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"><span class="comment"># `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span></span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure><h3 id="在现有的项目中安装插件"><a href="#在现有的项目中安装插件" class="headerlink" title="在现有的项目中安装插件"></a>在现有的项目中安装插件</h3><p>每个 CLI 插件都会包含一个 (用来创建文件的) 生成器和一个 (用来调整 webpack 核心配置和注入命令的) 运行时插件。当你使用 <code>vue create</code> 来创建一个新项目的时候，有些插件会根据你选择的特性被预安装好。如果你想在一个已经被创建好的项目中安装一个插件，可以使用 <code>vue add</code> 命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add @vue/eslint</span><br></pre></td></tr></table></figure><p>提示</p><p><code>vue add</code> 的设计意图是为了安装和调用 Vue CLI 插件。对于普通的 npm 包而言，这不意味有一个替代（命令）。对于这些普通的 npm 包，你仍然需要（根据所选的 npm 包）使用包管理器。</p><h2 id="vue-config-js-配置"><a href="#vue-config-js-配置" class="headerlink" title="vue.config.js 配置"></a>vue.config.js 配置</h2><p><a href="https://cli.vuejs.org/zh/config" target="_blank" rel="noopener">官网配置参考</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h3><p>基本路径</p><p>vue-cli3.3 以下版本使用 baseUrl</p><p>vue-cli3.3+ 使用 publicPath</p><p>默认 ‘/‘</p><p>‘./‘ 或为空(‘’) 所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径, 当使用 pages 选项构建多页面应用时,应当避免使用相对路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">publicPath: <span class="string">'./'</span></span><br></pre></td></tr></table></figure><h3 id="outputDir"><a href="#outputDir" class="headerlink" title="outputDir"></a>outputDir</h3><p>默认 ‘dist’</p><p>当运行 vue-cli-service build 时生成的生产环境构建文件的目录</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">outputDir: <span class="string">'dist'</span></span><br></pre></td></tr></table></figure><h3 id="assetsDir"><a href="#assetsDir" class="headerlink" title="assetsDir"></a>assetsDir</h3><p>默认 ‘’</p><p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assetsDir: <span class="string">'static'</span></span><br></pre></td></tr></table></figure><h3 id="indexPath"><a href="#indexPath" class="headerlink" title="indexPath"></a>indexPath</h3><p>指定生成的 <code>index.html</code> 的输出路径 (相对于 <code>outputDir</code>)。也可以是一个绝对路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">indexPath: <span class="string">'index.html'</span></span><br></pre></td></tr></table></figure><h3 id="filenameHashing"><a href="#filenameHashing" class="headerlink" title="filenameHashing"></a>filenameHashing</h3><p>默认 true</p><p>默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。然而，这也要求 index 的 HTML 是被 Vue CLI 自动生成的。如果你无法使用 Vue CLI 生成的 index HTML，你可以通过将这个选项设为 false 来关闭文件名哈希</p><h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><p>默认 undefined</p><p>是否以多页模式构建应用程序</p><p>每个 ‘page’ 应该有一个对应的 JavaScript 入口文件。其值应该是一个对象，对象的 key 是入口的名字，value 是 一个指定了 entry, template, filename, title 和 chunks 的对象 (除了 entry 之外都是可选的) 或一个指定其 entry 的字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      <span class="comment">// page 的入口</span></span><br><span class="line">      entry: <span class="string">'src/pages/index/main.js'</span>,</span><br><span class="line">      <span class="comment">// 模板来源</span></span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      <span class="comment">// 在 dist/index.html 的输出</span></span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">      title: <span class="string">'Index Page'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    pageA: &#123;</span><br><span class="line">      entry: <span class="string">'src/pages/pageA/main.js'</span>,</span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'pageA.html'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当使用只有入口的字符串格式时, 模板会被推导为 `public/pageB.html`</span></span><br><span class="line">    <span class="comment">// 并且如果找不到的话，就回退到 `public/index.html`, 输出文件名会被推导为 `pageB.html`</span></span><br><span class="line">    pageB: <span class="string">'src/pages/pageB/main.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lintOnSave"><a href="#lintOnSave" class="headerlink" title="lintOnSave"></a>lintOnSave</h3><p>默认 true</p><p>是否在保存的时候检查，如果为 true ，build 时会启用 eslint-loader 进行代码检查，可以使用如下配置禁用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">lintOnSave: process.env.NODE_ENV !== <span class="string">'production'</span></span><br></pre></td></tr></table></figure><h3 id="runtimeCompiler"><a href="#runtimeCompiler" class="headerlink" title="runtimeCompiler"></a>runtimeCompiler</h3><p>默认 false</p><p>是否使用包含运行时编译器的 Vue 构建版本</p><p>使用 template 语法需要开启，但是这会让你的应用额外增加 10kb 左右，使用渲染函数不需要开启</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">runtimeCompiler: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="productionSourceMap"><a href="#productionSourceMap" class="headerlink" title="productionSourceMap"></a>productionSourceMap</h3><p>默认 true</p><p>生产环境是否生成 sourceMap 文件，一般情况不建议打开</p><p>map 文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。有了 map 就可以像未加密的代码一样，准确的输出是哪一行哪一列有错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">productionSourceMap: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h3><p>对内部的 webpack 配置进行更细粒度的修改</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chainWebpack = <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 删除预加载模块的 prefetch，降低带宽压力</span></span><br><span class="line">  <span class="comment">// https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch</span></span><br><span class="line">  <span class="comment">// 移除 prefetch 插件</span></span><br><span class="line">  config.plugins.delete(<span class="string">'prefetch'</span>)</span><br><span class="line">  <span class="comment">// 移除 preload 插件</span></span><br><span class="line">  config.plugins.delete(<span class="string">'preload'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// config.plugin('html').tap(args =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   args[0].minify = false</span></span><br><span class="line">  <span class="comment">//   return args</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置绝对路径 */</span></span><br><span class="line">  config.resolve.alias.set(<span class="string">'~'</span>, path.resolve(<span class="string">'public'</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改静态资源打包方式，下例为超过10k才用文件导入的方式，否则为base64.默认为4k</span></span><br><span class="line">  config.module</span><br><span class="line">    .rule(<span class="string">'images'</span>)</span><br><span class="line">    .use(<span class="string">'url-loader'</span>)</span><br><span class="line">    .loader(<span class="string">'url-loader'</span>)</span><br><span class="line">    .tap(<span class="function"><span class="params">options</span> =&gt;</span> <span class="built_in">Object</span>.assign(options, &#123; <span class="attr">limit</span>: <span class="number">10240</span> &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  chainWebpack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html#preload" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/html-and-static-assets.html#preload</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" target="_blank" rel="noopener"><code>&lt;link rel=&quot;preload&quot;&gt;</code></a>是一种 resource hint，用来指定页面加载后很快会被用到的资源，所以在页面加载的过程中，我们希望在浏览器开始主体渲染之前尽早 preload。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ" target="_blank" rel="noopener"><code>&lt;link rel=&quot;prefetch&quot;&gt;</code></a> 是一种 resource hint，用来告诉浏览器在页面加载完成后，利用空闲时间提前获取用户未来可能会访问的内容。</p><h3 id="configureWebpack"><a href="#configureWebpack" class="headerlink" title="configureWebpack"></a>configureWebpack</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 自定义配置</span></span><br><span class="line"><span class="comment">// https://cli.vuejs.org/zh/guide/webpack.html</span></span><br><span class="line"><span class="keyword">const</span> configureWebpack = <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 生产 and 测试环境</span></span><br><span class="line">  <span class="keyword">let</span> pluginsPro = [</span><br><span class="line">    <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">      <span class="comment">// 文件开启 Gzip，也可以通过服务端(如：nginx)(https://github.com/webpack-contrib/compression-webpack-plugin)</span></span><br><span class="line">      filename: <span class="string">'[path].gz[query]'</span>,</span><br><span class="line">      algorithm: <span class="string">'gzip'</span>,</span><br><span class="line">      test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\.('</span> + [<span class="string">'js'</span>, <span class="string">'css'</span>].join(<span class="string">'|'</span>) + <span class="string">')$'</span>),</span><br><span class="line">      threshold: <span class="number">8192</span>,</span><br><span class="line">      minRatio: <span class="number">0.8</span></span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Webpack 包文件分析器(https://github.com/webpack-contrib/webpack-bundle-analyzer)</span></span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打包时删除 debugger 和 console</span></span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          drop_debugger: <span class="literal">true</span>,</span><br><span class="line">          drop_console: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      sourceMap: <span class="literal">true</span>,</span><br><span class="line">      parallel: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// 开发环境</span></span><br><span class="line">  <span class="keyword">let</span> pluginsDev = [</span><br><span class="line">    <span class="comment">//  移动端模拟开发者工具 (https://github.com/diamont1001/vconsole-webpack-plugin  https://github.com/Tencent/vConsole)</span></span><br><span class="line">    <span class="comment">// new vConsolePlugin(&#123;</span></span><br><span class="line">    <span class="comment">//   filter: [], // 需要过滤的入口文件</span></span><br><span class="line">    <span class="comment">//   enable: true // 发布代码前记得改回 false</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// 为生产环境修改配置...process.env.NODE_ENV !== 'development'</span></span><br><span class="line">    config.plugins = [...config.plugins, ...pluginsPro]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 为开发环境修改配置...</span></span><br><span class="line">    config.plugins = [...config.plugins, ...pluginsDev]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  configureWebpack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境变量与分环境打包"><a href="#环境变量与分环境打包" class="headerlink" title="环境变量与分环境打包"></a>环境变量与分环境打包</h3><p><a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-build" target="_blank" rel="noopener">vue-cli-service-build</a><br>vue-cli-service build –mode 指定环境模式(默认值：production)</p><p>npm run build 默认模式为 production ，命令执行时会把 process.env.NODE_ENV(环境变量) 设置为 ‘production’<br>npm run serve 时会把 process.env.NODE_ENV 设置为 ‘development’</p><p>所以可以根据 process.env.NODE_ENV 简单的区分出本地和线上环境</p><p>但是线上环境也可能分多种，比如测试环境和预发布环境等</p><p><strong>配置 vue-cli3 区分不同的线上环境</strong></p><p>在项目根目录创建下列文件来制定环境变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.env                # 在所有的环境中被载入</span><br><span class="line">.env.local          # 在所有的环境中被载入，但会被 git 忽略</span><br><span class="line">.env.[mode]         # 只在指定的模式中被载入</span><br><span class="line">.env.[mode].local   # 只在指定的模式中被载入，但会被 git 忽略</span><br></pre></td></tr></table></figure><p><code>.env.test</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* VUE_APP_CURRENTMODE 当前环境变量 */</span><br><span class="line">VUE_APP_CURRENTMODE = &apos;t&apos; // 表明开发环境模式信息</span><br><span class="line">NODE_ENV = &apos;development&apos; // 使用开发环境（因为默认开启 devtool，便于调试）</span><br><span class="line">// VUE_APP_BASEURL=&apos;&apos; // 测试服务器地址</span><br><span class="line">VUE_APP_ENV = &apos;test 环境&apos;</span><br></pre></td></tr></table></figure><p>在 package.json 中添加</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "vue-cli-service build --mode t",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 baseUrl.js 文件通过环境变量改变 baseUrl</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.VUE_APP_CURRENTMODE === <span class="string">'t'</span>) &#123;</span><br><span class="line">  <span class="comment">// 测试环境</span></span><br><span class="line">  baseUrl = <span class="string">''</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 正式环境</span></span><br><span class="line">  baseUrl = <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要为测试环境进行打包的时候 , 只需要运行下面指令进行打包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>但是将打包环境设置为 NODE_ENV = ‘development’ 导致打包出来的 js 文件只有 index.js 文件并且在根目录下, 并不是我们想要的</p><p>所以我们可以这样配置</p><p>.env.test</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VUE_APP_CURRENTMODE = &apos;t&apos;</span><br><span class="line">NODE_ENV = &apos;production&apos;</span><br><span class="line">VUE_APP_ENV = &apos;test 环境&apos;</span><br></pre></td></tr></table></figure><p>main.js 配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDebugMode = process.env.VUE_APP_CURRENTMODE === <span class="string">'t'</span></span><br><span class="line">Vue.config.debug = isDebugMode</span><br><span class="line">Vue.config.devtools = isDebugMode</span><br><span class="line">Vue.config.productionTip = isDebugMode</span><br></pre></td></tr></table></figure><h3 id="vue-公共路径提取"><a href="#vue-公共路径提取" class="headerlink" title="vue 公共路径提取"></a>vue 公共路径提取</h3><p>vue 项目中公共路径在打包之后一旦遇到整体的路径更改就需要再次打包。我们可以将公共路径提取出来，修改公共路径后不需要重新打包就能生效</p><p>在 public 文件夹下创建 config.js 文件，并配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> serverConfig = &#123;</span><br><span class="line">  baseUrl: <span class="string">''</span> <span class="comment">// 配置 url</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 index.html 中引入该文件，之后在开发时就可以通过 <code>serverConfig.baseUrl</code> 使用变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add router</span><br><span class="line">vue add vuex</span><br></pre></td></tr></table></figure><h3 id="配置-externals"><a href="#配置-externals" class="headerlink" title="配置 externals"></a>配置 externals</h3><p>如果我们想引用一个包，但是又不想让 webpack 打包，并且又不影响我们在程序中以 CMD、AMD 或者 window/global 全局等方式进行使用，那就可以通过配置 externals 将包抽离出来。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- script 标签引入vue  element-ui --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"cdn/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"cdn/element-ui.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.externals = &#123;</span><br><span class="line">    vue: <span class="string">'Vue'</span>, <span class="comment">// key 为库名称，value 为库在你项目中使用的关键字</span></span><br><span class="line">    <span class="string">'element-ui'</span>: <span class="string">'ELEMENT'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改本地-host-通过域名访问项目"><a href="#修改本地-host-通过域名访问项目" class="headerlink" title="修改本地 host 通过域名访问项目"></a>修改本地 host 通过域名访问项目</h3><p>配置 host</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># host</span><br><span class="line">127.0.0.1 abc.baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  host: <span class="string">'abc.baidu.com'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npm run serve 启动服务后可以通过 abc.baidu.com 访问</p><p>如果访问不了，可能需要清理 dns 缓存</p><p>清空电脑的 DNS 缓存：cmd 运行 ipconfig /flushdns</p><p>清理浏览器中的 dns 缓存：浏览器打开 chrome://net-internals/#dns</p><p>如果 host 为 127.0.0.1 或 localhost，需要配置 disableHostCheck: true</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  disableHostCheck: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新版的 webpack-dev-server 出于安全考虑，默认检查 hostname<br>disableHostCheck: true 目的是解决通过域名访问时出现 Invalid Host header</p><p>经测试 依然会出现 Invalid Host header，导致项目不能正常访问</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install -g @vue/cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>less 使用 - mixin 混合</title>
    <link href="https://cuilongjin.top/2019/tool/less-mixin%E6%B7%B7%E5%90%88/"/>
    <id>https://cuilongjin.top/2019/tool/less-mixin混合/</id>
    <published>2019-07-20T16:00:00.000Z</published>
    <updated>2019-08-01T12:05:11.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mixin-混合"><a href="#mixin-混合" class="headerlink" title="mixin 混合"></a>mixin 混合</h3><p>可以在 mixin 中使用类选择器和 id 选择器</p><p>.bgc 定义了一个属性集，在任何需要使用 .bgc 属性集的选择器中，只需像下面这样调用：(小括号是可选的)</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bgc</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">  <span class="selector-class">.bgc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的 CSS 代码为：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bgc</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：mixin 其实就是一种嵌套，简单的讲，mixin 就是规则级别的复用</p><p>mixin 的定义也会被原封不动的输出到编译生成的 CSS 代码中</p><p>如果希望编译生成的 CSS 代码中不包含 mixin 的定义，在定义 mixin 时，只需在 class、id 的后面添加一对小括号即可。如：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bgc</span>() &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.bgc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的 CSS 代码为：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mixin 可以包含选择器</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hover</span>() &#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.hover</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的 CSS 代码为：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令空间-Namespaces"><a href="#命令空间-Namespaces" class="headerlink" title="命令空间 Namespaces"></a>命令空间 Namespaces</h3><p>如果想要在一个更复杂的选择器中混合属性，可以堆叠多个 id 或类</p><p>可以将 mixin 置于 id 选择器之下，这样可以确保它不会和另一个库冲突</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#bgc</span> &#123;</span><br><span class="line">  <span class="selector-class">.inner</span>() &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-id">#bgc</span><span class="selector-class">.inner</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="important-关键字"><a href="#important-关键字" class="headerlink" title="!important 关键字"></a>!important 关键字</h3><p>在 mixin 后使用 !important 关键字，将会标记调用所有继承的属性为!important</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bgc</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.bgc</span> !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后 css 为</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带参数的 Mixin</p><p>mixin 还可以接受参数，这些参数在混合时传递给选择器块</p><p>从上面的代码可以看出：mixin 其实就是一种嵌套，简单的讲，mixin 就是规则级别的复用。除了类选择器外，你也可以使用 id 选择器来定义 mixin。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mixin-混合&quot;&gt;&lt;a href=&quot;#mixin-混合&quot; class=&quot;headerlink&quot; title=&quot;mixin 混合&quot;&gt;&lt;/a&gt;mixin 混合&lt;/h3&gt;&lt;p&gt;可以在 mixin 中使用类选择器和 id 选择器&lt;/p&gt;
&lt;p&gt;.bgc 定义了一个属性集
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>高阶函数与柯里化</title>
    <link href="https://cuilongjin.top/2019/javascript/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://cuilongjin.top/2019/javascript/高阶函数与柯里化/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数定义：将函数作为参数或者返回值是函数的函数<br>常见的 sort、reduce 等函数就是高阶函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = add(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6写法</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术</p><p>柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要 n 个参数的函数变成只需要剩下的（n - 1 个）参数就可以调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形如</span></span><br><span class="line">a =&gt; <span class="function"><span class="params">b</span> =&gt;</span> c =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br><span class="line"><span class="keyword">let</span> add1 = add(<span class="number">1</span>) <span class="comment">// a = 1; b =&gt; a + b</span></span><br><span class="line">add1(<span class="number">2</span>) <span class="comment">// 1 + 2 = 3</span></span><br></pre></td></tr></table></figure><p>add1 函数等价于有了 a 这个闭包变量的 b = a + b</p><p>add 函数按照 wiki 的定义可以理解成只柯里化了一次，n 个连续箭头组成的函数实际上就是柯里化了 n - 1 次<br>前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值</p><p>所以多个连续箭头函数就是多次柯里化的 es6 写法</p><p><strong>应用：</strong></p><p>函数懒执行<br>函数式编程</p><p><strong>柯里化函数使用场景：</strong></p><p>减少重复传递不变的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price, discount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * discount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次都要重复传入 discount 参数，可以将这个函数柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price, discount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">price</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price * discount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tenPercentDiscount = discount(<span class="number">0.9</span>) <span class="comment">// 9折</span></span><br><span class="line"><span class="keyword">const</span> twentyPercentDiscount = discount(<span class="number">0.8</span>) <span class="comment">// 8折</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在每次计算价格只需要：</span></span><br><span class="line">tenPercentDiscount(<span class="number">500</span>) <span class="comment">// 500 * 0.9</span></span><br><span class="line">twentyPercentDiscount(<span class="number">1000</span>) <span class="comment">// 1000 * 0.8</span></span><br></pre></td></tr></table></figure><h2 id="柯里化实现"><a href="#柯里化实现" class="headerlink" title="柯里化实现"></a>柯里化实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="keyword">this</span>, args.concat(args2))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum)</span><br><span class="line"><span class="built_in">console</span>.log(curriedSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curriedSum(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高阶函数&quot;&gt;&lt;a href=&quot;#高阶函数&quot; class=&quot;headerlink&quot; title=&quot;高阶函数&quot;&gt;&lt;/a&gt;高阶函数&lt;/h2&gt;&lt;p&gt;高阶函数定义：将函数作为参数或者返回值是函数的函数&lt;br&gt;常见的 sort、reduce 等函数就是高阶函数&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>axios 取消请求</title>
    <link href="https://cuilongjin.top/2019/javascript/axios%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/"/>
    <id>https://cuilongjin.top/2019/javascript/axios取消请求/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>原生 js abort() 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = $.ajax(&#123;&#125;)</span><br><span class="line">A.abort()</span><br></pre></td></tr></table></figure><p>Axios 提供了一个 CancelToken 的函数，这是一个构造函数，该函数的作用就是用来取消接口请求的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  getMsg () &#123;</span><br><span class="line">    <span class="keyword">let</span> CancelToken = axios.CancelToken</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    axios.get(<span class="string">''</span>, &#123;</span><br><span class="line">      cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        that.cancel = c</span><br><span class="line">        <span class="built_in">console</span>.log(c)</span><br><span class="line">        <span class="comment">// 这个参数 c 就是 CancelToken 构造函数里面自带的取消请求的函数，这里把该函数当参数用</span></span><br><span class="line">      &#125;)</span><br><span class="line">      params: &#123;&#125;</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.items = res.data</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelGetMsg () &#123;</span><br><span class="line">    <span class="keyword">this</span>.cancel()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原生 js abort() 方法&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; A 
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3 多页模式</title>
    <link href="https://cuilongjin.top/2019/vue/%E5%A4%9A%E9%A1%B5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://cuilongjin.top/2019/vue/多页模式/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2019-07-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cli.vuejs.org/zh/config/#pages" target="_blank" rel="noopener">vue-cli 多页面的配置官方介绍</a></p><p><code>vue.config.js</code> 配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      <span class="comment">// page 的入口</span></span><br><span class="line">      entry: <span class="string">'src/pages/index/main.js'</span>,</span><br><span class="line">      <span class="comment">// 模板来源</span></span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      <span class="comment">// 在 dist/index.html 的输出</span></span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">      title: <span class="string">'Index Page'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    pageA: &#123;</span><br><span class="line">      entry: <span class="string">'src/pages/pageA/main.js'</span>,</span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'pageA.html'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当使用只有入口的字符串格式时, 模板会被推导为 `public/pageB.html`</span></span><br><span class="line">    <span class="comment">// 并且如果找不到的话，就回退到 `public/index.html`, 输出文件名会被推导为 `pageB.html`</span></span><br><span class="line">    pageB: <span class="string">'src/pages/pageB/main.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个页面一套 SPA，入口文件、路由、资源的路径都要根据实际情况进行设置</p><p>页面内可以继续使用<code>SPA</code>模式的<code>&lt;router-link&gt;</code>，但是页面之间的跳转需要使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/pageA.html"</span>&gt;</span>前往 pageA 页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cli.vuejs.org/zh/config/#pages&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cli 多页面的配置官方介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vue.config.js&lt;/code&gt; 
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>keep-alive 实现页面缓存</title>
    <link href="https://cuilongjin.top/2019/vue/keep-alive/"/>
    <id>https://cuilongjin.top/2019/vue/keep-alive/</id>
    <published>2019-07-14T16:00:00.000Z</published>
    <updated>2019-07-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>缓存</p><ul><li><p>pageAList -&gt; pageADetail -&gt; pageAList，缓存 pageAList，同时如果 pageAList 发生变化需要更新</p></li><li><p>其他页面 -&gt; pageAList，pageAList 不缓存</p></li></ul><p>router 配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/pageAList'</span>,</span><br><span class="line">        name: <span class="string">'pageAList'</span>,</span><br><span class="line">        component: pageAList</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/pageADetail'</span>,</span><br><span class="line">        name: <span class="string">'pageADetail'</span>,</span><br><span class="line">        component: pageADetail</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>vuex 配置 store.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    includeComponents: [] <span class="comment">// 需要缓存的组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    addIncludeComponent(state, includeComponent) &#123;</span><br><span class="line">      <span class="comment">// includeComponent 可能是组件 name 字符串或者数组</span></span><br><span class="line">      <span class="keyword">let</span> includeComponents = state.includeComponents</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(includeComponent)) &#123;</span><br><span class="line">        state.includeComponents = [...new <span class="built_in">Set</span>([...includeComponents, ...includeComponent])]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.includeComponents = [...new <span class="built_in">Set</span>([...includeComponents, includeComponent])]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    removeIncludeComponent(state, includeComponent) &#123;</span><br><span class="line">      <span class="keyword">let</span> includeComponents = state.includeComponents</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(includeComponent)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; includeComponent.length; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> index = includeComponents.findIndex(<span class="function"><span class="params">v</span> =&gt;</span> v === includeComponent[i])</span><br><span class="line">          <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            includeComponents.splice(index, <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = includeComponents.length; i &lt; len; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (includeComponents[i] === includeComponent) &#123;</span><br><span class="line">            includeComponents.splice(i, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state.includeComponents = includeComponents</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>home.vue</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- keep-alive 包裹 router-view --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"includeComponents"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    computed: &#123;</span></span><br><span class="line"><span class="undefined">      includeComponents() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.includeComponents</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>pageAList.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'pageAList'</span>,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/pageADetail/</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(to.name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'addIncludeComponent'</span>, <span class="string">'pageADetail'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'removeIncludeComponent'</span>, <span class="string">'pageADetail'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pageADetail.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'pageADetail'</span>,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/pageA/</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(to.name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'addIncludeComponent'</span>, <span class="string">'pageAList'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'removeIncludeComponent'</span>, <span class="string">'pageAList'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>进入 pageAList，离开当前组件的时候有两种情况：<ul><li>跳转进去 pageADetail，在 pageAList 的 beforeRouteLeave 钩子里面缓存 pageAList</li><li>跳转到非 pageADetail 的页面，在 pageAList 的 beforeRouteLeave 钩子里面清除 pageAList 的缓存</li></ul></li></ul><ul><li>从 pageADetail 离开的时候，也有两种情况：<ul><li>回到 pageAList，在 pageADetail 的 beforeRouteLeave 钩子里面缓存 pageAList，所以从 pageAList-pageADetail-pageAList 的时候，pageAList 可以被缓存，还是之前的页码状态</li><li>进入其他路由，在 pageADetail 的 beforeRouteLeave 钩子里面清除 pageAList 的缓存</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pageAList -&amp;gt; pageADetail -&amp;gt; pageAList，缓存 pageAList，同时如果 pageAList 发生变化需要更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他页面 -&amp;gt; pageAList
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3.0 内存溢出 JavaScript heap out of memory</title>
    <link href="https://cuilongjin.top/2019/vue/vue-cli3%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3/"/>
    <id>https://cuilongjin.top/2019/vue/vue-cli3 内存溢出解决/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>错误内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;--- JS stacktrace ---&gt;</span><br><span class="line"></span><br><span class="line">==== JS stack trace =========================================</span><br><span class="line"></span><br><span class="line">    0: ExitFrame [pc: 000002861B95C5C1]</span><br><span class="line">Security context: 0x002fdeb1e6e9 &lt;JSObject&gt;</span><br><span class="line">    1: DoJoin(aka DoJoin) [0000002FDEB05E91] [native array.js:~87] [pc=000002861C436409](this=0x0037aae826f1 &lt;undefined&gt;,l=0x01420be65761 &lt;JSArray[2]&gt;,m=2,A=0x0037aae828c9 &lt;true&gt;,w=0x0375f51b46d9 &lt;String[1]\: \n&gt;,v=0x0037aae829a1 &lt;false&gt;)</span><br><span class="line">    2: Join(aka Join) [0000002FDEB05EE1] [native array.js:~112] [pc=000002861BC4F978](this=0x0037aae826f1 &lt;undefined&gt;,l...</span><br><span class="line"></span><br><span class="line">FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory</span><br></pre></td></tr></table></figure><p>百度出的原因及解决方案基本都是：</p><p>nodejs 内存限制，通过添加启动参数可以解决</p><p>vue-cli2：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dev 和 npm run build 直接在前面加上--max_old_space_size=4096</span><br></pre></td></tr></table></figure><p>vue-cli3：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx --max_old_space_size=4096 vue-cli-service serve</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i increase-memory-limit cross-env</span><br><span class="line">scripts 中添加指令 <span class="string">"fix-memory-limit"</span>: <span class="string">"cross-env LIMIT=4096 increase-memory-limit"</span></span><br><span class="line">npm run fix-memory-limit</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p><span class="red">但是通过以上设置并没有解决问题，最后将 lintOnsave: false 解决了</span></p><p>由此分析 lintOnsave 为 true 时 ，npm run serve|build 时会启用 eslint-loader 进行代码检查，某些插件可能无法进行代码检查并产生了递归，导致内存溢出，因为该项目使用了 Ueditor 插件，之后将 Ueditor 插件加入 eslintignore 并将 lintOnsave 恢复成 true，项目依然能够正常运行</p><p>参考链接: <a href="https://github.com/vuejs/vue-cli/issues/1453" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli/issues/1453</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;错误内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;--- JS stacktrace ---&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli 常用配置</title>
    <link href="https://cuilongjin.top/2019/vue/vue-cli%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://cuilongjin.top/2019/vue/vue-cli常用配置/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h2 id="vue-cli-webpack-打包后-index-html-引入文件没有引号"><a href="#vue-cli-webpack-打包后-index-html-引入文件没有引号" class="headerlink" title="vue-cli webpack 打包后 index.html 引入文件没有引号"></a>vue-cli webpack 打包后 index.html 引入文件没有引号</h2></li></ul><p>解决办法：</p><p>vue-cli2：</p><p>在 webpack.prod.conf.js 中修改：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeAttributeQuotes: <span class="literal">false</span> <span class="comment">// 如果该方法没有用那就把整个 minify 去掉</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>vue-cli3:</p><p>在 vue.config.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">    args[<span class="number">0</span>].minify = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="vue-cli-打包时删除-console、deugger、注释"><a href="#vue-cli-打包时删除-console、deugger、注释" class="headerlink" title="vue-cli 打包时删除 console、deugger、注释"></a>vue-cli 打包时删除 console、deugger、注释</h2></li></ul><p>vue-cli2：</p><p>在 webpack.prod.conf.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">    uglifyOptions: &#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        drop_debugger: <span class="literal">true</span>,</span><br><span class="line">        drop_console: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        comment: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>vue-cli3：</p><p>安装 uglifyjs-webpack-plugin</p><p>在 vue.config.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          drop_debugger: <span class="literal">true</span>,</span><br><span class="line">          drop_console: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">          comment: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      parallel: <span class="literal">true</span>,</span><br><span class="line">      cache: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;vue-cli-webpack-打包后-index-html-引入文件没有引号&quot;&gt;&lt;a href=&quot;#vue-cli-webpack-打包后-index-html-引入文件没有引号&quot; class=&quot;headerlink&quot; title=&quot;vue-c
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>js 中编码（encode）和解码（decode）的三种方法</title>
    <link href="https://cuilongjin.top/2019/other/js%20%E4%B8%AD%E7%BC%96%E7%A0%81%EF%BC%88encode%EF%BC%89%E5%92%8C%E8%A7%A3%E7%A0%81%EF%BC%88decode%EF%BC%89%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://cuilongjin.top/2019/other/js 中编码（encode）和解码（decode）的三种方法/</id>
    <published>2019-07-09T08:42:00.000Z</published>
    <updated>2019-07-09T09:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js-中编码（encode）和解码（decode）的三种方法"><a href="#js-中编码（encode）和解码（decode）的三种方法" class="headerlink" title="js 中编码（encode）和解码（decode）的三种方法"></a>js 中编码（encode）和解码（decode）的三种方法</h3><p>js 对文字进行编码涉及 3 个函数：escape、encodeURI、encodeURIComponent，相应 3 个解码函数：unescape、decodeURI、decodeURIComponent</p><ul><li>escape()函数</li></ul><p>定义和用法：escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串<br>语法：escape(string)<br>参数：string 必需，要被转义或编码的字符串。<br>返回值：已编码的 string 的副本。其中某些字符被替换成了十六进制的转义序列<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： <code>-_.!~*&#39;()</code> ，其他所有的字符都会被转义序列替换</p><ul><li>encodeURI()函数</li></ul><p>定义和用法：encodeURI() 函数可把字符串作为 URI 进行编码<br>语法：encodeURI(URIstring)<br>参数：URIstring 必需，一个字符串，含有 URI 或其他要编码的文本。<br>返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：<code>-_.!~*&#39;()</code> ，该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：<code>;/?:@&amp;=+$,#</code></p><ul><li>encodeURIComponent()</li></ul><p>定义和用法：encodeURIComponent() 函数可把字符串作为 URI 组件进行编码<br>语法：encodeURIComponent(URIstring)<br>参数：URIstring 必需，一个字符串，含有 URI 组件或其他要编码的文本<br>返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：<code>-_.!~*&#39;()</code>，其他字符（比如 ：<code>;/?:@&amp;=+$,#</code> 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的</p><p>说明：</p><ul><li><p>encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号</p></li><li><p>传递参数时需要使用 encodeURIComponent，这样组合的 url 才不会被#等特殊字符截断</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js-中编码（encode）和解码（decode）的三种方法&quot;&gt;&lt;a href=&quot;#js-中编码（encode）和解码（decode）的三种方法&quot; class=&quot;headerlink&quot; title=&quot;js 中编码（encode）和解码（decode）的三种方法&quot;&gt;
      
    
    </summary>
    
      <category term="other" scheme="https://cuilongjin.top/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端(Safari)浏览网页时对数字禁用电话功能</title>
    <link href="https://cuilongjin.top/2019/%E7%A7%BB%E5%8A%A8web/%E7%A7%BB%E5%8A%A8%E7%AB%AF(Safari)%E6%B5%8F%E8%A7%88%E7%BD%91%E9%A1%B5%E6%97%B6%E5%AF%B9%E6%95%B0%E5%AD%97%E7%A6%81%E7%94%A8%E7%94%B5%E8%AF%9D%E5%8A%9F%E8%83%BD/"/>
    <id>https://cuilongjin.top/2019/移动web/移动端(Safari)浏览网页时对数字禁用电话功能/</id>
    <published>2019-07-09T06:51:00.000Z</published>
    <updated>2019-08-01T12:05:11.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端-Safari-浏览网页时对数字禁用电话功能"><a href="#移动端-Safari-浏览网页时对数字禁用电话功能" class="headerlink" title="移动端(Safari)浏览网页时对数字禁用电话功能"></a>移动端(Safari)浏览网页时对数字禁用电话功能</h2><ul><li>标准的电话号码格式是：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"tel:+86-123-456-7890"</span>&gt;</span>1234567890<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>有时候不是电话号码的数字会被浏览器自动解析为如上电话号码格式，导致样式和布局改变</p></li><li><p>忽略页面中的数字识别为电话号码, 只要把这个默认行为关闭就行</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这个关闭不会影响真正电话号码的识别</li></ul><p>说明：Meta 标签中的 format-detection 属性及含义<br>format-detection 中文的意思是 “格式检测”，它是用来检测 html 里的一些格式的</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 禁止了把数字转化为拨号链接 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 禁止作为邮箱地址 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"email=no"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 禁止跳转至地图 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"adress=no"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no,email=no,adress=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移动端-Safari-浏览网页时对数字禁用电话功能&quot;&gt;&lt;a href=&quot;#移动端-Safari-浏览网页时对数字禁用电话功能&quot; class=&quot;headerlink&quot; title=&quot;移动端(Safari)浏览网页时对数字禁用电话功能&quot;&gt;&lt;/a&gt;移动端(Safari)
      
    
    </summary>
    
      <category term="移动web" scheme="https://cuilongjin.top/categories/%E7%A7%BB%E5%8A%A8web/"/>
    
    
  </entry>
  
  <entry>
    <title>npm 使用</title>
    <link href="https://cuilongjin.top/2019/tool/npm/"/>
    <id>https://cuilongjin.top/2019/tool/npm/</id>
    <published>2019-07-02T16:00:00.000Z</published>
    <updated>2019-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-使用"><a href="#npm-使用" class="headerlink" title="npm 使用"></a>npm 使用</h2><h3 id="解决-npm-包无法下载"><a href="#解决-npm-包无法下载" class="headerlink" title="解决 npm 包无法下载"></a>解决 npm 包无法下载</h3><p>electron sass</p><p>进入 <code>~/.npmrc</code>，增加如下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org</span><br><span class="line">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjs</span><br><span class="line">electron_mirror=http://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure><p>淘宝 npm 镜像 <a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a></p><h3 id="npm-基本命令"><a href="#npm-基本命令" class="headerlink" title="npm 基本命令"></a>npm 基本命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 npm</span></span><br><span class="line">npm -v|--version</span><br><span class="line">npm install npm@latest -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># nvm : npm Version Manager</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索包</span></span><br><span class="line">npm search &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt; <span class="comment"># [&lt;@scope&gt;/] 安装限定范围的包</span></span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt;</span><br><span class="line">npm install &lt;folder&gt;</span><br><span class="line">npm install &lt;tarball file&gt;  <span class="comment"># .tar, .tar.gz, or .tgz</span></span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install &lt;github usename&gt;/&lt;guthub project&gt;</span><br><span class="line">npm install &lt;git:// url&gt;</span><br><span class="line"></span><br><span class="line">npm install &lt;pkg&gt; -S|--save <span class="comment"># 安装到 dependencies</span></span><br><span class="line">npm install &lt;pkg&gt; -D|--save-dev <span class="comment"># 安装到 devDependencies</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装全局包</span></span><br><span class="line">npm install -g &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包</span></span><br><span class="line">npm outdated <span class="comment"># 检查可以更新的模块</span></span><br><span class="line">npm update <span class="comment"># 更新全部本地包</span></span><br><span class="line"><span class="comment"># 更新全局安装的包</span></span><br><span class="line">npm update -g <span class="comment"># 更新全部</span></span><br><span class="line">npm update -g| --global &lt;pkg&gt; <span class="comment"># 更新指定包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新方式 1</span></span><br><span class="line"><span class="comment"># 手动修改 package.json 中依赖包版本，之后执行</span></span><br><span class="line">npm install --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新方式 2 使用第三方插件：</span></span><br><span class="line">npm install -g npm-check-updates</span><br><span class="line">ncu <span class="comment"># 查看可更新包</span></span><br><span class="line">ncu -u <span class="comment"># 更新 package.json</span></span><br><span class="line">npm install <span class="comment"># 升级到最新版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地包</span></span><br><span class="line">npm uninstall &lt;pkg&gt;</span><br><span class="line">npm uninstall --save &lt;pkg&gt; <span class="comment"># 从 `package.json` 文件中删除依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载全局安装的包</span></span><br><span class="line">npm uninstall -g &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开官网</span></span><br><span class="line">npm docs|home [&lt;pkg&gt;]</span><br><span class="line"><span class="comment"># 打开源码仓库页面</span></span><br><span class="line">npm repo [&lt;pkg&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 package.json 文件</span></span><br><span class="line">npm init</span><br><span class="line"><span class="comment"># 创建默认 package.json 文件</span></span><br><span class="line">npm init --yes or -y</span><br></pre></td></tr></table></figure><h3 id="npm-修改源"><a href="#npm-修改源" class="headerlink" title="npm 修改源"></a>npm 修改源</h3><ul><li><p>进入~/.npmrc 增加 <code>registry=https://registry.npm.taobao.org</code></p></li><li><p>通过命令 <code>npm config set registry http://registry.cnpmjs.org</code></p></li><li><p>临时使用指定源下载 <code>npm install jquery --registry=https://registry.npm.taobao.org</code></p></li><li><p>使用 nrm 管理源</p></li></ul><h3 id="npm-配置文件"><a href="#npm-配置文件" class="headerlink" title="npm 配置文件"></a>npm 配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .npmrc 配置文件位置（~/.npmrc）</span></span><br><span class="line">npm config list</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 缓存目录，默认 C:\Users\&lt;username&gt;\AppData\Roaming\npm-cache</span></span><br><span class="line">npm config get cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 npm 缓存</span></span><br><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 全局 node 包位置</span></span><br><span class="line">npm config get prefix</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm root -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 npm 全局文件位置及缓存文件位置</span></span><br><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"&lt;new_path&gt;"</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"&lt;new_path&gt;"</span></span><br></pre></td></tr></table></figure><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>使用 NPM 下载和发布代码时都会接触到版本号。NPM 使用语义版本号来管理代码</p><p>语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p><ul><li>如果只是修复 bug，需要更新 Z 位</li><li>如果是新增了功能，但是向下兼容，需要更新 Y 位</li><li>如果有大变动，向下不兼容，需要更新 X 位</li></ul><h3 id="nrm-使用"><a href="#nrm-使用" class="headerlink" title="nrm 使用"></a>nrm 使用</h3><p>nrm ls 查看配置列表，带*号即为当前使用的配置</p><p>nrm use 源的别名：切换源</p><p>nrm add 别名 地址 ： 添加源</p><p>nrm test 别名 ： 测速</p><p>nrm del 别名 ：删除源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;npm-使用&quot;&gt;&lt;a href=&quot;#npm-使用&quot; class=&quot;headerlink&quot; title=&quot;npm 使用&quot;&gt;&lt;/a&gt;npm 使用&lt;/h2&gt;&lt;h3 id=&quot;解决-npm-包无法下载&quot;&gt;&lt;a href=&quot;#解决-npm-包无法下载&quot; class=&quot;head
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Markdown" scheme="https://cuilongjin.top/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://cuilongjin.top/2019/tool/docker/"/>
    <id>https://cuilongjin.top/2019/tool/docker/</id>
    <published>2019-06-18T11:52:00.000Z</published>
    <updated>2019-07-09T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-dcoker"><a href="#安装-dcoker" class="headerlink" title="安装 dcoker"></a>安装 dcoker</h2><h3 id="ubuntu-16-04-LTS-安装-docker"><a href="#ubuntu-16-04-LTS-安装-docker" class="headerlink" title="ubuntu 16.04 (LTS) 安装 docker"></a>ubuntu 16.04 (LTS) 安装 docker</h3><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p>镜像仓库方式安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置镜像仓库</span></span><br><span class="line"><span class="comment"># 更新 apt 软件包索引：</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># 安装软件包，以允许 apt 通过 HTTPS 使用镜像仓库：</span></span><br><span class="line">$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥：</span></span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 验证密钥指纹是否为 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。</span></span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p>设置 stable 镜像仓库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># amd64:</span></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br></pre></td></tr></table></figure><p>安装 DOCKER CE</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><p>验证是否正确安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令将下载一个测试镜像并在容器中运行它。容器运行时，它将输出一条参考消息并退出</p><p>升级 docker ce</p><p>如需升级 Docker CE，首先运行 <code>sudo apt-get update</code>，然后按照顺序执行操作，并选择您要安装的新版本</p><p>卸载 docker ce</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure><p>主机上的镜像、容器、存储卷、或定制配置文件不会自动删除。如需删除所有镜像、容器和存储卷，请运行下列命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><p>将 docker 配置为在启动时启动</p><h3 id="centos-安装-docker"><a href="#centos-安装-docker" class="headerlink" title="centos 安装 docker"></a>centos 安装 docker</h3><p>卸载旧版本(如果安装过旧版本的话)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><p>安装需要的软件包， yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>设置 yum 源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>可以查看所有仓库中所有 docker 版本，并选择特定版本安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 报错：Requires: container-selinux &gt;= 2:2.74</span></span><br><span class="line">You could try using --skip-broken to work around the problem</span><br><span class="line"></span><br><span class="line">$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">$ yum install epel-release   <span class="comment"># 阿里云上的 epel 源</span></span><br><span class="line">$ yum makecache</span><br><span class="line">$ yum install container-selinux</span><br></pre></td></tr></table></figure><h2 id="使用-docker"><a href="#使用-docker" class="headerlink" title="使用 docker"></a>使用 docker</h2><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><p>修改 docker 源</p><p>daemon.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 docker</p><p>安装 Ubuntu</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search ubuntu <span class="comment"># 查找 Ubuntu 镜像</span></span><br><span class="line">docker pull ubuntu <span class="comment"># 安装 Ubuntu 镜像</span></span><br><span class="line">docker images <span class="comment">#查看 docker 镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并运行 docker 容器</span></span><br><span class="line">docker run -it -d --name ubuntu_test -p 8088:80 ubuntu</span><br><span class="line"><span class="comment"># --name 自定义容器名，-p 指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回 id</span></span><br><span class="line"><span class="comment"># 多个 -p 指定多个端口映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 docker 容器  启动一个 bash 交互终端</span></span><br><span class="line">docker run -it 容器名:容器tag /bin/bash</span><br><span class="line"></span><br><span class="line">docker start container_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有启动的容器(查看所有容器加 -a)</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 id 查看容器信息</span></span><br><span class="line">docker inspect id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker(或者把容器id改为容器名，也可以进入)</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id或容器名 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi 删除镜像</span><br></pre></td></tr></table></figure><p>备份镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 制作 docker 镜像  1.0 为版本号</span></span><br><span class="line">docker commit 98 ubuntu_test:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像是否创建</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存镜像到 docker 账号中</span></span><br><span class="line"><span class="comment"># 登录进 Docker 注册中心</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送镜像</span></span><br><span class="line">docker tag a25ddfec4d2a arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line">docker push arunpyasi/container-backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包镜像并查看</span></span><br><span class="line">docker save -o ubuntu_test.tar ubuntu_test:1.0</span><br></pre></td></tr></table></figure><p>恢复容器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从docker账号中拉取</span></span><br><span class="line">docker pull arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地</span></span><br><span class="line">docker load -i ~/container-backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用加载的镜像去运行Docker容器</span></span><br><span class="line">docker run -d -p 80:80 container-backup</span><br></pre></td></tr></table></figure><p><strong>docker 给已存在的容器添加或修改端口映射</strong></p><p>方式 1：</p><p>提交一个运行中的容器为镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker commit containerid foo/live</span><br></pre></td></tr></table></figure><p>运行镜像并添加端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 8000:80  foo/live /bin/bash</span><br></pre></td></tr></table></figure><p>方式 2：iptable 转发端口</p><p>将容器的 8000 端口映射到 docker 主机的 8001 端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iptables -t nat -A  DOCKER -p tcp --dport 5001 -j DNAT --to-destination 45.77.150.20:8000</span><br></pre></td></tr></table></figure><h3 id="docker-容器使用问题"><a href="#docker-容器使用问题" class="headerlink" title="docker 容器使用问题"></a>docker 容器使用问题</h3><p>Centos7 docker 容器报 docker Failed to get D-Bus connection 错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start nginx</span><br><span class="line">Failed to get D-Bus connection: Operation not permitted。</span><br></pre></td></tr></table></figure><p>原因是 dbus-daemon 没能启动</p><p>解决方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -d --name ubuntu_test -p 8088:80 ubuntu</span><br><span class="line">$ docker run --privileged -ti --name test1  centos /usr/sbin/init</span><br></pre></td></tr></table></figure><p>ssh 链接 docker 容器</p><p>进入容器</p><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install passwd openssl openssh-server openssh-clients -y</span><br></pre></td></tr></table></figure><p>安装 service 命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install initscripts -y</span><br></pre></td></tr></table></figure><p>修改密码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p>修改配置：</p><p>vi /etc/ssh/sshd_config</p><p>PubkeyAuthentication yes #启用公钥私钥配对认证方式<br>AuthorizedKeysFile .ssh/authorized_keys #公钥文件路径</p><p>PermitRootLogin yes #root 能使用 ssh 登录</p><p>重启 ssh 服务，并设置开机启动：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service sshd restartchkconfig sshd on</span><br></pre></td></tr></table></figure><p>如果无法执行，可试着执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start sshd.service systemctl enable sshd.service</span><br><span class="line"></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><p>docker-compose</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-dcoker&quot;&gt;&lt;a href=&quot;#安装-dcoker&quot; class=&quot;headerlink&quot; title=&quot;安装 dcoker&quot;&gt;&lt;/a&gt;安装 dcoker&lt;/h2&gt;&lt;h3 id=&quot;ubuntu-16-04-LTS-安装-docker&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="https://cuilongjin.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>移动端调试</title>
    <link href="https://cuilongjin.top/2019/tool/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    <id>https://cuilongjin.top/2019/tool/移动端调试/</id>
    <published>2019-06-18T11:52:00.000Z</published>
    <updated>2019-06-18T11:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些调试工具"><a href="#一些调试工具" class="headerlink" title="一些调试工具"></a>一些调试工具</h2><ol><li><p>直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法 100% 还原手机的真实情况</p></li><li><p>chrome <a href="https://developer.chrome.com/devtools/docs/remote-debugging" target="_blank" rel="noopener">远程调试功能</a></p><p><code>chrome://inspect/#devices</code></p><p>需要连接数据线，其次是设置比较繁琐，而且还限制了 android 手机。对于 IOS 的调试则可能要使用 Safari 的另一套工具</p></li><li><p><a href="https://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener">weinre</a>：远程调试，在 PC 上生成一个像 chrome 开发工具一样的调试器，需要手动引入 js</p></li><li><p>Eruda、vConsole：在移动端页面上生成一个调试器，调试信息会挡住操作元素，查看复杂数据结构的 log 不方便，需要手动引入 js</p></li><li><p>安装各种虚拟机sdk，在电脑上进行手机调试。能比较真实模拟手机，但是安装繁琐，操作不方便，无法模拟真实的手势操作</p></li></ol><h2 id="Eruda"><a href="#Eruda" class="headerlink" title="Eruda"></a>Eruda</h2><p><a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">https://github.com/liriliri/eruda</a></p><p>Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。</p><ol><li>按钮拖拽，面板透明度大小设置。</li><li>Console面板：捕获Console日志，支持log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括%c自定义样式输出；支持按日志类型及正则表达式过滤；支持快捷命令加载underscore、jQuery库；支持JavaScript脚本执行。</li><li>Elements面板：查看标签内容及属性；查看应用在Dom上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看Dom上绑定的各类事件。</li><li>Network面板：捕获请求，查看发送数据、返回头、返回内容等信息。</li><li>Resources面板：查看并清除localStorage、sessionStorage及cookie；查看页面加载脚本及样式文件；查看页面加载图片。</li><li>Sources面板：查看页面源码；格式化html，css，js代码及json数据。</li><li>Info面板：输出URL及User Agent；支持自定义输出内容。</li><li>Snippets面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。</li></ol><p>使用</p><p>通过 CDN 使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/eruda/1.5.2/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 npm 安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install eruda --save</span><br></pre></td></tr></table></figure><p>在页面中加载脚本：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/eruda/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Js文件对于移动端来说略重（gzip后大概100kb）。建议通过url参数来控制是否加载调试器，比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> src = <span class="string">'node_modules/eruda/eruda.min.js'</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/eruda=true/</span>.test(<span class="built_in">window</span>.location) &amp;&amp; localStorage.getItem(<span class="string">'active-eruda'</span>) != <span class="string">'true'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt src="'</span> + src + <span class="string">'"&gt;&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt&gt;eruda.init();&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>初始化时可以传入配置：</p><ul><li>container：用于插件初始化的 Dom 元素，如果不设置，默认创建 div 作为容器直接置于 html 根结点下面</li><li>tool：指定要初始化哪些面板，默认加载所有</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el)</span><br><span class="line"></span><br><span class="line">eruda.init(&#123;</span><br><span class="line">  container: el,</span><br><span class="line">  tool: [<span class="string">'console'</span>, <span class="string">'elements'</span>],</span><br><span class="line">  useShadowDom: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vConsole"><a href="#vConsole" class="headerlink" title="vConsole"></a>vConsole</h2><p><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">https://github.com/Tencent/vConsole</a></p><p>一个轻量、可拓展、针对手机网页的前端开发者调试面板。</p><p>特性</p><ul><li>查看 console 日志</li><li>查看网络请求</li><li>查看页面 element 结构</li><li>查看 Cookies、localStorage 和 SessionStorage</li><li>手动执行 JS 命令行</li><li>自定义插件</li></ul><p><a href="https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md" target="_blank" rel="noopener">使用说明</a></p><p>下载 vConsole 的<a href="https://github.com/Tencent/vConsole/releases/latest" target="_blank" rel="noopener">最新版本</a>。（不要直接下载 dev 分支下的 <code>dist/vconsole.min.js</code>）</p><p>或者使用 npm 安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure><p>引入 <code>dist/vconsole.min.js</code> 到项目中：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/vconsole.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vConsole = <span class="keyword">new</span> VConsole()</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'Hello world'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="weinre"><a href="#weinre" class="headerlink" title="weinre"></a>weinre</h2><p><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html" target="_blank" rel="noopener">http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html</a></p><ol><li>Element： 查看/修改dom，查看/修改 dom CSS</li><li>Resources：查看/修改 localStorage, sessionStorage</li><li>Network：查看网络请求</li><li>Timeline：</li><li>Console：查看控制台输出</li></ol><p>不能做 JS 调试</p><p>使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install -g weinre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 weinre 服务</span></span><br><span class="line">weinre --boundHost 192.168.3.44 --httpPort 8888</span><br><span class="line"></span><br><span class="line">启动调试客户端</span><br><span class="line">在浏览器中打开 <span class="string">'http://192.168.3.44:8888'</span> 即可启动调试客户端</span><br><span class="line"></span><br><span class="line">在需要调试的页面中添加如下</span><br><span class="line">&lt;script src=<span class="string">"http://192.168.3.44:8888/target/target-script-min.js#anonymous"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="spy-debugger"><a href="#spy-debugger" class="headerlink" title="spy-debugger"></a>spy-debugger</h2><p><a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="noopener">https://github.com/wuchangming/spy-debugger</a></p><p>微信调试，各种 WebView 样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP/HTTPS，无需USB连接设备</p><p>spy-debugger 集成了<code>weinre</code>，简化了<code>weinre</code>需要给每个调试的页面添加 js 代码。原理是拦截所有 html 页面请求注入<code>weinre</code>所需要的 js 代码。让页面调试更加方便</p><p>1、页面调试＋抓包<br>2、操作简单，无需USB连接设备<br>3、<strong>支持HTTPS</strong><br>4、<code>spy-debugger</code>内部集成了<a href="http://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener"><code>weinre</code></a>、<a href="https://github.com/wuchangming/node-mitmproxy" target="_blank" rel="noopener"><code>node-mitmproxy</code></a>、<a href="https://github.com/alibaba/anyproxy" target="_blank" rel="noopener"><code>AnyProxy</code></a>。<br>5、自动忽略原生 App 发起的 https 请求，只拦截 webview 发起的 https 请求。对使用了 SSL pinning 技术的原生App 不造成任何影响。<br>6、可以配合其它代理工具一起使用(默认使用AnyProxy) <a href="https://github.com/wuchangming/spy-debugger#%E8%AE%BE%E7%BD%AE%E5%A4%96%E9%83%A8%E4%BB%A3%E7%90%86%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8anyproxy" target="_blank" rel="noopener">(设置外部代理)</a></p><p>基本使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install spy-debugger -g</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">spy-debugger</span><br><span class="line"><span class="comment">#设置手机的HTTP代理</span></span><br><span class="line">代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)</span><br><span class="line"><span class="comment"># 手机安装证书</span></span><br><span class="line">手机浏览器访问 http://s.xxx</span><br><span class="line">设置-&gt;通用-&gt;描述文件与设备管理-&gt;找到node-mitmproxy CA（安装）</span><br><span class="line">设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到node-mitmproxy CA（打开）</span><br></pre></td></tr></table></figure><p>自定义选项</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义端口</span></span><br><span class="line">spy-debugger -p 8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置页面内容为可编辑模式</span></span><br><span class="line">spy-debugger -w <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否只拦截浏览器发起的https请求(默认： true)</span></span><br><span class="line">spy-debugger -b <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许weinre监控iframe加载的页面(默认： false)</span></span><br><span class="line">spy-debugger -i <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 HTTP 缓存(默认： false)</span></span><br><span class="line">spy-debugger -c <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="m-console"><a href="#m-console" class="headerlink" title="m-console"></a>m-console</h2><p><a href="https://github.com/fwon/m-console" target="_blank" rel="noopener">https://github.com/fwon/m-console</a></p><p>手机远程调试工具，手机通过代理连接上PC后，可以在PC版浏览器打印log和错误日志</p><p>需要手动给每个调试的页面添加 js 代码</p><h2 id="DebugGap-VIDE"><a href="#DebugGap-VIDE" class="headerlink" title="DebugGap-VIDE"></a>DebugGap-VIDE</h2><p><a href="https://www.debuggap.com/debug_webview.html" target="_blank" rel="noopener">https://www.debuggap.com/debug_webview.html</a></p><h2 id="Mobile-Debug"><a href="#Mobile-Debug" class="headerlink" title="Mobile Debug"></a>Mobile Debug</h2><p><a href="https://www.mobiledebug.com/" target="_blank" rel="noopener">https://www.mobiledebug.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些调试工具&quot;&gt;&lt;a href=&quot;#一些调试工具&quot; class=&quot;headerlink&quot; title=&quot;一些调试工具&quot;&gt;&lt;/a&gt;一些调试工具&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="移动端调试" scheme="https://cuilongjin.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://cuilongjin.top/2019/other/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://cuilongjin.top/2019/other/面试题/</id>
    <published>2019-03-21T10:30:00.000Z</published>
    <updated>2019-03-26T02:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><h3 id="http-相关"><a href="#http-相关" class="headerlink" title="http 相关"></a>http 相关</h3><h3 id="HTML-css-相关"><a href="#HTML-css-相关" class="headerlink" title="HTML css 相关"></a>HTML css 相关</h3><h3 id="js-相关"><a href="#js-相关" class="headerlink" title="js 相关"></a>js 相关</h3><h3 id="jquery-相关"><a href="#jquery-相关" class="headerlink" title="jquery 相关"></a>jquery 相关</h3><h3 id="工具类相关"><a href="#工具类相关" class="headerlink" title="工具类相关"></a>工具类相关</h3><p><a href="zh-cn/_Tool/webpack配置?id=webpack-和-gulp-区别">webpack 和 gulp 区别</a><br><a href></a><br><a href></a><br><a href></a><br><a href></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器相关&quot;&gt;&lt;a href=&quot;#浏览器相关&quot; class=&quot;headerlink&quot; title=&quot;浏览器相关&quot;&gt;&lt;/a&gt;浏览器相关&lt;/h3&gt;&lt;h3 id=&quot;http-相关&quot;&gt;&lt;a href=&quot;#http-相关&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="other" scheme="https://cuilongjin.top/categories/other/"/>
    
    
  </entry>
  
</feed>
