<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>稻草人</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cuilongjin.top/"/>
  <updated>2019-08-01T16:00:00.000Z</updated>
  <id>https://cuilongjin.top/</id>
  
  <author>
    <name>稻草人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>icon 图标的使用</title>
    <link href="https://cuilongjin.top/2019/other/icon%E5%9B%BE%E6%A0%87%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://cuilongjin.top/2019/other/icon图标的使用/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-08-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<br><a href="https://juejin.im/post/59bb864b5188257e7a427c09" target="_blank" rel="noopener">https://juejin.im/post/59bb864b5188257e7a427c09</a></p><h3 id="使用-iconfont"><a href="#使用-iconfont" class="headerlink" title="使用 iconfont"></a>使用 iconfont</h3><p>阿里开源图库 <a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></p><p>下载代码到本地（也可以使用在线链接）打开 demo_index.html 使用说明，有三种使用方式 unicode font-class symbol<br>unicode 方式： <span class="iconfont">&#x33;</span> 这样，不直观，语意不明确，不支持多色图标<br>font-class 方式： <span class="iconfont icon-xxx"></span> 使用 class 定义，有语意，需要注意命名空间的问题，也是不支持多色图标<br>symbol 方式：使用 svg 不用再去请求 woff|eot|ttf| 这些字体库，且缩放不会失真，支持更加复杂的图标</p><p>symbol 方式使用步骤：</p><p>第一步：引入项目下面生成的 symbol 代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./iconfont.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或通过 import 导入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./iconfont.js'</span></span><br></pre></td></tr></table></figure><p>第二步：加入通用 CSS 代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: -<span class="number">0.15em</span>;</span><br><span class="line">  <span class="attribute">fill</span>: currentColor;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步：挑选相应图标并获取类名，应用于页面：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon-xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>symbol 其实使用了 SVG Sprite 技术， 所有的 svg-sprite 都是通过 iconfont 的 iconfont.js 生成的，所以：</p><p>所有图标 icon 都很不直观，完全不知道哪个图标名对应什么图标，每次增删改图标，或者添加一些自定义的 svg 图标，只能将其也上传到 iconfont 和原有的图标放在一个项目库中，之后再重新下载，将整体 js 文件一起替换，而且也做不到按需加载</p><p>导出的 svg 包含大量的无用信息，例如编辑器源信息、注释等。通常包含其它一些不会影响渲染结果或可以移除的内容</p><h3 id="vue-cli3-项目使用-svg-sprite-loader-打包-svg"><a href="#vue-cli3-项目使用-svg-sprite-loader-打包-svg" class="headerlink" title="vue cli3 项目使用 svg-sprite-loader 打包 svg"></a>vue cli3 项目使用 svg-sprite-loader 打包 svg</h3><p>vue cli3 默认使用 file-loader 处理 svg：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* config.module.rule('svg') */</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(svg)(\?.*)?$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="comment">/* config.module.rule('svg').use('file-loader') */</span></span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'file-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        name: <span class="string">'static/img/[name].[hash:8].[ext]'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并路径指定为在 img 文件夹下，但我们的 svg 并不在 img 文件夹，而且 svg-sprite-loader 已经自带了 file-loader 的功能，所以，我们可以在我们自定义的 vue.config.js 文件下将 rule(svg) 清除：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.module.rule(<span class="string">'svg'</span>).uses.clear()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者添加忽略，然后加上自定义的 svg rule，最后的配置如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用 svg-sprite-loader 处理 svg */</span></span><br><span class="line"><span class="comment">// 默认规则忽略 src/icons 文件夹</span></span><br><span class="line">config.module</span><br><span class="line">  .rule(<span class="string">'svg'</span>)</span><br><span class="line">  .exclude.add(path.resolve(__dirname, <span class="string">'src/icons'</span>))</span><br><span class="line">  .end()</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/icons 文件夹下的 svg 使用 svg-sprite-loader</span></span><br><span class="line">config.module</span><br><span class="line">  .rule(<span class="string">'svg-sprite-loader'</span>)</span><br><span class="line">  .test(<span class="regexp">/\.svg$/</span>)</span><br><span class="line">  .use(<span class="string">'svg-sprite'</span>)</span><br><span class="line">  .loader(<span class="string">'svg-sprite-loader'</span>)</span><br><span class="line">  .options(&#123;</span><br><span class="line">    symbolId: <span class="string">'icon-[name]'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .end()</span><br><span class="line">  .include.add(path.resolve(__dirname, <span class="string">'src/icons'</span>))</span><br><span class="line">  .end()</span><br></pre></td></tr></table></figure><p>之后可以通过如下方式使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'@/icons/qq.svg'</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- xlink:href="#icon-图标文件名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#icon-qq"</span> /&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用缺点：需要手动导入图标</p><h3 id="自动导入"><a href="#自动导入" class="headerlink" title="自动导入"></a>自动导入</h3><p>使用 webpack 的 <a href="https://webpack.js.org/guides/dependency-management/#require-context" target="_blank" rel="noopener">require.context</a> api</p><p>require.context 语法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(directory, (useSubdirectories = <span class="literal">false</span>), (regExp = <span class="regexp">/^\.\//</span>))</span><br><span class="line"><span class="comment">// directory：说明需要检索的目录</span></span><br><span class="line"><span class="comment">// useSubdirectories：是否检索子目录</span></span><br><span class="line"><span class="comment">// regExp: 匹配文件的正则表达式</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="built_in">require</span>.context(<span class="string">'./test'</span>, <span class="literal">false</span>, /\.test\.js$/)</span><br><span class="line"><span class="comment">// 表示在 test 文件夹（不包含子目录）下面的找所有文件名以 .test.js 结尾的能被 require 的文件</span></span><br></pre></td></tr></table></figure><p>自动引入 @/icons 下面所有的图标</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础组件的自动化全局注册</span></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(<span class="string">'../../components'</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// console.log(requireComponent.keys())</span></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(filename)</span><br><span class="line">  <span class="comment">// console.log(componentConfig)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> componentName = filename</span><br><span class="line">    .split(<span class="string">'/'</span>)</span><br><span class="line">    .pop()</span><br><span class="line">    .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>)</span><br><span class="line">  <span class="comment">// console.log(componentName)</span></span><br><span class="line"></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后直接将图标放入 <code>@/icons</code> 文件夹下就可以直接使用了，删改图标同理</p><h3 id="优化-svg"><a href="#优化-svg" class="headerlink" title="优化 svg"></a>优化 svg</h3><p>删除无用信息 <a href="https://github.com/svg/svgo" target="_blank" rel="noopener">svgo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考链接：&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/59bb864b5188257e7a427c09&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/59bb864b5188257e
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>addEventListener 以及 vue 中的 .passive 修饰符</title>
    <link href="https://cuilongjin.top/2019/javascript/addEventListener%E4%BB%A5%E5%8F%8Avue%E4%B8%AD%E7%9A%84.passive%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>https://cuilongjin.top/2019/javascript/addEventListener以及vue中的.passive修饰符/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-08-01T12:05:11.459Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener</a></p><p>添加事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line">target.addEventListener(type, listener[, useCapture])</span><br><span class="line"><span class="comment">// type: 事件的类型: click mouseover  字符串类型，不带 on</span></span><br><span class="line"><span class="comment">// listener: 函数，每次点击，执行这个函数</span></span><br><span class="line"><span class="comment">// useCapture: 可选，true: 事件在捕获阶段执行，false: 事件在冒泡阶段执行(默认)</span></span><br><span class="line"></span><br><span class="line">target.addEventListener(type, listener[, options])</span><br></pre></td></tr></table></figure><p>options 可选，可用的选项如下：<br>capture: Boolean，默认 false，等价于以前的 useCapture 参数<br>once: Boolean，默认 false，如果是 true，表示 listener 在添加之后最多只调用一次。 listener 也会在其被调用之后自动移除<br>passive: Boolean，默认 false，设置为 true 时，表示 listener 永远不会调用 preventDefault() 如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</p><p>浏览器无法预先知道一个监听器会不会调用 preventDefault()，它能做的只有等监听器执行完后再去执行默认行为，而监听器执行是要耗时的，有些甚至耗时很明显，这样就会导致页面卡顿</p><p><code>.passive</code> 修饰符尤其能够提升移动端的性能<br><a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">vue .passive 事件修饰符</a></p><p>移除事件</p><p>removeEventListener</p><p>在第三个参数是布尔值的时候，addEventListener(“foo”, listener, true) 添加的监听器，必须用 removeEventListener(“foo”, listener, true) 才能删除掉, 因为这个监听器也有可能还注册在了冒泡阶段, 如果第三个参数为 false 则直接通过 removeEventListener(“foo”, listener) 就可以删除</p><p>通过 addEventListener(“foo”, listener, {capture: true}) 添加的监听器删除时也同样需要添加 {capture: true} 来删除，当然 {capture: true} 换成 true 也可以</p><p>通过 addEventListener(“foo”, listener, {passive: true}) 添加的监听器直接通过 removeEventListener(“foo”, listener) 就可以删除了<br>因为一个监听器同时是 passive 和非 passive（以及同时是 once 和非 once）是说不通的，如果你添加了多个，那么后添加的会忽略</p><p>removeEventListener(“foo”, listener, {capture: true}) // {capture: true} 必须加，当然 {capture: true} 换成 true 也可以</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端兼容性问题总结</title>
    <link href="https://cuilongjin.top/2019/%E7%A7%BB%E5%8A%A8web/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://cuilongjin.top/2019/移动web/移动端兼容性问题/</id>
    <published>2019-07-22T16:00:00.000Z</published>
    <updated>2019-07-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ios-移动端页面对点击事件有-300ms-延时"><a href="#1-ios-移动端页面对点击事件有-300ms-延时" class="headerlink" title="1. ios 移动端页面对点击事件有 300ms 延时"></a>1. ios 移动端页面对点击事件有 300ms 延时</h3><p>使用 fastclick 库 <a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a></p><p>使用 FastClick 的时候，在需要使用的层上，实例化它。我们使用 document.body 是因为希望所有的按钮和链接都获得快速点击</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> FastClick <span class="keyword">from</span> <span class="string">'fastclick'</span></span><br><span class="line">FastClick.attach(<span class="built_in">document</span>.body)</span><br></pre></td></tr></table></figure><h3 id="2-ios-滚动卡顿"><a href="#2-ios-滚动卡顿" class="headerlink" title="2. ios 滚动卡顿"></a>2. ios 滚动卡顿</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch; <span class="comment">/* 当手指从触摸屏上移开，会保持一段时间的滚动 */</span></span><br><span class="line">  <span class="comment">/* -webkit-overflow-scrolling: auto; */</span> <span class="comment">/* 当手指从触摸屏上移开，滚动会立即停止 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ios-1px-border-变宽"><a href="#3-ios-1px-border-变宽" class="headerlink" title="3. ios 1px border 变宽"></a>3. ios 1px border 变宽</h3><p>以 dpr = 2 为例：<br>你拿到一张标准的基于 iphone6 的设计稿(750px)<br>你看到它设计的一个 border 宽度是 1px<br>你兴致勃勃地写下了 border: 1px solid #000;<br>然而 iphone6 实际渲染像素是 375px，那么设计需要 border 的其实是 border: 0.5px solid #000;<br>然后你的是 1px<br>不是 1px 变粗了，只是实际只是需要 0.5px 而已</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code> 意思是将物理设备的宽度设置给当前浏览器</p><p>在使用 table 标签设置 <code>border: 1px</code> 并使用 <code>border-collapse: collapse;</code> 合并边框后，发现 td 之间的边框宽度并不是 1px，而是比 1px 宽，大概为 1.5px</p><h3 id="4-webapp-软键盘弹起时问题"><a href="#4-webapp-软键盘弹起时问题" class="headerlink" title="4. webapp 软键盘弹起时问题"></a>4. webapp 软键盘弹起时问题</h3><p>页面放大:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"user-scalable=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>输入框被遮挡，看不见输入的内容: <code>element.scrollIntoView()</code></p><p>页面自动上移，但收回软键盘时页面少了一截:</p><p>fixed 定位效果失效: <code>ios 弹出软键盘的时候, webview 的高度没有变化导致超出屏幕范围</code></p><h3 id="5-手机端页面文件上传兼容性问题"><a href="#5-手机端页面文件上传兼容性问题" class="headerlink" title="5. 手机端页面文件上传兼容性问题"></a>5. 手机端页面文件上传兼容性问题</h3><h3 id="6-移动和-PC-端中的-hover-处理-移动端点击时会有-pc-端-hover-效果"><a href="#6-移动和-PC-端中的-hover-处理-移动端点击时会有-pc-端-hover-效果" class="headerlink" title="6. 移动和 PC 端中的 hover 处理 移动端点击时会有 pc 端 hover 效果"></a>6. 移动和 PC 端中的 hover 处理 移动端点击时会有 pc 端 hover 效果</h3><h3 id="7-webapp-禁用长按复制"><a href="#7-webapp-禁用长按复制" class="headerlink" title="7. webapp 禁用长按复制"></a>7. webapp 禁用长按复制</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">user-select</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><h3 id="8-ios-a-链接-input-type-”file”-等在点击时会出现灰色（touch-高亮）"><a href="#8-ios-a-链接-input-type-”file”-等在点击时会出现灰色（touch-高亮）" class="headerlink" title="8. ios a 链接 input type=”file” 等在点击时会出现灰色（touch 高亮）"></a>8. ios a 链接 input type=”file” 等在点击时会出现灰色（touch 高亮）</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-tap-highlight-color</span>: <span class="selector-tag">transparent</span>;</span><br></pre></td></tr></table></figure><h3 id="9-禁用浏览器自动调整字体大小"><a href="#9-禁用浏览器自动调整字体大小" class="headerlink" title="9. 禁用浏览器自动调整字体大小"></a>9. 禁用浏览器自动调整字体大小</h3><p>移动端浏览器切换橫向模式时会调整字体大小（字体变大），解决方式:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-text-size-adjust</span>: none; <span class="comment">/* 或 100% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>谷歌浏览器已不支持这个属性了，不能通过该方式实现小于 12px 的字体，可使用缩放（transform:scale(0.8)）来实现小于 12px 的字体</p></blockquote><h3 id="10-appearance-属性"><a href="#10-appearance-属性" class="headerlink" title="10. appearance 属性"></a>10. appearance 属性</h3><p>normal|icon|window|button|menu|field<br>所有主流浏览器都不支持 appearance 属性</p><p><code>-webkit-appearance: none;</code> 去除默认样式，使 ios 端和安卓端显示效果一样，但有一个问题，input 的 checkbox 和 radio 类型在安卓端可能无法正常显示</p><h3 id="11-webkit-touch-callout-none"><a href="#11-webkit-touch-callout-none" class="headerlink" title="11. -webkit-touch-callout: none;"></a>11. -webkit-touch-callout: none;</h3><p>在 iOS 上，当你触摸并按住触摸的目标，比如一个链接，浏览器将显示链接有关的系统默认菜单。该属性可以禁用系统默认菜单</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-ios-移动端页面对点击事件有-300ms-延时&quot;&gt;&lt;a href=&quot;#1-ios-移动端页面对点击事件有-300ms-延时&quot; class=&quot;headerlink&quot; title=&quot;1. ios 移动端页面对点击事件有 300ms 延时&quot;&gt;&lt;/a&gt;1. ios 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3 配置通用模板及配置详解</title>
    <link href="https://cuilongjin.top/2019/vue/vue-cli3%E9%85%8D%E7%BD%AE%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://cuilongjin.top/2019/vue/vue-cli3配置通用模板及配置详解/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-08-03T07:32:38.283Z</updated>
    
    <content type="html"><![CDATA[<p>安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>创建一个项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create my-project</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">vue ui</span><br></pre></td></tr></table></figure><p>如果你仍然需要使用旧版本的 <code>vue init</code> 功能，你可以全局安装一个桥接工具：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line"><span class="comment"># `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同</span></span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure><h3 id="在现有的项目中安装插件"><a href="#在现有的项目中安装插件" class="headerlink" title="在现有的项目中安装插件"></a>在现有的项目中安装插件</h3><p>每个 CLI 插件都会包含一个 (用来创建文件的) 生成器和一个 (用来调整 webpack 核心配置和注入命令的) 运行时插件。当你使用 <code>vue create</code> 来创建一个新项目的时候，有些插件会根据你选择的特性被预安装好。如果你想在一个已经被创建好的项目中安装一个插件，可以使用 <code>vue add</code> 命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add @vue/eslint</span><br></pre></td></tr></table></figure><p>提示</p><p><code>vue add</code> 的设计意图是为了安装和调用 Vue CLI 插件。对于普通的 npm 包而言，这不意味有一个替代（命令）。对于这些普通的 npm 包，你仍然需要（根据所选的 npm 包）使用包管理器。</p><h2 id="vue-config-js-配置"><a href="#vue-config-js-配置" class="headerlink" title="vue.config.js 配置"></a>vue.config.js 配置</h2><p><a href="https://cli.vuejs.org/zh/config" target="_blank" rel="noopener">官网配置参考</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h3><p>基本路径</p><p>vue-cli3.3 以下版本使用 baseUrl</p><p>vue-cli3.3+ 使用 publicPath</p><p>默认 ‘/‘</p><p>‘./‘ 或为空(‘’) 所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径, 当使用 pages 选项构建多页面应用时,应当避免使用相对路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">publicPath: <span class="string">'./'</span></span><br></pre></td></tr></table></figure><h3 id="outputDir"><a href="#outputDir" class="headerlink" title="outputDir"></a>outputDir</h3><p>默认 ‘dist’</p><p>当运行 vue-cli-service build 时生成的生产环境构建文件的目录</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">outputDir: <span class="string">'dist'</span></span><br></pre></td></tr></table></figure><h3 id="assetsDir"><a href="#assetsDir" class="headerlink" title="assetsDir"></a>assetsDir</h3><p>默认 ‘’</p><p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">assetsDir: <span class="string">'static'</span></span><br></pre></td></tr></table></figure><h3 id="indexPath"><a href="#indexPath" class="headerlink" title="indexPath"></a>indexPath</h3><p>指定生成的 <code>index.html</code> 的输出路径 (相对于 <code>outputDir</code>)。也可以是一个绝对路径</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">indexPath: <span class="string">'index.html'</span></span><br></pre></td></tr></table></figure><h3 id="filenameHashing"><a href="#filenameHashing" class="headerlink" title="filenameHashing"></a>filenameHashing</h3><p>默认 true</p><p>默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。然而，这也要求 index 的 HTML 是被 Vue CLI 自动生成的。如果你无法使用 Vue CLI 生成的 index HTML，你可以通过将这个选项设为 false 来关闭文件名哈希</p><h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><p>默认 undefined</p><p>是否以多页模式构建应用程序</p><p>每个 ‘page’ 应该有一个对应的 JavaScript 入口文件。其值应该是一个对象，对象的 key 是入口的名字，value 是 一个指定了 entry, template, filename, title 和 chunks 的对象 (除了 entry 之外都是可选的) 或一个指定其 entry 的字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      <span class="comment">// page 的入口</span></span><br><span class="line">      entry: <span class="string">'src/pages/index/main.js'</span>,</span><br><span class="line">      <span class="comment">// 模板来源</span></span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      <span class="comment">// 在 dist/index.html 的输出</span></span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">      title: <span class="string">'Index Page'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    pageA: &#123;</span><br><span class="line">      entry: <span class="string">'src/pages/pageA/main.js'</span>,</span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'pageA.html'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当使用只有入口的字符串格式时, 模板会被推导为 `public/pageB.html`</span></span><br><span class="line">    <span class="comment">// 并且如果找不到的话，就回退到 `public/index.html`, 输出文件名会被推导为 `pageB.html`</span></span><br><span class="line">    pageB: <span class="string">'src/pages/pageB/main.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lintOnSave"><a href="#lintOnSave" class="headerlink" title="lintOnSave"></a>lintOnSave</h3><p>默认 true</p><p>是否在保存的时候检查，如果为 true ，build 时会启用 eslint-loader 进行代码检查，可以使用如下配置禁用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">lintOnSave: process.env.NODE_ENV !== <span class="string">'production'</span></span><br></pre></td></tr></table></figure><h3 id="runtimeCompiler"><a href="#runtimeCompiler" class="headerlink" title="runtimeCompiler"></a>runtimeCompiler</h3><p>默认 false</p><p>是否使用包含运行时编译器的 Vue 构建版本</p><p>使用 template 语法需要开启，但是这会让你的应用额外增加 10kb 左右，使用渲染函数不需要开启</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">runtimeCompiler: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="productionSourceMap"><a href="#productionSourceMap" class="headerlink" title="productionSourceMap"></a>productionSourceMap</h3><p>默认 true</p><p>生产环境是否生成 sourceMap 文件，一般情况不建议打开</p><p>map 文件的作用在于：项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误信息无法准确得知是哪里的代码报错。有了 map 就可以像未加密的代码一样，准确的输出是哪一行哪一列有错</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">productionSourceMap: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h3><p>对内部的 webpack 配置进行更细粒度的修改</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chainWebpack = <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 删除预加载模块的 prefetch，降低带宽压力</span></span><br><span class="line">  <span class="comment">// https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch</span></span><br><span class="line">  <span class="comment">// 移除 prefetch 插件</span></span><br><span class="line">  config.plugins.delete(<span class="string">'prefetch'</span>)</span><br><span class="line">  <span class="comment">// 移除 preload 插件</span></span><br><span class="line">  config.plugins.delete(<span class="string">'preload'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// config.plugin('html').tap(args =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   args[0].minify = false</span></span><br><span class="line">  <span class="comment">//   return args</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 配置绝对路径 */</span></span><br><span class="line">  config.resolve.alias.set(<span class="string">'~'</span>, path.resolve(<span class="string">'public'</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改静态资源打包方式，下例为超过10k才用文件导入的方式，否则为base64.默认为4k</span></span><br><span class="line">  config.module</span><br><span class="line">    .rule(<span class="string">'images'</span>)</span><br><span class="line">    .use(<span class="string">'url-loader'</span>)</span><br><span class="line">    .loader(<span class="string">'url-loader'</span>)</span><br><span class="line">    .tap(<span class="function"><span class="params">options</span> =&gt;</span> <span class="built_in">Object</span>.assign(options, &#123; <span class="attr">limit</span>: <span class="number">10240</span> &#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  chainWebpack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://cli.vuejs.org/zh/guide/html-and-static-assets.html#preload" target="_blank" rel="noopener">https://cli.vuejs.org/zh/guide/html-and-static-assets.html#preload</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" target="_blank" rel="noopener"><code>&lt;link rel=&quot;preload&quot;&gt;</code></a>是一种 resource hint，用来指定页面加载后很快会被用到的资源，所以在页面加载的过程中，我们希望在浏览器开始主体渲染之前尽早 preload。</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Link_prefetching_FAQ" target="_blank" rel="noopener"><code>&lt;link rel=&quot;prefetch&quot;&gt;</code></a> 是一种 resource hint，用来告诉浏览器在页面加载完成后，利用空闲时间提前获取用户未来可能会访问的内容。</p><h3 id="configureWebpack"><a href="#configureWebpack" class="headerlink" title="configureWebpack"></a>configureWebpack</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 自定义配置</span></span><br><span class="line"><span class="comment">// https://cli.vuejs.org/zh/guide/webpack.html</span></span><br><span class="line"><span class="keyword">const</span> configureWebpack = <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 生产 and 测试环境</span></span><br><span class="line">  <span class="keyword">let</span> pluginsPro = [</span><br><span class="line">    <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">      <span class="comment">// 文件开启 Gzip，也可以通过服务端(如：nginx)(https://github.com/webpack-contrib/compression-webpack-plugin)</span></span><br><span class="line">      filename: <span class="string">'[path].gz[query]'</span>,</span><br><span class="line">      algorithm: <span class="string">'gzip'</span>,</span><br><span class="line">      test: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\.('</span> + [<span class="string">'js'</span>, <span class="string">'css'</span>].join(<span class="string">'|'</span>) + <span class="string">')$'</span>),</span><br><span class="line">      threshold: <span class="number">8192</span>,</span><br><span class="line">      minRatio: <span class="number">0.8</span></span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Webpack 包文件分析器(https://github.com/webpack-contrib/webpack-bundle-analyzer)</span></span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打包时删除 debugger 和 console</span></span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          drop_debugger: <span class="literal">true</span>,</span><br><span class="line">          drop_console: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      sourceMap: <span class="literal">true</span>,</span><br><span class="line">      parallel: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// 开发环境</span></span><br><span class="line">  <span class="keyword">let</span> pluginsDev = [</span><br><span class="line">    <span class="comment">//  移动端模拟开发者工具 (https://github.com/diamont1001/vconsole-webpack-plugin  https://github.com/Tencent/vConsole)</span></span><br><span class="line">    <span class="comment">// new vConsolePlugin(&#123;</span></span><br><span class="line">    <span class="comment">//   filter: [], // 需要过滤的入口文件</span></span><br><span class="line">    <span class="comment">//   enable: true // 发布代码前记得改回 false</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// 为生产环境修改配置...process.env.NODE_ENV !== 'development'</span></span><br><span class="line">    config.plugins = [...config.plugins, ...pluginsPro]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 为开发环境修改配置...</span></span><br><span class="line">    config.plugins = [...config.plugins, ...pluginsDev]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  configureWebpack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境变量与分环境打包"><a href="#环境变量与分环境打包" class="headerlink" title="环境变量与分环境打包"></a>环境变量与分环境打包</h3><p><a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-build" target="_blank" rel="noopener">vue-cli-service-build</a><br>vue-cli-service build –mode 指定环境模式(默认值：production)</p><p>npm run build 默认模式为 production ，命令执行时会把 process.env.NODE_ENV(环境变量) 设置为 ‘production’<br>npm run serve 时会把 process.env.NODE_ENV 设置为 ‘development’</p><p>所以可以根据 process.env.NODE_ENV 简单的区分出本地和线上环境</p><p>但是线上环境也可能分多种，比如测试环境和预发布环境等</p><p><strong>配置 vue-cli3 区分不同的线上环境</strong></p><p>在项目根目录创建下列文件来制定环境变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.env                # 在所有的环境中被载入</span><br><span class="line">.env.local          # 在所有的环境中被载入，但会被 git 忽略</span><br><span class="line">.env.[mode]         # 只在指定的模式中被载入</span><br><span class="line">.env.[mode].local   # 只在指定的模式中被载入，但会被 git 忽略</span><br></pre></td></tr></table></figure><p><code>.env.test</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* VUE_APP_CURRENTMODE 当前环境变量 */</span><br><span class="line">VUE_APP_CURRENTMODE = &apos;t&apos; // 表明开发环境模式信息</span><br><span class="line">NODE_ENV = &apos;development&apos; // 使用开发环境（因为默认开启 devtool，便于调试）</span><br><span class="line">// VUE_APP_BASEURL=&apos;&apos; // 测试服务器地址</span><br><span class="line">VUE_APP_ENV = &apos;test 环境&apos;</span><br></pre></td></tr></table></figure><p>在 package.json 中添加</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "vue-cli-service build --mode t",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 baseUrl.js 文件通过环境变量改变 baseUrl</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.VUE_APP_CURRENTMODE === <span class="string">'t'</span>) &#123;</span><br><span class="line">  <span class="comment">// 测试环境</span></span><br><span class="line">  baseUrl = <span class="string">''</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 正式环境</span></span><br><span class="line">  baseUrl = <span class="string">''</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要为测试环境进行打包的时候 , 只需要运行下面指令进行打包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>但是将打包环境设置为 NODE_ENV = ‘development’ 导致打包出来的 js 文件只有 index.js 文件并且在根目录下, 并不是我们想要的</p><p>所以我们可以这样配置</p><p>.env.test</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VUE_APP_CURRENTMODE = &apos;t&apos;</span><br><span class="line">NODE_ENV = &apos;production&apos;</span><br><span class="line">VUE_APP_ENV = &apos;test 环境&apos;</span><br></pre></td></tr></table></figure><p>main.js 配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isDebugMode = process.env.VUE_APP_CURRENTMODE === <span class="string">'t'</span></span><br><span class="line">Vue.config.debug = isDebugMode</span><br><span class="line">Vue.config.devtools = isDebugMode</span><br><span class="line">Vue.config.productionTip = isDebugMode</span><br></pre></td></tr></table></figure><h3 id="vue-公共路径提取"><a href="#vue-公共路径提取" class="headerlink" title="vue 公共路径提取"></a>vue 公共路径提取</h3><p>vue 项目中公共路径在打包之后一旦遇到整体的路径更改就需要再次打包。我们可以将公共路径提取出来，修改公共路径后不需要重新打包就能生效</p><p>在 public 文件夹下创建 config.js 文件，并配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> serverConfig = &#123;</span><br><span class="line">  baseUrl: <span class="string">''</span> <span class="comment">// 配置 url</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 index.html 中引入该文件，之后在开发时就可以通过 <code>serverConfig.baseUrl</code> 使用变量</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue add router</span><br><span class="line">vue add vuex</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install -g @vue/cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>less 使用 - mixin 混合</title>
    <link href="https://cuilongjin.top/2019/tool/less-mixin%E6%B7%B7%E5%90%88/"/>
    <id>https://cuilongjin.top/2019/tool/less-mixin混合/</id>
    <published>2019-07-20T16:00:00.000Z</published>
    <updated>2019-08-01T12:05:11.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mixin-混合"><a href="#mixin-混合" class="headerlink" title="mixin 混合"></a>mixin 混合</h3><p>可以在 mixin 中使用类选择器和 id 选择器</p><p>.bgc 定义了一个属性集，在任何需要使用 .bgc 属性集的选择器中，只需像下面这样调用：(小括号是可选的)</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bgc</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">  <span class="selector-class">.bgc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的 CSS 代码为：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bgc</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：mixin 其实就是一种嵌套，简单的讲，mixin 就是规则级别的复用</p><p>mixin 的定义也会被原封不动的输出到编译生成的 CSS 代码中</p><p>如果希望编译生成的 CSS 代码中不包含 mixin 的定义，在定义 mixin 时，只需在 class、id 的后面添加一对小括号即可。如：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bgc</span>() &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.bgc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的 CSS 代码为：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mixin 可以包含选择器</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hover</span>() &#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.hover</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的 CSS 代码为：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令空间-Namespaces"><a href="#命令空间-Namespaces" class="headerlink" title="命令空间 Namespaces"></a>命令空间 Namespaces</h3><p>如果想要在一个更复杂的选择器中混合属性，可以堆叠多个 id 或类</p><p>可以将 mixin 置于 id 选择器之下，这样可以确保它不会和另一个库冲突</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#bgc</span> &#123;</span><br><span class="line">  <span class="selector-class">.inner</span>() &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-id">#bgc</span><span class="selector-class">.inner</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="important-关键字"><a href="#important-关键字" class="headerlink" title="!important 关键字"></a>!important 关键字</h3><p>在 mixin 后使用 !important 关键字，将会标记调用所有继承的属性为!important</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bgc</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.bgc</span> !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后 css 为</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带参数的 Mixin</p><p>mixin 还可以接受参数，这些参数在混合时传递给选择器块</p><p>从上面的代码可以看出：mixin 其实就是一种嵌套，简单的讲，mixin 就是规则级别的复用。除了类选择器外，你也可以使用 id 选择器来定义 mixin。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mixin-混合&quot;&gt;&lt;a href=&quot;#mixin-混合&quot; class=&quot;headerlink&quot; title=&quot;mixin 混合&quot;&gt;&lt;/a&gt;mixin 混合&lt;/h3&gt;&lt;p&gt;可以在 mixin 中使用类选择器和 id 选择器&lt;/p&gt;
&lt;p&gt;.bgc 定义了一个属性集
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>高阶函数与柯里化</title>
    <link href="https://cuilongjin.top/2019/javascript/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://cuilongjin.top/2019/javascript/高阶函数与柯里化/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数定义：将函数作为参数或者返回值是函数的函数<br>常见的 sort、reduce 等函数就是高阶函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = add(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6写法</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>wiki 的柯里化定义: 把接受多个参数的函数变换成接受一个单一参数的函数，并且返回（接受余下的参数而且返回结果的）新函数的技术</p><p>柯里化后，将第一个参数变量存在函数里面了(闭包)，然后本来需要 n 个参数的函数变成只需要剩下的（n - 1 个）参数就可以调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形如</span></span><br><span class="line">a =&gt; <span class="function"><span class="params">b</span> =&gt;</span> c =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; a + b</span><br><span class="line"><span class="keyword">let</span> add1 = add(<span class="number">1</span>) <span class="comment">// a = 1; b =&gt; a + b</span></span><br><span class="line">add1(<span class="number">2</span>) <span class="comment">// 1 + 2 = 3</span></span><br></pre></td></tr></table></figure><p>add1 函数等价于有了 a 这个闭包变量的 b = a + b</p><p>add 函数按照 wiki 的定义可以理解成只柯里化了一次，n 个连续箭头组成的函数实际上就是柯里化了 n - 1 次<br>前 n - 1 次调用，其实是提前将参数传递进去，并没有调用最内层函数体，最后一次调用才会调用最内层函数体，并返回最内层函数体的返回值</p><p>所以多个连续箭头函数就是多次柯里化的 es6 写法</p><p><strong>应用：</strong></p><p>函数懒执行<br>函数式编程</p><p><strong>柯里化函数使用场景：</strong></p><p>减少重复传递不变的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price, discount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> price * discount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次都要重复传入 discount 参数，可以将这个函数柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">price, discount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">price</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price * discount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tenPercentDiscount = discount(<span class="number">0.9</span>) <span class="comment">// 9折</span></span><br><span class="line"><span class="keyword">const</span> twentyPercentDiscount = discount(<span class="number">0.8</span>) <span class="comment">// 8折</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在每次计算价格只需要：</span></span><br><span class="line">tenPercentDiscount(<span class="number">500</span>) <span class="comment">// 500 * 0.9</span></span><br><span class="line">twentyPercentDiscount(<span class="number">1000</span>) <span class="comment">// 1000 * 0.8</span></span><br></pre></td></tr></table></figure><h2 id="柯里化实现"><a href="#柯里化实现" class="headerlink" title="柯里化实现"></a>柯里化实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="keyword">this</span>, args.concat(args2))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> curriedSum = curry(sum)</span><br><span class="line"><span class="built_in">console</span>.log(curriedSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curriedSum(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高阶函数&quot;&gt;&lt;a href=&quot;#高阶函数&quot; class=&quot;headerlink&quot; title=&quot;高阶函数&quot;&gt;&lt;/a&gt;高阶函数&lt;/h2&gt;&lt;p&gt;高阶函数定义：将函数作为参数或者返回值是函数的函数&lt;br&gt;常见的 sort、reduce 等函数就是高阶函数&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>axios 取消请求</title>
    <link href="https://cuilongjin.top/2019/javascript/axios%E5%8F%96%E6%B6%88%E8%AF%B7%E6%B1%82/"/>
    <id>https://cuilongjin.top/2019/javascript/axios取消请求/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>原生 js abort() 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> A = $.ajax(&#123;&#125;)</span><br><span class="line">A.abort()</span><br></pre></td></tr></table></figure><p>Axios 提供了一个 CancelToken 的函数，这是一个构造函数，该函数的作用就是用来取消接口请求的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  getMsg () &#123;</span><br><span class="line">    <span class="keyword">let</span> CancelToken = axios.CancelToken</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    axios.get(<span class="string">''</span>, &#123;</span><br><span class="line">      cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        that.cancel = c</span><br><span class="line">        <span class="built_in">console</span>.log(c)</span><br><span class="line">        <span class="comment">// 这个参数 c 就是 CancelToken 构造函数里面自带的取消请求的函数，这里把该函数当参数用</span></span><br><span class="line">      &#125;)</span><br><span class="line">      params: &#123;&#125;</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.items = res.data</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelGetMsg () &#123;</span><br><span class="line">    <span class="keyword">this</span>.cancel()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原生 js abort() 方法&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; A 
      
    
    </summary>
    
      <category term="js" scheme="https://cuilongjin.top/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3 多页模式</title>
    <link href="https://cuilongjin.top/2019/vue/%E5%A4%9A%E9%A1%B5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://cuilongjin.top/2019/vue/多页模式/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2019-07-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cli.vuejs.org/zh/config/#pages" target="_blank" rel="noopener">vue-cli 多页面的配置官方介绍</a></p><p><code>vue.config.js</code> 配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      <span class="comment">// page 的入口</span></span><br><span class="line">      entry: <span class="string">'src/pages/index/main.js'</span>,</span><br><span class="line">      <span class="comment">// 模板来源</span></span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      <span class="comment">// 在 dist/index.html 的输出</span></span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">      title: <span class="string">'Index Page'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    pageA: &#123;</span><br><span class="line">      entry: <span class="string">'src/pages/pageA/main.js'</span>,</span><br><span class="line">      template: <span class="string">'public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'pageA.html'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当使用只有入口的字符串格式时, 模板会被推导为 `public/pageB.html`</span></span><br><span class="line">    <span class="comment">// 并且如果找不到的话，就回退到 `public/index.html`, 输出文件名会被推导为 `pageB.html`</span></span><br><span class="line">    pageB: <span class="string">'src/pages/pageB/main.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个页面一套 SPA，入口文件、路由、资源的路径都要根据实际情况进行设置</p><p>页面内可以继续使用<code>SPA</code>模式的<code>&lt;router-link&gt;</code>，但是页面之间的跳转需要使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/pageA.html"</span>&gt;</span>前往 pageA 页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://cli.vuejs.org/zh/config/#pages&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cli 多页面的配置官方介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vue.config.js&lt;/code&gt; 
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>keep-alive 实现页面缓存</title>
    <link href="https://cuilongjin.top/2019/vue/keep-alive/"/>
    <id>https://cuilongjin.top/2019/vue/keep-alive/</id>
    <published>2019-07-14T16:00:00.000Z</published>
    <updated>2019-07-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>缓存</p><ul><li><p>pageAList -&gt; pageADetail -&gt; pageAList，缓存 pageAList，同时如果 pageAList 发生变化需要更新</p></li><li><p>其他页面 -&gt; pageAList，pageAList 不缓存</p></li></ul><p>router 配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/pageAList'</span>,</span><br><span class="line">        name: <span class="string">'pageAList'</span>,</span><br><span class="line">        component: pageAList</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'/pageADetail'</span>,</span><br><span class="line">        name: <span class="string">'pageADetail'</span>,</span><br><span class="line">        component: pageADetail</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>vuex 配置 store.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    includeComponents: [] <span class="comment">// 需要缓存的组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    addIncludeComponent(state, includeComponent) &#123;</span><br><span class="line">      <span class="comment">// includeComponent 可能是组件 name 字符串或者数组</span></span><br><span class="line">      <span class="keyword">let</span> includeComponents = state.includeComponents</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(includeComponent)) &#123;</span><br><span class="line">        state.includeComponents = [...new <span class="built_in">Set</span>([...includeComponents, ...includeComponent])]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        state.includeComponents = [...new <span class="built_in">Set</span>([...includeComponents, includeComponent])]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    removeIncludeComponent(state, includeComponent) &#123;</span><br><span class="line">      <span class="keyword">let</span> includeComponents = state.includeComponents</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(includeComponent)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; includeComponent.length; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> index = includeComponents.findIndex(<span class="function"><span class="params">v</span> =&gt;</span> v === includeComponent[i])</span><br><span class="line">          <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            includeComponents.splice(index, <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = includeComponents.length; i &lt; len; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (includeComponents[i] === includeComponent) &#123;</span><br><span class="line">            includeComponents.splice(i, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state.includeComponents = includeComponents</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>home.vue</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- keep-alive 包裹 router-view --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"includeComponents"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">    computed: &#123;</span></span><br><span class="line"><span class="undefined">      includeComponents() &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.includeComponents</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>pageAList.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'pageAList'</span>,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/pageADetail/</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(to.name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'addIncludeComponent'</span>, <span class="string">'pageADetail'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'removeIncludeComponent'</span>, <span class="string">'pageADetail'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pageADetail.vue</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'pageADetail'</span>,</span><br><span class="line">  beforeRouteLeave(to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/pageA/</span></span><br><span class="line">    <span class="keyword">if</span> (reg.test(to.name)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'addIncludeComponent'</span>, <span class="string">'pageAList'</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store.commit(<span class="string">'removeIncludeComponent'</span>, <span class="string">'pageAList'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;,</span><br><span class="line">  activated() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getList()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>进入 pageAList，离开当前组件的时候有两种情况：<ul><li>跳转进去 pageADetail，在 pageAList 的 beforeRouteLeave 钩子里面缓存 pageAList</li><li>跳转到非 pageADetail 的页面，在 pageAList 的 beforeRouteLeave 钩子里面清除 pageAList 的缓存</li></ul></li></ul><ul><li>从 pageADetail 离开的时候，也有两种情况：<ul><li>回到 pageAList，在 pageADetail 的 beforeRouteLeave 钩子里面缓存 pageAList，所以从 pageAList-pageADetail-pageAList 的时候，pageAList 可以被缓存，还是之前的页码状态</li><li>进入其他路由，在 pageADetail 的 beforeRouteLeave 钩子里面清除 pageAList 的缓存</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pageAList -&amp;gt; pageADetail -&amp;gt; pageAList，缓存 pageAList，同时如果 pageAList 发生变化需要更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他页面 -&amp;gt; pageAList
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3.0 内存溢出 JavaScript heap out of memory</title>
    <link href="https://cuilongjin.top/2019/vue/vue-cli3%20%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E8%A7%A3%E5%86%B3/"/>
    <id>https://cuilongjin.top/2019/vue/vue-cli3 内存溢出解决/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>错误内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;--- JS stacktrace ---&gt;</span><br><span class="line"></span><br><span class="line">==== JS stack trace =========================================</span><br><span class="line"></span><br><span class="line">    0: ExitFrame [pc: 000002861B95C5C1]</span><br><span class="line">Security context: 0x002fdeb1e6e9 &lt;JSObject&gt;</span><br><span class="line">    1: DoJoin(aka DoJoin) [0000002FDEB05E91] [native array.js:~87] [pc=000002861C436409](this=0x0037aae826f1 &lt;undefined&gt;,l=0x01420be65761 &lt;JSArray[2]&gt;,m=2,A=0x0037aae828c9 &lt;true&gt;,w=0x0375f51b46d9 &lt;String[1]\: \n&gt;,v=0x0037aae829a1 &lt;false&gt;)</span><br><span class="line">    2: Join(aka Join) [0000002FDEB05EE1] [native array.js:~112] [pc=000002861BC4F978](this=0x0037aae826f1 &lt;undefined&gt;,l...</span><br><span class="line"></span><br><span class="line">FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory</span><br></pre></td></tr></table></figure><p>百度出的原因及解决方案基本都是：</p><p>nodejs 内存限制，通过添加启动参数可以解决</p><p>vue-cli2：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dev 和 npm run build 直接在前面加上--max_old_space_size=4096</span><br></pre></td></tr></table></figure><p>vue-cli3：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx --max_old_space_size=4096 vue-cli-service serve</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i increase-memory-limit cross-env</span><br><span class="line">scripts 中添加指令 <span class="string">"fix-memory-limit"</span>: <span class="string">"cross-env LIMIT=4096 increase-memory-limit"</span></span><br><span class="line">npm run fix-memory-limit</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p><span class="red">但是通过以上设置并没有解决问题，最后将 lintOnsave: false 解决了</span></p><p>由此分析 lintOnsave 为 true 时 ，npm run serve|build 时会启用 eslint-loader 进行代码检查，某些插件可能无法进行代码检查并产生了递归，导致内存溢出，因为该项目使用了 Ueditor 插件，之后将 Ueditor 插件加入 eslintignore 并将 lintOnsave 恢复成 true，项目依然能够正常运行</p><p>参考链接: <a href="https://github.com/vuejs/vue-cli/issues/1453" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli/issues/1453</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;错误内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;--- JS stacktrace ---&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli 常用配置</title>
    <link href="https://cuilongjin.top/2019/vue/vue-cli%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://cuilongjin.top/2019/vue/vue-cli常用配置/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h2 id="vue-cli-webpack-打包后-index-html-引入文件没有引号"><a href="#vue-cli-webpack-打包后-index-html-引入文件没有引号" class="headerlink" title="vue-cli webpack 打包后 index.html 引入文件没有引号"></a>vue-cli webpack 打包后 index.html 引入文件没有引号</h2></li></ul><p>解决办法：</p><p>vue-cli2：</p><p>在 webpack.prod.conf.js 中修改：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeAttributeQuotes: <span class="literal">false</span> <span class="comment">// 如果该方法没有用那就把整个 minify 去掉</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>vue-cli3:</p><p>在 vue.config.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  config.plugin(<span class="string">'html'</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">    args[<span class="number">0</span>].minify = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> args</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="svue-cli-打包时删除-console、deugger、注释"><a href="#svue-cli-打包时删除-console、deugger、注释" class="headerlink" title="svue-cli 打包时删除 console、deugger、注释"></a>svue-cli 打包时删除 console、deugger、注释</h2></li></ul><p>vue-cli2：</p><p>在 webpack.prod.conf.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">    uglifyOptions: &#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        drop_debugger: <span class="literal">true</span>,</span><br><span class="line">        drop_console: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      output: &#123;</span><br><span class="line">        comment: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>vue-cli3：</p><p>安装 uglifyjs-webpack-plugin</p><p>在 vue.config.js 中添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">      uglifyOptions: &#123;</span><br><span class="line">        compress: &#123;</span><br><span class="line">          drop_debugger: <span class="literal">true</span>,</span><br><span class="line">          drop_console: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        output: &#123;</span><br><span class="line">          comment: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      parallel: <span class="literal">true</span>,</span><br><span class="line">      cache: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;vue-cli-webpack-打包后-index-html-引入文件没有引号&quot;&gt;&lt;a href=&quot;#vue-cli-webpack-打包后-index-html-引入文件没有引号&quot; class=&quot;headerlink&quot; title=&quot;vue-c
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>js 中编码（encode）和解码（decode）的三种方法</title>
    <link href="https://cuilongjin.top/2019/other/js%20%E4%B8%AD%E7%BC%96%E7%A0%81%EF%BC%88encode%EF%BC%89%E5%92%8C%E8%A7%A3%E7%A0%81%EF%BC%88decode%EF%BC%89%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://cuilongjin.top/2019/other/js 中编码（encode）和解码（decode）的三种方法/</id>
    <published>2019-07-09T08:42:00.000Z</published>
    <updated>2019-07-09T09:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js-中编码（encode）和解码（decode）的三种方法"><a href="#js-中编码（encode）和解码（decode）的三种方法" class="headerlink" title="js 中编码（encode）和解码（decode）的三种方法"></a>js 中编码（encode）和解码（decode）的三种方法</h3><p>js 对文字进行编码涉及 3 个函数：escape、encodeURI、encodeURIComponent，相应 3 个解码函数：unescape、decodeURI、decodeURIComponent</p><ul><li>escape()函数</li></ul><p>定义和用法：escape() 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串<br>语法：escape(string)<br>参数：string 必需，要被转义或编码的字符串。<br>返回值：已编码的 string 的副本。其中某些字符被替换成了十六进制的转义序列<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： <code>-_.!~*&#39;()</code> ，其他所有的字符都会被转义序列替换</p><ul><li>encodeURI()函数</li></ul><p>定义和用法：encodeURI() 函数可把字符串作为 URI 进行编码<br>语法：encodeURI(URIstring)<br>参数：URIstring 必需，一个字符串，含有 URI 或其他要编码的文本。<br>返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：<code>-_.!~*&#39;()</code> ，该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：<code>;/?:@&amp;=+$,#</code></p><ul><li>encodeURIComponent()</li></ul><p>定义和用法：encodeURIComponent() 函数可把字符串作为 URI 组件进行编码<br>语法：encodeURIComponent(URIstring)<br>参数：URIstring 必需，一个字符串，含有 URI 组件或其他要编码的文本<br>返回值：URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换<br>说明：该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：<code>-_.!~*&#39;()</code>，其他字符（比如 ：<code>;/?:@&amp;=+$,#</code> 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的</p><p>说明：</p><ul><li><p>encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号</p></li><li><p>传递参数时需要使用 encodeURIComponent，这样组合的 url 才不会被#等特殊字符截断</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js-中编码（encode）和解码（decode）的三种方法&quot;&gt;&lt;a href=&quot;#js-中编码（encode）和解码（decode）的三种方法&quot; class=&quot;headerlink&quot; title=&quot;js 中编码（encode）和解码（decode）的三种方法&quot;&gt;
      
    
    </summary>
    
      <category term="other" scheme="https://cuilongjin.top/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>移动端(Safari)浏览网页时对数字禁用电话功能</title>
    <link href="https://cuilongjin.top/2019/%E7%A7%BB%E5%8A%A8web/%E7%A7%BB%E5%8A%A8%E7%AB%AF(Safari)%E6%B5%8F%E8%A7%88%E7%BD%91%E9%A1%B5%E6%97%B6%E5%AF%B9%E6%95%B0%E5%AD%97%E7%A6%81%E7%94%A8%E7%94%B5%E8%AF%9D%E5%8A%9F%E8%83%BD/"/>
    <id>https://cuilongjin.top/2019/移动web/移动端(Safari)浏览网页时对数字禁用电话功能/</id>
    <published>2019-07-09T06:51:00.000Z</published>
    <updated>2019-08-01T12:05:11.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端-Safari-浏览网页时对数字禁用电话功能"><a href="#移动端-Safari-浏览网页时对数字禁用电话功能" class="headerlink" title="移动端(Safari)浏览网页时对数字禁用电话功能"></a>移动端(Safari)浏览网页时对数字禁用电话功能</h2><ul><li>标准的电话号码格式是：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"tel:+86-123-456-7890"</span>&gt;</span>1234567890<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>有时候不是电话号码的数字会被浏览器自动解析为如上电话号码格式，导致样式和布局改变</p></li><li><p>忽略页面中的数字识别为电话号码, 只要把这个默认行为关闭就行</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这个关闭不会影响真正电话号码的识别</li></ul><p>说明：Meta 标签中的 format-detection 属性及含义<br>format-detection 中文的意思是 “格式检测”，它是用来检测 html 里的一些格式的</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 禁止了把数字转化为拨号链接 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 禁止作为邮箱地址 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"email=no"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 禁止跳转至地图 默认为 yes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"adress=no"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no,email=no,adress=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移动端-Safari-浏览网页时对数字禁用电话功能&quot;&gt;&lt;a href=&quot;#移动端-Safari-浏览网页时对数字禁用电话功能&quot; class=&quot;headerlink&quot; title=&quot;移动端(Safari)浏览网页时对数字禁用电话功能&quot;&gt;&lt;/a&gt;移动端(Safari)
      
    
    </summary>
    
      <category term="移动web" scheme="https://cuilongjin.top/categories/%E7%A7%BB%E5%8A%A8web/"/>
    
    
  </entry>
  
  <entry>
    <title>npm 使用</title>
    <link href="https://cuilongjin.top/2019/tool/npm/"/>
    <id>https://cuilongjin.top/2019/tool/npm/</id>
    <published>2019-07-02T16:00:00.000Z</published>
    <updated>2019-07-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm-使用"><a href="#npm-使用" class="headerlink" title="npm 使用"></a>npm 使用</h2><h3 id="解决-npm-包无法下载"><a href="#解决-npm-包无法下载" class="headerlink" title="解决 npm 包无法下载"></a>解决 npm 包无法下载</h3><p>electron sass</p><p>进入 <code>~/.npmrc</code>，增加如下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry=https://registry.npm.taobao.org</span><br><span class="line">sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</span><br><span class="line">phantomjs_cdnurl=http://npm.taobao.org/mirrors/phantomjs</span><br><span class="line">electron_mirror=http://npm.taobao.org/mirrors/electron/</span><br></pre></td></tr></table></figure><p>淘宝 npm 镜像 <a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a></p><h3 id="npm-基本命令"><a href="#npm-基本命令" class="headerlink" title="npm 基本命令"></a>npm 基本命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 npm</span></span><br><span class="line">npm -v|--version</span><br><span class="line">npm install npm@latest -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># nvm : npm Version Manager</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索包</span></span><br><span class="line">npm search &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt; <span class="comment"># [&lt;@scope&gt;/] 安装限定范围的包</span></span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;tag&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version&gt;</span><br><span class="line">npm install [&lt;@scope&gt;/]&lt;pkg&gt;@&lt;version range&gt;</span><br><span class="line">npm install &lt;folder&gt;</span><br><span class="line">npm install &lt;tarball file&gt;  <span class="comment"># .tar, .tar.gz, or .tgz</span></span><br><span class="line">npm install &lt;tarball url&gt;</span><br><span class="line">npm install &lt;github usename&gt;/&lt;guthub project&gt;</span><br><span class="line">npm install &lt;git:// url&gt;</span><br><span class="line"></span><br><span class="line">npm install &lt;pkg&gt; -S|--save <span class="comment"># 安装到 dependencies</span></span><br><span class="line">npm install &lt;pkg&gt; -D|--save-dev <span class="comment"># 安装到 devDependencies</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装全局包</span></span><br><span class="line">npm install -g &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新包</span></span><br><span class="line">npm outdated <span class="comment"># 检查可以更新的模块</span></span><br><span class="line">npm update <span class="comment"># 更新全部本地包</span></span><br><span class="line"><span class="comment"># 更新全局安装的包</span></span><br><span class="line">npm update -g <span class="comment"># 更新全部</span></span><br><span class="line">npm update -g| --global &lt;pkg&gt; <span class="comment"># 更新指定包</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新方式 1</span></span><br><span class="line"><span class="comment"># 手动修改 package.json 中依赖包版本，之后执行</span></span><br><span class="line">npm install --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新方式 2 使用第三方插件：</span></span><br><span class="line">npm install -g npm-check-updates</span><br><span class="line">ncu <span class="comment"># 查看可更新包</span></span><br><span class="line">ncu -u <span class="comment"># 更新 package.json</span></span><br><span class="line">npm install <span class="comment"># 升级到最新版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地包</span></span><br><span class="line">npm uninstall &lt;pkg&gt;</span><br><span class="line">npm uninstall --save &lt;pkg&gt; <span class="comment"># 从 `package.json` 文件中删除依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载全局安装的包</span></span><br><span class="line">npm uninstall -g &lt;pkg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开官网</span></span><br><span class="line">npm docs|home [&lt;pkg&gt;]</span><br><span class="line"><span class="comment"># 打开源码仓库页面</span></span><br><span class="line">npm repo [&lt;pkg&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 package.json 文件</span></span><br><span class="line">npm init</span><br><span class="line"><span class="comment"># 创建默认 package.json 文件</span></span><br><span class="line">npm init --yes or -y</span><br></pre></td></tr></table></figure><h3 id="npm-修改源"><a href="#npm-修改源" class="headerlink" title="npm 修改源"></a>npm 修改源</h3><ul><li><p>进入~/.npmrc 增加 <code>registry=https://registry.npm.taobao.org</code></p></li><li><p>通过命令 <code>npm config set registry http://registry.cnpmjs.org</code></p></li><li><p>临时使用指定源下载 <code>npm install jquery --registry=https://registry.npm.taobao.org</code></p></li><li><p>使用 nrm 管理源</p></li></ul><h3 id="npm-配置文件"><a href="#npm-配置文件" class="headerlink" title="npm 配置文件"></a>npm 配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .npmrc 配置文件位置（~/.npmrc）</span></span><br><span class="line">npm config list</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 缓存目录，默认 C:\Users\&lt;username&gt;\AppData\Roaming\npm-cache</span></span><br><span class="line">npm config get cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 npm 缓存</span></span><br><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm 全局 node 包位置</span></span><br><span class="line">npm config get prefix</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">npm root -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 npm 全局文件位置及缓存文件位置</span></span><br><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">"&lt;new_path&gt;"</span></span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">"&lt;new_path&gt;"</span></span><br></pre></td></tr></table></figure><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>使用 NPM 下载和发布代码时都会接触到版本号。NPM 使用语义版本号来管理代码</p><p>语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p><ul><li>如果只是修复 bug，需要更新 Z 位</li><li>如果是新增了功能，但是向下兼容，需要更新 Y 位</li><li>如果有大变动，向下不兼容，需要更新 X 位</li></ul><h3 id="nrm-使用"><a href="#nrm-使用" class="headerlink" title="nrm 使用"></a>nrm 使用</h3><p>nrm ls 查看配置列表，带*号即为当前使用的配置</p><p>nrm use 源的别名：切换源</p><p>nrm add 别名 地址 ： 添加源</p><p>nrm test 别名 ： 测速</p><p>nrm del 别名 ：删除源</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;npm-使用&quot;&gt;&lt;a href=&quot;#npm-使用&quot; class=&quot;headerlink&quot; title=&quot;npm 使用&quot;&gt;&lt;/a&gt;npm 使用&lt;/h2&gt;&lt;h3 id=&quot;解决-npm-包无法下载&quot;&gt;&lt;a href=&quot;#解决-npm-包无法下载&quot; class=&quot;head
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Markdown" scheme="https://cuilongjin.top/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://cuilongjin.top/2019/tool/docker/"/>
    <id>https://cuilongjin.top/2019/tool/docker/</id>
    <published>2019-06-18T11:52:00.000Z</published>
    <updated>2019-07-09T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-dcoker"><a href="#安装-dcoker" class="headerlink" title="安装 dcoker"></a>安装 dcoker</h2><h3 id="ubuntu-16-04-LTS-安装-docker"><a href="#ubuntu-16-04-LTS-安装-docker" class="headerlink" title="ubuntu 16.04 (LTS) 安装 docker"></a>ubuntu 16.04 (LTS) 安装 docker</h3><p>卸载旧版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure><p>镜像仓库方式安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置镜像仓库</span></span><br><span class="line"><span class="comment"># 更新 apt 软件包索引：</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line"><span class="comment"># 安装软件包，以允许 apt 通过 HTTPS 使用镜像仓库：</span></span><br><span class="line">$ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment"># 添加 Docker 的官方 GPG 密钥：</span></span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># 验证密钥指纹是否为 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88。</span></span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p>设置 stable 镜像仓库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># amd64:</span></span><br><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br></pre></td></tr></table></figure><p>安装 DOCKER CE</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure><p>验证是否正确安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令将下载一个测试镜像并在容器中运行它。容器运行时，它将输出一条参考消息并退出</p><p>升级 docker ce</p><p>如需升级 Docker CE，首先运行 <code>sudo apt-get update</code>，然后按照顺序执行操作，并选择您要安装的新版本</p><p>卸载 docker ce</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure><p>主机上的镜像、容器、存储卷、或定制配置文件不会自动删除。如需删除所有镜像、容器和存储卷，请运行下列命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><p>将 docker 配置为在启动时启动</p><h3 id="centos-安装-docker"><a href="#centos-安装-docker" class="headerlink" title="centos 安装 docker"></a>centos 安装 docker</h3><p>卸载旧版本(如果安装过旧版本的话)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><p>安装需要的软件包， yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>设置 yum 源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>可以查看所有仓库中所有 docker 版本，并选择特定版本安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 报错：Requires: container-selinux &gt;= 2:2.74</span></span><br><span class="line">You could try using --skip-broken to work around the problem</span><br><span class="line"></span><br><span class="line">$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">$ yum install epel-release   <span class="comment"># 阿里云上的 epel 源</span></span><br><span class="line">$ yum makecache</span><br><span class="line">$ yum install container-selinux</span><br></pre></td></tr></table></figure><h2 id="使用-docker"><a href="#使用-docker" class="headerlink" title="使用 docker"></a>使用 docker</h2><h3 id="安装镜像"><a href="#安装镜像" class="headerlink" title="安装镜像"></a>安装镜像</h3><p>修改 docker 源</p><p>daemon.json</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 docker</p><p>安装 Ubuntu</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search ubuntu <span class="comment"># 查找 Ubuntu 镜像</span></span><br><span class="line">docker pull ubuntu <span class="comment"># 安装 Ubuntu 镜像</span></span><br><span class="line">docker images <span class="comment">#查看 docker 镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并运行 docker 容器</span></span><br><span class="line">docker run -it -d --name ubuntu_test -p 8088:80 ubuntu</span><br><span class="line"><span class="comment"># --name 自定义容器名，-p 指定端口映射，前者为虚拟机端口，后者为容器端口,成功后返回 id</span></span><br><span class="line"><span class="comment"># 多个 -p 指定多个端口映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 docker 容器  启动一个 bash 交互终端</span></span><br><span class="line">docker run -it 容器名:容器tag /bin/bash</span><br><span class="line"></span><br><span class="line">docker start container_id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有启动的容器(查看所有容器加 -a)</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 id 查看容器信息</span></span><br><span class="line">docker inspect id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker(或者把容器id改为容器名，也可以进入)</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id或容器名 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出容器</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker stop id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi 删除镜像</span><br></pre></td></tr></table></figure><p>备份镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 制作 docker 镜像  1.0 为版本号</span></span><br><span class="line">docker commit 98 ubuntu_test:1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像是否创建</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存镜像到 docker 账号中</span></span><br><span class="line"><span class="comment"># 登录进 Docker 注册中心</span></span><br><span class="line">docker login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送镜像</span></span><br><span class="line">docker tag a25ddfec4d2a arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line">docker push arunpyasi/container-backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包镜像并查看</span></span><br><span class="line">docker save -o ubuntu_test.tar ubuntu_test:1.0</span><br></pre></td></tr></table></figure><p>恢复容器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从docker账号中拉取</span></span><br><span class="line">docker pull arunpyasi/container-backup:<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从本地</span></span><br><span class="line">docker load -i ~/container-backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用加载的镜像去运行Docker容器</span></span><br><span class="line">docker run -d -p 80:80 container-backup</span><br></pre></td></tr></table></figure><p><strong>docker 给已存在的容器添加或修改端口映射</strong></p><p>方式 1：</p><p>提交一个运行中的容器为镜像</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker commit containerid foo/live</span><br></pre></td></tr></table></figure><p>运行镜像并添加端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d -p 8000:80  foo/live /bin/bash</span><br></pre></td></tr></table></figure><p>方式 2：iptable 转发端口</p><p>将容器的 8000 端口映射到 docker 主机的 8001 端口</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iptables -t nat -A  DOCKER -p tcp --dport 5001 -j DNAT --to-destination 45.77.150.20:8000</span><br></pre></td></tr></table></figure><h3 id="docker-容器使用问题"><a href="#docker-容器使用问题" class="headerlink" title="docker 容器使用问题"></a>docker 容器使用问题</h3><p>Centos7 docker 容器报 docker Failed to get D-Bus connection 错误</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl start nginx</span><br><span class="line">Failed to get D-Bus connection: Operation not permitted。</span><br></pre></td></tr></table></figure><p>原因是 dbus-daemon 没能启动</p><p>解决方法</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -d --name ubuntu_test -p 8088:80 ubuntu</span><br><span class="line">$ docker run --privileged -ti --name test1  centos /usr/sbin/init</span><br></pre></td></tr></table></figure><p>ssh 链接 docker 容器</p><p>进入容器</p><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install passwd openssl openssh-server openssh-clients -y</span><br></pre></td></tr></table></figure><p>安装 service 命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install initscripts -y</span><br></pre></td></tr></table></figure><p>修改密码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p>修改配置：</p><p>vi /etc/ssh/sshd_config</p><p>PubkeyAuthentication yes #启用公钥私钥配对认证方式<br>AuthorizedKeysFile .ssh/authorized_keys #公钥文件路径</p><p>PermitRootLogin yes #root 能使用 ssh 登录</p><p>重启 ssh 服务，并设置开机启动：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service sshd restartchkconfig sshd on</span><br></pre></td></tr></table></figure><p>如果无法执行，可试着执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start sshd.service systemctl enable sshd.service</span><br><span class="line"></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><p>docker-compose</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装-dcoker&quot;&gt;&lt;a href=&quot;#安装-dcoker&quot; class=&quot;headerlink&quot; title=&quot;安装 dcoker&quot;&gt;&lt;/a&gt;安装 dcoker&lt;/h2&gt;&lt;h3 id=&quot;ubuntu-16-04-LTS-安装-docker&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="https://cuilongjin.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>移动端调试</title>
    <link href="https://cuilongjin.top/2019/tool/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    <id>https://cuilongjin.top/2019/tool/移动端调试/</id>
    <published>2019-06-18T11:52:00.000Z</published>
    <updated>2019-06-18T11:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些调试工具"><a href="#一些调试工具" class="headerlink" title="一些调试工具"></a>一些调试工具</h2><ol><li><p>直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法 100% 还原手机的真实情况</p></li><li><p>chrome <a href="https://developer.chrome.com/devtools/docs/remote-debugging" target="_blank" rel="noopener">远程调试功能</a></p><p><code>chrome://inspect/#devices</code></p><p>需要连接数据线，其次是设置比较繁琐，而且还限制了 android 手机。对于 IOS 的调试则可能要使用 Safari 的另一套工具</p></li><li><p><a href="https://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener">weinre</a>：远程调试，在 PC 上生成一个像 chrome 开发工具一样的调试器，需要手动引入 js</p></li><li><p>Eruda、vConsole：在移动端页面上生成一个调试器，调试信息会挡住操作元素，查看复杂数据结构的 log 不方便，需要手动引入 js</p></li><li><p>安装各种虚拟机sdk，在电脑上进行手机调试。能比较真实模拟手机，但是安装繁琐，操作不方便，无法模拟真实的手势操作</p></li></ol><h2 id="Eruda"><a href="#Eruda" class="headerlink" title="Eruda"></a>Eruda</h2><p><a href="https://github.com/liriliri/eruda" target="_blank" rel="noopener">https://github.com/liriliri/eruda</a></p><p>Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。</p><ol><li>按钮拖拽，面板透明度大小设置。</li><li>Console面板：捕获Console日志，支持log、error、info、warn、dir、time/timeEnd、clear、count、assert、table；支持占位符，包括%c自定义样式输出；支持按日志类型及正则表达式过滤；支持快捷命令加载underscore、jQuery库；支持JavaScript脚本执行。</li><li>Elements面板：查看标签内容及属性；查看应用在Dom上的样式；支持页面元素高亮；支持屏幕直接点击选取；查看Dom上绑定的各类事件。</li><li>Network面板：捕获请求，查看发送数据、返回头、返回内容等信息。</li><li>Resources面板：查看并清除localStorage、sessionStorage及cookie；查看页面加载脚本及样式文件；查看页面加载图片。</li><li>Sources面板：查看页面源码；格式化html，css，js代码及json数据。</li><li>Info面板：输出URL及User Agent；支持自定义输出内容。</li><li>Snippets面板：页面元素添加边框；加时间戳刷新页面；支持自定义代码片段。</li></ol><p>使用</p><p>通过 CDN 使用：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/eruda/1.5.2/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 npm 安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install eruda --save</span><br></pre></td></tr></table></figure><p>在页面中加载脚本：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/eruda/eruda.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">eruda.init()</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Js文件对于移动端来说略重（gzip后大概100kb）。建议通过url参数来控制是否加载调试器，比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> src = <span class="string">'node_modules/eruda/eruda.min.js'</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/eruda=true/</span>.test(<span class="built_in">window</span>.location) &amp;&amp; localStorage.getItem(<span class="string">'active-eruda'</span>) != <span class="string">'true'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt src="'</span> + src + <span class="string">'"&gt;&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;scr'</span> + <span class="string">'ipt&gt;eruda.init();&lt;/scr'</span> + <span class="string">'ipt&gt;'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>初始化时可以传入配置：</p><ul><li>container：用于插件初始化的 Dom 元素，如果不设置，默认创建 div 作为容器直接置于 html 根结点下面</li><li>tool：指定要初始化哪些面板，默认加载所有</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el)</span><br><span class="line"></span><br><span class="line">eruda.init(&#123;</span><br><span class="line">  container: el,</span><br><span class="line">  tool: [<span class="string">'console'</span>, <span class="string">'elements'</span>],</span><br><span class="line">  useShadowDom: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vConsole"><a href="#vConsole" class="headerlink" title="vConsole"></a>vConsole</h2><p><a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">https://github.com/Tencent/vConsole</a></p><p>一个轻量、可拓展、针对手机网页的前端开发者调试面板。</p><p>特性</p><ul><li>查看 console 日志</li><li>查看网络请求</li><li>查看页面 element 结构</li><li>查看 Cookies、localStorage 和 SessionStorage</li><li>手动执行 JS 命令行</li><li>自定义插件</li></ul><p><a href="https://github.com/Tencent/vConsole/blob/dev/doc/tutorial_CN.md" target="_blank" rel="noopener">使用说明</a></p><p>下载 vConsole 的<a href="https://github.com/Tencent/vConsole/releases/latest" target="_blank" rel="noopener">最新版本</a>。（不要直接下载 dev 分支下的 <code>dist/vconsole.min.js</code>）</p><p>或者使用 npm 安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vconsole</span><br></pre></td></tr></table></figure><p>引入 <code>dist/vconsole.min.js</code> 到项目中：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/vconsole.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vConsole = <span class="keyword">new</span> VConsole()</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'Hello world'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="weinre"><a href="#weinre" class="headerlink" title="weinre"></a>weinre</h2><p><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html" target="_blank" rel="noopener">http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html</a></p><ol><li>Element： 查看/修改dom，查看/修改 dom CSS</li><li>Resources：查看/修改 localStorage, sessionStorage</li><li>Network：查看网络请求</li><li>Timeline：</li><li>Console：查看控制台输出</li></ol><p>不能做 JS 调试</p><p>使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install -g weinre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 weinre 服务</span></span><br><span class="line">weinre --boundHost 192.168.3.44 --httpPort 8888</span><br><span class="line"></span><br><span class="line">启动调试客户端</span><br><span class="line">在浏览器中打开 <span class="string">'http://192.168.3.44:8888'</span> 即可启动调试客户端</span><br><span class="line"></span><br><span class="line">在需要调试的页面中添加如下</span><br><span class="line">&lt;script src=<span class="string">"http://192.168.3.44:8888/target/target-script-min.js#anonymous"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="spy-debugger"><a href="#spy-debugger" class="headerlink" title="spy-debugger"></a>spy-debugger</h2><p><a href="https://github.com/wuchangming/spy-debugger" target="_blank" rel="noopener">https://github.com/wuchangming/spy-debugger</a></p><p>微信调试，各种 WebView 样式调试、手机浏览器的页面真机调试。便捷的远程调试手机页面、抓包工具，支持：HTTP/HTTPS，无需USB连接设备</p><p>spy-debugger 集成了<code>weinre</code>，简化了<code>weinre</code>需要给每个调试的页面添加 js 代码。原理是拦截所有 html 页面请求注入<code>weinre</code>所需要的 js 代码。让页面调试更加方便</p><p>1、页面调试＋抓包<br>2、操作简单，无需USB连接设备<br>3、<strong>支持HTTPS</strong><br>4、<code>spy-debugger</code>内部集成了<a href="http://people.apache.org/~pmuellr/weinre/docs/latest/" target="_blank" rel="noopener"><code>weinre</code></a>、<a href="https://github.com/wuchangming/node-mitmproxy" target="_blank" rel="noopener"><code>node-mitmproxy</code></a>、<a href="https://github.com/alibaba/anyproxy" target="_blank" rel="noopener"><code>AnyProxy</code></a>。<br>5、自动忽略原生 App 发起的 https 请求，只拦截 webview 发起的 https 请求。对使用了 SSL pinning 技术的原生App 不造成任何影响。<br>6、可以配合其它代理工具一起使用(默认使用AnyProxy) <a href="https://github.com/wuchangming/spy-debugger#%E8%AE%BE%E7%BD%AE%E5%A4%96%E9%83%A8%E4%BB%A3%E7%90%86%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8anyproxy" target="_blank" rel="noopener">(设置外部代理)</a></p><p>基本使用</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">npm install spy-debugger -g</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">spy-debugger</span><br><span class="line"><span class="comment">#设置手机的HTTP代理</span></span><br><span class="line">代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)</span><br><span class="line"><span class="comment"># 手机安装证书</span></span><br><span class="line">手机浏览器访问 http://s.xxx</span><br><span class="line">设置-&gt;通用-&gt;描述文件与设备管理-&gt;找到node-mitmproxy CA（安装）</span><br><span class="line">设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt; 找到node-mitmproxy CA（打开）</span><br></pre></td></tr></table></figure><p>自定义选项</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义端口</span></span><br><span class="line">spy-debugger -p 8888</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置页面内容为可编辑模式</span></span><br><span class="line">spy-debugger -w <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否只拦截浏览器发起的https请求(默认： true)</span></span><br><span class="line">spy-debugger -b <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许weinre监控iframe加载的页面(默认： false)</span></span><br><span class="line">spy-debugger -i <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 HTTP 缓存(默认： false)</span></span><br><span class="line">spy-debugger -c <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="m-console"><a href="#m-console" class="headerlink" title="m-console"></a>m-console</h2><p><a href="https://github.com/fwon/m-console" target="_blank" rel="noopener">https://github.com/fwon/m-console</a></p><p>手机远程调试工具，手机通过代理连接上PC后，可以在PC版浏览器打印log和错误日志</p><p>需要手动给每个调试的页面添加 js 代码</p><h2 id="DebugGap-VIDE"><a href="#DebugGap-VIDE" class="headerlink" title="DebugGap-VIDE"></a>DebugGap-VIDE</h2><p><a href="https://www.debuggap.com/debug_webview.html" target="_blank" rel="noopener">https://www.debuggap.com/debug_webview.html</a></p><h2 id="Mobile-Debug"><a href="#Mobile-Debug" class="headerlink" title="Mobile Debug"></a>Mobile Debug</h2><p><a href="https://www.mobiledebug.com/" target="_blank" rel="noopener">https://www.mobiledebug.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一些调试工具&quot;&gt;&lt;a href=&quot;#一些调试工具&quot; class=&quot;headerlink&quot; title=&quot;一些调试工具&quot;&gt;&lt;/a&gt;一些调试工具&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接在 chrome，firefox 等开启模拟器调试，简单直接，还能模拟网络等，但是无法
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="移动端调试" scheme="https://cuilongjin.top/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="https://cuilongjin.top/2019/other/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://cuilongjin.top/2019/other/面试题/</id>
    <published>2019-03-21T10:30:00.000Z</published>
    <updated>2019-03-26T02:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><h3 id="http-相关"><a href="#http-相关" class="headerlink" title="http 相关"></a>http 相关</h3><h3 id="HTML-css-相关"><a href="#HTML-css-相关" class="headerlink" title="HTML css 相关"></a>HTML css 相关</h3><h3 id="js-相关"><a href="#js-相关" class="headerlink" title="js 相关"></a>js 相关</h3><h3 id="jquery-相关"><a href="#jquery-相关" class="headerlink" title="jquery 相关"></a>jquery 相关</h3><h3 id="工具类相关"><a href="#工具类相关" class="headerlink" title="工具类相关"></a>工具类相关</h3><p><a href="zh-cn/_Tool/webpack配置?id=webpack-和-gulp-区别">webpack 和 gulp 区别</a><br><a href></a><br><a href></a><br><a href></a><br><a href></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器相关&quot;&gt;&lt;a href=&quot;#浏览器相关&quot; class=&quot;headerlink&quot; title=&quot;浏览器相关&quot;&gt;&lt;/a&gt;浏览器相关&lt;/h3&gt;&lt;h3 id=&quot;http-相关&quot;&gt;&lt;a href=&quot;#http-相关&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="other" scheme="https://cuilongjin.top/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>Webpack</title>
    <link href="https://cuilongjin.top/2019/tool/webpack%E9%85%8D%E7%BD%AE/"/>
    <id>https://cuilongjin.top/2019/tool/webpack配置/</id>
    <published>2019-01-15T10:00:00.000Z</published>
    <updated>2019-07-09T10:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><ul><li><a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack 官网</a></li><li><a href="https://webpack.docschina.org/" target="_blank" rel="noopener">webpack 中文网</a></li><li><a href="https://github.com/cuilongjin/webpack-config/" target="_blank" rel="noopener">webpack 配置文件</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>webpack 是一个现代 JavaScript 应用程序的模块打包器（module bundler）</p><p>webpack 是一个模块化方案（预编译）</p><p>webpack 获取具有依赖关系的模块，并生成表示这些模块的静态资源</p><p>webpack 的两个特点：模块化、打包</p><p>四个核心概念：<strong>入口(entry)</strong>、<strong>输出(output)</strong>、<strong>加载器(loader)</strong>、<strong>插件(plugins)</strong></p><p>模块化方案：webpack 和 requirejs（通过编写代码的方式将前端的功能，划分成独立的模块）<br>browserify 是与 webpack 相似的模块化打包工具</p><h3 id="webpack-起源"><a href="#webpack-起源" class="headerlink" title="webpack 起源"></a>webpack 起源</h3><ul><li>webpack 解决了现存模块打包器的两个痛点：<ul><li>Code Spliting - 代码分离</li><li>静态资源的模块化处理方案</li></ul></li></ul><h3 id="webpack-与模块"><a href="#webpack-与模块" class="headerlink" title="webpack 与模块"></a>webpack 与模块</h3><ul><li><p><a href="http://zhaoda.net/webpack-handbook/module-system.html" target="_blank" rel="noopener">前端模块系统的演进</a></p></li><li><p>在 webpack 看来：所有的<strong>静态资源都是模块</strong></p></li><li><p>webpack 模块能够识别以下等形式的模块之间的依赖：</p><ul><li><p>ES2015 <code>import</code> <code>export</code></p></li><li><p>CommonJS <code>require()</code> <code>module.exports</code></p></li><li><p>AMD <code>define</code> 和 <code>require</code></p></li><li><p>css/sass/less 文件中的 <code>@import</code></p></li><li><p>图片连接，比如：样式 <code>url(...)</code> 或 HTML <code>&lt;img src=...&gt;</code></p></li><li><p>字体等</p></li></ul></li></ul><ul><li>在webpack提供的模块化环境中<ul><li>想要加载一个JS文件，只需要 require(‘a.js’)</li><li>想要加载一个CSS文件，只需要 require(‘css/index.css’)</li><li>想要加载一个图片文件，只需要 require(‘images/a.png’)</li></ul></li></ul><ul><li><a href="http://www.jianshu.com/p/42e11515c10f#" target="_blank" rel="noopener">入门 Webpack，看这篇就够了</a></li></ul><h3 id="webpack-打包原理："><a href="#webpack-打包原理：" class="headerlink" title="webpack 打包原理："></a>webpack 打包原理：</h3><p>​        入口文件： main.js</p><p>​        webpack 从入口出发，递归分析项目中所有的依赖项（模块），使用loader来处理对应的模块最终，打包生成一个 bundle.js 文件。</p><p>​        如果配置了 webpack 中的 代码分离（Code Spliting），webpack 会根据 分离点 将这个模块生成一个独立的JS文件</p><p>​        还可以通过配置，将 CSS 、 图片、 字体 等文件，从 bundle.js 中抽离为独立的文件</p><h2 id="webpack-的基本使用"><a href="#webpack-的基本使用" class="headerlink" title="webpack 的基本使用"></a>webpack 的基本使用</h2><p>安装：<code>npm i -D webpack webpack-cli</code></p><p>webpack：是 webpack 工具的核心包</p><p>webpack-cli：提供了一些在终端中使用的命令</p><p>-D(–save-dev)：表示项目开发期间的依赖</p><p>webpack 的两种使用方式：命令行、配置文件（<code>webpack.config.js</code>）</p><h3 id="命令行使用说明"><a href="#命令行使用说明" class="headerlink" title="命令行使用说明"></a>命令行使用说明</h3><ul><li><code>package.json</code>中的<code>scripts</code>中可以存放一些 bash 命令，这些 bash 命令可以通过 <code>npm run 命令名称</code> 来执行</li><li>注意：npm 在执行 scripts 中的命令的时候，是在电脑系统后台默认开启一个 bash，将当前目录下的<code>./node_modules/.bin</code>这个文件夹临时加入了系统环境变量</li><li>使用方式：<code>npm run build</code></li><li>设置开发状态： <code>mode</code>  如果没有设置 mode 配置项，webpack 会默认提供开发环境(production)</li><li>在入口文件中可以使用 <code>import</code> 引入 js css less 等文件</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  // webpack 是 webpack-cli 提供的命令</span><br><span class="line">  // src/js/main.js 为入口文件</span><br><span class="line">  // --output dist/bundle.js 为出口文件</span><br><span class="line">  // --mode development 生产环境</span><br><span class="line">  "build": "webpack"</span><br><span class="line">  "build1": "webpack src/js/main.js --output dist/bundle.js --mode development"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件方式（推荐）"><a href="#配置文件方式（推荐）" class="headerlink" title="配置文件方式（推荐）"></a>配置文件方式（推荐）</h3><p>项目<code>根目录</code>下创建一个 <code>webpack.config.js</code>文件，运行 <code>webpack</code> 命令时的默认配置文件</p><p>指定其他文件：<code>--config  webpack.XX.js</code></p><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;build&quot;: &quot;webpack&quot;</code></p><p>执行命令 : <code>npm run build</code></p><p>示例代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack 是基于 node的 , 所以配置文件符合 node 方式书写配置</span></span><br><span class="line"><span class="comment">// 注意 : 不要再这个文件中使用ES6的的模块化 import语法</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  entry: path.join(__dirname, <span class="string">'./src/js/main.js'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出口</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 出口目录</span></span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'js/bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 开发模式</span></span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>安装：<code>npm i -D webpack-dev-server</code></p><p>作用：配合 webpack，创建开发环境（启动服务器、监视文件变化、自动编译、刷新浏览器等），提高开发效率</p><p>注意：无法直接在终端中执行 <code>webpack-dev-server</code>，需要在 <code>package.json</code> 配置 <code>scripts</code> 后使用</p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><ul><li><code>webpack-dev-server</code>将打包好的文件存储在内存中，提高编译和加载速度，效率更高（不会生成dist目录）</li><li>在内存中出口目录为项目根目录（命令行中的提示：<code>webpack output is served from /</code>）<ul><li>在<code>index.html</code>页面中引入文件不需要加<code>dist</code></li></ul></li></ul><h3 id="CLI-配置"><a href="#CLI-配置" class="headerlink" title="CLI 配置"></a>CLI 配置</h3><ul><li><code>--contentBase</code> ：告诉服务器在哪个目录中提供服务（可以理解为：打开哪个目录中的 index.html）<ul><li><code>--contentBase ./src</code>：当前目录下的 src 文件夹</li></ul></li><li><code>--open true</code> ：自动打开浏览器</li><li><code>--port 3000</code> ：指定端口号</li><li><code>--hot</code> ：热更新，只加载修改的文件(按需加载修改的内容)，而非全部加载</li><li><code>--progress</code>：显示进度条</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --contentBase src --open --port 8888 --hot"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h3><p>配置 <code>package.json</code> 中的 <code>scripts</code> , 脚本命令为： <code>&quot;dev&quot;: &quot;webpack-dev-server --hot&quot;</code></p><p>执行命令 : <code>npm run dev</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --hot 热更新写在命令行里，不然的话还要配其他插件麻烦</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'src'</span>),</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">// hot: true,</span></span><br><span class="line">    </span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123; <span class="comment">// api 表示当前项目请求的 key</span></span><br><span class="line">        target: <span class="string">'http://www.baidu.com'</span>, <span class="comment">// 代理服务器路径</span></span><br><span class="line">        pathRewrite: &#123; <span class="string">'^/api'</span>: <span class="string">'/api'</span> &#125;, <span class="comment">// 重写路径</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求 localhost:8080/api/.. 会被代理到 http://www.baidu.com/api/..</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// plugins: [</span></span><br><span class="line">  <span class="comment">//   new webpack.HotModuleReplacementPlugin()</span></span><br><span class="line">  <span class="comment">// ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="html-webpack-plugin-插件"><a href="#html-webpack-plugin-插件" class="headerlink" title="html-webpack-plugin 插件"></a>html-webpack-plugin 插件</h2><ul><li>安装：<code>npm i -D html-webpack-plugin</code></li><li>作用：根据模板，在内存中自动生成 html 页面，并自动引入<code>bundle.js</code>、<code>css</code>等文件</li></ul><p>配置文件配置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 html-webpack-plugin 插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 配置插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// html-webpack-plugin 配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 模板页面路径</span></span><br><span class="line">      template: path.join(__dirname, <span class="string">'src/index.html'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包非js文件"><a href="#打包非js文件" class="headerlink" title="打包非js文件"></a>打包非js文件</h2><p>webpack 默认只能处理 js 文件，非 js(css、less、图片、字体等)处理不了，借助 loader 加载器</p><h3 id="处理-css-文件"><a href="#处理-css-文件" class="headerlink" title="处理 css 文件"></a>处理 css 文件</h3><p>在 <code>main.js</code>中引入css文件 <code>import &#39;../css/main.css&#39;</code></p><p>安装 : <code>npm i -D style-loader css-loader</code></p><p>在 <code>webpack.config.js</code> 中，添加个新的配置项 <code>module</code></p><p>在 <code>module</code> 中添加 <code>loader</code> 来处理 <code>css</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理 css</span></span><br><span class="line">      <span class="comment">// 注意点 use 执行loader 顺序 从右往左</span></span><br><span class="line">      <span class="comment">// css-loader: 读取css文件内容，将其转化为一个模块</span></span><br><span class="line">      <span class="comment">// style-loader: 拿到模块, 创建一个style标签，插入页面中</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-less-文件"><a href="#处理-less-文件" class="headerlink" title="处理 less 文件"></a>处理 less 文件</h3><p>在 <code>main.js</code>中引入 less 文件 <code>import &#39;../css/main.less&#39;</code></p><p>安装 : <code>npm i -D less-loader less style-loader css-loader</code></p><p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理 <code>less</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">//处理 css</span></span><br><span class="line">      &#123;</span><br><span class="line">        test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h3><p>安装 : <code>npm i -D url-loader file-loader</code></p><p>在 webpack.config.js 中配置项 <code>module-&gt;rules</code>中添加 loader 来处理图片</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理图片</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpg|png)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              <span class="comment">//  图片大小 &lt;= 10000 =&gt; 转化为base64</span></span><br><span class="line">              <span class="comment">//  图片大小 &gt;= 10000 =&gt; 不会转base64 内部调用 file-loader 加载图片</span></span><br><span class="line">              limit: <span class="number">10000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url-loader</strong> 默认会将图片转化为 base64 编码格式，目的：提高性能</p><p><strong>file-loader</strong> 在处理图片时，会对文件进行重命名</p><p>base64 编码格式的图片说明：</p><ul><li>精灵图：将一些小图片合并为一张图片，减少请求次数，提高性能</li><li>字体图标：直接将一些小的图片,合并到字体文件中，并且不会失真</li><li>base64：是一种编码格式,能够将图片、文字等常见的文件，转化为 base64 格式，这种字符串格式浏览器能够识别并且读取显示到页面中</li><li>base64 是一个字符串，也可以直接被内嵌到页面中，或者 css 中</li><li>注意：大图片不适合用 base64 处理，只有小的图标才适合 base64 处理</li></ul><h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><p>在 <strong>main.js</strong> 中引入 css 文件 <code>import &#39;../css/iconfont/iconfont.css&#39;</code></p><p>在 webpack.config.js 中配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理字体图标</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(svg|woff|woff2|ttf|eot)$/</span>,</span><br><span class="line">        use: <span class="string">'url-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理-ES6-语法"><a href="#处理-ES6-语法" class="headerlink" title="处理 ES6 语法"></a>处理 ES6 语法</h3><ol><li>现在的项目都是使用 ES6 开发的，但是这些新的 ES6 语法，并不是所有的浏览器都支持，所以就需要有一个工具，帮我们转成 es5 语法，这个就是：babel</li><li><a href="https://babeljs.io/" target="_blank" rel="noopener">babel</a></li><li>Babel is a JavaScript compiler. ==&gt; babel 是一个 JavaScript 编译器</li><li>webpack 只能处理 import / export 这个 es6 模块化语法，而其他的 js 新语法，应该使用 babel 来处理</li></ol><p>babel 的使用 :</p><ul><li>安装： <code>npm i -D babel-core babel-loader@7</code><ul><li>babel-core 是 babel 的核心包</li><li>babel-loader 加载 js 文件，并将 js 代码内容交给 babel-core 解析为 es5 低版本的 js</li></ul></li></ul><ul><li>安装：<code>npm i -D babel-preset-env babel-preset-stage-2</code><ul><li>babel-preset-env：表示能够解析 es2015、es2016、es2017、es2018 这些标准的语法</li><li>babel-preset-stage-2：用来解析还没有被采纳为标准的语法</li><li><code>babel-polyfill与babel-plugin-transform-runtime</code> 也是做兼容处理的,以前都是用这个，兼容更早的</li></ul></li></ul><ul><li>配置 : 在 webpack.config.js 中添加一个 loader</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 处理 ES6 语法</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">        <span class="comment">// 设置忽略 node-modules 文件夹</span></span><br><span class="line">        exclude: <span class="regexp">/node-modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在项目根目录中创建 babel 的配置文件，叫：<code>.babelrc</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    &quot;env&quot;,</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  -----------</span><br><span class="line">  // 暂时不用</span><br><span class="line">  // 如果未来某一天真的用到了polify</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;transform-runtime&quot;, &#123;</span><br><span class="line">      &quot;helpers&quot;: false,</span><br><span class="line">      &quot;polyfill&quot;: true,</span><br><span class="line">      &quot;regenerator&quot;: true,</span><br><span class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目打包上线"><a href="#项目打包上线" class="headerlink" title="项目打包上线"></a>项目打包上线</h2><p>执行 : <code>npm run build</code> 对项目进行打包，生成dist文件</p><p>模拟本地服务器 : 安装 : <code>npm i -g http-server</code></p><p>把dist文件里的内容放到服务器里即可，直接运行<code>http-server</code></p><h2 id="webpack-和-gulp-区别"><a href="#webpack-和-gulp-区别" class="headerlink" title="webpack 和 gulp 区别"></a>webpack 和 gulp 区别</h2><ol><li>Gulp 侧重于前端开发的整个过程的控制管理（像是流水线），我们可以通过给 gulp 配置不通的 task（通过Gulp 中的 gulp.task() 方法配置，比如启动 server、sass/less 预编译、文件的合并压缩等等）来让 gulp 实现不同的功能，从而构建整个前端开发流程</li><li>Webpack 也称之为模块打包机 ，由此也可以看出 Webpack 更侧重于模块打包，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块，最初 Webpack 本身就是为前端 JS 代码打包而设计的，后来被扩展到其他资源的打包处理。Webpack 是通过 loader（加载器）和 plugins（插件）对资源进行处理的</li><li>gulp是构建工具，Webpack是 js 模块化的解决方案</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Webpack&quot;&gt;&lt;a href=&quot;#Webpack&quot; class=&quot;headerlink&quot; title=&quot;Webpack&quot;&gt;&lt;/a&gt;Webpack&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://webpack.js.org/&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="工具" scheme="https://cuilongjin.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Webpack" scheme="https://cuilongjin.top/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="https://cuilongjin.top/2019/vue/vue+elementui/"/>
    <id>https://cuilongjin.top/2019/vue/vue+elementui/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-19T11:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p>组件抽离</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 标签不要动，只需要把内容题出去后，添加 src 引入即可</span><br><span class="line">&lt;template src=&quot;./Roles.html&quot;&gt;&lt;/template&gt;</span><br><span class="line">&lt;script src=&quot;./Roles.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style src=&quot;./Roles.less&quot; lang=&quot;less&quot; scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>scoped</p><p>vue 组件之间的样式有自动复用的问题，给一个类设置样式，其他组件中相同类的元素也会被设置样式</p><p>解决：在 <code>style</code> 标签上添加 <code>scoped</code> 字段，设置样式只作用于当前组件</p><p><code>&lt;style scoped&gt;&lt;/style&gt;</code></p><p>作用 1：让当前组件内的样式，只能在当前组件上起效果<br>作用 2：如果添加了 scoped，样式只会对本来就存在的标签/组件起效果，如果是动态添加的组件/标签，是无效的</p><p>动态添加的组件/标签，在 <code>.vue</code>文件里添加一个 style 标签，在标签里设置该样式属性，或者在选择器前添加<code>/deep/</code></p><p>vm.$nextTick( [callback] )：将回调延迟到下次 DOM 更新循环之后执行</p><p>如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise：<code>await this.$nextTick()</code></p><p>插槽</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">  通过 scope.row 获取当前行的数据</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面跳转</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/login'</span>)</span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">'login'</span> &#125;)</span><br><span class="line"><span class="keyword">this</span>.$router.go(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="element"><a href="#element" class="headerlink" title="element"></a>element</h2><p><code>span=&#39;1&#39;</code>：赋值 span 的是一个字符串 ‘1’</p><p><code>:span=&#39;1&#39;</code>：前面加一个<code>:</code> 意思是动态数据绑定，赋值 span 的是具体数据类型的数据，即数字 1</p><h3 id="时间日期选择器"><a href="#时间日期选择器" class="headerlink" title="时间日期选择器"></a>时间日期选择器</h3><p>日期选择器限制选择范围</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-date-picker</span> <span class="attr">v-model</span>=<span class="string">"options.endDate"</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">:picker-options</span>=<span class="string">"endDateOptions"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-date-picker</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">endDateOptions: &#123;</span><br><span class="line">  disabledDate: <span class="function"><span class="params">time</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 限制结束时间范围为大于开始时间，并在一周内</span></span><br><span class="line">    <span class="keyword">return</span> time.getTime() &lt; <span class="keyword">this</span>.options.startDate || time.getTime() &gt; <span class="keyword">this</span>.options.startDate + <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> * <span class="number">7</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tree-树形控件"><a href="#Tree-树形控件" class="headerlink" title="Tree 树形控件"></a>Tree 树形控件</h3><ul><li>Attributes</li></ul><p>show-checkbox：节点是否可被选择</p><p>default-expand-all：是否默认展开所有节点</p><p>node-key： 每个树节点用来作为唯一标识的属性，整棵树应该是唯一的</p><ul><li>方法</li></ul><p>this.$refs.tree.setCheckedKeys：通过 keys 设置目前勾选的节点，使用此方法必须设置 node-key 属性</p><p>this.$refs.tree.getCheckedKeys：若节点可被选择（即 show-checkbox 为 true），则返回目前被选中的节点的 key 所组成的数组</p><h3 id="NavMenu-导航菜单"><a href="#NavMenu-导航菜单" class="headerlink" title="NavMenu 导航菜单"></a>NavMenu 导航菜单</h3><h4 id="Menu-Attribute"><a href="#Menu-Attribute" class="headerlink" title="Menu Attribute"></a>Menu Attribute</h4><p>router：是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转</p><p>background-color：菜单的背景色（仅支持 hex 格式）#ffffff</p><p>text-color：菜单的文字颜色（仅支持 hex 格式）</p><p>active-text-color：当前激活菜单的文字颜色（仅支持 hex 格式）</p><p>default-active：当前激活菜单的 index</p><p>unique-opened：是否只保持一个子菜单的展开</p><h3 id="Table-表格"><a href="#Table-表格" class="headerlink" title="Table 表格"></a>Table 表格</h3><h4 id="Table-column-Attributes"><a href="#Table-column-Attributes" class="headerlink" title="Table-column Attributes"></a>Table-column Attributes</h4><ul><li>type：设置 <code>index</code> 则显示该行的索引（从 1 开始计算）；设置 <code>expand</code> 则显示为一个可展开的按钮；</li></ul><p>设置了 <code>selection</code> 则显示多选框</p><ul><li>自定义索引 <code>index</code>：如果设置了 <code>type=index</code>，可以通过传递 <code>index</code> 属性来自定义索引，属性传入数字时，将作为索引的起始值。传入方法是，它提供当前行的行号（从 <code>0</code> 开始）作为参数，返回值将作为索引展示。</li></ul><p><code>type=&quot;index&quot; :index=&quot;indexMethod&quot;</code> <code>indexMethod(index) {return index}</code></p><h3 id="Radio-单选框"><a href="#Radio-单选框" class="headerlink" title="Radio 单选框"></a>Radio 单选框</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-radio v-model=&quot;radio&quot; label=&quot;1&quot;&gt;备选项&lt;/el-radio&gt;</span><br><span class="line">&lt;el-radio v-model=&quot;radio&quot; label=&quot;2&quot;&gt;备选项&lt;/el-radio&gt;</span><br></pre></td></tr></table></figure><p>选中意味着变量的值为相应 <code>label</code> 属性的值，<code>label</code>可以是<code>String</code>、<code>Number</code>或<code>Boolean</code>。</p><h4 id="禁用状态"><a href="#禁用状态" class="headerlink" title="禁用状态"></a>禁用状态</h4><p>设置<code>disabled</code>属性<code>true</code>为禁用</p><h4 id="单选框组"><a href="#单选框组" class="headerlink" title="单选框组"></a>单选框组</h4><p>结合 el-radio-group 元素和子元素 el-radio 可以实现单选组，在 el-radio-group 中绑定 v-model，在 el-radio 中设置好 label 即可，无需再给每一个 el-radio 绑定变量，另外，还提供了 change 事件来响应变化，它会传入一个参数 value</p><h4 id="Radio-Events"><a href="#Radio-Events" class="headerlink" title="Radio Events"></a>Radio Events</h4><p>change：绑定值变化时触发的事件 选中的 Radio label 值</p><h3 id="Cascader-级联选择器"><a href="#Cascader-级联选择器" class="headerlink" title="Cascader 级联选择器"></a>Cascader 级联选择器</h3><h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>options：可选项数据源，键名可通过 <code>props</code> 属性配置</p><p>props：配置选项，对象</p><p>​ value：指定选项的值为选项对象的某个属性值</p><p>​ label：指定选项标签为选项对象的某个属性值</p><p>​ children：指定选项的子选项为选项对象的某个属性值</p><h3 id="Upload-上传"><a href="#Upload-上传" class="headerlink" title="Upload 上传"></a>Upload 上传</h3><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><ul><li><p>action: 必选参数，上传的完整地址</p></li><li><p>multiple: 是否支持多选文件</p></li><li><p>:on-preview: 点击文件列表中已上传的文件时的钩子 function(file)</p></li><li><p>:on-remove: 文件列表移除文件时的钩子 function(file, fileList)</p></li><li><p>list-type: 文件列表的类型</p></li><li><p>:before-upload: 对文件校验 function(file)，若返回 false 或者返回 Promise 且被 reject，则停止上传</p></li><li><p>:on-success: 文件上传成功时的钩子 function(response, file, fileList)</p></li></ul><p>​ response：参数一， 接口的响应结；file：参数二， 文件对象；fileLIst：参数三，文件对象列表</p><p>​ 自定义参数 <code>:on-success=&quot;(res, file, fileList) =&gt; UploadImg(1, res, file, fileList)&quot;</code></p><ul><li><p>headers: 设置上传的请求头部 object</p></li><li><p>:auto-upload=”false”：手动调用<code>this.$refs.upload.submit()</code>上传</p></li><li><p>on-progress: 文件上传时的钩子 function(event, file, fileList)</p></li></ul><h3 id="Steps-步骤条"><a href="#Steps-步骤条" class="headerlink" title="Steps 步骤条"></a>Steps 步骤条</h3><p>active 设置当前激活步骤 number</p><p>设置<code>active</code>属性，接受一个<code>Number</code>，表明步骤的 index，从 0 开始</p><h3 id="Tabs-标签页"><a href="#Tabs-标签页" class="headerlink" title="Tabs 标签页"></a>Tabs 标签页</h3><h4 id="Tabs-Attributes"><a href="#Tabs-Attributes" class="headerlink" title="Tabs Attributes"></a>Tabs Attributes</h4><p>value / v-model 绑定值，选中选项卡的 name string — 第一个选项卡的 name</p><p>tab-position 选项卡所在位置 string top/right/bottom/left top</p><h4 id="Tabs-Events"><a href="#Tabs-Events" class="headerlink" title="Tabs Events"></a>Tabs Events</h4><p>tab-click tab 被选中时触发 被选中的标签 tab 实例</p><h3 id="element-中的-Events-和-Methods"><a href="#element-中的-Events-和-Methods" class="headerlink" title="element 中的 Events 和 Methods"></a>element 中的 Events 和 Methods</h3><p>// 假设有个 el-box ,如果看文档,有个 Events 和 Methods<br><el-box></el-box></p><p>// Events<br>close</p><p>// Methdos<br>getData</p><p>// 使用<br>&lt;el-box ref=’box’ @close=’函数名自己写’&gt;</p><p>this.$refs.box.getData()</p><h3 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h3><p>打包 : npm run build<br>把打好的包放到 http-server 里面</p><p>介绍 vendor : 里面放一些第三方包 vue/vue-router/element-ui 包等</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化 :"></a>优化 :</h4><ul><li><p>按需加载</p></li><li><p>首屏加载时间，是衡量一个网站性能快慢的很重要的一个指标</p></li><li><p>如何提高加载速度呢?</p></li></ul><p>只加载首屏中看到的内容，没有看到的内容都不加载，需要用到的时候，再去加载<br>进来减少首屏的请求次数</p><ul><li>vue 项目打包的时候，如何实现按需加载功能 ?</li></ul><p>vue 的异步组件(路由) 配合 webpack 代码分割的功能实现按需加载功能</p><p>路由懒加载：<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'Home.vue'</span></span><br><span class="line">==&gt;</span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'Home.vue'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个组件打包在一起</span></span><br><span class="line"><span class="keyword">const</span> Goods = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'goods' */</span> <span class="string">'Goods.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> GoodsAdd = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'goods' */</span> <span class="string">'GoodsAdd.vue'</span>)</span><br></pre></td></tr></table></figure><ul><li>CDN</li></ul><p>在 index.html 引入 CDN 提供的文件</p><p>在 webpack.base.conf.js 中配置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">  <span class="comment">// 键：表示 导入包语法 from 后面跟着的名称</span></span><br><span class="line">  <span class="comment">// 值：表示 script 引入JS文件时，在全局环境中的变量名称</span></span><br><span class="line">  vue: <span class="string">'Vue'</span>,</span><br><span class="line">  <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">  axios: <span class="string">'axios'</span>,</span><br><span class="line">  <span class="string">'element-ui'</span>: <span class="string">'ELEMENT'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 index.html 引入 css 文件就不需要在 main.js 中引入了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vue&quot;&gt;&lt;a href=&quot;#vue&quot; class=&quot;headerlink&quot; title=&quot;vue&quot;&gt;&lt;/a&gt;vue&lt;/h2&gt;&lt;p&gt;组件抽离&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
      <category term="vue" scheme="https://cuilongjin.top/tags/vue/"/>
    
      <category term="element" scheme="https://cuilongjin.top/tags/element/"/>
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="https://cuilongjin.top/2019/vue/vuex/"/>
    <id>https://cuilongjin.top/2019/vue/vuex/</id>
    <published>2019-01-08T10:00:00.000Z</published>
    <updated>2019-02-19T11:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="vuex-是什么"><a href="#vuex-是什么" class="headerlink" title="vuex 是什么?"></a>vuex 是什么?</h2><ul><li>状态管理工具</li><li>状态即数据，状态管理就是管理组件中的 data(数据)</li><li>Vuex 中的状态管理工具采用 <code>集中式</code> 统一管理项目中组件之间需要通讯的数据</li><li>最佳实践：只将组件之间共享的数据放在 vuex 中，而不是将所有的数据都放在 vuex 中，也就是如果数据只是在组件内部使用的，这个数据应该放在组件中，而不要放在 vuex</li><li>vuex 中的数据也是响应式的，如果一个组件中修改了 vuex 中的数据，另外一个使用的 vuex 数据的组件，就会自动更新</li><li>任何组件中都可以直接获取 vuex</li><li>前端状态该管理的思想最早是由 react 团队提出来的，就是 Flux(思想以及具体的实现)</li><li>前端状态管理工具 : Flux / Redux / Mobx / vuex 等等</li></ul><h2 id="什么时候用"><a href="#什么时候用" class="headerlink" title="什么时候用?"></a>什么时候用?</h2><ul><li>项目体量很小，不需要使用 vuex，如果项目中组件通讯不复杂，也不需要使用 vuex</li><li>写项目的时候，发现组件通讯多，组件之间的关系复杂，项目已经无法继续开发了，此时就应该使用 vuex</li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul><li>安装 : <code>npm i vuex</code></li><li>导入 vuex</li><li>创建 vuex 示例</li></ul><h2 id="vuex-中的概念"><a href="#vuex-中的概念" class="headerlink" title="vuex 中的概念"></a>vuex 中的概念</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li>状态 , 状态即数据</li><li>状态是由 store 提供的</li><li>状态也是响应的</li><li>推荐通过 mutations 中提供的方法去修改数据，因为在严格模式下不允许在 mutation 外部修改 state 下的数据，否则会报错</li></ul><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><ul><li>作用：提供修改 state 的状态数据的方法</li><li>只要想改变 state 中的状态数据，就应该在 mutations 中提供一个方法来修改，接受 <code>state</code> 作为第一个参数（如果定义在模块中，则为模块的局部状态），<code>payload</code> 作为第二个参数（可选）</li><li>通过 <code>$store.commit(&#39;方法名&#39;)</code> 调用 mutations 中的方法</li><li>传参数的话，紧挨着方法名后面继续传就可以了，推荐传入一个对象（payload 即可）</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addTodo () &#123;</span><br><span class="line">    <span class="comment">// commit =&gt; 找 mutations</span></span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'addTodo'</span>, &#123;</span><br><span class="line">      todoName: <span class="keyword">this</span>.todoName</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  addTodo (state, playload) &#123;</span><br><span class="line">    state.list.push(playload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>提供异步修改 state 的状态数据的方法</p><p>处理函数总是接受 <code>context</code> 作为第一个参数，<code>payload</code>作为第二个参数（可选）</p><p>通过 <code>$store.dispatch(&#39;方法名&#39;)</code> 调用 actions 中的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  addTodo () &#123;</span><br><span class="line">    <span class="comment">// 异步: 分发 dispatch  =&gt; actions</span></span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'addTodoAsync'</span>, &#123;</span><br><span class="line">      todoName: <span class="keyword">this</span>.todoName</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  addTodoAsync (context, playload) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">'addTodo'</span>, playload)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>可以认为是 store 的计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</p><p>getter 接受 state 作为其第一个参数，Getter 也可以接受其他 getter 作为第二个参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：<code>store.getters.doneTodos</code></p><h2 id="vue-和-vuex-的配合使用"><a href="#vue-和-vuex-的配合使用" class="headerlink" title="vue 和 vuex 的配合使用"></a>vue 和 vuex 的配合使用</h2><ol><li>实例 vue 和实例 store</li><li>一定要把 store 挂在到 vue 上</li><li>读取</li></ol><ul><li>组件读取:<code></code></li><li>js 读取: <code>this.$store.state.count</code></li><li>js 操作: 在 mutations 里放一个方法，在方法里修改</li><li>js 中触发这个方法 <code>this.​$store.commit(&#39;addCount&#39;, { num : 8})</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h1&gt;&lt;h2 id=&quot;vuex-是什么&quot;&gt;&lt;a href=&quot;#vuex-是什么&quot; class=&quot;headerlink&quot; title=&quot;v
      
    
    </summary>
    
      <category term="vue" scheme="https://cuilongjin.top/categories/vue/"/>
    
    
      <category term="vue" scheme="https://cuilongjin.top/tags/vue/"/>
    
      <category term="vuex" scheme="https://cuilongjin.top/tags/vuex/"/>
    
  </entry>
  
</feed>
